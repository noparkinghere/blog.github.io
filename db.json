{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"source/logo_backup/favicon3.ico","path":"logo_backup/favicon3.ico","modified":0,"renderable":0},{"_id":"source/logo_backup/favicon4.ico","path":"logo_backup/favicon4.ico","modified":0,"renderable":0},{"_id":"source/logo_backup/favicon5.ico","path":"logo_backup/favicon5.ico","modified":0,"renderable":0},{"_id":"source/logo_backup/favicon2.ico","path":"logo_backup/favicon2.ico","modified":0,"renderable":0}],"Cache":[{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1486430417204},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1486430417204},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1486430417204},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1486430417204},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1486430417204},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1486430417204},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1486430417204},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1486430417212},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1486430417212},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1486430417212},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1486430417212},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1486430417212},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1486430417212},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1486430417212},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1486430417212},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1486430417212},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1486430417212},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1486430417212},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1486430417212},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1486430417212},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1486430417212},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1486430417212},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1486430417248},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1486430417248},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1486430417248},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1486430417248},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1486430417248},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1486430417248},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1486430417248},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1486430417248},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1486430417248},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1486430417248},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1486430417248},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1486430417248},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1486430417248},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1486430417248},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1486430417248},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1486430417248},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1486430417248},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1486430417248},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1486430417248},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1486430417248},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1486430417248},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1486430417248},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1486430417248},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1486430417248},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1486430417252},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1486430417248},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1486430417248},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1486430417248},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1486430417264},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1486430417264},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1486430417264},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1486430417264},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1486430417264},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1486430417264},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1486430417264},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1486430417264},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1486430417264},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1486430417264},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1486430417264},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1486430417264},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1486430417264},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1486430417264},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1486430417264},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1486430417264},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1486430417264},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1486430417264},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1486430417264},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1486430417264},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1486430417264},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1486430417264},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1486430417264},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1486430417264},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1486430417264},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1486430417264},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1486430417264},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1486430417264},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1486430417264},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1486430417264},{"_id":"source/_post/2016/2016-07-13-jlink相关问题汇总/说明.txt","hash":"b14eaad03a1b47b57e0bd5920ebd51f7ab6ce843","modified":1486431192383},{"_id":"source/_post/2016/2016-07-14-chrome使用推荐/DeepinScrot-5445.png","hash":"c8df3336d1a24fe0d2dce77080286158ae4b07e9","modified":1486431192083},{"_id":"source/_post/2016/2016-07-13-jlink相关问题汇总/v8ww.bin","hash":"01a3eba057862231bafa4883cd6d8d7551b9ac51","modified":1486431192379},{"_id":"source/_post/2016/2016-07-16-windows7安装详解/2-140G411193B09.jpg","hash":"69a1edcb7d91c766ffb281e40c42aac397df185d","modified":1486431192051},{"_id":"source/_post/2016/2016-07-16-windows7安装详解/2-140G411191b25.jpg","hash":"693ee547b3293488a0c96fbe32c411593e521dfd","modified":1486431192043},{"_id":"source/_post/2016/2016-07-16-windows7安装详解/2-140G4111Z2E6.jpg","hash":"8f728e60e4f036160c6bbcfefa3c188c8a6060c7","modified":1486431192031},{"_id":"source/_post/2016/2016-07-16-windows7安装详解/BaiduShurufa_2016-7-18_11-23-6.png","hash":"ef71d15a078e91431d087c47c3d424789e29cba1","modified":1486431192075},{"_id":"source/_post/2016/2016-07-16-windows7安装详解/BaiduShurufa_2016-7-18_10-53-18.png","hash":"d8e61e9d0fa9872ff04fc02eab5eac89fc3bfc11","modified":1486431192067},{"_id":"source/_post/2016/2016-07-16-windows7安装详解/BaiduShurufa_2016-7-18_10-54-24.png","hash":"c0e394089916b379d8ac3dc05d0e17ce6b28567b","modified":1486431192071},{"_id":"source/_post/2016/2016-07-16-windows7安装详解/2-140G4111953b7.jpg","hash":"bda39c627d178dc345f6b30c4567a70b4e6ed553","modified":1486431192051},{"_id":"source/_post/2016/2016-07-13-jlink相关问题汇总/JLinkV8固件烧录指导.pdf","hash":"ce14feb4518a30bfdf395ee983f11e686bbe3a3f","modified":1486431192115},{"_id":"source/_post/2016/2016-07-13-jlink相关问题汇总/Install AT91-ISP v1.13.exe","hash":"8b1162d5a478978fc4f328ca008354efc3c9523b","modified":1486431192107},{"_id":"source/_post/2016/2016-07-13-jlink相关问题汇总/Setup_JLinkARM_V415e.exe","hash":"81e1297e4ad2c0daa3b1ab78213ac3417738b0f3","modified":1486431192175},{"_id":"source/_post/2016/2016-07-13-jlink相关问题汇总/Setup_JLinkARM_V440.exe","hash":"f2f4ac2f9dc88b84d55db6c48c0128bfc00c0aa6","modified":1486431192243},{"_id":"source/_post/2016/2016-07-13-jlink相关问题汇总/Setup_JLink_V490.exe","hash":"55ecc7830b028c82f6b557c9375a320a34b5a62d","modified":1486431192367},{"_id":"source/_posts/test","hash":"aad7dbe3916180d8a3f5631eac1e7e6b0da7846b","modified":1474618667796},{"_id":"source/logo_backup/favicon3.ico","hash":"19b31a1a0e052eaa17cb808a3a0683ee4ae1d893","modified":1467858890815},{"_id":"source/logo_backup/favicon4.ico","hash":"3053ea5e167c15f9eca97620e09630e83ff1013c","modified":1467858890815},{"_id":"source/logo_backup/favicon5.ico","hash":"98eab8d29cfe50ba6ddea4c9ac211ef5a9737383","modified":1468564888265},{"_id":"source/logo_backup/favicon2.ico","hash":"7becfcfb8c0e31a9ba23a4888f5fd0bb881edd44","modified":1467858890815},{"_id":"source/_drafts/shanbay/shanbay_English_source.md","hash":"5db51ef203d750efffab03a7ef8c5f9ec0a11a43","modified":1473147248735},{"_id":"source/_drafts/shanbay/shanbay_notice.md","hash":"e648d6ab70784ddff75b76777f3d7934d355d2a0","modified":1473776832356},{"_id":"source/_drafts/shanbay/shanbay_guide.md","hash":"eefff30951afee3228a54303b449ba271ddd2b6d","modified":1483528920523},{"_id":"source/_drafts/shanbay/shanbay_info.md","hash":"05bf04b11ed599dd20d20cb0833569c8852182a6","modified":1473776788807},{"_id":"source/_drafts/test/test.py","hash":"ad4d9d7bea5604579ccdaafc1d6062eaad51767d","modified":1478753704169},{"_id":"source/_drafts/trash/11.11","hash":"b85f638bfe85022591a30e885300d1b8d30cf013","modified":1478874001186},{"_id":"source/_drafts/shanbay/shanbay_welcome_msg.md","hash":"a7ea37e6f99a7ac720b5d3677e437356e1c167e7","modified":1475109571010},{"_id":"source/_drafts/test/test.c","hash":"ef2473cf16e8a3affdc383c2cbf2cdb0c0467376","modified":1479776330982},{"_id":"source/_pic/2016-06-24-ssh_error-via-vpn.pic/DeepinScrot-3457.png","hash":"ebeaad427338d089981892b99126c5aae78ed1a7","modified":1467858890803},{"_id":"source/_pic/2016-06-24-ssh_error-via-vpn.pic/DeepinScrot-3044.png","hash":"73a215e1eb1b9b746a5d256a57f2f92c8ce9eab7","modified":1467858890803},{"_id":"source/_pic/2016-06-24-ssh_error-via-vpn.pic/2016-06-23-remarkable-install.png","hash":"5f3ad0104668995075936cf9bf3a4c6253cf87f9","modified":1467858890803},{"_id":"source/_pic/2016-06-30-windowsXP纯净版安装/0_1318048924euuu (1).gif","hash":"33af4df6b1766d34c4a240dec233621f3403cdb4","modified":1467858890807},{"_id":"source/_pic/2016-06-30-windowsXP纯净版安装/0_13180489424H7X (1).gif","hash":"649336788a66a729911de7bfd40c6aa6bcecd3aa","modified":1467858890807},{"_id":"source/_pic/2016-06-30-windowsXP纯净版安装/0_13180507809T6V.gif","hash":"d8c7168364a4573706b7f77377d80321675c2091","modified":1467858890811},{"_id":"source/_pic/2016-06-30-windowsXP纯净版安装/1893017496.jpg","hash":"a45f504b8c46fa61510a5756d252c8af6ed1c951","modified":1467858890811},{"_id":"source/_pic/2016-07-11-MDK5安装及配置/Picture1.png","hash":"64346124d779fd3404f8e7c70050447b9323a958","modified":1473148044392},{"_id":"source/_pic/2016-07-11-MDK5安装及配置/Picture2.png","hash":"7404bb3cd9a2f330a5973ec874693820ec6ce563","modified":1473148051272},{"_id":"source/_pic/2016-07-11-MDK5安装及配置/Picture10.png","hash":"b79ec866195435fb736fb8f5a0d05082a4cd5ba2","modified":1473149333449},{"_id":"source/_pic/2016-07-10-chrome使用总结/1.png","hash":"18e5e31395c7c3233a7f4d0a79c93b767d2bf64f","modified":1480500491102},{"_id":"source/_pic/2016-07-11-MDK5安装及配置/Picture12.png","hash":"da2615547b4bd88fadd12d8f5a14b820771f7e45","modified":1473149410226},{"_id":"source/_pic/2016-07-11-MDK5安装及配置/Picture6.png","hash":"2bc7d15f5af9d0e79e7d8c2e6c34666cf57823c4","modified":1473148075284},{"_id":"source/_pic/2016-07-11-MDK5安装及配置/Picture9.png","hash":"d6e82bd3c73cb51822a2aecf3bcbf51fbe7161df","modified":1473148090352},{"_id":"source/_pic/2016-07-11-git常用指令详解/0.png","hash":"cf981952a2ed1a3fb4be484962b46c7fae150313","modified":1475058462675},{"_id":"source/_pic/2016-07-12-linux下vpn配置/2.png","hash":"94d250e00f3cd1fcb19bb18cc34ac82fd6b058d7","modified":1484193127575},{"_id":"source/_pic/2016-07-12-linux下vpn配置/3.png","hash":"4e5c78cb22aaec85ff71cc418cfdf3a6819b6c81","modified":1484193155347},{"_id":"source/_pic/2016-07-12-linux下vpn配置/5.png","hash":"4d96876581f7b92e21dfc79bd73b36e327e4fcce","modified":1484193170815},{"_id":"source/_pic/2016-07-12-linux下vpn配置/4.png","hash":"635050cf73c20c791b61a605fc7e87843b19d58e","modified":1484193162091},{"_id":"source/_pic/2016-07-12-linux下vpn配置/6.png","hash":"3b544cf662ee982ad42167b39ed781b2c981fdba","modified":1484193177035},{"_id":"source/_pic/2016-07-12-linux下vpn配置/7.png","hash":"2150aec8dc771770962f3fd242ce3f5024ff365c","modified":1484193187975},{"_id":"source/_pic/2016-07-25-桥接、nat、host-only上网方式的区别/1.png","hash":"32995abef7bf97bccb6ae0834ef07e1c6745b04a","modified":1474178988823},{"_id":"source/_pic/2016-07-25-桥接、nat、host-only上网方式的区别/0.png","hash":"53b965c31bede1fea22255f56329b65ce3fb4214","modified":1474208648000},{"_id":"source/_pic/2016-07-25-桥接、nat、host-only上网方式的区别/2.png","hash":"e019e9e4324cbd09ab2372a4ca1e6e6952bd8aab","modified":1474179001287},{"_id":"source/_pic/2016-07-25-桥接、nat、host-only上网方式的区别/host-only","hash":"b059a0b71bc5aad7746d5c773094a34c1f0b7a07","modified":1474179237814},{"_id":"source/_pic/2016-07-25-桥接、nat、host-only上网方式的区别/NAT","hash":"f93e5bf7ce9cecb3060b0887f40c4b5b32675f15","modified":1474178993671},{"_id":"source/_pic/2016-07-29-git服务器搭建/DeepinScrot-1126.png","hash":"14211e4e8e2048e2ddcfe34b0112e276ff277b78","modified":1470060705456},{"_id":"source/_pic/2016-07-25-桥接、nat、host-only上网方式的区别/3.png","hash":"750c7b55f7559e120edf3c7f5759383d515c5c21","modified":1474179249846},{"_id":"source/_pic/2016-07-25-桥接、nat、host-only上网方式的区别/4.png","hash":"476b408292d180d9194fcd5ba0e34253cbee0f0a","modified":1474175120000},{"_id":"source/_pic/2016-07-25-桥接、nat、host-only上网方式的区别/桥接","hash":"a73d524796964898f5407774541e54194477c4e5","modified":1474179212006},{"_id":"source/_pic/2016-07-29-git服务器搭建/DeepinScrot-4326.png","hash":"98385dea8fbb45c2b97c37452bbff71bd319567c","modified":1470055416652},{"_id":"source/_pic/2016-07-29-git服务器搭建/DeepinScrot-4534.png","hash":"7ff34be48d39151481f5b7c8c3be483454edf091","modified":1470055553936},{"_id":"source/_pic/2016-08-03-gpio口详解/8b82b9014a90f6037a3d50aa3a12b31bb151ed4a.jpg","hash":"69b8e73eef6357a64aab3bebe1a0fbe3e6d0ca4c","modified":1470718994143},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/1.png","hash":"852c84822cdd034ed0d67b5d887b1477ca2dd334","modified":1474539534000},{"_id":"source/_pic/2016-07-29-git服务器搭建/DeepinScrot-2011.png","hash":"94c46d6be8869f5b9e78c26122fdfc716dfcc7bc","modified":1470054700153},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/8.png","hash":"5a8b346275e3b4f3d4fa3f3181a40c05edd0bbe1","modified":1473779110000},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/e2.png","hash":"fad25a78c59803ad593a751da1e0e58ae6244492","modified":1480333250000},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/e3.png","hash":"fde0104eb8a7f3baa43cedd193704e01a4a4d0c6","modified":1480333276000},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/e4.png","hash":"ceea9674ea8d2d862ac0901b0202506630590ffc","modified":1480333310000},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/e7.png","hash":"cdc201de5e44df7aaf61a6ee80850e58634d0b01","modified":1480333362000},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/e5.png","hash":"a50c94202c5ef2a4bacbeb9d6945514cf9c35309","modified":1480333326000},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/e6.png","hash":"a5daaa7154626817ccaec3b4e46dfadb6e54fb27","modified":1480333340000},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/e8.png","hash":"115e04751cb7de8da5ab8121abd78dbbdc33ac90","modified":1480333534000},{"_id":"source/_pic/2016-09-28-通过git管理一个工程/0.png","hash":"cf981952a2ed1a3fb4be484962b46c7fae150313","modified":1475058462675},{"_id":"source/_pic/2016-09-26-windows7和虚拟机中的ubuntu实现文件共享/1.jpg","hash":"eee79472de027cbcfebbb4e8e7e1340ac8aee843","modified":1474872060309},{"_id":"source/_pic/2016-10-16-note-7-的一些个人看法/1.jpg","hash":"ae6ef11bd30942cbf86cf346e639e29a56937bba","modified":1479185529132},{"_id":"source/_pic/2016-10-19-usb转串口/1.png","hash":"01935ad2b3440b8af8efc2b9b5f74346375b9585","modified":1479215184226},{"_id":"source/_pic/2016-10-19-usb转串口/3.png","hash":"fb8b8cd10ba9bc1c0adad9eff68e5b1a0d8ddf8d","modified":1479216618501},{"_id":"source/_pic/2016-10-19-串口RS232通信详解/1.jpg","hash":"b09c968c15f1d5841f1043f332369a35e939c714","modified":1477531178415},{"_id":"source/_pic/2016-10-19-usb转串口/2.jpg","hash":"fab6383043dd9bce9f5ae7420f76fc412d93e986","modified":1479215288175},{"_id":"source/_pic/2016-10-19-串口RS232通信详解/6.jpg","hash":"dddc40f0ec1a37db2e93e69faf93c55d2a52e067","modified":1477988729041},{"_id":"source/_pic/2016-10-19-串口RS232通信详解/2.jpg","hash":"0b3fce8556a2e912ef84cd15560ff8cd41531584","modified":1477531235821},{"_id":"source/_pic/2016-10-19-串口RS232通信详解/5.jpg","hash":"ace1c3bdaa8f0ebef578bf35ff1461d7760551db","modified":1477535001785},{"_id":"source/_pic/2016-10-19-串口RS485通信详解/2.jpg","hash":"a55c0043aba4e196db61360fb900d2767b529893","modified":1479214028610},{"_id":"source/_pic/2016-10-19-串口RS485通信详解/3.jpg","hash":"a68cc97f89f5f877553ae283d092b1b27847b966","modified":1477531247917},{"_id":"source/_pic/2016-10-19-串口RS485通信详解/4.jpg","hash":"dba899b8ee4ff894667d11ffd8389f7b43aff782","modified":1477531267942},{"_id":"source/_pic/2016-11-15-notepad-和mingw/2.png","hash":"f7891030c7d58778fc9081d023f47208d38da1f5","modified":1479203174384},{"_id":"source/_pic/2016-11-16-keil工程的代码优化/1.png","hash":"f5d2aa61a8dcc69993a5770f8b610f6a8afa424b","modified":1479325280000},{"_id":"source/_pic/2016-11-03-如何看待蓝绿大厂问鼎中国/2.jpg","hash":"f3640866d398f434f57a1d02b7ebcab706c5c78c","modified":1479186080999},{"_id":"source/_pic/2016-11-16-keil工程的代码优化/3.png","hash":"efa17a46b493df32ca7ad8ff432d42e2e3b13fc3","modified":1479325356000},{"_id":"source/_pic/2016-11-16-keil工程的代码优化/5.png","hash":"7921f61ffe509d86168fb477ce45c7d59843eebb","modified":1479325412000},{"_id":"source/_pic/2016-11-16-keil工程的代码优化/2.png","hash":"6d20cd8e910b1b312bf375b7c03d2901366c904a","modified":1479325324000},{"_id":"source/_pic/2016-11-16-keil工程的代码优化/4.png","hash":"42b5db7359d7a7a3d52250a5ee09fd06d4e23091","modified":1479325390000},{"_id":"source/_pic/2016-11-25-vps-shadowsocks/4.png","hash":"83180c61f76920831b538f4b96e068f50764d15c","modified":1480064039206},{"_id":"source/_pic/2016-11-25-vps-shadowsocks/5.png","hash":"e3bf010c0f54b6f1c2f040a712b3a20cf0812817","modified":1480246627243},{"_id":"source/_pic/2016-11-25-vps-shadowsocks/ss1.png","hash":"a18e72d5ed67fbaddc9736039df9c7168fd98544","modified":1480245754339},{"_id":"source/_pic/2016-11-25-vps-shadowsocks/ss2.png","hash":"6062a7474e26fd92ad2bbbcfa854409c64c621b9","modified":1480245783347},{"_id":"source/_pic/2016-11-25-vps-shadowsocks/ss3.png","hash":"4613fcc1932182816aa1734354cca2e2e2f87fc7","modified":1480245790531},{"_id":"source/_pic/2016-11-25-vps-shadowsocks/ss4.png","hash":"5189639e3bb1beaa834d1cd2a10a113858015410","modified":1480245797359},{"_id":"source/_pic/2016-11-25-vps-shadowsocks/what-is-shadowsocks.png","hash":"b6a97e7a26a2cbe36ab864bad16f3ec9cb14037e","modified":1480062079337},{"_id":"source/_pic/2016-12-01-putty-xming-远程使用-linux-gui/2.png","hash":"d0b042083b47ea822b0f1837a0309361bb12d66e","modified":1480569770234},{"_id":"source/_pic/2016-12-01-putty-xming-远程使用-linux-gui/4.png","hash":"0b92399bb0d2c992afe5fccc307b18dcac968331","modified":1480569787482},{"_id":"source/_pic/2016-12-01-putty-xming-远程使用-linux-gui/1.png","hash":"bd295616758ee252f2ebfc595d23b72f7c08f1ec","modified":1480569421041},{"_id":"source/_pic/2016-12-01-putty-xming-远程使用-linux-gui/3.png","hash":"1e33ba9b6ba5ab96e8a1b3f7a20810696c54ecf3","modified":1480569779206},{"_id":"source/_pic/2016-12-12-teamviewer-远程控制/1.jpg","hash":"e3b245bf19a6f6bcc99196b29f5f0cde8a73a379","modified":1481514069882},{"_id":"source/_posts/2017/2017-01-01-别了，2016；你好，2017.md","hash":"0146642b7ca0ce602cb55ca79446078d3db521a7","modified":1483580300386},{"_id":"source/_pic/2016-12-12-teamviewer-远程控制/3.jpg","hash":"6150d11ac280fb880bea7891d71602a91f5bb007","modified":1481514810433},{"_id":"source/_pic/2016-12-12-teamviewer-远程控制/2.jpg","hash":"8413a07062ceb4a5373395d106a6c0143635d1ed","modified":1481514798652},{"_id":"source/_posts/2017/2017-01-05-（转）中文技术文档的写作规范.md","hash":"a714b3e750c2e96733fe0480124c808f367f6a84","modified":1483580372584},{"_id":"source/_pic/2016-12-08-efm32-开发板问题总结/1.png","hash":"ae3106718731cab7696c02727620cb9f44ac5566","modified":1480671436000},{"_id":"source/_posts/2017/2017-01-25-ss-linux全局代理.md","hash":"70ee1f194781f19d1fab67cf2394ac264950fd85","modified":1485313603366},{"_id":"source/_posts/2016/2016-06-23-remarkable-install.md","hash":"27dfb731d7e77153415fd0321fcb214a4705ad8d","modified":1481850705554},{"_id":"source/_posts/2016/2016-06-27-关于英国的独立日.md","hash":"0566d2a8d3b1e9c47b761ef6b674e9615612bdf2","modified":1481850713550},{"_id":"source/_posts/2016/2016-06-28-linux下ssh通过VPN推送失败.md","hash":"7ba668c516fee5277b12f09ea6e2f90cd5460d35","modified":1481851084957},{"_id":"source/_posts/2016/2016-07-01-linux下文件查找.md","hash":"243cf311dfd3e6d05f0ef9041506e2a1ae13f163","modified":1484191218068},{"_id":"source/_posts/2016/2016-06-29-linux下的下载.md","hash":"8c5f0963462c81cf249ee10a9a2084fb8c49a785","modified":1484189543163},{"_id":"source/_posts/2016/2016-06-30-windowsXP纯净版安装.md","hash":"fc90d5a66de4b63f36fa636f140dd3acaaca3017","modified":1484190577293},{"_id":"source/_posts/2016/2016-07-05-（转）github_markdown.md","hash":"bf22ec04f32035f39696544c1ed52ab5b6324aaf","modified":1483410641347},{"_id":"source/_posts/2016/2016-07-05-github本地推送.md","hash":"df377179ccbc8788b40f8f451c091874fb10ad0d","modified":1481851130558},{"_id":"source/_posts/2016/2016-07-07-linux下的virtualbox安装配置.md","hash":"b5e29853350bab209dcef001ca3020291b5fdc68","modified":1481851135902},{"_id":"source/_posts/2016/2016-07-11-MDK5安装及配置.md","hash":"c38f78bfd515b96b62271259cea7f957eee2c1e2","modified":1484191614117},{"_id":"source/_posts/2016/2016-07-10-chrome使用总结.md","hash":"abd58e696474ae4086ba29789d251ef6209c1bbd","modified":1481851140518},{"_id":"source/_posts/2016/2016-07-11-github-page页面无法更新.md","hash":"54fc7e69442566956e9af55da13eb437e25b6d04","modified":1481851145470},{"_id":"source/_posts/2016/2016-07-11-git常用指令详解.md","hash":"86ec00e1f6747a888fed5694365d61652cf8ef84","modified":1483410737428},{"_id":"source/_posts/2016/2016-07-11-换车_换行_文件末尾空行.md","hash":"c691baf7f99f146786bc694ae542e4e796e931c5","modified":1484191646470},{"_id":"source/_posts/2016/2016-07-11-linux正常学习办公.md","hash":"070b088f48d006e3bbb1835f3e6276ac8504d8f7","modified":1484188851457},{"_id":"source/_posts/2016/2016-07-11-神州stm32案例练习.md","hash":"c49a1afc2f8b0faf08585501db098d92fb225b40","modified":1481852532611},{"_id":"source/_posts/2016/2016-07-12-jlink相关问题汇总.md","hash":"527509af5b5df8398cc86dddcb3e7933298cb24c","modified":1484191799959},{"_id":"source/_posts/2016/2016-07-12-linux下vpn配置.md","hash":"03035a242ea23ac62245bc245fffc80e289c61a0","modified":1484199633436},{"_id":"source/_posts/2016/2016-07-14-Caps_Lock与右Ctrl互换.md","hash":"a81b06d6db4f9788fd26adb029c06ecf5fd967f5","modified":1484199457686},{"_id":"source/_posts/2016/2016-07-16-windows7安装详解.md","hash":"7580f1756a8340a379abb493a8e46a7c94e39d32","modified":1484199364101},{"_id":"source/_posts/2016/2016-07-21-githubpage-jekyll搭建博客.md","hash":"7092558d878fc89c70a417e9628874cd9661f512","modified":1485261123100},{"_id":"source/_posts/2016/2016-07-15-atom使用总结.md","hash":"e270870a61e463d79f064ac4e7f88dcc326a413b","modified":1484199595094},{"_id":"source/_posts/2016/2016-07-27-多个发行版linux使用体验.md","hash":"9053afcdb398b86c6f8b0c19423c8986a4392dd3","modified":1484198413774},{"_id":"source/_posts/2016/2016-07-25-桥接、nat、host-only上网方式的区别.md","hash":"c2c5cbfa394c98554c73ed871554e306e128a274","modified":1484199187931},{"_id":"source/_posts/2016/2016-07-29-架设自己的git服务.md","hash":"dab86bc63018912e28ecf71c35bce576dcce69c2","modified":1484199949199},{"_id":"source/_posts/2016/2016-08-03-gpio口详解.md","hash":"dbb980f765776360ca221bc22102aa964f52fdb2","modified":1484199994141},{"_id":"source/_posts/2016/2016-08-06-常规的通讯校验.md","hash":"87c5964568721893d1b4106b65bab5090d85ce3b","modified":1481852622275},{"_id":"source/_posts/2016/2016-08-10-模拟IIC通信时IO选用模式.md","hash":"cf7632b5299e9f89e68b89f92c06b1aa4ec195f8","modified":1484200091981},{"_id":"source/_posts/2016/2016-08-24-c语言中宏定义存在位置.md","hash":"c8b00f36c12bb48375a97eee26bed04f6e8760e8","modified":1484198860006},{"_id":"source/_posts/2016/2016-08-24-头文件交叉引用.md","hash":"a2df8376ea71414f1b32bfc57c73f937e4a1e045","modified":1481852738916},{"_id":"source/_posts/2016/2016-08-15-ubuntu的基本使用.md","hash":"0293bcab44a0da1683a4c02236128dd108a669a2","modified":1481852717536},{"_id":"source/_posts/2016/2016-08-26-linux下的shell和终端使用.md","hash":"21e8e98dcdb90a677116ae184aa3148ecc374230","modified":1481852817261},{"_id":"source/_posts/2016/2016-08-11-C编程规范.md","hash":"a0fe808814c267486e5fd11df6acd8a64269b39a","modified":1484200155219},{"_id":"source/_posts/2016/2016-09-06-linux下的bash.md","hash":"4ae7be21ea6042e043904360d68c0b5360bb2566","modified":1481852836941},{"_id":"source/_posts/2016/2016-09-06-linux-CLI下的常用命令.md","hash":"6603fa45114a9cab92d771613a3d051eee7ab095","modified":1481852827217},{"_id":"source/_posts/2016/2016-09-09-国内云服务器体验.md","hash":"e44fc8a3bac8dbbfc98178462244dcf59c9647d4","modified":1484200295859},{"_id":"source/_posts/2016/2016-09-09-ssh相关使用.md","hash":"2f2c3a4e6db40d675bcd3fd59b2ae7a46acbfa25","modified":1481852852918},{"_id":"source/_posts/2016/2016-08-25-（转）谈谈写程序与学英语.md","hash":"02f9fde0c47be7cd5e2db77710d3e389e84cbc07","modified":1483579379697},{"_id":"source/_posts/2016/2016-08-28-git问题总结FAQ.md","hash":"298509abc6dfde137520b53eb013d4460439578f","modified":1481852821297},{"_id":"source/_posts/2016/2016-09-12-解决重启网卡后ip-route-add丢失.md","hash":"b114cc8a4c7596d3d33ad6f76aa592c5acb38b24","modified":1481852873430},{"_id":"source/_posts/2016/2016-09-12-网络监控工具wireshark.md","hash":"142fd455aebdf9384478624e4a5d39ff14a2f866","modified":1481852869966},{"_id":"source/_posts/2016/2016-09-14-ubuntu搭建wordpress服务.md","hash":"1282cc28d1afe06e638a2d1066c8f1f6637898cd","modified":1481852881586},{"_id":"source/_posts/2016/2016-09-22-字符编码.md","hash":"790b31c439fd449f29c3b9c0b9da004f24ce836f","modified":1481852897146},{"_id":"source/_posts/2016/2016-09-28-git的配置及相关插件.md","hash":"38cca8ed1ed652a412ac2bdd734d42d5e949e24f","modified":1481852919050},{"_id":"source/_posts/2016/2016-09-28-关于手机的一些个人看法.md","hash":"c2ec09ddb649aa459d6efa70ef5836cc428362be","modified":1481852922850},{"_id":"source/_posts/2016/2016-09-20-windows-7个人使用环境配置.md","hash":"b118126e96b4c15784e64e9c114170f0707dada1","modified":1481852893282},{"_id":"source/_posts/2016/2016-09-26-windows7和虚拟机中的ubuntu实现文件共享.md","hash":"36cc248eb8d305b0ead03e4a4a18742cb01a3cbd","modified":1481852901586},{"_id":"source/_posts/2016/2016-09-28-通过git管理一个工程.md","hash":"7fec5619aa59c83edba8d3d51874fe0a513a3df1","modified":1481852926738},{"_id":"source/_posts/2016/2016-09-30-GP22芯片详解.md","hash":"bcbcb7de7a4eb475bb8076853ca1c077c51fcc92","modified":1481852930654},{"_id":"source/_posts/2016/2016-10-01-ubuntu下安装搜狗输入法.md","hash":"ebb687acc0298ee08292efe322a3570683731331","modified":1485314489223},{"_id":"source/_posts/2016/2016-10-09-多种电平的区分.md","hash":"e7ed3b782074e324ced38c6351ec58eb8c972f96","modified":1481852943446},{"_id":"source/_posts/2016/2016-10-17-杂谈小纪.md","hash":"a1f93ff7ada611950d98b892e508193ee952d0a0","modified":1481852949538},{"_id":"source/_posts/2016/2016-10-02-传输速率.md","hash":"f7da8388ec7d93800a0e9550097ee73d4b84a7e9","modified":1481852939738},{"_id":"source/_posts/2016/2016-10-16-note-7-的一些个人看法.md","hash":"1df4e9212b94cae287beabf86f785687f2f2467c","modified":1481852946834},{"_id":"source/_posts/2016/2016-10-18-ubuntu关闭笔记本触摸板.md","hash":"f7f824dd83996caef4c753b6c30f0ce741d1b3b7","modified":1481852952946},{"_id":"source/_posts/2016/2016-10-19-usb转串口.md","hash":"d2c0c84b1ab1be1778d56cd302ca64c1e7c47c44","modified":1481852958714},{"_id":"source/_posts/2016/2016-10-18-计算机中的通信简介.md","hash":"f0fa3948707de063e5a1e31ed47560e1ef8e7143","modified":1481852956430},{"_id":"source/_posts/2016/2016-10-20-iic通信详解.md","hash":"f8dfddfbfabafe10e58e3e0b77c0e92b6a454531","modified":1481852967991},{"_id":"source/_posts/2016/2016-10-19-串口RS485通信详解.md","hash":"a05231f491b2fd02710b6fe40e24f12616671ce2","modified":1481852965115},{"_id":"source/_posts/2016/2016-10-19-串口RS232通信详解.md","hash":"b25d95107f865d4bdb46293639d42c9c5bfa0158","modified":1481852961823},{"_id":"source/_posts/2016/2016-10-24-linux免密码命令.md","hash":"14243eb63833362ec19b2c293324864c4ac65133","modified":1481852979955},{"_id":"source/_posts/2016/2016-09-28-（转）机器人工程师学习计划.md","hash":"1fc0e48b4fbd50e690a3a4aaacbf9404bbecf88b","modified":1483576329455},{"_id":"source/_posts/2016/2016-10-28-linux分区问题.md","hash":"1bff38ac87444994c600e78cdca229d6763ad4f7","modified":1481852992443},{"_id":"source/_posts/2016/2016-10-27-aria2详解.md","hash":"daf81e2f7634694ffed94ad08d6b6bf98e88c42f","modified":1484189222051},{"_id":"source/_posts/2016/2016-10-29-msb-和-lsb.md","hash":"98872d3bb030f7878f4c9d3fa6116185e4a256f3","modified":1482897029440},{"_id":"source/_posts/2016/2016-10-29-spi通信详解.md","hash":"c4758c4432da528a5367b075c882ab48e634637b","modified":1481852995347},{"_id":"source/_posts/2016/2016-10-30-uart-spi-iic的比较.md","hash":"c025c54929e1e845343d4accbd837e913509fce0","modified":1481852998027},{"_id":"source/_posts/2016/2016-11-10-c语言工程组建.md","hash":"a09ffb21c2db792187157efce39aea2ad902d261","modified":1481853005463},{"_id":"source/_posts/2016/2016-10-30-大端和小端.md","hash":"a6b8cb104217ec942717ae8454cbc7134e66ad3f","modified":1482826117283},{"_id":"source/_posts/2016/2016-11-10-美国总统诞生了.md","hash":"a59bd6fa9a27015ee1909325af625cff954cebdd","modified":1481853016851},{"_id":"source/_posts/2016/2016-10-30-字节对齐.md","hash":"982b18f33436c0b595a35a7a8552ffa23f2393a3","modified":1482825718227},{"_id":"source/_posts/2016/2016-11-15-notepad-和mingw.md","hash":"8a6b2d5dfe014aba3e6b56b5097d8234dd8aef6e","modified":1481853023115},{"_id":"source/_posts/2016/2016-11-03-如何看待蓝绿大厂问鼎中国.md","hash":"530d4199a544888307d1c7bcc9bfec56cd258043","modified":1481853003035},{"_id":"source/_posts/2016/2016-11-21-vim学习.md","hash":"6ab114459fd1d81620d829acf9ab5dd4b289f1a4","modified":1483580164775},{"_id":"source/_posts/2016/2016-11-16-keil工程的代码优化.md","hash":"1280c195a389cd192d7c0b0931f34b30413cb78e","modified":1481853033467},{"_id":"source/_posts/2016/2016-11-22-crc校验.md","hash":"f4daa4ceb26887c660e3c79df3045adfccb04ea5","modified":1481853089916},{"_id":"source/_posts/2016/2016-11-23-git-submodule-详解.md","hash":"d736823b3d5b8b38efa78c45690a0128d9c9ca2a","modified":1481853087128},{"_id":"source/_posts/2016/2016-11-26-检测VPS虚拟化技术.md","hash":"d8f7d4ded739cb099292838c3d1370eb78f856f7","modified":1482412028439},{"_id":"source/_posts/2016/2016-11-28-vps-docker.md","hash":"a686135b467065b2503d6203e37f4961a0a3bb79","modified":1481853070240},{"_id":"source/_posts/2016/2016-11-23-转-虚拟主机、vps和云主机.md","hash":"edffb699834876f965812491c955540a5e68d434","modified":1481853085100},{"_id":"source/_posts/2016/2016-12-09-lamp-环境搭建.md","hash":"a1f5cf95d10419cc2126c513336d0d800a9ce750","modified":1481853054959},{"_id":"source/_posts/2016/2016-11-25-vps-shadowsocks.md","hash":"f70a47ee020269fbc337d8114e4d6cbb10072ff7","modified":1485313314775},{"_id":"source/_posts/2016/2016-12-01-putty-xming-远程使用-linux-gui.md","hash":"caf3981fd2c386cf287878badbd16112aa40ebd4","modified":1481853065895},{"_id":"source/_posts/2016/2016-12-08-efm32-开发板问题总结.md","hash":"b5101cfbc8ecbf1498ce803ba533f3fb8d0f57a5","modified":1481853057999},{"_id":"source/_posts/2016/2016-12-12-teamviewer-远程控制.md","hash":"f744485c584a7318080eb5c9fd667ba26bc390f7","modified":1481853052619},{"_id":"source/_posts/2016/2016-12-19-vps-简介.md","hash":"8299a68d2498882c59186cdc2e7856722ed63116","modified":1482246016341},{"_id":"source/_posts/2016/2016-12-20-linux-系统瘦身.md","hash":"c764f5134ef5b4b13208cc2d6dcd35d43c4905fa","modified":1483580276214},{"_id":"source/_posts/2016/2016-12-14-githubpage-hexo搭建博客.md","hash":"76ab17211b98ce8bf7d3614da2d844e90bd65638","modified":1485324223639},{"_id":"source/_posts/2016/2016-12-26-针对百度网盘限速的解决方案.md","hash":"916a81843fa3a8e6aa39b0f0239c512cb04d6f6b","modified":1483580286638},{"_id":"source/_posts/2016/2016-12-27-ssh-使用详解.md","hash":"7374fb7759e4a64706fd5b371ecd30d5fac37018","modified":1483580289854},{"_id":"source/_posts/FAQ/EFM32芯片单步执行跳转错误.md","hash":"3959d9176df6ee69fded5a9667b7f8566b91370e","modified":1483068975618},{"_id":"source/_posts/2016/2016-12-28-mcu中的hardfault-handler问题.md","hash":"6d0b1a8e9833f5bd771386a93af39b8fa70f9a39","modified":1484801864290},{"_id":"source/_pic/2016-06-23-remarkable-install/remarkable.png","hash":"f3ae2a2823469f674b9e8f2721dbeae396567423","modified":1467858890803},{"_id":"source/_pic/2016-06-30-windowsXP纯净版安装/0_1318048780HUDh (1).gif","hash":"7e2e0daf31e42f234ca863ea34e6916dacf96ecd","modified":1467858890803},{"_id":"source/_pic/2016-06-30-windowsXP纯净版安装/0_1318048847e9Ed (1).gif","hash":"ee9ab2e755023c6aa7b07d450d22d5ae85db17e9","modified":1467858890803},{"_id":"source/_pic/2016-06-30-windowsXP纯净版安装/0_1318048880092p (1).gif","hash":"be334144370b6024813b19efbe7b1538c295c546","modified":1467858890807},{"_id":"source/_pic/2016-06-30-windowsXP纯净版安装/0_13180489614yw5 (1).gif","hash":"466cc87d7a34f8a6c44d3ddc93c49e814bcf75e8","modified":1467858890807},{"_id":"source/_pic/2016-06-30-windowsXP纯净版安装/0_1318048983TOgd (1).gif","hash":"2169b20b7bf658ac38c42ed99436c082be6f5c0f","modified":1467858890811},{"_id":"source/_pic/2016-06-30-windowsXP纯净版安装/0_1318049022B22v (1).gif","hash":"2889d831e6ac85515cf24cd461355265f829612f","modified":1467858890811},{"_id":"source/_pic/2016-06-30-windowsXP纯净版安装/0_1318050059MUvv (1).gif","hash":"d84c07c4e8629ce71ab2641b3511802093003239","modified":1467858890811},{"_id":"source/_pic/2016-07-11-MDK5安装及配置/Picture3.png","hash":"40670894857cf546e460327f174f186204834b71","modified":1473148058460},{"_id":"source/_pic/2016-07-11-MDK5安装及配置/Picture11.png","hash":"eaa2c6c09fd269b0788b8cc2d4f45bd178bd6b49","modified":1473148099932},{"_id":"source/_pic/2016-07-11-MDK5安装及配置/Picture4.png","hash":"d608b098d2ec1ee32e849c3260ae3b019891a7fd","modified":1473148063836},{"_id":"source/_pic/2016-07-11-MDK5安装及配置/Picture5.png","hash":"1e54badd7f75bbf41d6e329a35fee872d971eb7a","modified":1473148069896},{"_id":"source/_pic/2016-07-11-MDK5安装及配置/Picture7.png","hash":"586fe1727fde9ddc6782a453e5193ddf8b0e1137","modified":1473148080384},{"_id":"source/_pic/2016-07-11-MDK5安装及配置/Picture8.png","hash":"4d407b32f19d5123674872f823aa5d37350281f7","modified":1473148085464},{"_id":"source/_pic/2016-07-11-git常用指令详解/265643011.jpg","hash":"68d4e8978534e06ca2ff747cda2853e3dd05e8a5","modified":1473154185005},{"_id":"source/_pic/2016-07-14-Caps_Lock与右Ctrl互换/BaiduShurufa_2016-8-10_14-5-24.png","hash":"1ccd5d1f83048e8c502fd27be2d986fd0327c1bf","modified":1473850372000},{"_id":"source/_pic/2016-08-03-gpio口详解/DeepinScrot-2019.png","hash":"218eec01685c3aab8a94aedcbf2dead477e6abeb","modified":1470730843452},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/2.png","hash":"459e3a62c2b0b99c1935ae8516e1110ff5780459","modified":1473798654000},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/4.png","hash":"157facdeaad567fbca8783ef4eb99051feb448e4","modified":1473784096000},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/5.png","hash":"0ec7f86d430ef8f8e092c604aa5f08ad10360676","modified":1474542860000},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/6.png","hash":"1ccd5d1f83048e8c502fd27be2d986fd0327c1bf","modified":1473850372000},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/7.png","hash":"e12a4998b44ea2a49e07bc83e3d51f772a667479","modified":1473780394000},{"_id":"source/_pic/2016-09-26-windows7和虚拟机中的ubuntu实现文件共享/2.jpg","hash":"9db866cbac9c517066657b2b67c0f036ecfa5cb6","modified":1474872076526},{"_id":"source/_pic/2016-10-16-note-7-的一些个人看法/2.jpg","hash":"4713714d675a4d9729c330ce88a82be1208588b9","modified":1479185642305},{"_id":"source/_pic/2016-10-19-串口RS485通信详解/1.jpg","hash":"0f632956586ffaf4b2cc5c67cd3f07fb6f70c321","modified":1479213748563},{"_id":"source/_pic/2016-11-03-如何看待蓝绿大厂问鼎中国/1.jpg","hash":"348c21b0a47d53c05e232dcce380f5124c2cc504","modified":1479186028846},{"_id":"source/_pic/2016-11-15-notepad-和mingw/1.png","hash":"86dc2033fa4b27faa81ccd65d0797fc6ec540d0a","modified":1479203157124},{"_id":"source/_pic/2016-11-25-vps-shadowsocks/1.png","hash":"f9c7e8114ce2b2cf7a3f850eb52d3923e382bdaa","modified":1480064019201},{"_id":"source/_pic/2016-11-25-vps-shadowsocks/3.png","hash":"9936b668801f8f23a8a892f20ea0efc1c00d641a","modified":1480064032106},{"_id":"source/_pic/2016-11-25-vps-shadowsocks/2.png","hash":"7b4270a7e08bd2cfc494a618b47c88206076a60d","modified":1480064028086},{"_id":"source/_pic/2016-11-25-vps-shadowsocks/6.png","hash":"154e718bd135a6724bd60d21b0aedd9626b45522","modified":1480247380699},{"_id":"source/_pic/2016-07-12-linux下vpn配置/1.png","hash":"dc8c144d45f8cf58b25ee5cf6e67774585567881","modified":1484192753289},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/3.png","hash":"b3e074a9032d4285ff5c28bd97427c532385a912","modified":1473784056000},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/e1.png","hash":"f025eba46391eed4b1ef4678e409bf0c00f262a8","modified":1480333184000},{"_id":"source/_pic/2016-09-20-windows-7个人使用环境配置/sagng","hash":"1b36e71f3d7cd8ac19a5759a6f49e3d00c318b0c","modified":1473785928000},{"_id":"source/_pic/2016-09-28-通过git管理一个工程/master.png","hash":"30efa42c5ff7d50f45a325c6a82ae1ed93b8665e","modified":1478742145939},{"_id":"source/_pic/2016-10-19-串口RS232通信详解/72.png","hash":"b15a86894fa8f91754d2275ff67732feae8b1bfd","modified":1478764573887},{"_id":"source/_pic/2016-09-28-通过git管理一个工程/git.xmind","hash":"f5db41882c8aad2298071cd4c673302ccfc23c02","modified":1475080316000},{"_id":"source/_pic/生命不息奋斗不止.jpg","hash":"fc3a450b50ad8f0da7910f1d1605281fbee0c606","modified":1470028962243}],"Category":[{"name":"read","_id":"ciyuv3ag0000amumu3oz051d5"},{"name":"杂记","_id":"ciyuv3agb000fmumuo3jd9kam"},{"name":"软件安装","_id":"ciyuv3agq0014mumuxh8ecrte"},{"name":"“问题总结”","_id":"ciyuv3agw001fmumuzggi6nmz"}],"Data":[],"Page":[],"Post":[{"_content":"*本帖不定期的更新一些英语资料，内容涵盖广泛，包括并不止限于：语法书籍，视频教程，听力音频，单词书籍，原版小说，学习类网站等。小伙伴们有些什么好的学习资料也可以在楼下回帖，一楼会对所有楼下的回复内容进行汇总。*\n\n**注意：大多数资源是百度云分享，手机APP浏览帖子未必能够点开，请点击右上角复制链接到浏览器中打开，或者可以直接PC端浏览器访问原帖。**\n\n**以下书籍仅供学习交流，如果你觉得试读不错，为了更好的学习建议购买相关纸质书籍。**\n\n### *资源汇总：*\n\n- [ENGLISH GRAMMAR GUIDE][1]：一个比较正规的英语语法学习类网站，前提是你的英语够扎实。\n\n- [Online Resources for Writers][2]：同上，又是一个全英文的学习网站，主要专注于语法和写作。\n\n- [可可英语语法大全][3]：不要怕，这个是一个中文类的语法学习网站，我个人觉得内容还是浅显易懂的，不仅这个语法内容，同样[可可英语][4]也是个值得推荐的英语学习类网站。\n\n- [英语语法新思维][5]：题主不是英语专业的，但听说这个书籍是作为部分英语专业教材使用的，可以想象内容还是恨详尽的，分为初级中级高级三册，讲解相当详尽，而有配套习题，该书对于想要深入学习理解英语语法的人，应该可以算是不错的教材了。\n\n- [哈利波特全本][6]：pdf文档，附生词表，词频之类的。\n\n- [易混淆单词手册][7]：这本书偶然发现的，并没有仔细翻阅过，有兴趣的朋友可以看看。\n\n- [英语入门王][8]，名字看起来很霸气的一本书，主要包括音标，还有一些日常用语。\n\n- [象形5000][9]：某单词网站出的单词书，主要是关于图形记词，好不好用这个就见仁见智了，我个人觉得用处不大，这篇较生硬，很多是硬套上去的，有兴趣的朋友可以看看。买一赠一，这边再列出[象形9K][10]的pdf扫描件。\n\n- [第三版4晨读美丽英文][11]和[第三版6晨读美丽英文][12]：偶然看到的资源，还没有看过。\n\n- [新东方英语美文][13]：网络比较常见的一个资源了，包含了一些传统的美文文章，以前听过，但这个文件新找的，没有打开过，不保证质量。\n\n- [晨读英语美文100篇][14]：这个暂时还没有下载体验过，之前上学看过一些晨读文章，有兴趣的小伙伴可以下载下来看看，等题主有空体验过后，可能会修改这部分简介。\n\n- [计算机专业英语][15]：这是一个视频教程，网络版的，关于这个的视频网上并不算多，有用没用自己用了才知道。\n\n- [上海交大计算机专业英语(21讲)][16]：没仔细看，印象中唯一的特点就是画质不清楚呢，声音还算清晰。\n\n- [计算机专用英语词汇1500词][17]：这个是比较广为人知的一个词汇册了，百度文库或者任意地方都可以下载到，涉及单词都是较为基础的，最应该掌握的单词，另外扇贝有[程序员必学电脑计算机专业英语词汇1700词][18]，有兴趣的朋友也可以选用这个词汇书背单词。\n\n\n\n******\n\n\n\nTo be continued...\n\n\n\n\n  [1]: http://www.ef.com/english-resources/english-grammar/english-grammar-guide/\n  [2]: http://webster.commnet.edu/writing/writing.htm\n  [3]: http://www.kekenet.com/grammar/\n  [4]: http://www.kekenet.com/\n  [5]: https://pan.baidu.com/s/1cqSgHo\n  [6]: https://pan.baidu.com/s/1jHSp4kI\n  [7]: https://pan.baidu.com/s/1hs0P3q0\n  [8]: https://pan.baidu.com/s/1c20rTJy\n  [9]: https://pan.baidu.com/s/1c1VkCOo\n  [10]: https://pan.baidu.com/s/1nv8Olbr\n  [11]: https://pan.baidu.com/s/1boEsaeF\n  [12]: https://pan.baidu.com/s/1qY1W4BM\n  [13]: https://pan.baidu.com/s/1gfyRaEJ\n  [14]: https://pan.baidu.com/s/1jI4k7ZK\n  [15]: http://%20http://list.youku.com/albumlist/show?id=813471&ascending;=1&page;=1\n  [16]: https://pan.baidu.com/s/1o893hkY\n  [17]: https://pan.baidu.com/s/1qYVdLLE\n  [18]: https://www.shanbay.com/wordbook/104791/\n","source":"_drafts/shanbay/shanbay_English_source.md","raw":"*本帖不定期的更新一些英语资料，内容涵盖广泛，包括并不止限于：语法书籍，视频教程，听力音频，单词书籍，原版小说，学习类网站等。小伙伴们有些什么好的学习资料也可以在楼下回帖，一楼会对所有楼下的回复内容进行汇总。*\n\n**注意：大多数资源是百度云分享，手机APP浏览帖子未必能够点开，请点击右上角复制链接到浏览器中打开，或者可以直接PC端浏览器访问原帖。**\n\n**以下书籍仅供学习交流，如果你觉得试读不错，为了更好的学习建议购买相关纸质书籍。**\n\n### *资源汇总：*\n\n- [ENGLISH GRAMMAR GUIDE][1]：一个比较正规的英语语法学习类网站，前提是你的英语够扎实。\n\n- [Online Resources for Writers][2]：同上，又是一个全英文的学习网站，主要专注于语法和写作。\n\n- [可可英语语法大全][3]：不要怕，这个是一个中文类的语法学习网站，我个人觉得内容还是浅显易懂的，不仅这个语法内容，同样[可可英语][4]也是个值得推荐的英语学习类网站。\n\n- [英语语法新思维][5]：题主不是英语专业的，但听说这个书籍是作为部分英语专业教材使用的，可以想象内容还是恨详尽的，分为初级中级高级三册，讲解相当详尽，而有配套习题，该书对于想要深入学习理解英语语法的人，应该可以算是不错的教材了。\n\n- [哈利波特全本][6]：pdf文档，附生词表，词频之类的。\n\n- [易混淆单词手册][7]：这本书偶然发现的，并没有仔细翻阅过，有兴趣的朋友可以看看。\n\n- [英语入门王][8]，名字看起来很霸气的一本书，主要包括音标，还有一些日常用语。\n\n- [象形5000][9]：某单词网站出的单词书，主要是关于图形记词，好不好用这个就见仁见智了，我个人觉得用处不大，这篇较生硬，很多是硬套上去的，有兴趣的朋友可以看看。买一赠一，这边再列出[象形9K][10]的pdf扫描件。\n\n- [第三版4晨读美丽英文][11]和[第三版6晨读美丽英文][12]：偶然看到的资源，还没有看过。\n\n- [新东方英语美文][13]：网络比较常见的一个资源了，包含了一些传统的美文文章，以前听过，但这个文件新找的，没有打开过，不保证质量。\n\n- [晨读英语美文100篇][14]：这个暂时还没有下载体验过，之前上学看过一些晨读文章，有兴趣的小伙伴可以下载下来看看，等题主有空体验过后，可能会修改这部分简介。\n\n- [计算机专业英语][15]：这是一个视频教程，网络版的，关于这个的视频网上并不算多，有用没用自己用了才知道。\n\n- [上海交大计算机专业英语(21讲)][16]：没仔细看，印象中唯一的特点就是画质不清楚呢，声音还算清晰。\n\n- [计算机专用英语词汇1500词][17]：这个是比较广为人知的一个词汇册了，百度文库或者任意地方都可以下载到，涉及单词都是较为基础的，最应该掌握的单词，另外扇贝有[程序员必学电脑计算机专业英语词汇1700词][18]，有兴趣的朋友也可以选用这个词汇书背单词。\n\n\n\n******\n\n\n\nTo be continued...\n\n\n\n\n  [1]: http://www.ef.com/english-resources/english-grammar/english-grammar-guide/\n  [2]: http://webster.commnet.edu/writing/writing.htm\n  [3]: http://www.kekenet.com/grammar/\n  [4]: http://www.kekenet.com/\n  [5]: https://pan.baidu.com/s/1cqSgHo\n  [6]: https://pan.baidu.com/s/1jHSp4kI\n  [7]: https://pan.baidu.com/s/1hs0P3q0\n  [8]: https://pan.baidu.com/s/1c20rTJy\n  [9]: https://pan.baidu.com/s/1c1VkCOo\n  [10]: https://pan.baidu.com/s/1nv8Olbr\n  [11]: https://pan.baidu.com/s/1boEsaeF\n  [12]: https://pan.baidu.com/s/1qY1W4BM\n  [13]: https://pan.baidu.com/s/1gfyRaEJ\n  [14]: https://pan.baidu.com/s/1jI4k7ZK\n  [15]: http://%20http://list.youku.com/albumlist/show?id=813471&ascending;=1&page;=1\n  [16]: https://pan.baidu.com/s/1o893hkY\n  [17]: https://pan.baidu.com/s/1qYVdLLE\n  [18]: https://www.shanbay.com/wordbook/104791/\n","slug":"shanbay/shanbay_English_source","published":0,"date":"2017-02-07T01:39:04.182Z","updated":"2016-09-06T07:34:08.735Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyuv3aet0000mumua3u2p0jt","content":"<p><em>本帖不定期的更新一些英语资料，内容涵盖广泛，包括并不止限于：语法书籍，视频教程，听力音频，单词书籍，原版小说，学习类网站等。小伙伴们有些什么好的学习资料也可以在楼下回帖，一楼会对所有楼下的回复内容进行汇总。</em></p>\n<p><strong>注意：大多数资源是百度云分享，手机APP浏览帖子未必能够点开，请点击右上角复制链接到浏览器中打开，或者可以直接PC端浏览器访问原帖。</strong></p>\n<p><strong>以下书籍仅供学习交流，如果你觉得试读不错，为了更好的学习建议购买相关纸质书籍。</strong></p>\n<h3 id=\"资源汇总：\"><a href=\"#资源汇总：\" class=\"headerlink\" title=\"资源汇总：\"></a><em>资源汇总：</em></h3><ul>\n<li><p><a href=\"http://www.ef.com/english-resources/english-grammar/english-grammar-guide/\" target=\"_blank\" rel=\"external\">ENGLISH GRAMMAR GUIDE</a>：一个比较正规的英语语法学习类网站，前提是你的英语够扎实。</p>\n</li>\n<li><p><a href=\"http://webster.commnet.edu/writing/writing.htm\" target=\"_blank\" rel=\"external\">Online Resources for Writers</a>：同上，又是一个全英文的学习网站，主要专注于语法和写作。</p>\n</li>\n<li><p><a href=\"http://www.kekenet.com/grammar/\" target=\"_blank\" rel=\"external\">可可英语语法大全</a>：不要怕，这个是一个中文类的语法学习网站，我个人觉得内容还是浅显易懂的，不仅这个语法内容，同样<a href=\"http://www.kekenet.com/\" target=\"_blank\" rel=\"external\">可可英语</a>也是个值得推荐的英语学习类网站。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1cqSgHo\" target=\"_blank\" rel=\"external\">英语语法新思维</a>：题主不是英语专业的，但听说这个书籍是作为部分英语专业教材使用的，可以想象内容还是恨详尽的，分为初级中级高级三册，讲解相当详尽，而有配套习题，该书对于想要深入学习理解英语语法的人，应该可以算是不错的教材了。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1jHSp4kI\" target=\"_blank\" rel=\"external\">哈利波特全本</a>：pdf文档，附生词表，词频之类的。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1hs0P3q0\" target=\"_blank\" rel=\"external\">易混淆单词手册</a>：这本书偶然发现的，并没有仔细翻阅过，有兴趣的朋友可以看看。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1c20rTJy\" target=\"_blank\" rel=\"external\">英语入门王</a>，名字看起来很霸气的一本书，主要包括音标，还有一些日常用语。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1c1VkCOo\" target=\"_blank\" rel=\"external\">象形5000</a>：某单词网站出的单词书，主要是关于图形记词，好不好用这个就见仁见智了，我个人觉得用处不大，这篇较生硬，很多是硬套上去的，有兴趣的朋友可以看看。买一赠一，这边再列出<a href=\"https://pan.baidu.com/s/1nv8Olbr\" target=\"_blank\" rel=\"external\">象形9K</a>的pdf扫描件。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1boEsaeF\" target=\"_blank\" rel=\"external\">第三版4晨读美丽英文</a>和<a href=\"https://pan.baidu.com/s/1qY1W4BM\" target=\"_blank\" rel=\"external\">第三版6晨读美丽英文</a>：偶然看到的资源，还没有看过。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1gfyRaEJ\" target=\"_blank\" rel=\"external\">新东方英语美文</a>：网络比较常见的一个资源了，包含了一些传统的美文文章，以前听过，但这个文件新找的，没有打开过，不保证质量。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1jI4k7ZK\" target=\"_blank\" rel=\"external\">晨读英语美文100篇</a>：这个暂时还没有下载体验过，之前上学看过一些晨读文章，有兴趣的小伙伴可以下载下来看看，等题主有空体验过后，可能会修改这部分简介。</p>\n</li>\n<li><p><a href=\"http://%20http://list.youku.com/albumlist/show?id=813471&ascending;=1&page;=1\" target=\"_blank\" rel=\"external\">计算机专业英语</a>：这是一个视频教程，网络版的，关于这个的视频网上并不算多，有用没用自己用了才知道。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1o893hkY\" target=\"_blank\" rel=\"external\">上海交大计算机专业英语(21讲)</a>：没仔细看，印象中唯一的特点就是画质不清楚呢，声音还算清晰。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1qYVdLLE\" target=\"_blank\" rel=\"external\">计算机专用英语词汇1500词</a>：这个是比较广为人知的一个词汇册了，百度文库或者任意地方都可以下载到，涉及单词都是较为基础的，最应该掌握的单词，另外扇贝有<a href=\"https://www.shanbay.com/wordbook/104791/\" target=\"_blank\" rel=\"external\">程序员必学电脑计算机专业英语词汇1700词</a>，有兴趣的朋友也可以选用这个词汇书背单词。</p>\n</li>\n</ul>\n<hr>\n<p>To be continued…</p>\n","excerpt":"","more":"<p><em>本帖不定期的更新一些英语资料，内容涵盖广泛，包括并不止限于：语法书籍，视频教程，听力音频，单词书籍，原版小说，学习类网站等。小伙伴们有些什么好的学习资料也可以在楼下回帖，一楼会对所有楼下的回复内容进行汇总。</em></p>\n<p><strong>注意：大多数资源是百度云分享，手机APP浏览帖子未必能够点开，请点击右上角复制链接到浏览器中打开，或者可以直接PC端浏览器访问原帖。</strong></p>\n<p><strong>以下书籍仅供学习交流，如果你觉得试读不错，为了更好的学习建议购买相关纸质书籍。</strong></p>\n<h3 id=\"资源汇总：\"><a href=\"#资源汇总：\" class=\"headerlink\" title=\"资源汇总：\"></a><em>资源汇总：</em></h3><ul>\n<li><p><a href=\"http://www.ef.com/english-resources/english-grammar/english-grammar-guide/\">ENGLISH GRAMMAR GUIDE</a>：一个比较正规的英语语法学习类网站，前提是你的英语够扎实。</p>\n</li>\n<li><p><a href=\"http://webster.commnet.edu/writing/writing.htm\">Online Resources for Writers</a>：同上，又是一个全英文的学习网站，主要专注于语法和写作。</p>\n</li>\n<li><p><a href=\"http://www.kekenet.com/grammar/\">可可英语语法大全</a>：不要怕，这个是一个中文类的语法学习网站，我个人觉得内容还是浅显易懂的，不仅这个语法内容，同样<a href=\"http://www.kekenet.com/\">可可英语</a>也是个值得推荐的英语学习类网站。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1cqSgHo\">英语语法新思维</a>：题主不是英语专业的，但听说这个书籍是作为部分英语专业教材使用的，可以想象内容还是恨详尽的，分为初级中级高级三册，讲解相当详尽，而有配套习题，该书对于想要深入学习理解英语语法的人，应该可以算是不错的教材了。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1jHSp4kI\">哈利波特全本</a>：pdf文档，附生词表，词频之类的。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1hs0P3q0\">易混淆单词手册</a>：这本书偶然发现的，并没有仔细翻阅过，有兴趣的朋友可以看看。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1c20rTJy\">英语入门王</a>，名字看起来很霸气的一本书，主要包括音标，还有一些日常用语。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1c1VkCOo\">象形5000</a>：某单词网站出的单词书，主要是关于图形记词，好不好用这个就见仁见智了，我个人觉得用处不大，这篇较生硬，很多是硬套上去的，有兴趣的朋友可以看看。买一赠一，这边再列出<a href=\"https://pan.baidu.com/s/1nv8Olbr\">象形9K</a>的pdf扫描件。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1boEsaeF\">第三版4晨读美丽英文</a>和<a href=\"https://pan.baidu.com/s/1qY1W4BM\">第三版6晨读美丽英文</a>：偶然看到的资源，还没有看过。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1gfyRaEJ\">新东方英语美文</a>：网络比较常见的一个资源了，包含了一些传统的美文文章，以前听过，但这个文件新找的，没有打开过，不保证质量。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1jI4k7ZK\">晨读英语美文100篇</a>：这个暂时还没有下载体验过，之前上学看过一些晨读文章，有兴趣的小伙伴可以下载下来看看，等题主有空体验过后，可能会修改这部分简介。</p>\n</li>\n<li><p><a href=\"http://%20http://list.youku.com/albumlist/show?id=813471&ascending;=1&page;=1\">计算机专业英语</a>：这是一个视频教程，网络版的，关于这个的视频网上并不算多，有用没用自己用了才知道。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1o893hkY\">上海交大计算机专业英语(21讲)</a>：没仔细看，印象中唯一的特点就是画质不清楚呢，声音还算清晰。</p>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1qYVdLLE\">计算机专用英语词汇1500词</a>：这个是比较广为人知的一个词汇册了，百度文库或者任意地方都可以下载到，涉及单词都是较为基础的，最应该掌握的单词，另外扇贝有<a href=\"https://www.shanbay.com/wordbook/104791/\">程序员必学电脑计算机专业英语词汇1700词</a>，有兴趣的朋友也可以选用这个词汇书背单词。</p>\n</li>\n</ul>\n<hr>\n<p>To be continued…</p>\n"},{"_content":"### 扇贝打卡通知：\n亲爱的组员，你之前未能按时完成扇贝的学习任务，如需补签请在https://www.shanbay.com/accounts/setting/上更改时区，扇贝小组是个学习进步的小组，小组会对未能完成学习任务的一些组员进行移除，请收到信息后及时学习打卡。\n**你学习的进步也是小组成长的动力。**\n","source":"_drafts/shanbay/shanbay_notice.md","raw":"### 扇贝打卡通知：\n亲爱的组员，你之前未能按时完成扇贝的学习任务，如需补签请在https://www.shanbay.com/accounts/setting/上更改时区，扇贝小组是个学习进步的小组，小组会对未能完成学习任务的一些组员进行移除，请收到信息后及时学习打卡。\n**你学习的进步也是小组成长的动力。**\n","slug":"shanbay/shanbay_notice","published":0,"date":"2017-02-07T01:39:04.202Z","updated":"2016-09-13T14:27:12.356Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyuv3aez0001mumub3calvtr","content":"<h3 id=\"扇贝打卡通知：\"><a href=\"#扇贝打卡通知：\" class=\"headerlink\" title=\"扇贝打卡通知：\"></a>扇贝打卡通知：</h3><p>亲爱的组员，你之前未能按时完成扇贝的学习任务，如需补签请在<a href=\"https://www.shanbay.com/accounts/setting/上更改时区，扇贝小组是个学习进步的小组，小组会对未能完成学习任务的一些组员进行移除，请收到信息后及时学习打卡。\" target=\"_blank\" rel=\"external\">https://www.shanbay.com/accounts/setting/上更改时区，扇贝小组是个学习进步的小组，小组会对未能完成学习任务的一些组员进行移除，请收到信息后及时学习打卡。</a><br><strong>你学习的进步也是小组成长的动力。</strong></p>\n","excerpt":"","more":"<h3 id=\"扇贝打卡通知：\"><a href=\"#扇贝打卡通知：\" class=\"headerlink\" title=\"扇贝打卡通知：\"></a>扇贝打卡通知：</h3><p>亲爱的组员，你之前未能按时完成扇贝的学习任务，如需补签请在<a href=\"https://www.shanbay.com/accounts/setting/上更改时区，扇贝小组是个学习进步的小组，小组会对未能完成学习任务的一些组员进行移除，请收到信息后及时学习打卡。\">https://www.shanbay.com/accounts/setting/上更改时区，扇贝小组是个学习进步的小组，小组会对未能完成学习任务的一些组员进行移除，请收到信息后及时学习打卡。</a><br><strong>你学习的进步也是小组成长的动力。</strong></p>\n"},{"_content":"## 亲爱的组员：\n\n\n*欢迎加入我们小组，扇贝是每天打卡都会有奖励的，连续打卡有额外的奖励和徽章，获得的奖励可以购买更多的扇贝增值服务。从现在起，你就可以在小组内发帖和大家一起讨论你感兴趣的话题了，你的学习进步也是小组成长的动力。*\n\n\n\n***\n\n\n### 小组寄语：\n\n- 首先感谢你在众多小组中选择了本小组。本小组是个促进大家共同学习，团结有爱的小组。\n- 加入小组后，只要有一天不打卡，小组打卡率就会下降，小组如果需要扩招，打卡率需要保持在 85% 以上。\n- 小组成长值增加后，小组的排名将会更高，也会吸引更多的小伙伴加入我们。\n- 小组有自己的微信及qq群，除了英语的学习外，也可以在qq群中畅聊兴趣爱好等。qq群和小组帖中也会定期分享一些资源，同时也期望大家踊跃分享。\n- 小组主要靠大家自觉自律的学习，组长虽然打卡时间不长，但对扇贝等比较了解，能自己做到坚持学习打卡，同时也会对所有组员严格要求。也希望大家通过本小组互相监督，共同进步。\n\n***\n\n### **1. 群规**\n- 前100天必须满勤（一天都不能漏卡）\n- 100天以后不得出现连续两天不打卡（如有特殊情况，请事先同组长协商）\n- 组员个人打卡率绝不得低于92%\n- 实在情况过于特殊，请提前与组长联系。\n- 如果你觉得太过严苛，请出门左拐！\n\n**组长工作党，精力有限，会不定期地抽查打卡（可能一天会查好几次，也可能会让其他组员帮查卡），一旦发现未达以上要求即会被踢出本组，以上要求也同时作为本组的底线要求。如果你觉得太过严苛，请出门左拐！**\n\n***\n\n### **2. 扇贝**\n\n#### **扇贝单词：**\n- 扇贝的招牌应用，当然现在市面上也有一些应用和扇贝单词类似了。\n- 特点就是确实能够帮助你背熟几千个单词，和大多数单词应用不同的地方是：**扇贝单词会比较智能的帮你不断复习你背过但不会的单词，以及巩固你可能还没有完全掌握的单词，**这些单词会呈周期性的出现，而设置的学习单词量中，大部分也是复习巩固，极少数是新单词。\n- **推荐使用拼写模式，效果极佳。**\n\n#### **扇贝阅读：**\n- 大多数是外文小说，原著，但其中的书大都比较老。\n- 有这个耐心好好阅读的话，肯定是有进步的。\n- 需要消耗扇贝的，所以购买时，**建议先试读，再考虑购买，且看完一本再买另一本。**\n\n#### **扇贝新闻：**\n- 作为扇贝系列中必备的一个软件，基本上可以解决英语阅读问题。\n- 内容方面主要涵盖：**时事热点（国内外），科技，体育，影视等**。\n- 按照各个难度会有划分，且每篇文章都会有热心的贝友分享笔记、心得、评论。\n\n#### **扇贝听力：**\n- 个人觉得难度较大，因为据说录制人员是美国本土的，会有一定的地方口音以及连读；另外一些场景下，录制不是特别清晰。\n- 如果你很想提高自己英语的专业水平，那这个绝对适合你。\n\n#### **扇贝炼句：**\n- 也是扇贝最受欢迎的一个应用之一，在其他软件上面没怎么见过这个英语学习功能。\n- 主要是帮你学习巩固英语短语日常应用，每个句子会学三遍，另外会加入录音识别功能。\n- **如果每个句子都可以完整复述效果是相当好的，另外价格看起来昂贵，其实不然，每个炼句书的学习周期很长，和扇贝单词类似，会不断巩固学习以前的内容，因此一本30课的书，可能实际学习会是3个月以上。**\n\n#### **扇贝口语：**\n- 该应用是最近出来的，还没怎么使用过，应用功能本身也正在实验开发中，貌似是个带语音识别功能的软件。有兴趣的小伙伴们可以赶紧去尝个鲜。\n- 可以肯定的是软件后续肯定也是会收取费用或者增加一些支出的，所以想使用的话趁早。\n\n***\n\n### **3. FAQ**\n#### 1. 如何设置每天的学习量？\n电脑浏览器[学习量](http://www.shanbay.com/bdc/setting/)，手机端在每个应用的设置->学习量中选择，但第二天才会生效，所以就别想着今天偷懒少学点了。\n\n#### 2. 完成了任务，但忘记打卡了怎么办？\n[点击补救](http://www.shanbay.com/checkin/status/)此链接能看到7天内每日任务完成情况，仅适用于前一天完成所有任务后。\n\n#### 3. 断签了，如何补以前的打卡？\n浏览器打开[急救](https://www.shanbay.com/accounts/setting/)，好像最晚的是洛杉矶时间，就是西八区的应该都行，补完卡一定要记得改回来，否则极有可能出现漏签。**但如果你是更早的时间段没打卡，那很遗憾的告诉你，放弃治疗吧！！！扇贝不像贴吧之类的娱乐圈钱应用，没有提供花钱补签这一功能，没学习就是没学习，吃一堑长一智吧。另外现在加入了扇贝计划和保险的，也没法通过改时区补签。**\n\n#### 4. 什么是阅读计划？听力计划？炼句计划？\n加入计划，并且完成计划，可以获得额外的奖励（积分及贝壳）。需要注意的是**现阶段的计划都是需要缴纳保金（贝壳）的，一单中途放弃，贝壳概不退还。**另外加入计划能够帮助那些爱拖延偷懒的患者，因为一旦入了计划，只有完成所有计划后，你才可以打卡。\n\n#### 5. 单词的记忆是只要能拼写出来算认识还是能记得住中文意思算认识这个单词？什么程度算认识一个单词 如果你选择不认识是不是一直会不断重复？\n\n**单词看你的个人要求，如果多用于阅读，口语的话，不需要拼写**。*扇贝每个单词会周期性的重复5次*，另外觉得实在简单的单词可以点击简单，让单词不再出现。学习量的选择是第二天生效，新词优先模式会每天加入新单词，如果这个模式关闭的话，一般会在你没有掌握的单词数低于你学习量的4倍，才会给你添加新单词。**建议基础词汇或者需要考试的词汇重点记忆**，比如4级词汇之类的，最好用拼写记忆模式，后续一些电视剧或者不是太常见的词汇可以识记，有个印象即刻。\n\n#### 6.打卡什么是成功的呢？打卡率100％有什么用处？\n\n每天相应的完成了打卡任务就可以完成打卡，如果没有加入任何保险或者计划，完成单一听力，炼句，阅读等内容均可完成打卡。**每天打卡才有100%**，*目前的打卡率只有小组打卡率，是你入组后的打卡率，暂时无法查看个人打卡率*。**扇贝有连续打卡徽章**，即你连续n天打卡，没有断过则会有这个徽章。打卡以及获得徽章荣誉积分扇贝等，都是对于坚持学习的鼓励认可。当然你不需要这个荣誉点数，就能好好学习，当然更好啦。\n\n*To be continued...*\n\n***\n\n### **4. 交流**\n- 有关扇贝的相关使用技巧，将会在小组贴中逐步完善，具体请查阅。\n- 扇贝qq群提供交流天南海北，各种兴趣爱好，学习，工作，技能等小组qq群号：568650162。\n- 微信群只讨论英语，扇贝，小组相关内容，入qq群后找二维码，扫码加群，**请慎入**，微信群已经取消了每日打卡提醒功能，扇贝微信账号加入了打卡提醒，可以手动设置该选项。\n\n***\n\n### **5. 注意**\n- 小组帖禁止侵犯个人私隐，广告类，非法，色情以及任何违反中华人民共和国法律的内容。\n- 后续可能会举办一些相关活动，也会发一些资源类福利贴，敬请期待。\n- 有任何不明白的问题，可以在群中讨论，如果仍有疑惑，可以联系组长。\n\n\n\n***\n![图片 1][1]\n\n\n  [1]: https://static.baydn.com/media/media_store/image/aaba0062151ffb390575b5717f1ae704.jpg\n\n***\n**happy learning.**\n***\n","source":"_drafts/shanbay/shanbay_guide.md","raw":"## 亲爱的组员：\n\n\n*欢迎加入我们小组，扇贝是每天打卡都会有奖励的，连续打卡有额外的奖励和徽章，获得的奖励可以购买更多的扇贝增值服务。从现在起，你就可以在小组内发帖和大家一起讨论你感兴趣的话题了，你的学习进步也是小组成长的动力。*\n\n\n\n***\n\n\n### 小组寄语：\n\n- 首先感谢你在众多小组中选择了本小组。本小组是个促进大家共同学习，团结有爱的小组。\n- 加入小组后，只要有一天不打卡，小组打卡率就会下降，小组如果需要扩招，打卡率需要保持在 85% 以上。\n- 小组成长值增加后，小组的排名将会更高，也会吸引更多的小伙伴加入我们。\n- 小组有自己的微信及qq群，除了英语的学习外，也可以在qq群中畅聊兴趣爱好等。qq群和小组帖中也会定期分享一些资源，同时也期望大家踊跃分享。\n- 小组主要靠大家自觉自律的学习，组长虽然打卡时间不长，但对扇贝等比较了解，能自己做到坚持学习打卡，同时也会对所有组员严格要求。也希望大家通过本小组互相监督，共同进步。\n\n***\n\n### **1. 群规**\n- 前100天必须满勤（一天都不能漏卡）\n- 100天以后不得出现连续两天不打卡（如有特殊情况，请事先同组长协商）\n- 组员个人打卡率绝不得低于92%\n- 实在情况过于特殊，请提前与组长联系。\n- 如果你觉得太过严苛，请出门左拐！\n\n**组长工作党，精力有限，会不定期地抽查打卡（可能一天会查好几次，也可能会让其他组员帮查卡），一旦发现未达以上要求即会被踢出本组，以上要求也同时作为本组的底线要求。如果你觉得太过严苛，请出门左拐！**\n\n***\n\n### **2. 扇贝**\n\n#### **扇贝单词：**\n- 扇贝的招牌应用，当然现在市面上也有一些应用和扇贝单词类似了。\n- 特点就是确实能够帮助你背熟几千个单词，和大多数单词应用不同的地方是：**扇贝单词会比较智能的帮你不断复习你背过但不会的单词，以及巩固你可能还没有完全掌握的单词，**这些单词会呈周期性的出现，而设置的学习单词量中，大部分也是复习巩固，极少数是新单词。\n- **推荐使用拼写模式，效果极佳。**\n\n#### **扇贝阅读：**\n- 大多数是外文小说，原著，但其中的书大都比较老。\n- 有这个耐心好好阅读的话，肯定是有进步的。\n- 需要消耗扇贝的，所以购买时，**建议先试读，再考虑购买，且看完一本再买另一本。**\n\n#### **扇贝新闻：**\n- 作为扇贝系列中必备的一个软件，基本上可以解决英语阅读问题。\n- 内容方面主要涵盖：**时事热点（国内外），科技，体育，影视等**。\n- 按照各个难度会有划分，且每篇文章都会有热心的贝友分享笔记、心得、评论。\n\n#### **扇贝听力：**\n- 个人觉得难度较大，因为据说录制人员是美国本土的，会有一定的地方口音以及连读；另外一些场景下，录制不是特别清晰。\n- 如果你很想提高自己英语的专业水平，那这个绝对适合你。\n\n#### **扇贝炼句：**\n- 也是扇贝最受欢迎的一个应用之一，在其他软件上面没怎么见过这个英语学习功能。\n- 主要是帮你学习巩固英语短语日常应用，每个句子会学三遍，另外会加入录音识别功能。\n- **如果每个句子都可以完整复述效果是相当好的，另外价格看起来昂贵，其实不然，每个炼句书的学习周期很长，和扇贝单词类似，会不断巩固学习以前的内容，因此一本30课的书，可能实际学习会是3个月以上。**\n\n#### **扇贝口语：**\n- 该应用是最近出来的，还没怎么使用过，应用功能本身也正在实验开发中，貌似是个带语音识别功能的软件。有兴趣的小伙伴们可以赶紧去尝个鲜。\n- 可以肯定的是软件后续肯定也是会收取费用或者增加一些支出的，所以想使用的话趁早。\n\n***\n\n### **3. FAQ**\n#### 1. 如何设置每天的学习量？\n电脑浏览器[学习量](http://www.shanbay.com/bdc/setting/)，手机端在每个应用的设置->学习量中选择，但第二天才会生效，所以就别想着今天偷懒少学点了。\n\n#### 2. 完成了任务，但忘记打卡了怎么办？\n[点击补救](http://www.shanbay.com/checkin/status/)此链接能看到7天内每日任务完成情况，仅适用于前一天完成所有任务后。\n\n#### 3. 断签了，如何补以前的打卡？\n浏览器打开[急救](https://www.shanbay.com/accounts/setting/)，好像最晚的是洛杉矶时间，就是西八区的应该都行，补完卡一定要记得改回来，否则极有可能出现漏签。**但如果你是更早的时间段没打卡，那很遗憾的告诉你，放弃治疗吧！！！扇贝不像贴吧之类的娱乐圈钱应用，没有提供花钱补签这一功能，没学习就是没学习，吃一堑长一智吧。另外现在加入了扇贝计划和保险的，也没法通过改时区补签。**\n\n#### 4. 什么是阅读计划？听力计划？炼句计划？\n加入计划，并且完成计划，可以获得额外的奖励（积分及贝壳）。需要注意的是**现阶段的计划都是需要缴纳保金（贝壳）的，一单中途放弃，贝壳概不退还。**另外加入计划能够帮助那些爱拖延偷懒的患者，因为一旦入了计划，只有完成所有计划后，你才可以打卡。\n\n#### 5. 单词的记忆是只要能拼写出来算认识还是能记得住中文意思算认识这个单词？什么程度算认识一个单词 如果你选择不认识是不是一直会不断重复？\n\n**单词看你的个人要求，如果多用于阅读，口语的话，不需要拼写**。*扇贝每个单词会周期性的重复5次*，另外觉得实在简单的单词可以点击简单，让单词不再出现。学习量的选择是第二天生效，新词优先模式会每天加入新单词，如果这个模式关闭的话，一般会在你没有掌握的单词数低于你学习量的4倍，才会给你添加新单词。**建议基础词汇或者需要考试的词汇重点记忆**，比如4级词汇之类的，最好用拼写记忆模式，后续一些电视剧或者不是太常见的词汇可以识记，有个印象即刻。\n\n#### 6.打卡什么是成功的呢？打卡率100％有什么用处？\n\n每天相应的完成了打卡任务就可以完成打卡，如果没有加入任何保险或者计划，完成单一听力，炼句，阅读等内容均可完成打卡。**每天打卡才有100%**，*目前的打卡率只有小组打卡率，是你入组后的打卡率，暂时无法查看个人打卡率*。**扇贝有连续打卡徽章**，即你连续n天打卡，没有断过则会有这个徽章。打卡以及获得徽章荣誉积分扇贝等，都是对于坚持学习的鼓励认可。当然你不需要这个荣誉点数，就能好好学习，当然更好啦。\n\n*To be continued...*\n\n***\n\n### **4. 交流**\n- 有关扇贝的相关使用技巧，将会在小组贴中逐步完善，具体请查阅。\n- 扇贝qq群提供交流天南海北，各种兴趣爱好，学习，工作，技能等小组qq群号：568650162。\n- 微信群只讨论英语，扇贝，小组相关内容，入qq群后找二维码，扫码加群，**请慎入**，微信群已经取消了每日打卡提醒功能，扇贝微信账号加入了打卡提醒，可以手动设置该选项。\n\n***\n\n### **5. 注意**\n- 小组帖禁止侵犯个人私隐，广告类，非法，色情以及任何违反中华人民共和国法律的内容。\n- 后续可能会举办一些相关活动，也会发一些资源类福利贴，敬请期待。\n- 有任何不明白的问题，可以在群中讨论，如果仍有疑惑，可以联系组长。\n\n\n\n***\n![图片 1][1]\n\n\n  [1]: https://static.baydn.com/media/media_store/image/aaba0062151ffb390575b5717f1ae704.jpg\n\n***\n**happy learning.**\n***\n","slug":"shanbay/shanbay_guide","published":0,"date":"2017-02-07T01:39:04.174Z","updated":"2017-01-04T11:22:00.523Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyuv3af20002mumu5kfhgtys","content":"<h2 id=\"亲爱的组员：\"><a href=\"#亲爱的组员：\" class=\"headerlink\" title=\"亲爱的组员：\"></a>亲爱的组员：</h2><p><em>欢迎加入我们小组，扇贝是每天打卡都会有奖励的，连续打卡有额外的奖励和徽章，获得的奖励可以购买更多的扇贝增值服务。从现在起，你就可以在小组内发帖和大家一起讨论你感兴趣的话题了，你的学习进步也是小组成长的动力。</em></p>\n<hr>\n<h3 id=\"小组寄语：\"><a href=\"#小组寄语：\" class=\"headerlink\" title=\"小组寄语：\"></a>小组寄语：</h3><ul>\n<li>首先感谢你在众多小组中选择了本小组。本小组是个促进大家共同学习，团结有爱的小组。</li>\n<li>加入小组后，只要有一天不打卡，小组打卡率就会下降，小组如果需要扩招，打卡率需要保持在 85% 以上。</li>\n<li>小组成长值增加后，小组的排名将会更高，也会吸引更多的小伙伴加入我们。</li>\n<li>小组有自己的微信及qq群，除了英语的学习外，也可以在qq群中畅聊兴趣爱好等。qq群和小组帖中也会定期分享一些资源，同时也期望大家踊跃分享。</li>\n<li>小组主要靠大家自觉自律的学习，组长虽然打卡时间不长，但对扇贝等比较了解，能自己做到坚持学习打卡，同时也会对所有组员严格要求。也希望大家通过本小组互相监督，共同进步。</li>\n</ul>\n<hr>\n<h3 id=\"1-群规\"><a href=\"#1-群规\" class=\"headerlink\" title=\"1. 群规\"></a><strong>1. 群规</strong></h3><ul>\n<li>前100天必须满勤（一天都不能漏卡）</li>\n<li>100天以后不得出现连续两天不打卡（如有特殊情况，请事先同组长协商）</li>\n<li>组员个人打卡率绝不得低于92%</li>\n<li>实在情况过于特殊，请提前与组长联系。</li>\n<li>如果你觉得太过严苛，请出门左拐！</li>\n</ul>\n<p><strong>组长工作党，精力有限，会不定期地抽查打卡（可能一天会查好几次，也可能会让其他组员帮查卡），一旦发现未达以上要求即会被踢出本组，以上要求也同时作为本组的底线要求。如果你觉得太过严苛，请出门左拐！</strong></p>\n<hr>\n<h3 id=\"2-扇贝\"><a href=\"#2-扇贝\" class=\"headerlink\" title=\"2. 扇贝\"></a><strong>2. 扇贝</strong></h3><h4 id=\"扇贝单词：\"><a href=\"#扇贝单词：\" class=\"headerlink\" title=\"扇贝单词：\"></a><strong>扇贝单词：</strong></h4><ul>\n<li>扇贝的招牌应用，当然现在市面上也有一些应用和扇贝单词类似了。</li>\n<li>特点就是确实能够帮助你背熟几千个单词，和大多数单词应用不同的地方是：<strong>扇贝单词会比较智能的帮你不断复习你背过但不会的单词，以及巩固你可能还没有完全掌握的单词，</strong>这些单词会呈周期性的出现，而设置的学习单词量中，大部分也是复习巩固，极少数是新单词。</li>\n<li><strong>推荐使用拼写模式，效果极佳。</strong></li>\n</ul>\n<h4 id=\"扇贝阅读：\"><a href=\"#扇贝阅读：\" class=\"headerlink\" title=\"扇贝阅读：\"></a><strong>扇贝阅读：</strong></h4><ul>\n<li>大多数是外文小说，原著，但其中的书大都比较老。</li>\n<li>有这个耐心好好阅读的话，肯定是有进步的。</li>\n<li>需要消耗扇贝的，所以购买时，<strong>建议先试读，再考虑购买，且看完一本再买另一本。</strong></li>\n</ul>\n<h4 id=\"扇贝新闻：\"><a href=\"#扇贝新闻：\" class=\"headerlink\" title=\"扇贝新闻：\"></a><strong>扇贝新闻：</strong></h4><ul>\n<li>作为扇贝系列中必备的一个软件，基本上可以解决英语阅读问题。</li>\n<li>内容方面主要涵盖：<strong>时事热点（国内外），科技，体育，影视等</strong>。</li>\n<li>按照各个难度会有划分，且每篇文章都会有热心的贝友分享笔记、心得、评论。</li>\n</ul>\n<h4 id=\"扇贝听力：\"><a href=\"#扇贝听力：\" class=\"headerlink\" title=\"扇贝听力：\"></a><strong>扇贝听力：</strong></h4><ul>\n<li>个人觉得难度较大，因为据说录制人员是美国本土的，会有一定的地方口音以及连读；另外一些场景下，录制不是特别清晰。</li>\n<li>如果你很想提高自己英语的专业水平，那这个绝对适合你。</li>\n</ul>\n<h4 id=\"扇贝炼句：\"><a href=\"#扇贝炼句：\" class=\"headerlink\" title=\"扇贝炼句：\"></a><strong>扇贝炼句：</strong></h4><ul>\n<li>也是扇贝最受欢迎的一个应用之一，在其他软件上面没怎么见过这个英语学习功能。</li>\n<li>主要是帮你学习巩固英语短语日常应用，每个句子会学三遍，另外会加入录音识别功能。</li>\n<li><strong>如果每个句子都可以完整复述效果是相当好的，另外价格看起来昂贵，其实不然，每个炼句书的学习周期很长，和扇贝单词类似，会不断巩固学习以前的内容，因此一本30课的书，可能实际学习会是3个月以上。</strong></li>\n</ul>\n<h4 id=\"扇贝口语：\"><a href=\"#扇贝口语：\" class=\"headerlink\" title=\"扇贝口语：\"></a><strong>扇贝口语：</strong></h4><ul>\n<li>该应用是最近出来的，还没怎么使用过，应用功能本身也正在实验开发中，貌似是个带语音识别功能的软件。有兴趣的小伙伴们可以赶紧去尝个鲜。</li>\n<li>可以肯定的是软件后续肯定也是会收取费用或者增加一些支出的，所以想使用的话趁早。</li>\n</ul>\n<hr>\n<h3 id=\"3-FAQ\"><a href=\"#3-FAQ\" class=\"headerlink\" title=\"3. FAQ\"></a><strong>3. FAQ</strong></h3><h4 id=\"1-如何设置每天的学习量？\"><a href=\"#1-如何设置每天的学习量？\" class=\"headerlink\" title=\"1. 如何设置每天的学习量？\"></a>1. 如何设置每天的学习量？</h4><p>电脑浏览器<a href=\"http://www.shanbay.com/bdc/setting/\" target=\"_blank\" rel=\"external\">学习量</a>，手机端在每个应用的设置-&gt;学习量中选择，但第二天才会生效，所以就别想着今天偷懒少学点了。</p>\n<h4 id=\"2-完成了任务，但忘记打卡了怎么办？\"><a href=\"#2-完成了任务，但忘记打卡了怎么办？\" class=\"headerlink\" title=\"2. 完成了任务，但忘记打卡了怎么办？\"></a>2. 完成了任务，但忘记打卡了怎么办？</h4><p><a href=\"http://www.shanbay.com/checkin/status/\" target=\"_blank\" rel=\"external\">点击补救</a>此链接能看到7天内每日任务完成情况，仅适用于前一天完成所有任务后。</p>\n<h4 id=\"3-断签了，如何补以前的打卡？\"><a href=\"#3-断签了，如何补以前的打卡？\" class=\"headerlink\" title=\"3. 断签了，如何补以前的打卡？\"></a>3. 断签了，如何补以前的打卡？</h4><p>浏览器打开<a href=\"https://www.shanbay.com/accounts/setting/\" target=\"_blank\" rel=\"external\">急救</a>，好像最晚的是洛杉矶时间，就是西八区的应该都行，补完卡一定要记得改回来，否则极有可能出现漏签。<strong>但如果你是更早的时间段没打卡，那很遗憾的告诉你，放弃治疗吧！！！扇贝不像贴吧之类的娱乐圈钱应用，没有提供花钱补签这一功能，没学习就是没学习，吃一堑长一智吧。另外现在加入了扇贝计划和保险的，也没法通过改时区补签。</strong></p>\n<h4 id=\"4-什么是阅读计划？听力计划？炼句计划？\"><a href=\"#4-什么是阅读计划？听力计划？炼句计划？\" class=\"headerlink\" title=\"4. 什么是阅读计划？听力计划？炼句计划？\"></a>4. 什么是阅读计划？听力计划？炼句计划？</h4><p>加入计划，并且完成计划，可以获得额外的奖励（积分及贝壳）。需要注意的是<strong>现阶段的计划都是需要缴纳保金（贝壳）的，一单中途放弃，贝壳概不退还。</strong>另外加入计划能够帮助那些爱拖延偷懒的患者，因为一旦入了计划，只有完成所有计划后，你才可以打卡。</p>\n<h4 id=\"5-单词的记忆是只要能拼写出来算认识还是能记得住中文意思算认识这个单词？什么程度算认识一个单词-如果你选择不认识是不是一直会不断重复？\"><a href=\"#5-单词的记忆是只要能拼写出来算认识还是能记得住中文意思算认识这个单词？什么程度算认识一个单词-如果你选择不认识是不是一直会不断重复？\" class=\"headerlink\" title=\"5. 单词的记忆是只要能拼写出来算认识还是能记得住中文意思算认识这个单词？什么程度算认识一个单词 如果你选择不认识是不是一直会不断重复？\"></a>5. 单词的记忆是只要能拼写出来算认识还是能记得住中文意思算认识这个单词？什么程度算认识一个单词 如果你选择不认识是不是一直会不断重复？</h4><p><strong>单词看你的个人要求，如果多用于阅读，口语的话，不需要拼写</strong>。<em>扇贝每个单词会周期性的重复5次</em>，另外觉得实在简单的单词可以点击简单，让单词不再出现。学习量的选择是第二天生效，新词优先模式会每天加入新单词，如果这个模式关闭的话，一般会在你没有掌握的单词数低于你学习量的4倍，才会给你添加新单词。<strong>建议基础词汇或者需要考试的词汇重点记忆</strong>，比如4级词汇之类的，最好用拼写记忆模式，后续一些电视剧或者不是太常见的词汇可以识记，有个印象即刻。</p>\n<h4 id=\"6-打卡什么是成功的呢？打卡率100％有什么用处？\"><a href=\"#6-打卡什么是成功的呢？打卡率100％有什么用处？\" class=\"headerlink\" title=\"6.打卡什么是成功的呢？打卡率100％有什么用处？\"></a>6.打卡什么是成功的呢？打卡率100％有什么用处？</h4><p>每天相应的完成了打卡任务就可以完成打卡，如果没有加入任何保险或者计划，完成单一听力，炼句，阅读等内容均可完成打卡。<strong>每天打卡才有100%</strong>，<em>目前的打卡率只有小组打卡率，是你入组后的打卡率，暂时无法查看个人打卡率</em>。<strong>扇贝有连续打卡徽章</strong>，即你连续n天打卡，没有断过则会有这个徽章。打卡以及获得徽章荣誉积分扇贝等，都是对于坚持学习的鼓励认可。当然你不需要这个荣誉点数，就能好好学习，当然更好啦。</p>\n<p><em>To be continued…</em></p>\n<hr>\n<h3 id=\"4-交流\"><a href=\"#4-交流\" class=\"headerlink\" title=\"4. 交流\"></a><strong>4. 交流</strong></h3><ul>\n<li>有关扇贝的相关使用技巧，将会在小组贴中逐步完善，具体请查阅。</li>\n<li>扇贝qq群提供交流天南海北，各种兴趣爱好，学习，工作，技能等小组qq群号：568650162。</li>\n<li>微信群只讨论英语，扇贝，小组相关内容，入qq群后找二维码，扫码加群，<strong>请慎入</strong>，微信群已经取消了每日打卡提醒功能，扇贝微信账号加入了打卡提醒，可以手动设置该选项。</li>\n</ul>\n<hr>\n<h3 id=\"5-注意\"><a href=\"#5-注意\" class=\"headerlink\" title=\"5. 注意\"></a><strong>5. 注意</strong></h3><ul>\n<li>小组帖禁止侵犯个人私隐，广告类，非法，色情以及任何违反中华人民共和国法律的内容。</li>\n<li>后续可能会举办一些相关活动，也会发一些资源类福利贴，敬请期待。</li>\n<li>有任何不明白的问题，可以在群中讨论，如果仍有疑惑，可以联系组长。</li>\n</ul>\n<hr>\n<p><img src=\"https://static.baydn.com/media/media_store/image/aaba0062151ffb390575b5717f1ae704.jpg\" alt=\"图片 1\"></p>\n<hr>\n<p><strong>happy learning.</strong></p>\n<hr>\n","excerpt":"","more":"<h2 id=\"亲爱的组员：\"><a href=\"#亲爱的组员：\" class=\"headerlink\" title=\"亲爱的组员：\"></a>亲爱的组员：</h2><p><em>欢迎加入我们小组，扇贝是每天打卡都会有奖励的，连续打卡有额外的奖励和徽章，获得的奖励可以购买更多的扇贝增值服务。从现在起，你就可以在小组内发帖和大家一起讨论你感兴趣的话题了，你的学习进步也是小组成长的动力。</em></p>\n<hr>\n<h3 id=\"小组寄语：\"><a href=\"#小组寄语：\" class=\"headerlink\" title=\"小组寄语：\"></a>小组寄语：</h3><ul>\n<li>首先感谢你在众多小组中选择了本小组。本小组是个促进大家共同学习，团结有爱的小组。</li>\n<li>加入小组后，只要有一天不打卡，小组打卡率就会下降，小组如果需要扩招，打卡率需要保持在 85% 以上。</li>\n<li>小组成长值增加后，小组的排名将会更高，也会吸引更多的小伙伴加入我们。</li>\n<li>小组有自己的微信及qq群，除了英语的学习外，也可以在qq群中畅聊兴趣爱好等。qq群和小组帖中也会定期分享一些资源，同时也期望大家踊跃分享。</li>\n<li>小组主要靠大家自觉自律的学习，组长虽然打卡时间不长，但对扇贝等比较了解，能自己做到坚持学习打卡，同时也会对所有组员严格要求。也希望大家通过本小组互相监督，共同进步。</li>\n</ul>\n<hr>\n<h3 id=\"1-群规\"><a href=\"#1-群规\" class=\"headerlink\" title=\"1. 群规\"></a><strong>1. 群规</strong></h3><ul>\n<li>前100天必须满勤（一天都不能漏卡）</li>\n<li>100天以后不得出现连续两天不打卡（如有特殊情况，请事先同组长协商）</li>\n<li>组员个人打卡率绝不得低于92%</li>\n<li>实在情况过于特殊，请提前与组长联系。</li>\n<li>如果你觉得太过严苛，请出门左拐！</li>\n</ul>\n<p><strong>组长工作党，精力有限，会不定期地抽查打卡（可能一天会查好几次，也可能会让其他组员帮查卡），一旦发现未达以上要求即会被踢出本组，以上要求也同时作为本组的底线要求。如果你觉得太过严苛，请出门左拐！</strong></p>\n<hr>\n<h3 id=\"2-扇贝\"><a href=\"#2-扇贝\" class=\"headerlink\" title=\"2. 扇贝\"></a><strong>2. 扇贝</strong></h3><h4 id=\"扇贝单词：\"><a href=\"#扇贝单词：\" class=\"headerlink\" title=\"扇贝单词：\"></a><strong>扇贝单词：</strong></h4><ul>\n<li>扇贝的招牌应用，当然现在市面上也有一些应用和扇贝单词类似了。</li>\n<li>特点就是确实能够帮助你背熟几千个单词，和大多数单词应用不同的地方是：<strong>扇贝单词会比较智能的帮你不断复习你背过但不会的单词，以及巩固你可能还没有完全掌握的单词，</strong>这些单词会呈周期性的出现，而设置的学习单词量中，大部分也是复习巩固，极少数是新单词。</li>\n<li><strong>推荐使用拼写模式，效果极佳。</strong></li>\n</ul>\n<h4 id=\"扇贝阅读：\"><a href=\"#扇贝阅读：\" class=\"headerlink\" title=\"扇贝阅读：\"></a><strong>扇贝阅读：</strong></h4><ul>\n<li>大多数是外文小说，原著，但其中的书大都比较老。</li>\n<li>有这个耐心好好阅读的话，肯定是有进步的。</li>\n<li>需要消耗扇贝的，所以购买时，<strong>建议先试读，再考虑购买，且看完一本再买另一本。</strong></li>\n</ul>\n<h4 id=\"扇贝新闻：\"><a href=\"#扇贝新闻：\" class=\"headerlink\" title=\"扇贝新闻：\"></a><strong>扇贝新闻：</strong></h4><ul>\n<li>作为扇贝系列中必备的一个软件，基本上可以解决英语阅读问题。</li>\n<li>内容方面主要涵盖：<strong>时事热点（国内外），科技，体育，影视等</strong>。</li>\n<li>按照各个难度会有划分，且每篇文章都会有热心的贝友分享笔记、心得、评论。</li>\n</ul>\n<h4 id=\"扇贝听力：\"><a href=\"#扇贝听力：\" class=\"headerlink\" title=\"扇贝听力：\"></a><strong>扇贝听力：</strong></h4><ul>\n<li>个人觉得难度较大，因为据说录制人员是美国本土的，会有一定的地方口音以及连读；另外一些场景下，录制不是特别清晰。</li>\n<li>如果你很想提高自己英语的专业水平，那这个绝对适合你。</li>\n</ul>\n<h4 id=\"扇贝炼句：\"><a href=\"#扇贝炼句：\" class=\"headerlink\" title=\"扇贝炼句：\"></a><strong>扇贝炼句：</strong></h4><ul>\n<li>也是扇贝最受欢迎的一个应用之一，在其他软件上面没怎么见过这个英语学习功能。</li>\n<li>主要是帮你学习巩固英语短语日常应用，每个句子会学三遍，另外会加入录音识别功能。</li>\n<li><strong>如果每个句子都可以完整复述效果是相当好的，另外价格看起来昂贵，其实不然，每个炼句书的学习周期很长，和扇贝单词类似，会不断巩固学习以前的内容，因此一本30课的书，可能实际学习会是3个月以上。</strong></li>\n</ul>\n<h4 id=\"扇贝口语：\"><a href=\"#扇贝口语：\" class=\"headerlink\" title=\"扇贝口语：\"></a><strong>扇贝口语：</strong></h4><ul>\n<li>该应用是最近出来的，还没怎么使用过，应用功能本身也正在实验开发中，貌似是个带语音识别功能的软件。有兴趣的小伙伴们可以赶紧去尝个鲜。</li>\n<li>可以肯定的是软件后续肯定也是会收取费用或者增加一些支出的，所以想使用的话趁早。</li>\n</ul>\n<hr>\n<h3 id=\"3-FAQ\"><a href=\"#3-FAQ\" class=\"headerlink\" title=\"3. FAQ\"></a><strong>3. FAQ</strong></h3><h4 id=\"1-如何设置每天的学习量？\"><a href=\"#1-如何设置每天的学习量？\" class=\"headerlink\" title=\"1. 如何设置每天的学习量？\"></a>1. 如何设置每天的学习量？</h4><p>电脑浏览器<a href=\"http://www.shanbay.com/bdc/setting/\">学习量</a>，手机端在每个应用的设置-&gt;学习量中选择，但第二天才会生效，所以就别想着今天偷懒少学点了。</p>\n<h4 id=\"2-完成了任务，但忘记打卡了怎么办？\"><a href=\"#2-完成了任务，但忘记打卡了怎么办？\" class=\"headerlink\" title=\"2. 完成了任务，但忘记打卡了怎么办？\"></a>2. 完成了任务，但忘记打卡了怎么办？</h4><p><a href=\"http://www.shanbay.com/checkin/status/\">点击补救</a>此链接能看到7天内每日任务完成情况，仅适用于前一天完成所有任务后。</p>\n<h4 id=\"3-断签了，如何补以前的打卡？\"><a href=\"#3-断签了，如何补以前的打卡？\" class=\"headerlink\" title=\"3. 断签了，如何补以前的打卡？\"></a>3. 断签了，如何补以前的打卡？</h4><p>浏览器打开<a href=\"https://www.shanbay.com/accounts/setting/\">急救</a>，好像最晚的是洛杉矶时间，就是西八区的应该都行，补完卡一定要记得改回来，否则极有可能出现漏签。<strong>但如果你是更早的时间段没打卡，那很遗憾的告诉你，放弃治疗吧！！！扇贝不像贴吧之类的娱乐圈钱应用，没有提供花钱补签这一功能，没学习就是没学习，吃一堑长一智吧。另外现在加入了扇贝计划和保险的，也没法通过改时区补签。</strong></p>\n<h4 id=\"4-什么是阅读计划？听力计划？炼句计划？\"><a href=\"#4-什么是阅读计划？听力计划？炼句计划？\" class=\"headerlink\" title=\"4. 什么是阅读计划？听力计划？炼句计划？\"></a>4. 什么是阅读计划？听力计划？炼句计划？</h4><p>加入计划，并且完成计划，可以获得额外的奖励（积分及贝壳）。需要注意的是<strong>现阶段的计划都是需要缴纳保金（贝壳）的，一单中途放弃，贝壳概不退还。</strong>另外加入计划能够帮助那些爱拖延偷懒的患者，因为一旦入了计划，只有完成所有计划后，你才可以打卡。</p>\n<h4 id=\"5-单词的记忆是只要能拼写出来算认识还是能记得住中文意思算认识这个单词？什么程度算认识一个单词-如果你选择不认识是不是一直会不断重复？\"><a href=\"#5-单词的记忆是只要能拼写出来算认识还是能记得住中文意思算认识这个单词？什么程度算认识一个单词-如果你选择不认识是不是一直会不断重复？\" class=\"headerlink\" title=\"5. 单词的记忆是只要能拼写出来算认识还是能记得住中文意思算认识这个单词？什么程度算认识一个单词 如果你选择不认识是不是一直会不断重复？\"></a>5. 单词的记忆是只要能拼写出来算认识还是能记得住中文意思算认识这个单词？什么程度算认识一个单词 如果你选择不认识是不是一直会不断重复？</h4><p><strong>单词看你的个人要求，如果多用于阅读，口语的话，不需要拼写</strong>。<em>扇贝每个单词会周期性的重复5次</em>，另外觉得实在简单的单词可以点击简单，让单词不再出现。学习量的选择是第二天生效，新词优先模式会每天加入新单词，如果这个模式关闭的话，一般会在你没有掌握的单词数低于你学习量的4倍，才会给你添加新单词。<strong>建议基础词汇或者需要考试的词汇重点记忆</strong>，比如4级词汇之类的，最好用拼写记忆模式，后续一些电视剧或者不是太常见的词汇可以识记，有个印象即刻。</p>\n<h4 id=\"6-打卡什么是成功的呢？打卡率100％有什么用处？\"><a href=\"#6-打卡什么是成功的呢？打卡率100％有什么用处？\" class=\"headerlink\" title=\"6.打卡什么是成功的呢？打卡率100％有什么用处？\"></a>6.打卡什么是成功的呢？打卡率100％有什么用处？</h4><p>每天相应的完成了打卡任务就可以完成打卡，如果没有加入任何保险或者计划，完成单一听力，炼句，阅读等内容均可完成打卡。<strong>每天打卡才有100%</strong>，<em>目前的打卡率只有小组打卡率，是你入组后的打卡率，暂时无法查看个人打卡率</em>。<strong>扇贝有连续打卡徽章</strong>，即你连续n天打卡，没有断过则会有这个徽章。打卡以及获得徽章荣誉积分扇贝等，都是对于坚持学习的鼓励认可。当然你不需要这个荣誉点数，就能好好学习，当然更好啦。</p>\n<p><em>To be continued…</em></p>\n<hr>\n<h3 id=\"4-交流\"><a href=\"#4-交流\" class=\"headerlink\" title=\"4. 交流\"></a><strong>4. 交流</strong></h3><ul>\n<li>有关扇贝的相关使用技巧，将会在小组贴中逐步完善，具体请查阅。</li>\n<li>扇贝qq群提供交流天南海北，各种兴趣爱好，学习，工作，技能等小组qq群号：568650162。</li>\n<li>微信群只讨论英语，扇贝，小组相关内容，入qq群后找二维码，扫码加群，<strong>请慎入</strong>，微信群已经取消了每日打卡提醒功能，扇贝微信账号加入了打卡提醒，可以手动设置该选项。</li>\n</ul>\n<hr>\n<h3 id=\"5-注意\"><a href=\"#5-注意\" class=\"headerlink\" title=\"5. 注意\"></a><strong>5. 注意</strong></h3><ul>\n<li>小组帖禁止侵犯个人私隐，广告类，非法，色情以及任何违反中华人民共和国法律的内容。</li>\n<li>后续可能会举办一些相关活动，也会发一些资源类福利贴，敬请期待。</li>\n<li>有任何不明白的问题，可以在群中讨论，如果仍有疑惑，可以联系组长。</li>\n</ul>\n<hr>\n<p><img src=\"https://static.baydn.com/media/media_store/image/aaba0062151ffb390575b5717f1ae704.jpg\" alt=\"图片 1\"></p>\n<hr>\n<p><strong>happy learning.</strong></p>\n<hr>\n"},{"_content":"\n\n\n### 扇贝新人通知：\n\n欢迎你选择了本小组，本小组是一个需要坚持每日学习的小组，入组请先参照阅读小组指南以及其他小组贴。也可以通过我们的qq群：568650162，微信群（入qq群，再索要）。\n\n#### 简述每日学习的缘由：\n\n如果你不是中学生，也不是大学英语专业，更不是每天需要和外国人打交道，那么你势必都经历过英语水平上下起伏周而复始的阶段。英语只要一段时间不用就会退步，本小组提倡每天学习打卡，无论是背单词，听听力或者看文章，只要你每天接触，即便你提高的不明显，也肯定不会退步。扇贝的英语学习如果不是背诵单词的话，并不会占用你过多的时间，即便你是在考研高考前夕，除夕夜等大多数时候，打开手机看一两篇文章或者听几句听力，一天的学习也仅仅是占用你5分钟左右的时间。当然如果你有考试目标，需要短期内快速提高英语，在扇贝APP每日刷几百分钟，英语也是会有显著提升的。\n\n#### 给新人的建议：\n\n1. 完成四级单词书的学习，四级单词的掌握差不多是你的一个基础词汇量。\n2. 如果是长期提升英语，没有考试等迫切需求的话，刚开始的每日学习量控制在20min之内，这样你更容易坚持下来，后续适应稳定后，可以逐步提升学习量。\n3. 英语学习是个长期的过程，不是身在国外的全沉浸式的环境的话，很难有快速的提升，良好的学习心态很重要，另外要坚持每日学习，只要有一天你懈怠了，之后就会诞生偷懒的无数天数，毕竟你总会给自己找各种各样的接口。\n\n*鉴于最近很多人不能坚持每日学习，小组创建了微信群和qq群（568650162），入群后会提供微信二维码。为了更好的提前督促大家学习，而不仅仅是扇贝软件内通知和移除小组，组长决定每天晚上10点后微信群提醒学习。微信群为了不影响大家工作学习，这边禁止日常聊天，请大家也不要屏蔽群消息，如果有任何需要讨论的问题可以直接加组长微信或者qq群（用的较少，可能不会及时回复，但一定会回复）内聊天。*\n\n> 知识不是一般的商品，买回来不是你的，放书架上不是你的，存硬盘上也不是你的；只有累过，烦过，咬牙切齿过，山穷水尽过，柳暗花明过，才会是你的。\n","source":"_drafts/shanbay/shanbay_info.md","raw":"\n\n\n### 扇贝新人通知：\n\n欢迎你选择了本小组，本小组是一个需要坚持每日学习的小组，入组请先参照阅读小组指南以及其他小组贴。也可以通过我们的qq群：568650162，微信群（入qq群，再索要）。\n\n#### 简述每日学习的缘由：\n\n如果你不是中学生，也不是大学英语专业，更不是每天需要和外国人打交道，那么你势必都经历过英语水平上下起伏周而复始的阶段。英语只要一段时间不用就会退步，本小组提倡每天学习打卡，无论是背单词，听听力或者看文章，只要你每天接触，即便你提高的不明显，也肯定不会退步。扇贝的英语学习如果不是背诵单词的话，并不会占用你过多的时间，即便你是在考研高考前夕，除夕夜等大多数时候，打开手机看一两篇文章或者听几句听力，一天的学习也仅仅是占用你5分钟左右的时间。当然如果你有考试目标，需要短期内快速提高英语，在扇贝APP每日刷几百分钟，英语也是会有显著提升的。\n\n#### 给新人的建议：\n\n1. 完成四级单词书的学习，四级单词的掌握差不多是你的一个基础词汇量。\n2. 如果是长期提升英语，没有考试等迫切需求的话，刚开始的每日学习量控制在20min之内，这样你更容易坚持下来，后续适应稳定后，可以逐步提升学习量。\n3. 英语学习是个长期的过程，不是身在国外的全沉浸式的环境的话，很难有快速的提升，良好的学习心态很重要，另外要坚持每日学习，只要有一天你懈怠了，之后就会诞生偷懒的无数天数，毕竟你总会给自己找各种各样的接口。\n\n*鉴于最近很多人不能坚持每日学习，小组创建了微信群和qq群（568650162），入群后会提供微信二维码。为了更好的提前督促大家学习，而不仅仅是扇贝软件内通知和移除小组，组长决定每天晚上10点后微信群提醒学习。微信群为了不影响大家工作学习，这边禁止日常聊天，请大家也不要屏蔽群消息，如果有任何需要讨论的问题可以直接加组长微信或者qq群（用的较少，可能不会及时回复，但一定会回复）内聊天。*\n\n> 知识不是一般的商品，买回来不是你的，放书架上不是你的，存硬盘上也不是你的；只有累过，烦过，咬牙切齿过，山穷水尽过，柳暗花明过，才会是你的。\n","slug":"shanbay/shanbay_info","published":0,"date":"2017-02-07T01:39:04.190Z","updated":"2016-09-13T14:26:28.807Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyuv3af30003mumu5981frwy","content":"<h3 id=\"扇贝新人通知：\"><a href=\"#扇贝新人通知：\" class=\"headerlink\" title=\"扇贝新人通知：\"></a>扇贝新人通知：</h3><p>欢迎你选择了本小组，本小组是一个需要坚持每日学习的小组，入组请先参照阅读小组指南以及其他小组贴。也可以通过我们的qq群：568650162，微信群（入qq群，再索要）。</p>\n<h4 id=\"简述每日学习的缘由：\"><a href=\"#简述每日学习的缘由：\" class=\"headerlink\" title=\"简述每日学习的缘由：\"></a>简述每日学习的缘由：</h4><p>如果你不是中学生，也不是大学英语专业，更不是每天需要和外国人打交道，那么你势必都经历过英语水平上下起伏周而复始的阶段。英语只要一段时间不用就会退步，本小组提倡每天学习打卡，无论是背单词，听听力或者看文章，只要你每天接触，即便你提高的不明显，也肯定不会退步。扇贝的英语学习如果不是背诵单词的话，并不会占用你过多的时间，即便你是在考研高考前夕，除夕夜等大多数时候，打开手机看一两篇文章或者听几句听力，一天的学习也仅仅是占用你5分钟左右的时间。当然如果你有考试目标，需要短期内快速提高英语，在扇贝APP每日刷几百分钟，英语也是会有显著提升的。</p>\n<h4 id=\"给新人的建议：\"><a href=\"#给新人的建议：\" class=\"headerlink\" title=\"给新人的建议：\"></a>给新人的建议：</h4><ol>\n<li>完成四级单词书的学习，四级单词的掌握差不多是你的一个基础词汇量。</li>\n<li>如果是长期提升英语，没有考试等迫切需求的话，刚开始的每日学习量控制在20min之内，这样你更容易坚持下来，后续适应稳定后，可以逐步提升学习量。</li>\n<li>英语学习是个长期的过程，不是身在国外的全沉浸式的环境的话，很难有快速的提升，良好的学习心态很重要，另外要坚持每日学习，只要有一天你懈怠了，之后就会诞生偷懒的无数天数，毕竟你总会给自己找各种各样的接口。</li>\n</ol>\n<p><em>鉴于最近很多人不能坚持每日学习，小组创建了微信群和qq群（568650162），入群后会提供微信二维码。为了更好的提前督促大家学习，而不仅仅是扇贝软件内通知和移除小组，组长决定每天晚上10点后微信群提醒学习。微信群为了不影响大家工作学习，这边禁止日常聊天，请大家也不要屏蔽群消息，如果有任何需要讨论的问题可以直接加组长微信或者qq群（用的较少，可能不会及时回复，但一定会回复）内聊天。</em></p>\n<blockquote>\n<p>知识不是一般的商品，买回来不是你的，放书架上不是你的，存硬盘上也不是你的；只有累过，烦过，咬牙切齿过，山穷水尽过，柳暗花明过，才会是你的。</p>\n</blockquote>\n","excerpt":"","more":"<h3 id=\"扇贝新人通知：\"><a href=\"#扇贝新人通知：\" class=\"headerlink\" title=\"扇贝新人通知：\"></a>扇贝新人通知：</h3><p>欢迎你选择了本小组，本小组是一个需要坚持每日学习的小组，入组请先参照阅读小组指南以及其他小组贴。也可以通过我们的qq群：568650162，微信群（入qq群，再索要）。</p>\n<h4 id=\"简述每日学习的缘由：\"><a href=\"#简述每日学习的缘由：\" class=\"headerlink\" title=\"简述每日学习的缘由：\"></a>简述每日学习的缘由：</h4><p>如果你不是中学生，也不是大学英语专业，更不是每天需要和外国人打交道，那么你势必都经历过英语水平上下起伏周而复始的阶段。英语只要一段时间不用就会退步，本小组提倡每天学习打卡，无论是背单词，听听力或者看文章，只要你每天接触，即便你提高的不明显，也肯定不会退步。扇贝的英语学习如果不是背诵单词的话，并不会占用你过多的时间，即便你是在考研高考前夕，除夕夜等大多数时候，打开手机看一两篇文章或者听几句听力，一天的学习也仅仅是占用你5分钟左右的时间。当然如果你有考试目标，需要短期内快速提高英语，在扇贝APP每日刷几百分钟，英语也是会有显著提升的。</p>\n<h4 id=\"给新人的建议：\"><a href=\"#给新人的建议：\" class=\"headerlink\" title=\"给新人的建议：\"></a>给新人的建议：</h4><ol>\n<li>完成四级单词书的学习，四级单词的掌握差不多是你的一个基础词汇量。</li>\n<li>如果是长期提升英语，没有考试等迫切需求的话，刚开始的每日学习量控制在20min之内，这样你更容易坚持下来，后续适应稳定后，可以逐步提升学习量。</li>\n<li>英语学习是个长期的过程，不是身在国外的全沉浸式的环境的话，很难有快速的提升，良好的学习心态很重要，另外要坚持每日学习，只要有一天你懈怠了，之后就会诞生偷懒的无数天数，毕竟你总会给自己找各种各样的接口。</li>\n</ol>\n<p><em>鉴于最近很多人不能坚持每日学习，小组创建了微信群和qq群（568650162），入群后会提供微信二维码。为了更好的提前督促大家学习，而不仅仅是扇贝软件内通知和移除小组，组长决定每天晚上10点后微信群提醒学习。微信群为了不影响大家工作学习，这边禁止日常聊天，请大家也不要屏蔽群消息，如果有任何需要讨论的问题可以直接加组长微信或者qq群（用的较少，可能不会及时回复，但一定会回复）内聊天。</em></p>\n<blockquote>\n<p>知识不是一般的商品，买回来不是你的，放书架上不是你的，存硬盘上也不是你的；只有累过，烦过，咬牙切齿过，山穷水尽过，柳暗花明过，才会是你的。</p>\n</blockquote>\n"},{"_content":"## 亲爱的组员：  \n\n### 扇贝寄语：  \n\n> 欢迎加入我们小组。\n> 从现在起，你就可以在小组内发帖和大家一起讨论你感兴趣的话题了。\n> 加入小组后，记得要和大家一起打卡。打卡会增加你个人的成长值，也会增加小组的成长值。小组成长值增加后，小组的排名将会更高，也会吸引更多的小伙伴加入我们。\n> 小组如果需要扩招，打卡率需要保持在 85% 以上，因此如果组员不打卡，小组将无法扩招。只要有一天不打卡，小组打卡率就会下降， 所以大家务必要一起坚持学习。\n> 如果有任何问题，可以在小组发帖向其他组员请教。\n\n    \n\n### 小组寄语：\n\n- 首先感谢你在众多小组中选择了本小组。本小组是个促进大家共同学习，团结有爱的小组。\n- 小组有自己的微信及qq群，除了英语的学习外，也可以在qq群中畅聊兴趣爱好等。qq群和小组帖中也会定期分享一些资源，同时也期望大家踊跃分享。\n- 小组主要靠大家自觉自律的学习，组长虽然打卡时间不长，但对扇贝等比较了解，能自己做到坚持学习打卡，同时也会对所有组员严格要求。也希望大家通过本小组互相监督，共同进步。\n\n    \n\n#### 1. 群规  \n- 前30天必须满勤（一天都不能漏卡）  \n- 30天以后不得出现连续两天不打卡  \n- 组员个人打卡率绝不得低于92%  \n- 实在情况过于特殊，请提前与组长联系。\n- **如果你觉得太过严苛，请出门左拐！**  \n\n    \n\n#### 2. 扇贝  \n- 有关扇贝的相关使用技巧，请参阅小组精华帖以及置顶帖。\n\n    \n\n#### 3. 交流\n- 扇贝qq群提供交流天南海北，各种兴趣爱好，学习，工作，技能等小组qq群号：568650162。\n- 微信群只讨论英语，扇贝，小组相关内容，入qq群后索要二维码，扫码加群，微信群每天组长会发消息提醒学习，拒绝闲聊。\n\n    \n\n***\n**happy learning.**\n","source":"_drafts/shanbay/shanbay_welcome_msg.md","raw":"## 亲爱的组员：  \n\n### 扇贝寄语：  \n\n> 欢迎加入我们小组。\n> 从现在起，你就可以在小组内发帖和大家一起讨论你感兴趣的话题了。\n> 加入小组后，记得要和大家一起打卡。打卡会增加你个人的成长值，也会增加小组的成长值。小组成长值增加后，小组的排名将会更高，也会吸引更多的小伙伴加入我们。\n> 小组如果需要扩招，打卡率需要保持在 85% 以上，因此如果组员不打卡，小组将无法扩招。只要有一天不打卡，小组打卡率就会下降， 所以大家务必要一起坚持学习。\n> 如果有任何问题，可以在小组发帖向其他组员请教。\n\n    \n\n### 小组寄语：\n\n- 首先感谢你在众多小组中选择了本小组。本小组是个促进大家共同学习，团结有爱的小组。\n- 小组有自己的微信及qq群，除了英语的学习外，也可以在qq群中畅聊兴趣爱好等。qq群和小组帖中也会定期分享一些资源，同时也期望大家踊跃分享。\n- 小组主要靠大家自觉自律的学习，组长虽然打卡时间不长，但对扇贝等比较了解，能自己做到坚持学习打卡，同时也会对所有组员严格要求。也希望大家通过本小组互相监督，共同进步。\n\n    \n\n#### 1. 群规  \n- 前30天必须满勤（一天都不能漏卡）  \n- 30天以后不得出现连续两天不打卡  \n- 组员个人打卡率绝不得低于92%  \n- 实在情况过于特殊，请提前与组长联系。\n- **如果你觉得太过严苛，请出门左拐！**  \n\n    \n\n#### 2. 扇贝  \n- 有关扇贝的相关使用技巧，请参阅小组精华帖以及置顶帖。\n\n    \n\n#### 3. 交流\n- 扇贝qq群提供交流天南海北，各种兴趣爱好，学习，工作，技能等小组qq群号：568650162。\n- 微信群只讨论英语，扇贝，小组相关内容，入qq群后索要二维码，扫码加群，微信群每天组长会发消息提醒学习，拒绝闲聊。\n\n    \n\n***\n**happy learning.**\n","slug":"shanbay/shanbay_welcome_msg","published":0,"date":"2017-02-07T01:39:04.194Z","updated":"2016-09-29T00:39:31.010Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyuv3af50004mumutjd1nmlh","content":"<h2 id=\"亲爱的组员：\"><a href=\"#亲爱的组员：\" class=\"headerlink\" title=\"亲爱的组员：\"></a>亲爱的组员：</h2><h3 id=\"扇贝寄语：\"><a href=\"#扇贝寄语：\" class=\"headerlink\" title=\"扇贝寄语：\"></a>扇贝寄语：</h3><blockquote>\n<p>欢迎加入我们小组。<br>从现在起，你就可以在小组内发帖和大家一起讨论你感兴趣的话题了。<br>加入小组后，记得要和大家一起打卡。打卡会增加你个人的成长值，也会增加小组的成长值。小组成长值增加后，小组的排名将会更高，也会吸引更多的小伙伴加入我们。<br>小组如果需要扩招，打卡率需要保持在 85% 以上，因此如果组员不打卡，小组将无法扩招。只要有一天不打卡，小组打卡率就会下降， 所以大家务必要一起坚持学习。<br>如果有任何问题，可以在小组发帖向其他组员请教。</p>\n</blockquote>\n<h3 id=\"小组寄语：\"><a href=\"#小组寄语：\" class=\"headerlink\" title=\"小组寄语：\"></a>小组寄语：</h3><ul>\n<li>首先感谢你在众多小组中选择了本小组。本小组是个促进大家共同学习，团结有爱的小组。</li>\n<li>小组有自己的微信及qq群，除了英语的学习外，也可以在qq群中畅聊兴趣爱好等。qq群和小组帖中也会定期分享一些资源，同时也期望大家踊跃分享。</li>\n<li>小组主要靠大家自觉自律的学习，组长虽然打卡时间不长，但对扇贝等比较了解，能自己做到坚持学习打卡，同时也会对所有组员严格要求。也希望大家通过本小组互相监督，共同进步。</li>\n</ul>\n<h4 id=\"1-群规\"><a href=\"#1-群规\" class=\"headerlink\" title=\"1. 群规\"></a>1. 群规</h4><ul>\n<li>前30天必须满勤（一天都不能漏卡）  </li>\n<li>30天以后不得出现连续两天不打卡  </li>\n<li>组员个人打卡率绝不得低于92%  </li>\n<li>实在情况过于特殊，请提前与组长联系。</li>\n<li><strong>如果你觉得太过严苛，请出门左拐！</strong>  </li>\n</ul>\n<h4 id=\"2-扇贝\"><a href=\"#2-扇贝\" class=\"headerlink\" title=\"2. 扇贝\"></a>2. 扇贝</h4><ul>\n<li>有关扇贝的相关使用技巧，请参阅小组精华帖以及置顶帖。</li>\n</ul>\n<h4 id=\"3-交流\"><a href=\"#3-交流\" class=\"headerlink\" title=\"3. 交流\"></a>3. 交流</h4><ul>\n<li>扇贝qq群提供交流天南海北，各种兴趣爱好，学习，工作，技能等小组qq群号：568650162。</li>\n<li>微信群只讨论英语，扇贝，小组相关内容，入qq群后索要二维码，扫码加群，微信群每天组长会发消息提醒学习，拒绝闲聊。</li>\n</ul>\n<hr>\n<p><strong>happy learning.</strong></p>\n","excerpt":"","more":"<h2 id=\"亲爱的组员：\"><a href=\"#亲爱的组员：\" class=\"headerlink\" title=\"亲爱的组员：\"></a>亲爱的组员：</h2><h3 id=\"扇贝寄语：\"><a href=\"#扇贝寄语：\" class=\"headerlink\" title=\"扇贝寄语：\"></a>扇贝寄语：</h3><blockquote>\n<p>欢迎加入我们小组。<br>从现在起，你就可以在小组内发帖和大家一起讨论你感兴趣的话题了。<br>加入小组后，记得要和大家一起打卡。打卡会增加你个人的成长值，也会增加小组的成长值。小组成长值增加后，小组的排名将会更高，也会吸引更多的小伙伴加入我们。<br>小组如果需要扩招，打卡率需要保持在 85% 以上，因此如果组员不打卡，小组将无法扩招。只要有一天不打卡，小组打卡率就会下降， 所以大家务必要一起坚持学习。<br>如果有任何问题，可以在小组发帖向其他组员请教。</p>\n</blockquote>\n<h3 id=\"小组寄语：\"><a href=\"#小组寄语：\" class=\"headerlink\" title=\"小组寄语：\"></a>小组寄语：</h3><ul>\n<li>首先感谢你在众多小组中选择了本小组。本小组是个促进大家共同学习，团结有爱的小组。</li>\n<li>小组有自己的微信及qq群，除了英语的学习外，也可以在qq群中畅聊兴趣爱好等。qq群和小组帖中也会定期分享一些资源，同时也期望大家踊跃分享。</li>\n<li>小组主要靠大家自觉自律的学习，组长虽然打卡时间不长，但对扇贝等比较了解，能自己做到坚持学习打卡，同时也会对所有组员严格要求。也希望大家通过本小组互相监督，共同进步。</li>\n</ul>\n<h4 id=\"1-群规\"><a href=\"#1-群规\" class=\"headerlink\" title=\"1. 群规\"></a>1. 群规</h4><ul>\n<li>前30天必须满勤（一天都不能漏卡）  </li>\n<li>30天以后不得出现连续两天不打卡  </li>\n<li>组员个人打卡率绝不得低于92%  </li>\n<li>实在情况过于特殊，请提前与组长联系。</li>\n<li><strong>如果你觉得太过严苛，请出门左拐！</strong>  </li>\n</ul>\n<h4 id=\"2-扇贝\"><a href=\"#2-扇贝\" class=\"headerlink\" title=\"2. 扇贝\"></a>2. 扇贝</h4><ul>\n<li>有关扇贝的相关使用技巧，请参阅小组精华帖以及置顶帖。</li>\n</ul>\n<h4 id=\"3-交流\"><a href=\"#3-交流\" class=\"headerlink\" title=\"3. 交流\"></a>3. 交流</h4><ul>\n<li>扇贝qq群提供交流天南海北，各种兴趣爱好，学习，工作，技能等小组qq群号：568650162。</li>\n<li>微信群只讨论英语，扇贝，小组相关内容，入qq群后索要二维码，扫码加群，微信群每天组长会发消息提醒学习，拒绝闲聊。</li>\n</ul>\n<hr>\n<p><strong>happy learning.</strong></p>\n"},{"layout":"post","title":"别了，2016；你好，2017","date":"2016-12-31T17:01:00.000Z","_content":"\n这篇文章写的晚了，本来是想年前写得，结果一耽搁已经是2017了，过去得一年有太多值得说得，新的一年也有太多值得期待的，这篇文章中只会写有关学习工作上面的得失，个人生活不做涉及。\n\n\n<!-- more -->\n\n\n### 别了，2016\n\n#### 收获\n2016 对我来说也算是一个特殊的年份，但其实细想起来所有的得失也基本都集中在了下半年，其中最值得一提的可以分为如下几点：\n- 首先是加入了 github 这个家庭，虽然是 15 年就注册了 github 但一直没有研究和使用过，且那时对 git 也不够熟悉了解，有大半年的时间都没能开采这座金矿。\n- 放弃了玩了多年的游戏（LOL），这中间也是是非曲中良多，朋友同学的互相指责，让单纯的游戏最后都不欢而散，之后转型玩了一段时间 dota2 ，网速不是太好，加上更新有问题，后来也就不玩了。也许已经不再是个孩子，再者本身从事电脑工作，是时候和电脑游戏说再见了。不玩游戏后也确实节省出了很多时间，也完成了接下来绝大多数的一些工作内容。\n- 在 github 上搭建了个人博客，建立博客本身并不是难事，阅读教程按部就班就可以了，但最大的收获还是切实得整理总结了一些有内容的文章，对于高中语文一直不及格的我来说，能够写博客也是怪不可思议的。\n- 基本掌握了 git 的使用，且也用于个人的一些项目上了。有关 git ，个人觉得还是比较复杂抽象的，也可能原因在于起初学习时，没看到什么较好的教程，现在学会了，却发现最近出来了不少通俗易懂的教程。\n- 对 EFM32 的芯片有了一定的研究认识，虽然过程是十分艰难的，但目前而言，已经可以写一些常规的驱动了。\n- 学了两次 Python，只能说基本掌握了 Python 的思想和语法。\n- 尝试并体验了多家云服务器，买了国外一个分拆的 VPS 服务，体验来说良好，通过虚拟机和 VPS 也学习并且尝试了多个服务的搭建，简单的搭建并不困难，但要运营管理好，对现阶段的我来说还是有相当一段距离的。\n- 使用 shanbay 学习了快两年了，阅读英文文档和网站已经基本可以胜任。\n\n\n#### 欠缺\n\n- 学了两次 Python，说来还是比较失败的，两次都因为各种原因中断了，应该来说还是缺少一个项目历练或者学习全面的学习计划，两次都是学到某一阶段，后面不知道该做啥了，然后又因为某些原因中断了一段时间。\n- 学习方法差，效率低，很多计划未能够完成，python 的书籍，还有 linux-c 的一本书籍都未能完成阅读\n- 网络文档看多了或者其他原因，不能/未能静下心好好的看看书，学习一些东西，光靠互联网，走了不少歪路。\n- 上半年浪费时间过多，收获不显著，早点不玩游戏，可能会收获更多。\n- shanbay 单词荒废过多，一整年都没能静下心来真正拼写背诵单词，虽有提高但不大，主要在于学习不够专注，对自己不够狠。\n- 周末利用率不高，对于技术从业者来说，提高基本上靠业余时间，但一般也仅仅能够利用晚上，且效率比较低，总的来说还是不够专注。\n- linux 虽然用了也蛮久了，但还是需要重新系统的学习一次，命令的使用，思想的建立都不够完善。\n- blog 未能好好装修，计划的 H5 没能研究学习完。\n\n\n### 你好，2017\n\n2016 在学习工作上面不算成功，有不少欠缺之处，最主要还是表现两点：1.在工作学习不够专注，效率低。 2.业余时间尤其是周末利用率不高。\n","source":"_posts/2017/2017-01-01-别了，2016；你好，2017.md","raw":"---\nlayout: \"post\"\ntitle: \"别了，2016；你好，2017\"\ndate: \"2017-01-01 01:01\"\n---\n\n这篇文章写的晚了，本来是想年前写得，结果一耽搁已经是2017了，过去得一年有太多值得说得，新的一年也有太多值得期待的，这篇文章中只会写有关学习工作上面的得失，个人生活不做涉及。\n\n\n<!-- more -->\n\n\n### 别了，2016\n\n#### 收获\n2016 对我来说也算是一个特殊的年份，但其实细想起来所有的得失也基本都集中在了下半年，其中最值得一提的可以分为如下几点：\n- 首先是加入了 github 这个家庭，虽然是 15 年就注册了 github 但一直没有研究和使用过，且那时对 git 也不够熟悉了解，有大半年的时间都没能开采这座金矿。\n- 放弃了玩了多年的游戏（LOL），这中间也是是非曲中良多，朋友同学的互相指责，让单纯的游戏最后都不欢而散，之后转型玩了一段时间 dota2 ，网速不是太好，加上更新有问题，后来也就不玩了。也许已经不再是个孩子，再者本身从事电脑工作，是时候和电脑游戏说再见了。不玩游戏后也确实节省出了很多时间，也完成了接下来绝大多数的一些工作内容。\n- 在 github 上搭建了个人博客，建立博客本身并不是难事，阅读教程按部就班就可以了，但最大的收获还是切实得整理总结了一些有内容的文章，对于高中语文一直不及格的我来说，能够写博客也是怪不可思议的。\n- 基本掌握了 git 的使用，且也用于个人的一些项目上了。有关 git ，个人觉得还是比较复杂抽象的，也可能原因在于起初学习时，没看到什么较好的教程，现在学会了，却发现最近出来了不少通俗易懂的教程。\n- 对 EFM32 的芯片有了一定的研究认识，虽然过程是十分艰难的，但目前而言，已经可以写一些常规的驱动了。\n- 学了两次 Python，只能说基本掌握了 Python 的思想和语法。\n- 尝试并体验了多家云服务器，买了国外一个分拆的 VPS 服务，体验来说良好，通过虚拟机和 VPS 也学习并且尝试了多个服务的搭建，简单的搭建并不困难，但要运营管理好，对现阶段的我来说还是有相当一段距离的。\n- 使用 shanbay 学习了快两年了，阅读英文文档和网站已经基本可以胜任。\n\n\n#### 欠缺\n\n- 学了两次 Python，说来还是比较失败的，两次都因为各种原因中断了，应该来说还是缺少一个项目历练或者学习全面的学习计划，两次都是学到某一阶段，后面不知道该做啥了，然后又因为某些原因中断了一段时间。\n- 学习方法差，效率低，很多计划未能够完成，python 的书籍，还有 linux-c 的一本书籍都未能完成阅读\n- 网络文档看多了或者其他原因，不能/未能静下心好好的看看书，学习一些东西，光靠互联网，走了不少歪路。\n- 上半年浪费时间过多，收获不显著，早点不玩游戏，可能会收获更多。\n- shanbay 单词荒废过多，一整年都没能静下心来真正拼写背诵单词，虽有提高但不大，主要在于学习不够专注，对自己不够狠。\n- 周末利用率不高，对于技术从业者来说，提高基本上靠业余时间，但一般也仅仅能够利用晚上，且效率比较低，总的来说还是不够专注。\n- linux 虽然用了也蛮久了，但还是需要重新系统的学习一次，命令的使用，思想的建立都不够完善。\n- blog 未能好好装修，计划的 H5 没能研究学习完。\n\n\n### 你好，2017\n\n2016 在学习工作上面不算成功，有不少欠缺之处，最主要还是表现两点：1.在工作学习不够专注，效率低。 2.业余时间尤其是周末利用率不高。\n","slug":"2017/2017-01-01-别了，2016；你好，2017","published":1,"updated":"2017-01-05T01:38:20.386Z","comments":1,"photos":[],"link":"","_id":"ciyuv3afs0005mumuihqryjmj","content":"<p>这篇文章写的晚了，本来是想年前写得，结果一耽搁已经是2017了，过去得一年有太多值得说得，新的一年也有太多值得期待的，这篇文章中只会写有关学习工作上面的得失，个人生活不做涉及。</p>\n<a id=\"more\"></a>\n<h3 id=\"别了，2016\"><a href=\"#别了，2016\" class=\"headerlink\" title=\"别了，2016\"></a>别了，2016</h3><h4 id=\"收获\"><a href=\"#收获\" class=\"headerlink\" title=\"收获\"></a>收获</h4><p>2016 对我来说也算是一个特殊的年份，但其实细想起来所有的得失也基本都集中在了下半年，其中最值得一提的可以分为如下几点：</p>\n<ul>\n<li>首先是加入了 github 这个家庭，虽然是 15 年就注册了 github 但一直没有研究和使用过，且那时对 git 也不够熟悉了解，有大半年的时间都没能开采这座金矿。</li>\n<li>放弃了玩了多年的游戏（LOL），这中间也是是非曲中良多，朋友同学的互相指责，让单纯的游戏最后都不欢而散，之后转型玩了一段时间 dota2 ，网速不是太好，加上更新有问题，后来也就不玩了。也许已经不再是个孩子，再者本身从事电脑工作，是时候和电脑游戏说再见了。不玩游戏后也确实节省出了很多时间，也完成了接下来绝大多数的一些工作内容。</li>\n<li>在 github 上搭建了个人博客，建立博客本身并不是难事，阅读教程按部就班就可以了，但最大的收获还是切实得整理总结了一些有内容的文章，对于高中语文一直不及格的我来说，能够写博客也是怪不可思议的。</li>\n<li>基本掌握了 git 的使用，且也用于个人的一些项目上了。有关 git ，个人觉得还是比较复杂抽象的，也可能原因在于起初学习时，没看到什么较好的教程，现在学会了，却发现最近出来了不少通俗易懂的教程。</li>\n<li>对 EFM32 的芯片有了一定的研究认识，虽然过程是十分艰难的，但目前而言，已经可以写一些常规的驱动了。</li>\n<li>学了两次 Python，只能说基本掌握了 Python 的思想和语法。</li>\n<li>尝试并体验了多家云服务器，买了国外一个分拆的 VPS 服务，体验来说良好，通过虚拟机和 VPS 也学习并且尝试了多个服务的搭建，简单的搭建并不困难，但要运营管理好，对现阶段的我来说还是有相当一段距离的。</li>\n<li>使用 shanbay 学习了快两年了，阅读英文文档和网站已经基本可以胜任。</li>\n</ul>\n<h4 id=\"欠缺\"><a href=\"#欠缺\" class=\"headerlink\" title=\"欠缺\"></a>欠缺</h4><ul>\n<li>学了两次 Python，说来还是比较失败的，两次都因为各种原因中断了，应该来说还是缺少一个项目历练或者学习全面的学习计划，两次都是学到某一阶段，后面不知道该做啥了，然后又因为某些原因中断了一段时间。</li>\n<li>学习方法差，效率低，很多计划未能够完成，python 的书籍，还有 linux-c 的一本书籍都未能完成阅读</li>\n<li>网络文档看多了或者其他原因，不能/未能静下心好好的看看书，学习一些东西，光靠互联网，走了不少歪路。</li>\n<li>上半年浪费时间过多，收获不显著，早点不玩游戏，可能会收获更多。</li>\n<li>shanbay 单词荒废过多，一整年都没能静下心来真正拼写背诵单词，虽有提高但不大，主要在于学习不够专注，对自己不够狠。</li>\n<li>周末利用率不高，对于技术从业者来说，提高基本上靠业余时间，但一般也仅仅能够利用晚上，且效率比较低，总的来说还是不够专注。</li>\n<li>linux 虽然用了也蛮久了，但还是需要重新系统的学习一次，命令的使用，思想的建立都不够完善。</li>\n<li>blog 未能好好装修，计划的 H5 没能研究学习完。</li>\n</ul>\n<h3 id=\"你好，2017\"><a href=\"#你好，2017\" class=\"headerlink\" title=\"你好，2017\"></a>你好，2017</h3><p>2016 在学习工作上面不算成功，有不少欠缺之处，最主要还是表现两点：1.在工作学习不够专注，效率低。 2.业余时间尤其是周末利用率不高。</p>\n","excerpt":"<p>这篇文章写的晚了，本来是想年前写得，结果一耽搁已经是2017了，过去得一年有太多值得说得，新的一年也有太多值得期待的，这篇文章中只会写有关学习工作上面的得失，个人生活不做涉及。</p>","more":"<h3 id=\"别了，2016\"><a href=\"#别了，2016\" class=\"headerlink\" title=\"别了，2016\"></a>别了，2016</h3><h4 id=\"收获\"><a href=\"#收获\" class=\"headerlink\" title=\"收获\"></a>收获</h4><p>2016 对我来说也算是一个特殊的年份，但其实细想起来所有的得失也基本都集中在了下半年，其中最值得一提的可以分为如下几点：</p>\n<ul>\n<li>首先是加入了 github 这个家庭，虽然是 15 年就注册了 github 但一直没有研究和使用过，且那时对 git 也不够熟悉了解，有大半年的时间都没能开采这座金矿。</li>\n<li>放弃了玩了多年的游戏（LOL），这中间也是是非曲中良多，朋友同学的互相指责，让单纯的游戏最后都不欢而散，之后转型玩了一段时间 dota2 ，网速不是太好，加上更新有问题，后来也就不玩了。也许已经不再是个孩子，再者本身从事电脑工作，是时候和电脑游戏说再见了。不玩游戏后也确实节省出了很多时间，也完成了接下来绝大多数的一些工作内容。</li>\n<li>在 github 上搭建了个人博客，建立博客本身并不是难事，阅读教程按部就班就可以了，但最大的收获还是切实得整理总结了一些有内容的文章，对于高中语文一直不及格的我来说，能够写博客也是怪不可思议的。</li>\n<li>基本掌握了 git 的使用，且也用于个人的一些项目上了。有关 git ，个人觉得还是比较复杂抽象的，也可能原因在于起初学习时，没看到什么较好的教程，现在学会了，却发现最近出来了不少通俗易懂的教程。</li>\n<li>对 EFM32 的芯片有了一定的研究认识，虽然过程是十分艰难的，但目前而言，已经可以写一些常规的驱动了。</li>\n<li>学了两次 Python，只能说基本掌握了 Python 的思想和语法。</li>\n<li>尝试并体验了多家云服务器，买了国外一个分拆的 VPS 服务，体验来说良好，通过虚拟机和 VPS 也学习并且尝试了多个服务的搭建，简单的搭建并不困难，但要运营管理好，对现阶段的我来说还是有相当一段距离的。</li>\n<li>使用 shanbay 学习了快两年了，阅读英文文档和网站已经基本可以胜任。</li>\n</ul>\n<h4 id=\"欠缺\"><a href=\"#欠缺\" class=\"headerlink\" title=\"欠缺\"></a>欠缺</h4><ul>\n<li>学了两次 Python，说来还是比较失败的，两次都因为各种原因中断了，应该来说还是缺少一个项目历练或者学习全面的学习计划，两次都是学到某一阶段，后面不知道该做啥了，然后又因为某些原因中断了一段时间。</li>\n<li>学习方法差，效率低，很多计划未能够完成，python 的书籍，还有 linux-c 的一本书籍都未能完成阅读</li>\n<li>网络文档看多了或者其他原因，不能/未能静下心好好的看看书，学习一些东西，光靠互联网，走了不少歪路。</li>\n<li>上半年浪费时间过多，收获不显著，早点不玩游戏，可能会收获更多。</li>\n<li>shanbay 单词荒废过多，一整年都没能静下心来真正拼写背诵单词，虽有提高但不大，主要在于学习不够专注，对自己不够狠。</li>\n<li>周末利用率不高，对于技术从业者来说，提高基本上靠业余时间，但一般也仅仅能够利用晚上，且效率比较低，总的来说还是不够专注。</li>\n<li>linux 虽然用了也蛮久了，但还是需要重新系统的学习一次，命令的使用，思想的建立都不够完善。</li>\n<li>blog 未能好好装修，计划的 H5 没能研究学习完。</li>\n</ul>\n<h3 id=\"你好，2017\"><a href=\"#你好，2017\" class=\"headerlink\" title=\"你好，2017\"></a>你好，2017</h3><p>2016 在学习工作上面不算成功，有不少欠缺之处，最主要还是表现两点：1.在工作学习不够专注，效率低。 2.业余时间尤其是周末利用率不高。</p>"},{"layout":"post","title":"（转）中文技术文档的写作规范","date":"2017-01-05T00:31:00.000Z","_content":"\n这篇文章转自[阮一峰老师的 github 项目](https://github.com/noparkinghere/document-style-guide)，写博客也有一段时间了，也不断地修改格式排版等内容，但始终缺乏一个规范标准，直到看到这篇文章。文章中写的内容个人觉得大都算是在情在理，很适合像我这样用 markdown 写博客的人去遵循。\n\n# 标题\n\n## 层级\n\n标题分为四级。\n\n- 一级标题：文章的标题\n- 二级标题：文章主要部分的大标题\n- 三级标题：二级标题下面一级的小标题\n- 四级标题：三级标题下面某一方面的小标题\n\n## 原则\n\n- 一级标题下，不能直接出现三级标题。\n- 标题要避免孤立编号（即同级标题只有一个）。\n- 下级标题不重复上一级标题的内容。\n- 谨慎使用四级标题，尽量避免出现，保持层级的简单和防止出现过于复杂的章节。如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。\n\n<!-- more -->\n\n\n# 文本\n\n## 字间距\n\n全角中文字符与半角英文字符之间，应有一个半角空格。\n\n```\n错误：本文介绍如何快速启动Windows系统。\n\n正确：本文介绍如何快速启动 Windows 系统。\n```\n\n全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。\n\n```\n正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。\n\n正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。\n```\n\n半角的百分号，视同阿拉伯数字。\n\n英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。\n\n```\n错误：一部容量为 16 GB 的智能手机\n\n正确：一部容量为 16GB 的智能手机\n```\n\n半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。\n\n```\n错误：他的电脑是 MacBook Air 。\n\n正确：他的电脑是 MacBook Air。\n```\n\n## 句子\n\n- 避免使用长句。一个句子建议不超过 100 字或者正文的 3 行。\n- 尽量使用简单句和并列句，避免使用复合句。\n\n## 写作风格\n\n尽量不使用被动语态，改为使用主动语态。\n\n```\n错误：假如此软件尚未被安装，\n\n正确：假如尚未安装这个软件，\n```\n\n不使用非正式的语言风格。\n\n```\n错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！\n\n正确：无法参加本次活动，我深感遗憾。\n```\n\n用对“的”、“地”、“得”。\n\n```\n她露出了开心的笑容。\n（形容词＋的＋名词）\n\n她开心地笑了。\n（副词＋地＋动词）\n\n她笑得很开心。\n（动词＋得＋副词）\n```\n\n使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。\n\n```\n错误：从管理系统可以监视中继系统和受其直接控制的分配系统。\n\n正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。\n```\n\n名词前不要使用过多的形式词。\n\n```\n错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。\n\n正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。\n```\n\n单个句子的长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，在任何情况下都不能接受。\n\n```\n错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。\n\n正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。\n```\n\n同样一个意思，尽量使用肯定句表达，不使用否定句表达。\n\n```\n错误：请确认没有接通装置的电源。\n\n正确：请确认装置的电源已关闭。\n```\n\n避免使用双重否定句。\n\n```\n错误：没有删除权限的用户，不能删除此文件。\n\n正确：用户必须拥有删除权限，才能删除此文件。\n```\n\n## 英文处理\n\n英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。\n\n```\n英文：⋯information stored in random access memory (RAMs)⋯\n\n中文：……存储在随机存取存储器（RAM）里的信息……\n```\n\n外文缩写可以使用半角圆点(`.`)表示缩写。\n\n```\nU.S.A.\nApple, Inc.\n```\n\n表示中文时，英文省略号（`⋯`）应改为中文省略号（`……`）。\n\n```\n英文：5 minutes later⋯\n\n中文：5 分钟过去了⋯⋯\n```\n\n英文书名或电影名改用中文表达时，双引号应改为书名号。\n\n```\n英文：He published an article entitled \"The Future of the Aviation\".\n\n中文：他发表了一篇名为《航空业的未来》的文章。\n```\n\n第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。\n\n```\nIOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。\n```\n\n专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。\n\n```\n“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。\n\n“online transaction processing”（在线事务处理）不是专有名词，不应大写。\n```\n\n# 段落\n\n## 原则\n\n- 一个段落只能有一个主题，或一个中心句子。\n- 段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。\n- 一个段落的长度不能超过七行，最佳段落长度小于等于四行。\n- 段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。\n- 段落之间使用一个空行隔开。\n- 段落开头不要留出空白字符。\n\n## 引用\n\n引用第三方内容时，应注明出处。\n\n```\nOne man’s constant is another man’s variable. — Alan Perlis\n```\n\n如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。\n\n```\n本文转载自 WikiQuote\n```\n\n使用外部图片时，必须在图片下方或文末标明来源。\n\n```\n本文部分图片来自 Wikipedia\n```\n\n# 数值\n\n## 半角数字\n\n数字一律使用半角形式，不得使用全角形式。\n\n```\n错误： 这件商品的价格是１０００元。\n\n正确： 这件商品的价格是 1000 元。\n```\n\n## 千分号\n\n数值为千位以上，应添加千分号（半角逗号）。\n\n```\nXXX 公司的实收资本为 RMB1,258,000。\n```\n\n对于 4 ～ 6 位的数值，千分号是选用的，比如`1000`和`1,000`都可以接受。对于7位及以上的数值，千分号是必须的。\n\n多位小数要从小数点后从左向右添加千分号，比如`4.234,345`。\n\n## 货币\n\n货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。\n\n```\n$1,000\n1,000 美元\n```\n\n## 数值范围\n\n表示数值范围时，用`～`连接。参见《标点符号》一节的“连接号”部分。\n\n带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。\n\n```\n正确：132kg～234kg\n错误：132～234kg\n\n正确：67%～89%\n错误：67～89%\n```\n\n## 变化程度的表示法\n\n数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。\n\n```\n增加到过去的两倍\n（过去为一，现在为二）\n\n增加了两倍\n（过去为一，现在为三）\n```\n\n数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。\n\n```\n降低到百分之八十\n（定额是一百，现在是八十）\n\n降低了百分之八十\n（原来是一百，现在是二十）\n```\n\n不能用“降低N倍”或“减少N倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。\n\n# 标点符号\n\n## 原则\n\n- 中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。\n- 如果整句为英文，则该句使用英文/半角标点。\n- 句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。\n\n## 句号\n\n中文语句中的结尾处应该用全角句号（`。`）。\n\n句子末尾用括号加注时，句号应在括号之外。\n\n```\n错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）\n\n正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。\n```\n\n## 逗号\n\n逗号`，`表示句子内部的一般性停顿。\n\n注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。\n\n## 顿号\n\n句子内部的并列词，应该用全角顿号(`、`) 分隔，而不用逗号，即使并列词是英语也是如此。\n\n```\n错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。\n\n正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。\n```\n\n英文句子中，并列词语之间使用半角逗号（`,`）分隔。\n\n```\n例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components.\n```\n\n## 分号\n\n分号`；`表示复句内部并列分句之间的停顿。\n\n## 引号\n\n引用时，应该使用全角双引号（`“ ”`），注意前后双引号不同。\n\n```\n例句：许多人都认为客户服务的核心是“友好”和“专业”。\n```\n\n引号里面还要用引号时，外面一层用双引号，里面一层用单引号（`‘ ’`），注意前后单引号不同。\n\n```\n例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”\n```\n\n## 圆括号\n\n补充说明时，使用全角圆括号`（）`，括号前后不加空格。\n\n```\n例句：请确认所有的连接（电缆和接插件）均安装牢固。\n```\n\n## 冒号\n\n全角冒号（`：`）常用在需要解释的词语后边，引出解释和说明。\n\n```\n例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。\n```\n\n表示时间时，应使用半角冒号（`:`）。\n\n```\n例句：早上 8:00\n```\n\n## 省略号\n\n省略号`……`表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用`。。。`或`...`等非标准形式。\n\n省略号不应与“等”这个词一起使用。\n\n```\n错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。\n\n正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……\n\n正确：我们为会餐准备了香蕉、苹果、梨等各色水果。\n```\n\n## 感叹号\n\n应该使用平静的语气叙述，尽量避免使用感叹号`！`。\n\n不得多个感叹号连用，比如`！！`和`!!!`。\n\n## 破折号\n\n破折号`————`一般用于做进一步解释。破折号应占两个汉字的位置。\n\n```\n例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。\n```\n\n## 连接号\n\n连接号用于连接两个类似的词。\n\n以下场合应该使用直线连接号（`-`），占一个半角字符的位置。\n\n- 两个名词的复合\n- 图表编号\n\n```\n例句：氧化-还原反应\n\n例句：图 1-1\n```\n\n以下场合应该使用波浪连接号（`～`），占一个全角字符的位置。\n\n- 数值范围（例如日期、时间或数字）\n\n```\n例句：2009 年～2011 年\n```\n\n注意，波浪连接号前后两个值都应该加上单位。\n\n波浪连接号也可以用汉字“至”代替。\n\n```\n例句：周围温度：-20°C 至 -10°C\n```\n\n# 章节结构\n\n软件手册是一部完整的书，建议采用下面的结构。\n\n- **简介**（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明\n- **快速上手**（Getting Started）：[可选] [文件] 如何最快速地使用产品\n- **入门篇**（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程\n  - **环境准备**（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件\n  - **安装**（Installation）：[可选] [文件] 软件的安装方法\n  - **设置**（Configuration）：[必备] [文件] 软件的设置\n- **进阶篇**（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程\n- **API**（Reference）：[可选] [目录|文件] 软件API的逐一介绍\n- **FAQ**：[可选] [文件] 常见问题解答\n- **附录**（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容\n  - **Glossary**：[可选] [文件] 名词解释\n  - **Recipes**：[可选] [文件] 最佳实践\n  - **Troubleshooting**：[可选] [文件] 故障处理\n  - **ChangeLog**：[可选] [文件] 版本说明\n  - **Feedback**：[可选] [文件] 反馈方式\n\n**范例**\n\n- [Redux 手册](http://redux.js.org/index.html)\n- [Atom 手册](http://flight-manual.atom.io/)\n\n# 参考链接\n\n> [产品手册中文写作规范](http://wenku.baidu.com/view/23cc1a6527d3240c8447efbf.html), by 华为  \n> [写作规范和格式规范](http://docs.daocloud.io/write-docs/format), by DaoCloud  \n> [技术写作技巧在日汉翻译中的应用](http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf), by 刘方  \n> [简体中文规范指南](https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf)，by lengoo  \n> [文档风格指南](https://open.leancloud.cn/copywriting-style-guide.html), by LeanCloud  \n> [豌豆荚文案风格指南](https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit), by 豌豆荚  \n> [中文文案排版指北](https://github.com/sparanoid/chinese-copywriting-guidelines)，by sparanoid  \n> [中文排版需求](http://w3c.github.io/clreq/)，by W3C  \n\n***\n","source":"_posts/2017/2017-01-05-（转）中文技术文档的写作规范.md","raw":"---\nlayout: \"post\"\ntitle: \"（转）中文技术文档的写作规范\"\ndate: \"2017-01-05 08:31\"\n---\n\n这篇文章转自[阮一峰老师的 github 项目](https://github.com/noparkinghere/document-style-guide)，写博客也有一段时间了，也不断地修改格式排版等内容，但始终缺乏一个规范标准，直到看到这篇文章。文章中写的内容个人觉得大都算是在情在理，很适合像我这样用 markdown 写博客的人去遵循。\n\n# 标题\n\n## 层级\n\n标题分为四级。\n\n- 一级标题：文章的标题\n- 二级标题：文章主要部分的大标题\n- 三级标题：二级标题下面一级的小标题\n- 四级标题：三级标题下面某一方面的小标题\n\n## 原则\n\n- 一级标题下，不能直接出现三级标题。\n- 标题要避免孤立编号（即同级标题只有一个）。\n- 下级标题不重复上一级标题的内容。\n- 谨慎使用四级标题，尽量避免出现，保持层级的简单和防止出现过于复杂的章节。如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。\n\n<!-- more -->\n\n\n# 文本\n\n## 字间距\n\n全角中文字符与半角英文字符之间，应有一个半角空格。\n\n```\n错误：本文介绍如何快速启动Windows系统。\n\n正确：本文介绍如何快速启动 Windows 系统。\n```\n\n全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。\n\n```\n正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。\n\n正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。\n```\n\n半角的百分号，视同阿拉伯数字。\n\n英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。\n\n```\n错误：一部容量为 16 GB 的智能手机\n\n正确：一部容量为 16GB 的智能手机\n```\n\n半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。\n\n```\n错误：他的电脑是 MacBook Air 。\n\n正确：他的电脑是 MacBook Air。\n```\n\n## 句子\n\n- 避免使用长句。一个句子建议不超过 100 字或者正文的 3 行。\n- 尽量使用简单句和并列句，避免使用复合句。\n\n## 写作风格\n\n尽量不使用被动语态，改为使用主动语态。\n\n```\n错误：假如此软件尚未被安装，\n\n正确：假如尚未安装这个软件，\n```\n\n不使用非正式的语言风格。\n\n```\n错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！\n\n正确：无法参加本次活动，我深感遗憾。\n```\n\n用对“的”、“地”、“得”。\n\n```\n她露出了开心的笑容。\n（形容词＋的＋名词）\n\n她开心地笑了。\n（副词＋地＋动词）\n\n她笑得很开心。\n（动词＋得＋副词）\n```\n\n使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。\n\n```\n错误：从管理系统可以监视中继系统和受其直接控制的分配系统。\n\n正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。\n```\n\n名词前不要使用过多的形式词。\n\n```\n错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。\n\n正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。\n```\n\n单个句子的长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，在任何情况下都不能接受。\n\n```\n错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。\n\n正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。\n```\n\n同样一个意思，尽量使用肯定句表达，不使用否定句表达。\n\n```\n错误：请确认没有接通装置的电源。\n\n正确：请确认装置的电源已关闭。\n```\n\n避免使用双重否定句。\n\n```\n错误：没有删除权限的用户，不能删除此文件。\n\n正确：用户必须拥有删除权限，才能删除此文件。\n```\n\n## 英文处理\n\n英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。\n\n```\n英文：⋯information stored in random access memory (RAMs)⋯\n\n中文：……存储在随机存取存储器（RAM）里的信息……\n```\n\n外文缩写可以使用半角圆点(`.`)表示缩写。\n\n```\nU.S.A.\nApple, Inc.\n```\n\n表示中文时，英文省略号（`⋯`）应改为中文省略号（`……`）。\n\n```\n英文：5 minutes later⋯\n\n中文：5 分钟过去了⋯⋯\n```\n\n英文书名或电影名改用中文表达时，双引号应改为书名号。\n\n```\n英文：He published an article entitled \"The Future of the Aviation\".\n\n中文：他发表了一篇名为《航空业的未来》的文章。\n```\n\n第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。\n\n```\nIOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。\n```\n\n专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。\n\n```\n“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。\n\n“online transaction processing”（在线事务处理）不是专有名词，不应大写。\n```\n\n# 段落\n\n## 原则\n\n- 一个段落只能有一个主题，或一个中心句子。\n- 段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。\n- 一个段落的长度不能超过七行，最佳段落长度小于等于四行。\n- 段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。\n- 段落之间使用一个空行隔开。\n- 段落开头不要留出空白字符。\n\n## 引用\n\n引用第三方内容时，应注明出处。\n\n```\nOne man’s constant is another man’s variable. — Alan Perlis\n```\n\n如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。\n\n```\n本文转载自 WikiQuote\n```\n\n使用外部图片时，必须在图片下方或文末标明来源。\n\n```\n本文部分图片来自 Wikipedia\n```\n\n# 数值\n\n## 半角数字\n\n数字一律使用半角形式，不得使用全角形式。\n\n```\n错误： 这件商品的价格是１０００元。\n\n正确： 这件商品的价格是 1000 元。\n```\n\n## 千分号\n\n数值为千位以上，应添加千分号（半角逗号）。\n\n```\nXXX 公司的实收资本为 RMB1,258,000。\n```\n\n对于 4 ～ 6 位的数值，千分号是选用的，比如`1000`和`1,000`都可以接受。对于7位及以上的数值，千分号是必须的。\n\n多位小数要从小数点后从左向右添加千分号，比如`4.234,345`。\n\n## 货币\n\n货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。\n\n```\n$1,000\n1,000 美元\n```\n\n## 数值范围\n\n表示数值范围时，用`～`连接。参见《标点符号》一节的“连接号”部分。\n\n带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。\n\n```\n正确：132kg～234kg\n错误：132～234kg\n\n正确：67%～89%\n错误：67～89%\n```\n\n## 变化程度的表示法\n\n数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。\n\n```\n增加到过去的两倍\n（过去为一，现在为二）\n\n增加了两倍\n（过去为一，现在为三）\n```\n\n数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。\n\n```\n降低到百分之八十\n（定额是一百，现在是八十）\n\n降低了百分之八十\n（原来是一百，现在是二十）\n```\n\n不能用“降低N倍”或“减少N倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。\n\n# 标点符号\n\n## 原则\n\n- 中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。\n- 如果整句为英文，则该句使用英文/半角标点。\n- 句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。\n\n## 句号\n\n中文语句中的结尾处应该用全角句号（`。`）。\n\n句子末尾用括号加注时，句号应在括号之外。\n\n```\n错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）\n\n正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。\n```\n\n## 逗号\n\n逗号`，`表示句子内部的一般性停顿。\n\n注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。\n\n## 顿号\n\n句子内部的并列词，应该用全角顿号(`、`) 分隔，而不用逗号，即使并列词是英语也是如此。\n\n```\n错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。\n\n正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。\n```\n\n英文句子中，并列词语之间使用半角逗号（`,`）分隔。\n\n```\n例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components.\n```\n\n## 分号\n\n分号`；`表示复句内部并列分句之间的停顿。\n\n## 引号\n\n引用时，应该使用全角双引号（`“ ”`），注意前后双引号不同。\n\n```\n例句：许多人都认为客户服务的核心是“友好”和“专业”。\n```\n\n引号里面还要用引号时，外面一层用双引号，里面一层用单引号（`‘ ’`），注意前后单引号不同。\n\n```\n例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”\n```\n\n## 圆括号\n\n补充说明时，使用全角圆括号`（）`，括号前后不加空格。\n\n```\n例句：请确认所有的连接（电缆和接插件）均安装牢固。\n```\n\n## 冒号\n\n全角冒号（`：`）常用在需要解释的词语后边，引出解释和说明。\n\n```\n例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。\n```\n\n表示时间时，应使用半角冒号（`:`）。\n\n```\n例句：早上 8:00\n```\n\n## 省略号\n\n省略号`……`表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用`。。。`或`...`等非标准形式。\n\n省略号不应与“等”这个词一起使用。\n\n```\n错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。\n\n正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……\n\n正确：我们为会餐准备了香蕉、苹果、梨等各色水果。\n```\n\n## 感叹号\n\n应该使用平静的语气叙述，尽量避免使用感叹号`！`。\n\n不得多个感叹号连用，比如`！！`和`!!!`。\n\n## 破折号\n\n破折号`————`一般用于做进一步解释。破折号应占两个汉字的位置。\n\n```\n例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。\n```\n\n## 连接号\n\n连接号用于连接两个类似的词。\n\n以下场合应该使用直线连接号（`-`），占一个半角字符的位置。\n\n- 两个名词的复合\n- 图表编号\n\n```\n例句：氧化-还原反应\n\n例句：图 1-1\n```\n\n以下场合应该使用波浪连接号（`～`），占一个全角字符的位置。\n\n- 数值范围（例如日期、时间或数字）\n\n```\n例句：2009 年～2011 年\n```\n\n注意，波浪连接号前后两个值都应该加上单位。\n\n波浪连接号也可以用汉字“至”代替。\n\n```\n例句：周围温度：-20°C 至 -10°C\n```\n\n# 章节结构\n\n软件手册是一部完整的书，建议采用下面的结构。\n\n- **简介**（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明\n- **快速上手**（Getting Started）：[可选] [文件] 如何最快速地使用产品\n- **入门篇**（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程\n  - **环境准备**（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件\n  - **安装**（Installation）：[可选] [文件] 软件的安装方法\n  - **设置**（Configuration）：[必备] [文件] 软件的设置\n- **进阶篇**（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程\n- **API**（Reference）：[可选] [目录|文件] 软件API的逐一介绍\n- **FAQ**：[可选] [文件] 常见问题解答\n- **附录**（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容\n  - **Glossary**：[可选] [文件] 名词解释\n  - **Recipes**：[可选] [文件] 最佳实践\n  - **Troubleshooting**：[可选] [文件] 故障处理\n  - **ChangeLog**：[可选] [文件] 版本说明\n  - **Feedback**：[可选] [文件] 反馈方式\n\n**范例**\n\n- [Redux 手册](http://redux.js.org/index.html)\n- [Atom 手册](http://flight-manual.atom.io/)\n\n# 参考链接\n\n> [产品手册中文写作规范](http://wenku.baidu.com/view/23cc1a6527d3240c8447efbf.html), by 华为  \n> [写作规范和格式规范](http://docs.daocloud.io/write-docs/format), by DaoCloud  \n> [技术写作技巧在日汉翻译中的应用](http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf), by 刘方  \n> [简体中文规范指南](https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf)，by lengoo  \n> [文档风格指南](https://open.leancloud.cn/copywriting-style-guide.html), by LeanCloud  \n> [豌豆荚文案风格指南](https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit), by 豌豆荚  \n> [中文文案排版指北](https://github.com/sparanoid/chinese-copywriting-guidelines)，by sparanoid  \n> [中文排版需求](http://w3c.github.io/clreq/)，by W3C  \n\n***\n","slug":"2017/2017-01-05-（转）中文技术文档的写作规范","published":1,"updated":"2017-01-05T01:39:32.584Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aft0006mumucxfh49ap","content":"<p>这篇文章转自<a href=\"https://github.com/noparkinghere/document-style-guide\" target=\"_blank\" rel=\"external\">阮一峰老师的 github 项目</a>，写博客也有一段时间了，也不断地修改格式排版等内容，但始终缺乏一个规范标准，直到看到这篇文章。文章中写的内容个人觉得大都算是在情在理，很适合像我这样用 markdown 写博客的人去遵循。</p>\n<h1 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h1><h2 id=\"层级\"><a href=\"#层级\" class=\"headerlink\" title=\"层级\"></a>层级</h2><p>标题分为四级。</p>\n<ul>\n<li>一级标题：文章的标题</li>\n<li>二级标题：文章主要部分的大标题</li>\n<li>三级标题：二级标题下面一级的小标题</li>\n<li>四级标题：三级标题下面某一方面的小标题</li>\n</ul>\n<h2 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h2><ul>\n<li>一级标题下，不能直接出现三级标题。</li>\n<li>标题要避免孤立编号（即同级标题只有一个）。</li>\n<li>下级标题不重复上一级标题的内容。</li>\n<li>谨慎使用四级标题，尽量避免出现，保持层级的简单和防止出现过于复杂的章节。如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"文本\"><a href=\"#文本\" class=\"headerlink\" title=\"文本\"></a>文本</h1><h2 id=\"字间距\"><a href=\"#字间距\" class=\"headerlink\" title=\"字间距\"></a>字间距</h2><p>全角中文字符与半角英文字符之间，应有一个半角空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：本文介绍如何快速启动Windows系统。</div><div class=\"line\"></div><div class=\"line\">正确：本文介绍如何快速启动 Windows 系统。</div></pre></td></tr></table></figure>\n<p>全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。</div><div class=\"line\"></div><div class=\"line\">正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。</div></pre></td></tr></table></figure>\n<p>半角的百分号，视同阿拉伯数字。</p>\n<p>英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：一部容量为 16 GB 的智能手机</div><div class=\"line\"></div><div class=\"line\">正确：一部容量为 16GB 的智能手机</div></pre></td></tr></table></figure>\n<p>半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：他的电脑是 MacBook Air 。</div><div class=\"line\"></div><div class=\"line\">正确：他的电脑是 MacBook Air。</div></pre></td></tr></table></figure>\n<h2 id=\"句子\"><a href=\"#句子\" class=\"headerlink\" title=\"句子\"></a>句子</h2><ul>\n<li>避免使用长句。一个句子建议不超过 100 字或者正文的 3 行。</li>\n<li>尽量使用简单句和并列句，避免使用复合句。</li>\n</ul>\n<h2 id=\"写作风格\"><a href=\"#写作风格\" class=\"headerlink\" title=\"写作风格\"></a>写作风格</h2><p>尽量不使用被动语态，改为使用主动语态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：假如此软件尚未被安装，</div><div class=\"line\"></div><div class=\"line\">正确：假如尚未安装这个软件，</div></pre></td></tr></table></figure>\n<p>不使用非正式的语言风格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！</div><div class=\"line\"></div><div class=\"line\">正确：无法参加本次活动，我深感遗憾。</div></pre></td></tr></table></figure>\n<p>用对“的”、“地”、“得”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">她露出了开心的笑容。</div><div class=\"line\">（形容词＋的＋名词）</div><div class=\"line\"></div><div class=\"line\">她开心地笑了。</div><div class=\"line\">（副词＋地＋动词）</div><div class=\"line\"></div><div class=\"line\">她笑得很开心。</div><div class=\"line\">（动词＋得＋副词）</div></pre></td></tr></table></figure>\n<p>使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：从管理系统可以监视中继系统和受其直接控制的分配系统。</div><div class=\"line\"></div><div class=\"line\">正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。</div></pre></td></tr></table></figure>\n<p>名词前不要使用过多的形式词。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。</div><div class=\"line\"></div><div class=\"line\">正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。</div></pre></td></tr></table></figure>\n<p>单个句子的长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，在任何情况下都不能接受。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。</div><div class=\"line\"></div><div class=\"line\">正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。</div></pre></td></tr></table></figure>\n<p>同样一个意思，尽量使用肯定句表达，不使用否定句表达。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：请确认没有接通装置的电源。</div><div class=\"line\"></div><div class=\"line\">正确：请确认装置的电源已关闭。</div></pre></td></tr></table></figure>\n<p>避免使用双重否定句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：没有删除权限的用户，不能删除此文件。</div><div class=\"line\"></div><div class=\"line\">正确：用户必须拥有删除权限，才能删除此文件。</div></pre></td></tr></table></figure>\n<h2 id=\"英文处理\"><a href=\"#英文处理\" class=\"headerlink\" title=\"英文处理\"></a>英文处理</h2><p>英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">英文：⋯information stored in random access memory (RAMs)⋯</div><div class=\"line\"></div><div class=\"line\">中文：……存储在随机存取存储器（RAM）里的信息……</div></pre></td></tr></table></figure>\n<p>外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">U.S.A.</div><div class=\"line\">Apple, Inc.</div></pre></td></tr></table></figure>\n<p>表示中文时，英文省略号（<code>⋯</code>）应改为中文省略号（<code>……</code>）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">英文：5 minutes later⋯</div><div class=\"line\"></div><div class=\"line\">中文：5 分钟过去了⋯⋯</div></pre></td></tr></table></figure>\n<p>英文书名或电影名改用中文表达时，双引号应改为书名号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">英文：He published an article entitled &quot;The Future of the Aviation&quot;.</div><div class=\"line\"></div><div class=\"line\">中文：他发表了一篇名为《航空业的未来》的文章。</div></pre></td></tr></table></figure>\n<p>第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。</div></pre></td></tr></table></figure>\n<p>专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。</div><div class=\"line\"></div><div class=\"line\">“online transaction processing”（在线事务处理）不是专有名词，不应大写。</div></pre></td></tr></table></figure>\n<h1 id=\"段落\"><a href=\"#段落\" class=\"headerlink\" title=\"段落\"></a>段落</h1><h2 id=\"原则-1\"><a href=\"#原则-1\" class=\"headerlink\" title=\"原则\"></a>原则</h2><ul>\n<li>一个段落只能有一个主题，或一个中心句子。</li>\n<li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li>\n<li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li>\n<li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li>\n<li>段落之间使用一个空行隔开。</li>\n<li>段落开头不要留出空白字符。</li>\n</ul>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>引用第三方内容时，应注明出处。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">One man’s constant is another man’s variable. — Alan Perlis</div></pre></td></tr></table></figure>\n<p>如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">本文转载自 WikiQuote</div></pre></td></tr></table></figure>\n<p>使用外部图片时，必须在图片下方或文末标明来源。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">本文部分图片来自 Wikipedia</div></pre></td></tr></table></figure>\n<h1 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a>数值</h1><h2 id=\"半角数字\"><a href=\"#半角数字\" class=\"headerlink\" title=\"半角数字\"></a>半角数字</h2><p>数字一律使用半角形式，不得使用全角形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误： 这件商品的价格是１０００元。</div><div class=\"line\"></div><div class=\"line\">正确： 这件商品的价格是 1000 元。</div></pre></td></tr></table></figure>\n<h2 id=\"千分号\"><a href=\"#千分号\" class=\"headerlink\" title=\"千分号\"></a>千分号</h2><p>数值为千位以上，应添加千分号（半角逗号）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">XXX 公司的实收资本为 RMB1,258,000。</div></pre></td></tr></table></figure>\n<p>对于 4 ～ 6 位的数值，千分号是选用的，比如<code>1000</code>和<code>1,000</code>都可以接受。对于7位及以上的数值，千分号是必须的。</p>\n<p>多位小数要从小数点后从左向右添加千分号，比如<code>4.234,345</code>。</p>\n<h2 id=\"货币\"><a href=\"#货币\" class=\"headerlink\" title=\"货币\"></a>货币</h2><p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$1,000</div><div class=\"line\">1,000 美元</div></pre></td></tr></table></figure>\n<h2 id=\"数值范围\"><a href=\"#数值范围\" class=\"headerlink\" title=\"数值范围\"></a>数值范围</h2><p>表示数值范围时，用<code>～</code>连接。参见《标点符号》一节的“连接号”部分。</p>\n<p>带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">正确：132kg～234kg</div><div class=\"line\">错误：132～234kg</div><div class=\"line\"></div><div class=\"line\">正确：67%～89%</div><div class=\"line\">错误：67～89%</div></pre></td></tr></table></figure>\n<h2 id=\"变化程度的表示法\"><a href=\"#变化程度的表示法\" class=\"headerlink\" title=\"变化程度的表示法\"></a>变化程度的表示法</h2><p>数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">增加到过去的两倍</div><div class=\"line\">（过去为一，现在为二）</div><div class=\"line\"></div><div class=\"line\">增加了两倍</div><div class=\"line\">（过去为一，现在为三）</div></pre></td></tr></table></figure>\n<p>数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">降低到百分之八十</div><div class=\"line\">（定额是一百，现在是八十）</div><div class=\"line\"></div><div class=\"line\">降低了百分之八十</div><div class=\"line\">（原来是一百，现在是二十）</div></pre></td></tr></table></figure>\n<p>不能用“降低N倍”或“减少N倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p>\n<h1 id=\"标点符号\"><a href=\"#标点符号\" class=\"headerlink\" title=\"标点符号\"></a>标点符号</h1><h2 id=\"原则-2\"><a href=\"#原则-2\" class=\"headerlink\" title=\"原则\"></a>原则</h2><ul>\n<li>中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。</li>\n<li>如果整句为英文，则该句使用英文/半角标点。</li>\n<li>句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</li>\n</ul>\n<h2 id=\"句号\"><a href=\"#句号\" class=\"headerlink\" title=\"句号\"></a>句号</h2><p>中文语句中的结尾处应该用全角句号（<code>。</code>）。</p>\n<p>句子末尾用括号加注时，句号应在括号之外。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）</div><div class=\"line\"></div><div class=\"line\">正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。</div></pre></td></tr></table></figure>\n<h2 id=\"逗号\"><a href=\"#逗号\" class=\"headerlink\" title=\"逗号\"></a>逗号</h2><p>逗号<code>，</code>表示句子内部的一般性停顿。</p>\n<p>注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。</p>\n<h2 id=\"顿号\"><a href=\"#顿号\" class=\"headerlink\" title=\"顿号\"></a>顿号</h2><p>句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使并列词是英语也是如此。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。</div><div class=\"line\"></div><div class=\"line\">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</div></pre></td></tr></table></figure>\n<p>英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components.</div></pre></td></tr></table></figure>\n<h2 id=\"分号\"><a href=\"#分号\" class=\"headerlink\" title=\"分号\"></a>分号</h2><p>分号<code>；</code>表示复句内部并列分句之间的停顿。</p>\n<h2 id=\"引号\"><a href=\"#引号\" class=\"headerlink\" title=\"引号\"></a>引号</h2><p>引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：许多人都认为客户服务的核心是“友好”和“专业”。</div></pre></td></tr></table></figure>\n<p>引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”</div></pre></td></tr></table></figure>\n<h2 id=\"圆括号\"><a href=\"#圆括号\" class=\"headerlink\" title=\"圆括号\"></a>圆括号</h2><p>补充说明时，使用全角圆括号<code>（）</code>，括号前后不加空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：请确认所有的连接（电缆和接插件）均安装牢固。</div></pre></td></tr></table></figure>\n<h2 id=\"冒号\"><a href=\"#冒号\" class=\"headerlink\" title=\"冒号\"></a>冒号</h2><p>全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。</div></pre></td></tr></table></figure>\n<p>表示时间时，应使用半角冒号（<code>:</code>）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：早上 8:00</div></pre></td></tr></table></figure>\n<h2 id=\"省略号\"><a href=\"#省略号\" class=\"headerlink\" title=\"省略号\"></a>省略号</h2><p>省略号<code>……</code>表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用<code>。。。</code>或<code>...</code>等非标准形式。</p>\n<p>省略号不应与“等”这个词一起使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。</div><div class=\"line\"></div><div class=\"line\">正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……</div><div class=\"line\"></div><div class=\"line\">正确：我们为会餐准备了香蕉、苹果、梨等各色水果。</div></pre></td></tr></table></figure>\n<h2 id=\"感叹号\"><a href=\"#感叹号\" class=\"headerlink\" title=\"感叹号\"></a>感叹号</h2><p>应该使用平静的语气叙述，尽量避免使用感叹号<code>！</code>。</p>\n<p>不得多个感叹号连用，比如<code>！！</code>和<code>!!!</code>。</p>\n<h2 id=\"破折号\"><a href=\"#破折号\" class=\"headerlink\" title=\"破折号\"></a>破折号</h2><p>破折号<code>————</code>一般用于做进一步解释。破折号应占两个汉字的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。</div></pre></td></tr></table></figure>\n<h2 id=\"连接号\"><a href=\"#连接号\" class=\"headerlink\" title=\"连接号\"></a>连接号</h2><p>连接号用于连接两个类似的词。</p>\n<p>以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置。</p>\n<ul>\n<li>两个名词的复合</li>\n<li>图表编号</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：氧化-还原反应</div><div class=\"line\"></div><div class=\"line\">例句：图 1-1</div></pre></td></tr></table></figure>\n<p>以下场合应该使用波浪连接号（<code>～</code>），占一个全角字符的位置。</p>\n<ul>\n<li>数值范围（例如日期、时间或数字）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：2009 年～2011 年</div></pre></td></tr></table></figure>\n<p>注意，波浪连接号前后两个值都应该加上单位。</p>\n<p>波浪连接号也可以用汉字“至”代替。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：周围温度：-20°C 至 -10°C</div></pre></td></tr></table></figure>\n<h1 id=\"章节结构\"><a href=\"#章节结构\" class=\"headerlink\" title=\"章节结构\"></a>章节结构</h1><p>软件手册是一部完整的书，建议采用下面的结构。</p>\n<ul>\n<li><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</li>\n<li><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</li>\n<li><strong>入门篇</strong>（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程<ul>\n<li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li>\n<li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li>\n<li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li>\n</ul>\n</li>\n<li><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程</li>\n<li><strong>API</strong>（Reference）：[可选] [目录|文件] 软件API的逐一介绍</li>\n<li><strong>FAQ</strong>：[可选] [文件] 常见问题解答</li>\n<li><strong>附录</strong>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容<ul>\n<li><strong>Glossary</strong>：[可选] [文件] 名词解释</li>\n<li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li>\n<li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li>\n<li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li>\n<li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li>\n</ul>\n</li>\n</ul>\n<p><strong>范例</strong></p>\n<ul>\n<li><a href=\"http://redux.js.org/index.html\" target=\"_blank\" rel=\"external\">Redux 手册</a></li>\n<li><a href=\"http://flight-manual.atom.io/\" target=\"_blank\" rel=\"external\">Atom 手册</a></li>\n</ul>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><blockquote>\n<p><a href=\"http://wenku.baidu.com/view/23cc1a6527d3240c8447efbf.html\" target=\"_blank\" rel=\"external\">产品手册中文写作规范</a>, by 华为<br><a href=\"http://docs.daocloud.io/write-docs/format\" target=\"_blank\" rel=\"external\">写作规范和格式规范</a>, by DaoCloud<br><a href=\"http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf\" target=\"_blank\" rel=\"external\">技术写作技巧在日汉翻译中的应用</a>, by 刘方<br><a href=\"https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf\" target=\"_blank\" rel=\"external\">简体中文规范指南</a>，by lengoo<br><a href=\"https://open.leancloud.cn/copywriting-style-guide.html\" target=\"_blank\" rel=\"external\">文档风格指南</a>, by LeanCloud<br><a href=\"https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit\" target=\"_blank\" rel=\"external\">豌豆荚文案风格指南</a>, by 豌豆荚<br><a href=\"https://github.com/sparanoid/chinese-copywriting-guidelines\" target=\"_blank\" rel=\"external\">中文文案排版指北</a>，by sparanoid<br><a href=\"http://w3c.github.io/clreq/\" target=\"_blank\" rel=\"external\">中文排版需求</a>，by W3C  </p>\n</blockquote>\n<hr>\n","excerpt":"<p>这篇文章转自<a href=\"https://github.com/noparkinghere/document-style-guide\">阮一峰老师的 github 项目</a>，写博客也有一段时间了，也不断地修改格式排版等内容，但始终缺乏一个规范标准，直到看到这篇文章。文章中写的内容个人觉得大都算是在情在理，很适合像我这样用 markdown 写博客的人去遵循。</p>\n<h1 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h1><h2 id=\"层级\"><a href=\"#层级\" class=\"headerlink\" title=\"层级\"></a>层级</h2><p>标题分为四级。</p>\n<ul>\n<li>一级标题：文章的标题</li>\n<li>二级标题：文章主要部分的大标题</li>\n<li>三级标题：二级标题下面一级的小标题</li>\n<li>四级标题：三级标题下面某一方面的小标题</li>\n</ul>\n<h2 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h2><ul>\n<li>一级标题下，不能直接出现三级标题。</li>\n<li>标题要避免孤立编号（即同级标题只有一个）。</li>\n<li>下级标题不重复上一级标题的内容。</li>\n<li>谨慎使用四级标题，尽量避免出现，保持层级的简单和防止出现过于复杂的章节。如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</li>\n</ul>","more":"<h1 id=\"文本\"><a href=\"#文本\" class=\"headerlink\" title=\"文本\"></a>文本</h1><h2 id=\"字间距\"><a href=\"#字间距\" class=\"headerlink\" title=\"字间距\"></a>字间距</h2><p>全角中文字符与半角英文字符之间，应有一个半角空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：本文介绍如何快速启动Windows系统。</div><div class=\"line\"></div><div class=\"line\">正确：本文介绍如何快速启动 Windows 系统。</div></pre></td></tr></table></figure>\n<p>全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。</div><div class=\"line\"></div><div class=\"line\">正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。</div></pre></td></tr></table></figure>\n<p>半角的百分号，视同阿拉伯数字。</p>\n<p>英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：一部容量为 16 GB 的智能手机</div><div class=\"line\"></div><div class=\"line\">正确：一部容量为 16GB 的智能手机</div></pre></td></tr></table></figure>\n<p>半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：他的电脑是 MacBook Air 。</div><div class=\"line\"></div><div class=\"line\">正确：他的电脑是 MacBook Air。</div></pre></td></tr></table></figure>\n<h2 id=\"句子\"><a href=\"#句子\" class=\"headerlink\" title=\"句子\"></a>句子</h2><ul>\n<li>避免使用长句。一个句子建议不超过 100 字或者正文的 3 行。</li>\n<li>尽量使用简单句和并列句，避免使用复合句。</li>\n</ul>\n<h2 id=\"写作风格\"><a href=\"#写作风格\" class=\"headerlink\" title=\"写作风格\"></a>写作风格</h2><p>尽量不使用被动语态，改为使用主动语态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：假如此软件尚未被安装，</div><div class=\"line\"></div><div class=\"line\">正确：假如尚未安装这个软件，</div></pre></td></tr></table></figure>\n<p>不使用非正式的语言风格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！</div><div class=\"line\"></div><div class=\"line\">正确：无法参加本次活动，我深感遗憾。</div></pre></td></tr></table></figure>\n<p>用对“的”、“地”、“得”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">她露出了开心的笑容。</div><div class=\"line\">（形容词＋的＋名词）</div><div class=\"line\"></div><div class=\"line\">她开心地笑了。</div><div class=\"line\">（副词＋地＋动词）</div><div class=\"line\"></div><div class=\"line\">她笑得很开心。</div><div class=\"line\">（动词＋得＋副词）</div></pre></td></tr></table></figure>\n<p>使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：从管理系统可以监视中继系统和受其直接控制的分配系统。</div><div class=\"line\"></div><div class=\"line\">正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。</div></pre></td></tr></table></figure>\n<p>名词前不要使用过多的形式词。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。</div><div class=\"line\"></div><div class=\"line\">正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。</div></pre></td></tr></table></figure>\n<p>单个句子的长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，在任何情况下都不能接受。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。</div><div class=\"line\"></div><div class=\"line\">正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。</div></pre></td></tr></table></figure>\n<p>同样一个意思，尽量使用肯定句表达，不使用否定句表达。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：请确认没有接通装置的电源。</div><div class=\"line\"></div><div class=\"line\">正确：请确认装置的电源已关闭。</div></pre></td></tr></table></figure>\n<p>避免使用双重否定句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：没有删除权限的用户，不能删除此文件。</div><div class=\"line\"></div><div class=\"line\">正确：用户必须拥有删除权限，才能删除此文件。</div></pre></td></tr></table></figure>\n<h2 id=\"英文处理\"><a href=\"#英文处理\" class=\"headerlink\" title=\"英文处理\"></a>英文处理</h2><p>英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">英文：⋯information stored in random access memory (RAMs)⋯</div><div class=\"line\"></div><div class=\"line\">中文：……存储在随机存取存储器（RAM）里的信息……</div></pre></td></tr></table></figure>\n<p>外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">U.S.A.</div><div class=\"line\">Apple, Inc.</div></pre></td></tr></table></figure>\n<p>表示中文时，英文省略号（<code>⋯</code>）应改为中文省略号（<code>……</code>）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">英文：5 minutes later⋯</div><div class=\"line\"></div><div class=\"line\">中文：5 分钟过去了⋯⋯</div></pre></td></tr></table></figure>\n<p>英文书名或电影名改用中文表达时，双引号应改为书名号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">英文：He published an article entitled &quot;The Future of the Aviation&quot;.</div><div class=\"line\"></div><div class=\"line\">中文：他发表了一篇名为《航空业的未来》的文章。</div></pre></td></tr></table></figure>\n<p>第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。</div></pre></td></tr></table></figure>\n<p>专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。</div><div class=\"line\"></div><div class=\"line\">“online transaction processing”（在线事务处理）不是专有名词，不应大写。</div></pre></td></tr></table></figure>\n<h1 id=\"段落\"><a href=\"#段落\" class=\"headerlink\" title=\"段落\"></a>段落</h1><h2 id=\"原则-1\"><a href=\"#原则-1\" class=\"headerlink\" title=\"原则\"></a>原则</h2><ul>\n<li>一个段落只能有一个主题，或一个中心句子。</li>\n<li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li>\n<li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li>\n<li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li>\n<li>段落之间使用一个空行隔开。</li>\n<li>段落开头不要留出空白字符。</li>\n</ul>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>引用第三方内容时，应注明出处。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">One man’s constant is another man’s variable. — Alan Perlis</div></pre></td></tr></table></figure>\n<p>如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">本文转载自 WikiQuote</div></pre></td></tr></table></figure>\n<p>使用外部图片时，必须在图片下方或文末标明来源。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">本文部分图片来自 Wikipedia</div></pre></td></tr></table></figure>\n<h1 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a>数值</h1><h2 id=\"半角数字\"><a href=\"#半角数字\" class=\"headerlink\" title=\"半角数字\"></a>半角数字</h2><p>数字一律使用半角形式，不得使用全角形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误： 这件商品的价格是１０００元。</div><div class=\"line\"></div><div class=\"line\">正确： 这件商品的价格是 1000 元。</div></pre></td></tr></table></figure>\n<h2 id=\"千分号\"><a href=\"#千分号\" class=\"headerlink\" title=\"千分号\"></a>千分号</h2><p>数值为千位以上，应添加千分号（半角逗号）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">XXX 公司的实收资本为 RMB1,258,000。</div></pre></td></tr></table></figure>\n<p>对于 4 ～ 6 位的数值，千分号是选用的，比如<code>1000</code>和<code>1,000</code>都可以接受。对于7位及以上的数值，千分号是必须的。</p>\n<p>多位小数要从小数点后从左向右添加千分号，比如<code>4.234,345</code>。</p>\n<h2 id=\"货币\"><a href=\"#货币\" class=\"headerlink\" title=\"货币\"></a>货币</h2><p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$1,000</div><div class=\"line\">1,000 美元</div></pre></td></tr></table></figure>\n<h2 id=\"数值范围\"><a href=\"#数值范围\" class=\"headerlink\" title=\"数值范围\"></a>数值范围</h2><p>表示数值范围时，用<code>～</code>连接。参见《标点符号》一节的“连接号”部分。</p>\n<p>带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">正确：132kg～234kg</div><div class=\"line\">错误：132～234kg</div><div class=\"line\"></div><div class=\"line\">正确：67%～89%</div><div class=\"line\">错误：67～89%</div></pre></td></tr></table></figure>\n<h2 id=\"变化程度的表示法\"><a href=\"#变化程度的表示法\" class=\"headerlink\" title=\"变化程度的表示法\"></a>变化程度的表示法</h2><p>数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">增加到过去的两倍</div><div class=\"line\">（过去为一，现在为二）</div><div class=\"line\"></div><div class=\"line\">增加了两倍</div><div class=\"line\">（过去为一，现在为三）</div></pre></td></tr></table></figure>\n<p>数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">降低到百分之八十</div><div class=\"line\">（定额是一百，现在是八十）</div><div class=\"line\"></div><div class=\"line\">降低了百分之八十</div><div class=\"line\">（原来是一百，现在是二十）</div></pre></td></tr></table></figure>\n<p>不能用“降低N倍”或“减少N倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p>\n<h1 id=\"标点符号\"><a href=\"#标点符号\" class=\"headerlink\" title=\"标点符号\"></a>标点符号</h1><h2 id=\"原则-2\"><a href=\"#原则-2\" class=\"headerlink\" title=\"原则\"></a>原则</h2><ul>\n<li>中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。</li>\n<li>如果整句为英文，则该句使用英文/半角标点。</li>\n<li>句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</li>\n</ul>\n<h2 id=\"句号\"><a href=\"#句号\" class=\"headerlink\" title=\"句号\"></a>句号</h2><p>中文语句中的结尾处应该用全角句号（<code>。</code>）。</p>\n<p>句子末尾用括号加注时，句号应在括号之外。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）</div><div class=\"line\"></div><div class=\"line\">正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。</div></pre></td></tr></table></figure>\n<h2 id=\"逗号\"><a href=\"#逗号\" class=\"headerlink\" title=\"逗号\"></a>逗号</h2><p>逗号<code>，</code>表示句子内部的一般性停顿。</p>\n<p>注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。</p>\n<h2 id=\"顿号\"><a href=\"#顿号\" class=\"headerlink\" title=\"顿号\"></a>顿号</h2><p>句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使并列词是英语也是如此。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。</div><div class=\"line\"></div><div class=\"line\">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</div></pre></td></tr></table></figure>\n<p>英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components.</div></pre></td></tr></table></figure>\n<h2 id=\"分号\"><a href=\"#分号\" class=\"headerlink\" title=\"分号\"></a>分号</h2><p>分号<code>；</code>表示复句内部并列分句之间的停顿。</p>\n<h2 id=\"引号\"><a href=\"#引号\" class=\"headerlink\" title=\"引号\"></a>引号</h2><p>引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：许多人都认为客户服务的核心是“友好”和“专业”。</div></pre></td></tr></table></figure>\n<p>引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”</div></pre></td></tr></table></figure>\n<h2 id=\"圆括号\"><a href=\"#圆括号\" class=\"headerlink\" title=\"圆括号\"></a>圆括号</h2><p>补充说明时，使用全角圆括号<code>（）</code>，括号前后不加空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：请确认所有的连接（电缆和接插件）均安装牢固。</div></pre></td></tr></table></figure>\n<h2 id=\"冒号\"><a href=\"#冒号\" class=\"headerlink\" title=\"冒号\"></a>冒号</h2><p>全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。</div></pre></td></tr></table></figure>\n<p>表示时间时，应使用半角冒号（<code>:</code>）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：早上 8:00</div></pre></td></tr></table></figure>\n<h2 id=\"省略号\"><a href=\"#省略号\" class=\"headerlink\" title=\"省略号\"></a>省略号</h2><p>省略号<code>……</code>表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用<code>。。。</code>或<code>...</code>等非标准形式。</p>\n<p>省略号不应与“等”这个词一起使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。</div><div class=\"line\"></div><div class=\"line\">正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……</div><div class=\"line\"></div><div class=\"line\">正确：我们为会餐准备了香蕉、苹果、梨等各色水果。</div></pre></td></tr></table></figure>\n<h2 id=\"感叹号\"><a href=\"#感叹号\" class=\"headerlink\" title=\"感叹号\"></a>感叹号</h2><p>应该使用平静的语气叙述，尽量避免使用感叹号<code>！</code>。</p>\n<p>不得多个感叹号连用，比如<code>！！</code>和<code>!!!</code>。</p>\n<h2 id=\"破折号\"><a href=\"#破折号\" class=\"headerlink\" title=\"破折号\"></a>破折号</h2><p>破折号<code>————</code>一般用于做进一步解释。破折号应占两个汉字的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。</div></pre></td></tr></table></figure>\n<h2 id=\"连接号\"><a href=\"#连接号\" class=\"headerlink\" title=\"连接号\"></a>连接号</h2><p>连接号用于连接两个类似的词。</p>\n<p>以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置。</p>\n<ul>\n<li>两个名词的复合</li>\n<li>图表编号</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：氧化-还原反应</div><div class=\"line\"></div><div class=\"line\">例句：图 1-1</div></pre></td></tr></table></figure>\n<p>以下场合应该使用波浪连接号（<code>～</code>），占一个全角字符的位置。</p>\n<ul>\n<li>数值范围（例如日期、时间或数字）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：2009 年～2011 年</div></pre></td></tr></table></figure>\n<p>注意，波浪连接号前后两个值都应该加上单位。</p>\n<p>波浪连接号也可以用汉字“至”代替。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">例句：周围温度：-20°C 至 -10°C</div></pre></td></tr></table></figure>\n<h1 id=\"章节结构\"><a href=\"#章节结构\" class=\"headerlink\" title=\"章节结构\"></a>章节结构</h1><p>软件手册是一部完整的书，建议采用下面的结构。</p>\n<ul>\n<li><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</li>\n<li><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</li>\n<li><strong>入门篇</strong>（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程<ul>\n<li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li>\n<li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li>\n<li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li>\n</ul>\n</li>\n<li><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程</li>\n<li><strong>API</strong>（Reference）：[可选] [目录|文件] 软件API的逐一介绍</li>\n<li><strong>FAQ</strong>：[可选] [文件] 常见问题解答</li>\n<li><strong>附录</strong>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容<ul>\n<li><strong>Glossary</strong>：[可选] [文件] 名词解释</li>\n<li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li>\n<li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li>\n<li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li>\n<li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li>\n</ul>\n</li>\n</ul>\n<p><strong>范例</strong></p>\n<ul>\n<li><a href=\"http://redux.js.org/index.html\">Redux 手册</a></li>\n<li><a href=\"http://flight-manual.atom.io/\">Atom 手册</a></li>\n</ul>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><blockquote>\n<p><a href=\"http://wenku.baidu.com/view/23cc1a6527d3240c8447efbf.html\">产品手册中文写作规范</a>, by 华为<br><a href=\"http://docs.daocloud.io/write-docs/format\">写作规范和格式规范</a>, by DaoCloud<br><a href=\"http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf\">技术写作技巧在日汉翻译中的应用</a>, by 刘方<br><a href=\"https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf\">简体中文规范指南</a>，by lengoo<br><a href=\"https://open.leancloud.cn/copywriting-style-guide.html\">文档风格指南</a>, by LeanCloud<br><a href=\"https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit\">豌豆荚文案风格指南</a>, by 豌豆荚<br><a href=\"https://github.com/sparanoid/chinese-copywriting-guidelines\">中文文案排版指北</a>，by sparanoid<br><a href=\"http://w3c.github.io/clreq/\">中文排版需求</a>，by W3C  </p>\n</blockquote>\n<hr>"},{"layout":"post","title":"linux-shadowsocks全局代理","date":"2017-01-25T00:38:00.000Z","_content":"\nwindows 直接下载 ss 终端，稍加设置即可完成全局代理，linux 用户如果需要让某个软件可以使用 ss 一般都需要连接端口才行。例如本地 ss 配置为：\n```\n\"server_port\":1800,\n\"local_port\":1080,\n```\n\n### 原理简述\n\n这边就相当于将本地的 127.0.0.1:1080 和 server_ip:1800 建立了连接关系。因此软件如果需要使用 vps 上面搭建的 ss 服务的话，则需要让该软件使用的协议连接到 127.0.0.1:1080 上。之前在 vps-shadowsocks 中介绍的 chrome 插件 SwitchyOmega 就是使用 SOCKS5 协议连接到 127.0.0.1:1080 上，让所有数据通过 SOCKS5 协议，然后从 127.0.0.1:1080 进行收发。\n\n可以看出如果我们需要让其他软件也能够使用 ss 则需要让他们也能够使用 127.0.0.1:1080 代理服务器，然而不幸的是，大多数软件并不支持代理服务的功能， windows 平台下的软件很多可以通过设置 IE 代理让其他软件使用代理服务（原理是：大多数软件都会优先读取 IE 的代理设置，再访问网络）。\n\n<!-- more -->\n\n### 安装步骤\n\nlinux 下有个软件： proxychains 解决了我们的所有问题，该软件可以通过 `sudo apt-get install proxychains` 下载安装，一般为 3.1 版本。当然也可以去下载安装[源码](https://github.com/rofl0r/proxychains-ng)，源码安装版本较新，需要自行编译安装，一般为 4.x 版本。\n\n### 配置\n\nman proxychains 我们可以看到 proxychains 读取的配置文件地址，这边我们自定义 ~/.proxychains/proxychains.conf 文件，写入如下内容：\n\n```\nins.conf  VER 3.1\n#\n#        HTTP, SOCKS4, SOCKS5 tunneling proxifier with DNS.\n#   \n\n# The option below identifies how the ProxyList is treated.\n# only one option should be uncommented at time,\n# otherwise the last appearing option will be accepted\n#\n#dynamic_chain\n#\n# Dynamic - Each connection will be done via chained proxies\n# all proxies chained in the order as they appear in the list\n# at least one proxy must be online to play in chain\n# (dead proxies are skipped)\n# otherwise EINTR is returned to the app\n#\nstrict_chain\n#\n# Strict - Each connection will be done via chained proxies\n# all proxies chained in the order as they appear in the list\n# all proxies must be online to play in chain\n# otherwise EINTR is returned to the app\n#\n#random_chain\n#\n# Random - Each connection will be done via random proxy\n# (or proxy chain, see  chain_len) from the list.\n# this option is good to test your IDS :)\n\n# Make sense only if random_chain\n#chain_len = 2\n\n# Quiet mode (no output from library)\n#quiet_mode\n\n# Proxy DNS requests - no leak for DNS data\nproxy_dns \n\n# Some timeouts in milliseconds\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\n\n# ProxyList format\n#       type  host  port [user pass]\n#       (values separated by 'tab' or 'blank')\n#\n#\n#        Examples:\n#\n#               socks5192.168.67.781080lamersecret\n#       http192.168.89.38080justuhidden\n#       socks4192.168.1.491080\n#           http192.168.39.938080\n#       \n#\n#       proxy types: http, socks4, socks5\n#        ( auth types supported: \"basic\"-http  \"user/pass\"-socks  )\n#\n[ProxyList]\n# add proxy here ...\n# meanwile\n# defaults set to \"tor\"\nsocks5 127.0.0.1 1080\n```\n\n### 使用\n\n- 输入 `proxychains curl www.google.com` 命令，我们可以看到提示内容，如果一直等待或者无法访问则代表设置失败。这是一种方法通过 proxychains + 命令。\n\n**这边值得注意的是使用 `proxychains curl www.google.com` 命令，博主一开始使用的是  `proxychains ping www.google.com` 一直无法 ping 通，也一致认为自己配置的有问题，后来才发现： ping 命令本身不调用 http ，socks5 等协议，ping也属于一个通信协议，是 TCP/IP 协议的一部分。而诸如：  http ，socks5，ssh 等都是基于 TCP/IP 或者 UPD 之上的协议，所以验证的时候一定要当心注意了使用其他调用 socks5 协议的软件才可以验证。**\n\n- 输入 `proxychains bash` 我们可以建立一个新的 shell 基于这个 shell 运行的所有命令和软件都会通过 `127.0.0.1:1080` 转发数据。\n\n**通过 proxychains 打开的软件，在使用时都会有详细的网络连接信息。**\n\n补充一个问题：如果使用时出现 `ERROR: ld.so: object 'libproxychains.so.3' from LD_PRELOAD cannot be preloaded: ignored.` 原因是无法找到 libproxychains.so.3 文件，可以通过 `find /usr/lib/ -name libproxychains.so.3` 找到具体路径，然后 `export LD_PRELOAD=你找到的路径` 。\n\n### 全局代理\n\n基于 `proxychains bash` 开启的所有软件都可以通过 ss 来访问外网，而这个 terminal 可以相当于是全局代理的，当然如果你需要设置整个系统都全局代理的话，应该也是可以修改 linux 下面的源码的，让密码认证通过后，启用的 login-bash 采用 proxychains 方式启用。这边未做详细研究，理论上可能可行。\n\n***\n\n*个人对网络研究很欠缺，如有错误还望指正。*\n\n\n\n\n> 参考链接：\n> http://www.tuicool.com/articles/rUNFF3\n> http://askubuntu.com/questions/293649/proxychains-ld-preload-cannot-be-preloaded\n> http://blog.csdn.net/yusiguyuan/article/details/24269129\n","source":"_posts/2017/2017-01-25-ss-linux全局代理.md","raw":"---\nlayout: \"post\"\ntitle: \"linux-shadowsocks全局代理\"\ndate: \"2017-01-25 08:38\"\n---\n\nwindows 直接下载 ss 终端，稍加设置即可完成全局代理，linux 用户如果需要让某个软件可以使用 ss 一般都需要连接端口才行。例如本地 ss 配置为：\n```\n\"server_port\":1800,\n\"local_port\":1080,\n```\n\n### 原理简述\n\n这边就相当于将本地的 127.0.0.1:1080 和 server_ip:1800 建立了连接关系。因此软件如果需要使用 vps 上面搭建的 ss 服务的话，则需要让该软件使用的协议连接到 127.0.0.1:1080 上。之前在 vps-shadowsocks 中介绍的 chrome 插件 SwitchyOmega 就是使用 SOCKS5 协议连接到 127.0.0.1:1080 上，让所有数据通过 SOCKS5 协议，然后从 127.0.0.1:1080 进行收发。\n\n可以看出如果我们需要让其他软件也能够使用 ss 则需要让他们也能够使用 127.0.0.1:1080 代理服务器，然而不幸的是，大多数软件并不支持代理服务的功能， windows 平台下的软件很多可以通过设置 IE 代理让其他软件使用代理服务（原理是：大多数软件都会优先读取 IE 的代理设置，再访问网络）。\n\n<!-- more -->\n\n### 安装步骤\n\nlinux 下有个软件： proxychains 解决了我们的所有问题，该软件可以通过 `sudo apt-get install proxychains` 下载安装，一般为 3.1 版本。当然也可以去下载安装[源码](https://github.com/rofl0r/proxychains-ng)，源码安装版本较新，需要自行编译安装，一般为 4.x 版本。\n\n### 配置\n\nman proxychains 我们可以看到 proxychains 读取的配置文件地址，这边我们自定义 ~/.proxychains/proxychains.conf 文件，写入如下内容：\n\n```\nins.conf  VER 3.1\n#\n#        HTTP, SOCKS4, SOCKS5 tunneling proxifier with DNS.\n#   \n\n# The option below identifies how the ProxyList is treated.\n# only one option should be uncommented at time,\n# otherwise the last appearing option will be accepted\n#\n#dynamic_chain\n#\n# Dynamic - Each connection will be done via chained proxies\n# all proxies chained in the order as they appear in the list\n# at least one proxy must be online to play in chain\n# (dead proxies are skipped)\n# otherwise EINTR is returned to the app\n#\nstrict_chain\n#\n# Strict - Each connection will be done via chained proxies\n# all proxies chained in the order as they appear in the list\n# all proxies must be online to play in chain\n# otherwise EINTR is returned to the app\n#\n#random_chain\n#\n# Random - Each connection will be done via random proxy\n# (or proxy chain, see  chain_len) from the list.\n# this option is good to test your IDS :)\n\n# Make sense only if random_chain\n#chain_len = 2\n\n# Quiet mode (no output from library)\n#quiet_mode\n\n# Proxy DNS requests - no leak for DNS data\nproxy_dns \n\n# Some timeouts in milliseconds\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\n\n# ProxyList format\n#       type  host  port [user pass]\n#       (values separated by 'tab' or 'blank')\n#\n#\n#        Examples:\n#\n#               socks5192.168.67.781080lamersecret\n#       http192.168.89.38080justuhidden\n#       socks4192.168.1.491080\n#           http192.168.39.938080\n#       \n#\n#       proxy types: http, socks4, socks5\n#        ( auth types supported: \"basic\"-http  \"user/pass\"-socks  )\n#\n[ProxyList]\n# add proxy here ...\n# meanwile\n# defaults set to \"tor\"\nsocks5 127.0.0.1 1080\n```\n\n### 使用\n\n- 输入 `proxychains curl www.google.com` 命令，我们可以看到提示内容，如果一直等待或者无法访问则代表设置失败。这是一种方法通过 proxychains + 命令。\n\n**这边值得注意的是使用 `proxychains curl www.google.com` 命令，博主一开始使用的是  `proxychains ping www.google.com` 一直无法 ping 通，也一致认为自己配置的有问题，后来才发现： ping 命令本身不调用 http ，socks5 等协议，ping也属于一个通信协议，是 TCP/IP 协议的一部分。而诸如：  http ，socks5，ssh 等都是基于 TCP/IP 或者 UPD 之上的协议，所以验证的时候一定要当心注意了使用其他调用 socks5 协议的软件才可以验证。**\n\n- 输入 `proxychains bash` 我们可以建立一个新的 shell 基于这个 shell 运行的所有命令和软件都会通过 `127.0.0.1:1080` 转发数据。\n\n**通过 proxychains 打开的软件，在使用时都会有详细的网络连接信息。**\n\n补充一个问题：如果使用时出现 `ERROR: ld.so: object 'libproxychains.so.3' from LD_PRELOAD cannot be preloaded: ignored.` 原因是无法找到 libproxychains.so.3 文件，可以通过 `find /usr/lib/ -name libproxychains.so.3` 找到具体路径，然后 `export LD_PRELOAD=你找到的路径` 。\n\n### 全局代理\n\n基于 `proxychains bash` 开启的所有软件都可以通过 ss 来访问外网，而这个 terminal 可以相当于是全局代理的，当然如果你需要设置整个系统都全局代理的话，应该也是可以修改 linux 下面的源码的，让密码认证通过后，启用的 login-bash 采用 proxychains 方式启用。这边未做详细研究，理论上可能可行。\n\n***\n\n*个人对网络研究很欠缺，如有错误还望指正。*\n\n\n\n\n> 参考链接：\n> http://www.tuicool.com/articles/rUNFF3\n> http://askubuntu.com/questions/293649/proxychains-ld-preload-cannot-be-preloaded\n> http://blog.csdn.net/yusiguyuan/article/details/24269129\n","slug":"2017/2017-01-25-ss-linux全局代理","published":1,"updated":"2017-01-25T03:06:43.366Z","comments":1,"photos":[],"link":"","_id":"ciyuv3afw0007mumuitdqkvcq","content":"<p>windows 直接下载 ss 终端，稍加设置即可完成全局代理，linux 用户如果需要让某个软件可以使用 ss 一般都需要连接端口才行。例如本地 ss 配置为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;server_port&quot;:1800,</div><div class=\"line\">&quot;local_port&quot;:1080,</div></pre></td></tr></table></figure></p>\n<h3 id=\"原理简述\"><a href=\"#原理简述\" class=\"headerlink\" title=\"原理简述\"></a>原理简述</h3><p>这边就相当于将本地的 127.0.0.1:1080 和 server_ip:1800 建立了连接关系。因此软件如果需要使用 vps 上面搭建的 ss 服务的话，则需要让该软件使用的协议连接到 127.0.0.1:1080 上。之前在 vps-shadowsocks 中介绍的 chrome 插件 SwitchyOmega 就是使用 SOCKS5 协议连接到 127.0.0.1:1080 上，让所有数据通过 SOCKS5 协议，然后从 127.0.0.1:1080 进行收发。</p>\n<p>可以看出如果我们需要让其他软件也能够使用 ss 则需要让他们也能够使用 127.0.0.1:1080 代理服务器，然而不幸的是，大多数软件并不支持代理服务的功能， windows 平台下的软件很多可以通过设置 IE 代理让其他软件使用代理服务（原理是：大多数软件都会优先读取 IE 的代理设置，再访问网络）。</p>\n<a id=\"more\"></a>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><p>linux 下有个软件： proxychains 解决了我们的所有问题，该软件可以通过 <code>sudo apt-get install proxychains</code> 下载安装，一般为 3.1 版本。当然也可以去下载安装<a href=\"https://github.com/rofl0r/proxychains-ng\" target=\"_blank\" rel=\"external\">源码</a>，源码安装版本较新，需要自行编译安装，一般为 4.x 版本。</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>man proxychains 我们可以看到 proxychains 读取的配置文件地址，这边我们自定义 ~/.proxychains/proxychains.conf 文件，写入如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">ins.conf  VER 3.1</div><div class=\"line\">#</div><div class=\"line\">#        HTTP, SOCKS4, SOCKS5 tunneling proxifier with DNS.</div><div class=\"line\">#   </div><div class=\"line\"></div><div class=\"line\"># The option below identifies how the ProxyList is treated.</div><div class=\"line\"># only one option should be uncommented at time,</div><div class=\"line\"># otherwise the last appearing option will be accepted</div><div class=\"line\">#</div><div class=\"line\">#dynamic_chain</div><div class=\"line\">#</div><div class=\"line\"># Dynamic - Each connection will be done via chained proxies</div><div class=\"line\"># all proxies chained in the order as they appear in the list</div><div class=\"line\"># at least one proxy must be online to play in chain</div><div class=\"line\"># (dead proxies are skipped)</div><div class=\"line\"># otherwise EINTR is returned to the app</div><div class=\"line\">#</div><div class=\"line\">strict_chain</div><div class=\"line\">#</div><div class=\"line\"># Strict - Each connection will be done via chained proxies</div><div class=\"line\"># all proxies chained in the order as they appear in the list</div><div class=\"line\"># all proxies must be online to play in chain</div><div class=\"line\"># otherwise EINTR is returned to the app</div><div class=\"line\">#</div><div class=\"line\">#random_chain</div><div class=\"line\">#</div><div class=\"line\"># Random - Each connection will be done via random proxy</div><div class=\"line\"># (or proxy chain, see  chain_len) from the list.</div><div class=\"line\"># this option is good to test your IDS :)</div><div class=\"line\"></div><div class=\"line\"># Make sense only if random_chain</div><div class=\"line\">#chain_len = 2</div><div class=\"line\"></div><div class=\"line\"># Quiet mode (no output from library)</div><div class=\"line\">#quiet_mode</div><div class=\"line\"></div><div class=\"line\"># Proxy DNS requests - no leak for DNS data</div><div class=\"line\">proxy_dns </div><div class=\"line\"></div><div class=\"line\"># Some timeouts in milliseconds</div><div class=\"line\">tcp_read_time_out 15000</div><div class=\"line\">tcp_connect_time_out 8000</div><div class=\"line\"></div><div class=\"line\"># ProxyList format</div><div class=\"line\">#       type  host  port [user pass]</div><div class=\"line\">#       (values separated by &apos;tab&apos; or &apos;blank&apos;)</div><div class=\"line\">#</div><div class=\"line\">#</div><div class=\"line\">#        Examples:</div><div class=\"line\">#</div><div class=\"line\">#               socks5192.168.67.781080lamersecret</div><div class=\"line\">#       http192.168.89.38080justuhidden</div><div class=\"line\">#       socks4192.168.1.491080</div><div class=\"line\">#           http192.168.39.938080</div><div class=\"line\">#       </div><div class=\"line\">#</div><div class=\"line\">#       proxy types: http, socks4, socks5</div><div class=\"line\">#        ( auth types supported: &quot;basic&quot;-http  &quot;user/pass&quot;-socks  )</div><div class=\"line\">#</div><div class=\"line\">[ProxyList]</div><div class=\"line\"># add proxy here ...</div><div class=\"line\"># meanwile</div><div class=\"line\"># defaults set to &quot;tor&quot;</div><div class=\"line\">socks5 127.0.0.1 1080</div></pre></td></tr></table></figure>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>输入 <code>proxychains curl www.google.com</code> 命令，我们可以看到提示内容，如果一直等待或者无法访问则代表设置失败。这是一种方法通过 proxychains + 命令。</li>\n</ul>\n<p><strong>这边值得注意的是使用 <code>proxychains curl www.google.com</code> 命令，博主一开始使用的是  <code>proxychains ping www.google.com</code> 一直无法 ping 通，也一致认为自己配置的有问题，后来才发现： ping 命令本身不调用 http ，socks5 等协议，ping也属于一个通信协议，是 TCP/IP 协议的一部分。而诸如：  http ，socks5，ssh 等都是基于 TCP/IP 或者 UPD 之上的协议，所以验证的时候一定要当心注意了使用其他调用 socks5 协议的软件才可以验证。</strong></p>\n<ul>\n<li>输入 <code>proxychains bash</code> 我们可以建立一个新的 shell 基于这个 shell 运行的所有命令和软件都会通过 <code>127.0.0.1:1080</code> 转发数据。</li>\n</ul>\n<p><strong>通过 proxychains 打开的软件，在使用时都会有详细的网络连接信息。</strong></p>\n<p>补充一个问题：如果使用时出现 <code>ERROR: ld.so: object &#39;libproxychains.so.3&#39; from LD_PRELOAD cannot be preloaded: ignored.</code> 原因是无法找到 libproxychains.so.3 文件，可以通过 <code>find /usr/lib/ -name libproxychains.so.3</code> 找到具体路径，然后 <code>export LD_PRELOAD=你找到的路径</code> 。</p>\n<h3 id=\"全局代理\"><a href=\"#全局代理\" class=\"headerlink\" title=\"全局代理\"></a>全局代理</h3><p>基于 <code>proxychains bash</code> 开启的所有软件都可以通过 ss 来访问外网，而这个 terminal 可以相当于是全局代理的，当然如果你需要设置整个系统都全局代理的话，应该也是可以修改 linux 下面的源码的，让密码认证通过后，启用的 login-bash 采用 proxychains 方式启用。这边未做详细研究，理论上可能可行。</p>\n<hr>\n<p><em>个人对网络研究很欠缺，如有错误还望指正。</em></p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.tuicool.com/articles/rUNFF3\" target=\"_blank\" rel=\"external\">http://www.tuicool.com/articles/rUNFF3</a><br><a href=\"http://askubuntu.com/questions/293649/proxychains-ld-preload-cannot-be-preloaded\" target=\"_blank\" rel=\"external\">http://askubuntu.com/questions/293649/proxychains-ld-preload-cannot-be-preloaded</a><br><a href=\"http://blog.csdn.net/yusiguyuan/article/details/24269129\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/yusiguyuan/article/details/24269129</a></p>\n</blockquote>\n","excerpt":"<p>windows 直接下载 ss 终端，稍加设置即可完成全局代理，linux 用户如果需要让某个软件可以使用 ss 一般都需要连接端口才行。例如本地 ss 配置为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;server_port&quot;:1800,</div><div class=\"line\">&quot;local_port&quot;:1080,</div></pre></td></tr></table></figure></p>\n<h3 id=\"原理简述\"><a href=\"#原理简述\" class=\"headerlink\" title=\"原理简述\"></a>原理简述</h3><p>这边就相当于将本地的 127.0.0.1:1080 和 server_ip:1800 建立了连接关系。因此软件如果需要使用 vps 上面搭建的 ss 服务的话，则需要让该软件使用的协议连接到 127.0.0.1:1080 上。之前在 vps-shadowsocks 中介绍的 chrome 插件 SwitchyOmega 就是使用 SOCKS5 协议连接到 127.0.0.1:1080 上，让所有数据通过 SOCKS5 协议，然后从 127.0.0.1:1080 进行收发。</p>\n<p>可以看出如果我们需要让其他软件也能够使用 ss 则需要让他们也能够使用 127.0.0.1:1080 代理服务器，然而不幸的是，大多数软件并不支持代理服务的功能， windows 平台下的软件很多可以通过设置 IE 代理让其他软件使用代理服务（原理是：大多数软件都会优先读取 IE 的代理设置，再访问网络）。</p>","more":"<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><p>linux 下有个软件： proxychains 解决了我们的所有问题，该软件可以通过 <code>sudo apt-get install proxychains</code> 下载安装，一般为 3.1 版本。当然也可以去下载安装<a href=\"https://github.com/rofl0r/proxychains-ng\">源码</a>，源码安装版本较新，需要自行编译安装，一般为 4.x 版本。</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>man proxychains 我们可以看到 proxychains 读取的配置文件地址，这边我们自定义 ~/.proxychains/proxychains.conf 文件，写入如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">ins.conf  VER 3.1</div><div class=\"line\">#</div><div class=\"line\">#        HTTP, SOCKS4, SOCKS5 tunneling proxifier with DNS.</div><div class=\"line\">#   </div><div class=\"line\"></div><div class=\"line\"># The option below identifies how the ProxyList is treated.</div><div class=\"line\"># only one option should be uncommented at time,</div><div class=\"line\"># otherwise the last appearing option will be accepted</div><div class=\"line\">#</div><div class=\"line\">#dynamic_chain</div><div class=\"line\">#</div><div class=\"line\"># Dynamic - Each connection will be done via chained proxies</div><div class=\"line\"># all proxies chained in the order as they appear in the list</div><div class=\"line\"># at least one proxy must be online to play in chain</div><div class=\"line\"># (dead proxies are skipped)</div><div class=\"line\"># otherwise EINTR is returned to the app</div><div class=\"line\">#</div><div class=\"line\">strict_chain</div><div class=\"line\">#</div><div class=\"line\"># Strict - Each connection will be done via chained proxies</div><div class=\"line\"># all proxies chained in the order as they appear in the list</div><div class=\"line\"># all proxies must be online to play in chain</div><div class=\"line\"># otherwise EINTR is returned to the app</div><div class=\"line\">#</div><div class=\"line\">#random_chain</div><div class=\"line\">#</div><div class=\"line\"># Random - Each connection will be done via random proxy</div><div class=\"line\"># (or proxy chain, see  chain_len) from the list.</div><div class=\"line\"># this option is good to test your IDS :)</div><div class=\"line\"></div><div class=\"line\"># Make sense only if random_chain</div><div class=\"line\">#chain_len = 2</div><div class=\"line\"></div><div class=\"line\"># Quiet mode (no output from library)</div><div class=\"line\">#quiet_mode</div><div class=\"line\"></div><div class=\"line\"># Proxy DNS requests - no leak for DNS data</div><div class=\"line\">proxy_dns </div><div class=\"line\"></div><div class=\"line\"># Some timeouts in milliseconds</div><div class=\"line\">tcp_read_time_out 15000</div><div class=\"line\">tcp_connect_time_out 8000</div><div class=\"line\"></div><div class=\"line\"># ProxyList format</div><div class=\"line\">#       type  host  port [user pass]</div><div class=\"line\">#       (values separated by &apos;tab&apos; or &apos;blank&apos;)</div><div class=\"line\">#</div><div class=\"line\">#</div><div class=\"line\">#        Examples:</div><div class=\"line\">#</div><div class=\"line\">#               socks5192.168.67.781080lamersecret</div><div class=\"line\">#       http192.168.89.38080justuhidden</div><div class=\"line\">#       socks4192.168.1.491080</div><div class=\"line\">#           http192.168.39.938080</div><div class=\"line\">#       </div><div class=\"line\">#</div><div class=\"line\">#       proxy types: http, socks4, socks5</div><div class=\"line\">#        ( auth types supported: &quot;basic&quot;-http  &quot;user/pass&quot;-socks  )</div><div class=\"line\">#</div><div class=\"line\">[ProxyList]</div><div class=\"line\"># add proxy here ...</div><div class=\"line\"># meanwile</div><div class=\"line\"># defaults set to &quot;tor&quot;</div><div class=\"line\">socks5 127.0.0.1 1080</div></pre></td></tr></table></figure>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>输入 <code>proxychains curl www.google.com</code> 命令，我们可以看到提示内容，如果一直等待或者无法访问则代表设置失败。这是一种方法通过 proxychains + 命令。</li>\n</ul>\n<p><strong>这边值得注意的是使用 <code>proxychains curl www.google.com</code> 命令，博主一开始使用的是  <code>proxychains ping www.google.com</code> 一直无法 ping 通，也一致认为自己配置的有问题，后来才发现： ping 命令本身不调用 http ，socks5 等协议，ping也属于一个通信协议，是 TCP/IP 协议的一部分。而诸如：  http ，socks5，ssh 等都是基于 TCP/IP 或者 UPD 之上的协议，所以验证的时候一定要当心注意了使用其他调用 socks5 协议的软件才可以验证。</strong></p>\n<ul>\n<li>输入 <code>proxychains bash</code> 我们可以建立一个新的 shell 基于这个 shell 运行的所有命令和软件都会通过 <code>127.0.0.1:1080</code> 转发数据。</li>\n</ul>\n<p><strong>通过 proxychains 打开的软件，在使用时都会有详细的网络连接信息。</strong></p>\n<p>补充一个问题：如果使用时出现 <code>ERROR: ld.so: object &#39;libproxychains.so.3&#39; from LD_PRELOAD cannot be preloaded: ignored.</code> 原因是无法找到 libproxychains.so.3 文件，可以通过 <code>find /usr/lib/ -name libproxychains.so.3</code> 找到具体路径，然后 <code>export LD_PRELOAD=你找到的路径</code> 。</p>\n<h3 id=\"全局代理\"><a href=\"#全局代理\" class=\"headerlink\" title=\"全局代理\"></a>全局代理</h3><p>基于 <code>proxychains bash</code> 开启的所有软件都可以通过 ss 来访问外网，而这个 terminal 可以相当于是全局代理的，当然如果你需要设置整个系统都全局代理的话，应该也是可以修改 linux 下面的源码的，让密码认证通过后，启用的 login-bash 采用 proxychains 方式启用。这边未做详细研究，理论上可能可行。</p>\n<hr>\n<p><em>个人对网络研究很欠缺，如有错误还望指正。</em></p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.tuicool.com/articles/rUNFF3\">http://www.tuicool.com/articles/rUNFF3</a><br><a href=\"http://askubuntu.com/questions/293649/proxychains-ld-preload-cannot-be-preloaded\">http://askubuntu.com/questions/293649/proxychains-ld-preload-cannot-be-preloaded</a><br><a href=\"http://blog.csdn.net/yusiguyuan/article/details/24269129\">http://blog.csdn.net/yusiguyuan/article/details/24269129</a></p>\n</blockquote>"},{"layout":"post","title":"ubuntu下安装remarkable","date":"2016-06-23T04:12:00.000Z","_content":"\n### 界面展示\n\n![358bcf75911e433aed0abba8ff61ee2b.png](http://tc.ffsky.net/images/2016/07/01/358bcf75911e433aed0abba8ff61ee2b.png)\n\n### 下载安装\n安装环境位ubuntu 16.04(64位)，markdown的网站无法正确的下载软件。\n\n<!-- more -->\n\n> 附上其他下载地址：http://download.csdn.net/detail/ruanxingzhi/9402933\n\n1. 下载的deb文件\n\n2. 使用dpkg -i remarkable**.deb 命令安装\n\n3. 安装过程出现缺失错误，使用sudo apt-get install -f 修复依赖关系，最终软件能够正确安装\n\n4. 如果出现了步骤3的情况，则重新执行步骤2\n\n5. 新版ubuntu系统出现错误：\n\n> `GLib.Error: gtk-builder-error-quark: /usr/share/remarkable/ui/RemarkableWindow.ui:835:58 Object with ID  not found (13)`\n\n* 编辑 /usr/share/remarkable/ui/RemarkableWindow.ui将834~842之间的代码注释掉即可以解决问题：\n\n```sh\n<!--\n                <child>\n                  <object class=\"GtkMenuItem\" id=\"mnu_about\">\n                    <property name=\"related_action\"/>\n                    <property name=\"visible\">True</property>\n                    <property name=\"can_focus\">False</property>\n                    <property name=\"label\" translatable=\"yes\">About</property>\n                    <property name=\"use_underline\">True</property>\n                  </object>\n                </child>\n-->\n```\n\n### 总结：\n- 安装软件显得较为简单，主要是出错之后的解决方法，因为软件较为小众，国内只能搜到两篇外文译稿，出错后也只能通过谷歌去一个个尝试解决办法。\n- 该软件虽然较为轻巧，启动速度快，基本功能有，但个人仍然选择了atom（github提供的一款软件）作为markdown的常用书写环境，另外linux下也推荐可以使用chrome下的马克飞象插件或者直接使用`https://maxiang.io/`在线编辑。当然如果是vim高手，这些软件都没有必要。\n\n***\n\n\n>#### 参考网址：  \nhttps://github.com/remarkableapp/Remarkable-Linux/issues/14  \nhttps://linux.cn/article-3741-1.html#comment  \n","source":"_posts/2016/2016-06-23-remarkable-install.md","raw":"---\nlayout: post\ncategory: \"read\"\ntitle:  ubuntu下安装remarkable\ntags:   软件安装\ndate: \"2016-06-23 12:12\"\n---\n\n### 界面展示\n\n![358bcf75911e433aed0abba8ff61ee2b.png](http://tc.ffsky.net/images/2016/07/01/358bcf75911e433aed0abba8ff61ee2b.png)\n\n### 下载安装\n安装环境位ubuntu 16.04(64位)，markdown的网站无法正确的下载软件。\n\n<!-- more -->\n\n> 附上其他下载地址：http://download.csdn.net/detail/ruanxingzhi/9402933\n\n1. 下载的deb文件\n\n2. 使用dpkg -i remarkable**.deb 命令安装\n\n3. 安装过程出现缺失错误，使用sudo apt-get install -f 修复依赖关系，最终软件能够正确安装\n\n4. 如果出现了步骤3的情况，则重新执行步骤2\n\n5. 新版ubuntu系统出现错误：\n\n> `GLib.Error: gtk-builder-error-quark: /usr/share/remarkable/ui/RemarkableWindow.ui:835:58 Object with ID  not found (13)`\n\n* 编辑 /usr/share/remarkable/ui/RemarkableWindow.ui将834~842之间的代码注释掉即可以解决问题：\n\n```sh\n<!--\n                <child>\n                  <object class=\"GtkMenuItem\" id=\"mnu_about\">\n                    <property name=\"related_action\"/>\n                    <property name=\"visible\">True</property>\n                    <property name=\"can_focus\">False</property>\n                    <property name=\"label\" translatable=\"yes\">About</property>\n                    <property name=\"use_underline\">True</property>\n                  </object>\n                </child>\n-->\n```\n\n### 总结：\n- 安装软件显得较为简单，主要是出错之后的解决方法，因为软件较为小众，国内只能搜到两篇外文译稿，出错后也只能通过谷歌去一个个尝试解决办法。\n- 该软件虽然较为轻巧，启动速度快，基本功能有，但个人仍然选择了atom（github提供的一款软件）作为markdown的常用书写环境，另外linux下也推荐可以使用chrome下的马克飞象插件或者直接使用`https://maxiang.io/`在线编辑。当然如果是vim高手，这些软件都没有必要。\n\n***\n\n\n>#### 参考网址：  \nhttps://github.com/remarkableapp/Remarkable-Linux/issues/14  \nhttps://linux.cn/article-3741-1.html#comment  \n","slug":"2016/2016-06-23-remarkable-install","published":1,"updated":"2016-12-16T01:11:45.554Z","comments":1,"photos":[],"link":"","_id":"ciyuv3afy0008mumuwe6o0u0x","content":"<h3 id=\"界面展示\"><a href=\"#界面展示\" class=\"headerlink\" title=\"界面展示\"></a>界面展示</h3><p><img src=\"http://tc.ffsky.net/images/2016/07/01/358bcf75911e433aed0abba8ff61ee2b.png\" alt=\"358bcf75911e433aed0abba8ff61ee2b.png\"></p>\n<h3 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h3><p>安装环境位ubuntu 16.04(64位)，markdown的网站无法正确的下载软件。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>附上其他下载地址：<a href=\"http://download.csdn.net/detail/ruanxingzhi/9402933\" target=\"_blank\" rel=\"external\">http://download.csdn.net/detail/ruanxingzhi/9402933</a></p>\n</blockquote>\n<ol>\n<li><p>下载的deb文件</p>\n</li>\n<li><p>使用dpkg -i remarkable**.deb 命令安装</p>\n</li>\n<li><p>安装过程出现缺失错误，使用sudo apt-get install -f 修复依赖关系，最终软件能够正确安装</p>\n</li>\n<li><p>如果出现了步骤3的情况，则重新执行步骤2</p>\n</li>\n<li><p>新版ubuntu系统出现错误：</p>\n</li>\n</ol>\n<blockquote>\n<p><code>GLib.Error: gtk-builder-error-quark: /usr/share/remarkable/ui/RemarkableWindow.ui:835:58 Object with ID  not found (13)</code></p>\n</blockquote>\n<ul>\n<li>编辑 /usr/share/remarkable/ui/RemarkableWindow.ui将834~842之间的代码注释掉即可以解决问题：</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!--</div><div class=\"line\">                &lt;child&gt;</div><div class=\"line\">                  &lt;object class=<span class=\"string\">\"GtkMenuItem\"</span> id=<span class=\"string\">\"mnu_about\"</span>&gt;</div><div class=\"line\">                    &lt;property name=<span class=\"string\">\"related_action\"</span>/&gt;</div><div class=\"line\">                    &lt;property name=<span class=\"string\">\"visible\"</span>&gt;True&lt;/property&gt;</div><div class=\"line\">                    &lt;property name=<span class=\"string\">\"can_focus\"</span>&gt;False&lt;/property&gt;</div><div class=\"line\">                    &lt;property name=<span class=\"string\">\"label\"</span> translatable=<span class=\"string\">\"yes\"</span>&gt;About&lt;/property&gt;</div><div class=\"line\">                    &lt;property name=<span class=\"string\">\"use_underline\"</span>&gt;True&lt;/property&gt;</div><div class=\"line\">                  &lt;/object&gt;</div><div class=\"line\">                &lt;/child&gt;</div><div class=\"line\">--&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><ul>\n<li>安装软件显得较为简单，主要是出错之后的解决方法，因为软件较为小众，国内只能搜到两篇外文译稿，出错后也只能通过谷歌去一个个尝试解决办法。</li>\n<li>该软件虽然较为轻巧，启动速度快，基本功能有，但个人仍然选择了atom（github提供的一款软件）作为markdown的常用书写环境，另外linux下也推荐可以使用chrome下的马克飞象插件或者直接使用<code>https://maxiang.io/</code>在线编辑。当然如果是vim高手，这些软件都没有必要。</li>\n</ul>\n<hr>\n<blockquote>\n<h4 id=\"参考网址：\"><a href=\"#参考网址：\" class=\"headerlink\" title=\"参考网址：\"></a>参考网址：</h4><p><a href=\"https://github.com/remarkableapp/Remarkable-Linux/issues/14\" target=\"_blank\" rel=\"external\">https://github.com/remarkableapp/Remarkable-Linux/issues/14</a><br><a href=\"https://linux.cn/article-3741-1.html#comment\" target=\"_blank\" rel=\"external\">https://linux.cn/article-3741-1.html#comment</a>  </p>\n</blockquote>\n","excerpt":"<h3 id=\"界面展示\"><a href=\"#界面展示\" class=\"headerlink\" title=\"界面展示\"></a>界面展示</h3><p><img src=\"http://tc.ffsky.net/images/2016/07/01/358bcf75911e433aed0abba8ff61ee2b.png\" alt=\"358bcf75911e433aed0abba8ff61ee2b.png\"></p>\n<h3 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h3><p>安装环境位ubuntu 16.04(64位)，markdown的网站无法正确的下载软件。</p>","more":"<blockquote>\n<p>附上其他下载地址：<a href=\"http://download.csdn.net/detail/ruanxingzhi/9402933\">http://download.csdn.net/detail/ruanxingzhi/9402933</a></p>\n</blockquote>\n<ol>\n<li><p>下载的deb文件</p>\n</li>\n<li><p>使用dpkg -i remarkable**.deb 命令安装</p>\n</li>\n<li><p>安装过程出现缺失错误，使用sudo apt-get install -f 修复依赖关系，最终软件能够正确安装</p>\n</li>\n<li><p>如果出现了步骤3的情况，则重新执行步骤2</p>\n</li>\n<li><p>新版ubuntu系统出现错误：</p>\n</li>\n</ol>\n<blockquote>\n<p><code>GLib.Error: gtk-builder-error-quark: /usr/share/remarkable/ui/RemarkableWindow.ui:835:58 Object with ID  not found (13)</code></p>\n</blockquote>\n<ul>\n<li>编辑 /usr/share/remarkable/ui/RemarkableWindow.ui将834~842之间的代码注释掉即可以解决问题：</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!--</div><div class=\"line\">                &lt;child&gt;</div><div class=\"line\">                  &lt;object class=<span class=\"string\">\"GtkMenuItem\"</span> id=<span class=\"string\">\"mnu_about\"</span>&gt;</div><div class=\"line\">                    &lt;property name=<span class=\"string\">\"related_action\"</span>/&gt;</div><div class=\"line\">                    &lt;property name=<span class=\"string\">\"visible\"</span>&gt;True&lt;/property&gt;</div><div class=\"line\">                    &lt;property name=<span class=\"string\">\"can_focus\"</span>&gt;False&lt;/property&gt;</div><div class=\"line\">                    &lt;property name=<span class=\"string\">\"label\"</span> translatable=<span class=\"string\">\"yes\"</span>&gt;About&lt;/property&gt;</div><div class=\"line\">                    &lt;property name=<span class=\"string\">\"use_underline\"</span>&gt;True&lt;/property&gt;</div><div class=\"line\">                  &lt;/object&gt;</div><div class=\"line\">                &lt;/child&gt;</div><div class=\"line\">--&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><ul>\n<li>安装软件显得较为简单，主要是出错之后的解决方法，因为软件较为小众，国内只能搜到两篇外文译稿，出错后也只能通过谷歌去一个个尝试解决办法。</li>\n<li>该软件虽然较为轻巧，启动速度快，基本功能有，但个人仍然选择了atom（github提供的一款软件）作为markdown的常用书写环境，另外linux下也推荐可以使用chrome下的马克飞象插件或者直接使用<code>https://maxiang.io/</code>在线编辑。当然如果是vim高手，这些软件都没有必要。</li>\n</ul>\n<hr>\n<blockquote>\n<h4 id=\"参考网址：\"><a href=\"#参考网址：\" class=\"headerlink\" title=\"参考网址：\"></a>参考网址：</h4><p><a href=\"https://github.com/remarkableapp/Remarkable-Linux/issues/14\">https://github.com/remarkableapp/Remarkable-Linux/issues/14</a><br><a href=\"https://linux.cn/article-3741-1.html#comment\">https://linux.cn/article-3741-1.html#comment</a>  </p>\n</blockquote>"},{"layout":"post","title":"关于英国的独立日","date":"2016-06-27T04:12:00.000Z","_content":"\n\n\n> 6.24日英国通过公投，最终确认脱离欧盟。\n>\n> http://money.sohu.com/20160620/n455207391.shtml\n\n\n### 英国和欧盟多年的友谊最终到了尽头\n\n不得不让人唏嘘，数十年的结盟，说散就散了，也许很多人英国人自己都难以相信这以现实。而如果要说英国与欧盟的矛盾，主要也是：\n- 英国自身条件优越，几个有钱的大哥后面跟了一群要钱的小弟，试想谁都不愿意。\n- 欧盟这些年变得越来越大，不仅变得臃肿了，而且想要扩张自己的权利，很可能是想真正建立集权。\n- 无非是难民问题，某些地区经过美国的打击，以及欧盟的被忽悠跟在后面起哄，最终越来越动荡，也使得难民潮不绝。\n\n虽说如此，另一方面英国通过欧盟也实实在在获得了很多好处，有些东西，一旦拥有了，就再也无法摆脱，英国大概也是如此，因为欧盟，伦敦成了世界的经济中心，也因为欧盟，英国有将近一半的公司来自于欧洲各国。英国的繁荣昌盛很大一部分程度是来自于其他各国对它的输入的，其实这和中国的上海并没有多大的区别，一个底子好地理位置好的地方可以成为经济贸易的中心，但这种荣耀并非属于你一个人的。英国认为要不断的去救济其他国家，拖累了自己，这看起来多么滑稽可笑，试想如果没有其他国家的支持，又怎么会有你今天的繁华呢？！就经济发展而言，英国离开欧盟可以相当于自断臂膀，相信未来很长一段时间，英国经济发展都在难有起色。与欧盟相比，所谓的英联邦，从过去到现在又真的有给英国经济带来过什么吗？\n\n事实上欧洲也有很多国家发展的不错，也没有加入欧盟。很多人认为脱欧并代表不了什么。这就好比，如果你从来没有拥有过，你就也不会在乎你失去了什么。中国现在改革开放了，但如果说现在再次闭关锁国，在回到改革开放前，老百姓会受得了吗？！\n\n> http://news.163.com/16/0627/01/BQHGTUAS00014JB6.html?bdsj\n\n<!-- more -->\n\n### 英国人请愿二次公投\n\n英国数百位万人请愿二次公投，很多人觉得是一个滑稽可笑的事情，但却细思极恐。公投象征了什么？无意象征了人民群众掌权，权力来自于人民的象征，人民决定国家命运的象征。一直以来，很多中国人也都羡慕美国投票选总统，但事实真的如此吗？英国作为金百年最发达的国家，人民群众的文化教育生活水平，不所谓不高吧？但仍然很多人将投票作为儿戏，很多人投票结束后采取谷歌搜索什么是欧盟？脱欧意味着什么？不得不说，卡梅隆真是相信自己的人民，而事实上历来都是：真理掌握在少数人手中，只有10%的人去统治90%的人的命运。将命运作为儿戏，权力不知道利用的人哪儿都用，中外也并没有区别。民众的倾向，一般也只会考虑到自己，什么对自己不好，往往最让他们印象深刻，所以看到难民影响他们生活了，就会有许多人投票要脱欧，却没有去想过，脱欧后谁来给他们供给廉价又可口的早餐，谁来为一些受理给欧盟的专利版权买单？\n\n试想，如果中国人也拥有了公投，自己决定国家命运的权力！那会是什么样的乱象？！\n","source":"_posts/2016/2016-06-27-关于英国的独立日.md","raw":"---\nlayout: post\ncategory: \"杂记\"\ntitle:  关于英国的独立日\ntags:   杂记\ndate: \"2016-06-27 12:12\"\n---\n\n\n\n> 6.24日英国通过公投，最终确认脱离欧盟。\n>\n> http://money.sohu.com/20160620/n455207391.shtml\n\n\n### 英国和欧盟多年的友谊最终到了尽头\n\n不得不让人唏嘘，数十年的结盟，说散就散了，也许很多人英国人自己都难以相信这以现实。而如果要说英国与欧盟的矛盾，主要也是：\n- 英国自身条件优越，几个有钱的大哥后面跟了一群要钱的小弟，试想谁都不愿意。\n- 欧盟这些年变得越来越大，不仅变得臃肿了，而且想要扩张自己的权利，很可能是想真正建立集权。\n- 无非是难民问题，某些地区经过美国的打击，以及欧盟的被忽悠跟在后面起哄，最终越来越动荡，也使得难民潮不绝。\n\n虽说如此，另一方面英国通过欧盟也实实在在获得了很多好处，有些东西，一旦拥有了，就再也无法摆脱，英国大概也是如此，因为欧盟，伦敦成了世界的经济中心，也因为欧盟，英国有将近一半的公司来自于欧洲各国。英国的繁荣昌盛很大一部分程度是来自于其他各国对它的输入的，其实这和中国的上海并没有多大的区别，一个底子好地理位置好的地方可以成为经济贸易的中心，但这种荣耀并非属于你一个人的。英国认为要不断的去救济其他国家，拖累了自己，这看起来多么滑稽可笑，试想如果没有其他国家的支持，又怎么会有你今天的繁华呢？！就经济发展而言，英国离开欧盟可以相当于自断臂膀，相信未来很长一段时间，英国经济发展都在难有起色。与欧盟相比，所谓的英联邦，从过去到现在又真的有给英国经济带来过什么吗？\n\n事实上欧洲也有很多国家发展的不错，也没有加入欧盟。很多人认为脱欧并代表不了什么。这就好比，如果你从来没有拥有过，你就也不会在乎你失去了什么。中国现在改革开放了，但如果说现在再次闭关锁国，在回到改革开放前，老百姓会受得了吗？！\n\n> http://news.163.com/16/0627/01/BQHGTUAS00014JB6.html?bdsj\n\n<!-- more -->\n\n### 英国人请愿二次公投\n\n英国数百位万人请愿二次公投，很多人觉得是一个滑稽可笑的事情，但却细思极恐。公投象征了什么？无意象征了人民群众掌权，权力来自于人民的象征，人民决定国家命运的象征。一直以来，很多中国人也都羡慕美国投票选总统，但事实真的如此吗？英国作为金百年最发达的国家，人民群众的文化教育生活水平，不所谓不高吧？但仍然很多人将投票作为儿戏，很多人投票结束后采取谷歌搜索什么是欧盟？脱欧意味着什么？不得不说，卡梅隆真是相信自己的人民，而事实上历来都是：真理掌握在少数人手中，只有10%的人去统治90%的人的命运。将命运作为儿戏，权力不知道利用的人哪儿都用，中外也并没有区别。民众的倾向，一般也只会考虑到自己，什么对自己不好，往往最让他们印象深刻，所以看到难民影响他们生活了，就会有许多人投票要脱欧，却没有去想过，脱欧后谁来给他们供给廉价又可口的早餐，谁来为一些受理给欧盟的专利版权买单？\n\n试想，如果中国人也拥有了公投，自己决定国家命运的权力！那会是什么样的乱象？！\n","slug":"2016/2016-06-27-关于英国的独立日","published":1,"updated":"2016-12-16T01:11:53.550Z","comments":1,"photos":[],"link":"","_id":"ciyuv3afz0009mumuvg71y1mc","content":"<blockquote>\n<p>6.24日英国通过公投，最终确认脱离欧盟。</p>\n<p><a href=\"http://money.sohu.com/20160620/n455207391.shtml\" target=\"_blank\" rel=\"external\">http://money.sohu.com/20160620/n455207391.shtml</a></p>\n</blockquote>\n<h3 id=\"英国和欧盟多年的友谊最终到了尽头\"><a href=\"#英国和欧盟多年的友谊最终到了尽头\" class=\"headerlink\" title=\"英国和欧盟多年的友谊最终到了尽头\"></a>英国和欧盟多年的友谊最终到了尽头</h3><p>不得不让人唏嘘，数十年的结盟，说散就散了，也许很多人英国人自己都难以相信这以现实。而如果要说英国与欧盟的矛盾，主要也是：</p>\n<ul>\n<li>英国自身条件优越，几个有钱的大哥后面跟了一群要钱的小弟，试想谁都不愿意。</li>\n<li>欧盟这些年变得越来越大，不仅变得臃肿了，而且想要扩张自己的权利，很可能是想真正建立集权。</li>\n<li>无非是难民问题，某些地区经过美国的打击，以及欧盟的被忽悠跟在后面起哄，最终越来越动荡，也使得难民潮不绝。</li>\n</ul>\n<p>虽说如此，另一方面英国通过欧盟也实实在在获得了很多好处，有些东西，一旦拥有了，就再也无法摆脱，英国大概也是如此，因为欧盟，伦敦成了世界的经济中心，也因为欧盟，英国有将近一半的公司来自于欧洲各国。英国的繁荣昌盛很大一部分程度是来自于其他各国对它的输入的，其实这和中国的上海并没有多大的区别，一个底子好地理位置好的地方可以成为经济贸易的中心，但这种荣耀并非属于你一个人的。英国认为要不断的去救济其他国家，拖累了自己，这看起来多么滑稽可笑，试想如果没有其他国家的支持，又怎么会有你今天的繁华呢？！就经济发展而言，英国离开欧盟可以相当于自断臂膀，相信未来很长一段时间，英国经济发展都在难有起色。与欧盟相比，所谓的英联邦，从过去到现在又真的有给英国经济带来过什么吗？</p>\n<p>事实上欧洲也有很多国家发展的不错，也没有加入欧盟。很多人认为脱欧并代表不了什么。这就好比，如果你从来没有拥有过，你就也不会在乎你失去了什么。中国现在改革开放了，但如果说现在再次闭关锁国，在回到改革开放前，老百姓会受得了吗？！</p>\n<blockquote>\n<p><a href=\"http://news.163.com/16/0627/01/BQHGTUAS00014JB6.html?bdsj\" target=\"_blank\" rel=\"external\">http://news.163.com/16/0627/01/BQHGTUAS00014JB6.html?bdsj</a></p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"英国人请愿二次公投\"><a href=\"#英国人请愿二次公投\" class=\"headerlink\" title=\"英国人请愿二次公投\"></a>英国人请愿二次公投</h3><p>英国数百位万人请愿二次公投，很多人觉得是一个滑稽可笑的事情，但却细思极恐。公投象征了什么？无意象征了人民群众掌权，权力来自于人民的象征，人民决定国家命运的象征。一直以来，很多中国人也都羡慕美国投票选总统，但事实真的如此吗？英国作为金百年最发达的国家，人民群众的文化教育生活水平，不所谓不高吧？但仍然很多人将投票作为儿戏，很多人投票结束后采取谷歌搜索什么是欧盟？脱欧意味着什么？不得不说，卡梅隆真是相信自己的人民，而事实上历来都是：真理掌握在少数人手中，只有10%的人去统治90%的人的命运。将命运作为儿戏，权力不知道利用的人哪儿都用，中外也并没有区别。民众的倾向，一般也只会考虑到自己，什么对自己不好，往往最让他们印象深刻，所以看到难民影响他们生活了，就会有许多人投票要脱欧，却没有去想过，脱欧后谁来给他们供给廉价又可口的早餐，谁来为一些受理给欧盟的专利版权买单？</p>\n<p>试想，如果中国人也拥有了公投，自己决定国家命运的权力！那会是什么样的乱象？！</p>\n","excerpt":"<blockquote>\n<p>6.24日英国通过公投，最终确认脱离欧盟。</p>\n<p><a href=\"http://money.sohu.com/20160620/n455207391.shtml\">http://money.sohu.com/20160620/n455207391.shtml</a></p>\n</blockquote>\n<h3 id=\"英国和欧盟多年的友谊最终到了尽头\"><a href=\"#英国和欧盟多年的友谊最终到了尽头\" class=\"headerlink\" title=\"英国和欧盟多年的友谊最终到了尽头\"></a>英国和欧盟多年的友谊最终到了尽头</h3><p>不得不让人唏嘘，数十年的结盟，说散就散了，也许很多人英国人自己都难以相信这以现实。而如果要说英国与欧盟的矛盾，主要也是：</p>\n<ul>\n<li>英国自身条件优越，几个有钱的大哥后面跟了一群要钱的小弟，试想谁都不愿意。</li>\n<li>欧盟这些年变得越来越大，不仅变得臃肿了，而且想要扩张自己的权利，很可能是想真正建立集权。</li>\n<li>无非是难民问题，某些地区经过美国的打击，以及欧盟的被忽悠跟在后面起哄，最终越来越动荡，也使得难民潮不绝。</li>\n</ul>\n<p>虽说如此，另一方面英国通过欧盟也实实在在获得了很多好处，有些东西，一旦拥有了，就再也无法摆脱，英国大概也是如此，因为欧盟，伦敦成了世界的经济中心，也因为欧盟，英国有将近一半的公司来自于欧洲各国。英国的繁荣昌盛很大一部分程度是来自于其他各国对它的输入的，其实这和中国的上海并没有多大的区别，一个底子好地理位置好的地方可以成为经济贸易的中心，但这种荣耀并非属于你一个人的。英国认为要不断的去救济其他国家，拖累了自己，这看起来多么滑稽可笑，试想如果没有其他国家的支持，又怎么会有你今天的繁华呢？！就经济发展而言，英国离开欧盟可以相当于自断臂膀，相信未来很长一段时间，英国经济发展都在难有起色。与欧盟相比，所谓的英联邦，从过去到现在又真的有给英国经济带来过什么吗？</p>\n<p>事实上欧洲也有很多国家发展的不错，也没有加入欧盟。很多人认为脱欧并代表不了什么。这就好比，如果你从来没有拥有过，你就也不会在乎你失去了什么。中国现在改革开放了，但如果说现在再次闭关锁国，在回到改革开放前，老百姓会受得了吗？！</p>\n<blockquote>\n<p><a href=\"http://news.163.com/16/0627/01/BQHGTUAS00014JB6.html?bdsj\">http://news.163.com/16/0627/01/BQHGTUAS00014JB6.html?bdsj</a></p>\n</blockquote>","more":"<h3 id=\"英国人请愿二次公投\"><a href=\"#英国人请愿二次公投\" class=\"headerlink\" title=\"英国人请愿二次公投\"></a>英国人请愿二次公投</h3><p>英国数百位万人请愿二次公投，很多人觉得是一个滑稽可笑的事情，但却细思极恐。公投象征了什么？无意象征了人民群众掌权，权力来自于人民的象征，人民决定国家命运的象征。一直以来，很多中国人也都羡慕美国投票选总统，但事实真的如此吗？英国作为金百年最发达的国家，人民群众的文化教育生活水平，不所谓不高吧？但仍然很多人将投票作为儿戏，很多人投票结束后采取谷歌搜索什么是欧盟？脱欧意味着什么？不得不说，卡梅隆真是相信自己的人民，而事实上历来都是：真理掌握在少数人手中，只有10%的人去统治90%的人的命运。将命运作为儿戏，权力不知道利用的人哪儿都用，中外也并没有区别。民众的倾向，一般也只会考虑到自己，什么对自己不好，往往最让他们印象深刻，所以看到难民影响他们生活了，就会有许多人投票要脱欧，却没有去想过，脱欧后谁来给他们供给廉价又可口的早餐，谁来为一些受理给欧盟的专利版权买单？</p>\n<p>试想，如果中国人也拥有了公投，自己决定国家命运的权力！那会是什么样的乱象？！</p>"},{"layout":"post","title":"linux下ssh通过VPN推送失败","date":"2016-06-28T04:12:00.000Z","_content":"\n本文主要用于解决 VPN 和 SSH 两者冲突不兼容的问题。\n\n\n### VPN\n\n虚拟专用网络的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN有多种分类方式，主要是按协议进行分类。VPN可通过服务器、硬件、软件等多种方式实现。\n\nVPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。让外地员工访问到内网资源，利用VPN的解决方法就是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网。为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了VPN技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用VPN访问内网资源，这就是VPN在企业中应用得如此广泛的原因。\n\nVPN的协议分类主要有三种，PPTP、L2TP和IPSec，其中PPTP和L2TP协议工作在OSI模型的第二层，又称为二层隧道协议；IPSec是第三层隧道协议。\n\n### SSH\n\nSSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。windows 通过安装 putty等软件可以帮助安装 ssh 协议。\n\n<!-- more -->\n\n### 在VPN下使用SSH服务\n\n#### github使用ssh协议：#\n\n- 我们可以本地推送而免输入账户名密码，这里不作为本文重点，相关网址教程如下：\n\n  > http://playingfingers.com/2016/03/26/build-a-blog/\n  > http://beiyuu.com/github-pages\n  > http://www.cnblogs.com/ayseeing/p/3572582.html\n  > http://blog.csdn.net/renfufei/article/details/37725057/\n\n\n#### SSH无法推送: #\n\n- 当一切操作就绪后，会偶然出现无法通过SSH推送：\n\n  > 等待很长时间后，显示超时！\n\n#### 原理及方案： #\n\n- **通过排查发现主要是由于链接的VPN引起的，SSH协议和VPN本身存在不兼容，要想解决可以通过底层设置让需要使用SSH协议的IP地址不经过VPN服务器，由电脑主机网卡直接访问。**\n\n\n#### 具体步骤：  #\n\n- 查看网卡情况\n\n```\n输入指令：ifconfig\n下面出现的ppp0就是虚拟出来的VPN网卡。\n```\n\n  ![f358c182670c951780c5bf9c13266d77.png](http://tc.ffsky.net/images/2016/07/01/f358c182670c951780c5bf9c13266d77.png)\n\n\n- 查看ip列表,查看有哪些设置过了的IP地址\n\n```\nip route list\n```\n\n![df07d85a4866041cc61ca1591364a5c1.png](http://tc.ffsky.net/images/2016/07/01/df07d85a4866041cc61ca1591364a5c1.png)\n\n- 获取目标网站IP地址\n\n*最简单的可以通过ping命令如下*\n\nping www.github.com 终端返回：64 bytes from github.com (192.30.252.131): icmp_seq=1 ttl=54 time=210 ms，一般来说192.30.252.131 则为我们目标IP地址。但可能push的地址不一定是同一个地址。即便通过`nslookup + 详细网址`也未必能够获取真正推送的ip地址。最终通过谷歌搜索[网站](https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/)查看到github实际推送过程中ip地址为：192.30.252.0/22，（这边另外推荐可以使用wireshark进行抓包查看网络服务）\n\n- 将目标域名的IP地址加入到主机网卡中， 192.168.18.1为路由器网关的地址，通过上面ifconfig可以看到本机被路由器分配的ip地址为192.168.18.60，而eno1为计算机在访问外网中的实体网卡。\n\n\n```\nsudo ip route add 192.30.252.0/22 via 192.168.18.1 dev eno1\n```\n\n- 再次查看ip列表,查看有哪些设置过了的IP地址\n\n```\nip route list\n```\n\n- 最终完成推送\n\n![6e8f4d69e8d0fe0ea9aceb61834efd3f.png](http://tc.ffsky.net/images/2016/07/01/6e8f4d69e8d0fe0ea9aceb61834efd3f.png)\n\n\n***\n\n> 参考网址：\n> https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/\n","source":"_posts/2016/2016-06-28-linux下ssh通过VPN推送失败.md","raw":"---\nlayout: post\ncategory: \"read\"\ntitle:  linux下ssh通过VPN推送失败\ntags:   问题总结\ndate: \"2016-06-28 12:12\"\n---\n\n本文主要用于解决 VPN 和 SSH 两者冲突不兼容的问题。\n\n\n### VPN\n\n虚拟专用网络的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN有多种分类方式，主要是按协议进行分类。VPN可通过服务器、硬件、软件等多种方式实现。\n\nVPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。让外地员工访问到内网资源，利用VPN的解决方法就是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网。为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了VPN技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用VPN访问内网资源，这就是VPN在企业中应用得如此广泛的原因。\n\nVPN的协议分类主要有三种，PPTP、L2TP和IPSec，其中PPTP和L2TP协议工作在OSI模型的第二层，又称为二层隧道协议；IPSec是第三层隧道协议。\n\n### SSH\n\nSSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。windows 通过安装 putty等软件可以帮助安装 ssh 协议。\n\n<!-- more -->\n\n### 在VPN下使用SSH服务\n\n#### github使用ssh协议：#\n\n- 我们可以本地推送而免输入账户名密码，这里不作为本文重点，相关网址教程如下：\n\n  > http://playingfingers.com/2016/03/26/build-a-blog/\n  > http://beiyuu.com/github-pages\n  > http://www.cnblogs.com/ayseeing/p/3572582.html\n  > http://blog.csdn.net/renfufei/article/details/37725057/\n\n\n#### SSH无法推送: #\n\n- 当一切操作就绪后，会偶然出现无法通过SSH推送：\n\n  > 等待很长时间后，显示超时！\n\n#### 原理及方案： #\n\n- **通过排查发现主要是由于链接的VPN引起的，SSH协议和VPN本身存在不兼容，要想解决可以通过底层设置让需要使用SSH协议的IP地址不经过VPN服务器，由电脑主机网卡直接访问。**\n\n\n#### 具体步骤：  #\n\n- 查看网卡情况\n\n```\n输入指令：ifconfig\n下面出现的ppp0就是虚拟出来的VPN网卡。\n```\n\n  ![f358c182670c951780c5bf9c13266d77.png](http://tc.ffsky.net/images/2016/07/01/f358c182670c951780c5bf9c13266d77.png)\n\n\n- 查看ip列表,查看有哪些设置过了的IP地址\n\n```\nip route list\n```\n\n![df07d85a4866041cc61ca1591364a5c1.png](http://tc.ffsky.net/images/2016/07/01/df07d85a4866041cc61ca1591364a5c1.png)\n\n- 获取目标网站IP地址\n\n*最简单的可以通过ping命令如下*\n\nping www.github.com 终端返回：64 bytes from github.com (192.30.252.131): icmp_seq=1 ttl=54 time=210 ms，一般来说192.30.252.131 则为我们目标IP地址。但可能push的地址不一定是同一个地址。即便通过`nslookup + 详细网址`也未必能够获取真正推送的ip地址。最终通过谷歌搜索[网站](https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/)查看到github实际推送过程中ip地址为：192.30.252.0/22，（这边另外推荐可以使用wireshark进行抓包查看网络服务）\n\n- 将目标域名的IP地址加入到主机网卡中， 192.168.18.1为路由器网关的地址，通过上面ifconfig可以看到本机被路由器分配的ip地址为192.168.18.60，而eno1为计算机在访问外网中的实体网卡。\n\n\n```\nsudo ip route add 192.30.252.0/22 via 192.168.18.1 dev eno1\n```\n\n- 再次查看ip列表,查看有哪些设置过了的IP地址\n\n```\nip route list\n```\n\n- 最终完成推送\n\n![6e8f4d69e8d0fe0ea9aceb61834efd3f.png](http://tc.ffsky.net/images/2016/07/01/6e8f4d69e8d0fe0ea9aceb61834efd3f.png)\n\n\n***\n\n> 参考网址：\n> https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/\n","slug":"2016/2016-06-28-linux下ssh通过VPN推送失败","published":1,"updated":"2016-12-16T01:18:04.957Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ag8000cmumuknmh8x7c","content":"<p>本文主要用于解决 VPN 和 SSH 两者冲突不兼容的问题。</p>\n<h3 id=\"VPN\"><a href=\"#VPN\" class=\"headerlink\" title=\"VPN\"></a>VPN</h3><p>虚拟专用网络的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN有多种分类方式，主要是按协议进行分类。VPN可通过服务器、硬件、软件等多种方式实现。</p>\n<p>VPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。让外地员工访问到内网资源，利用VPN的解决方法就是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网。为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了VPN技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用VPN访问内网资源，这就是VPN在企业中应用得如此广泛的原因。</p>\n<p>VPN的协议分类主要有三种，PPTP、L2TP和IPSec，其中PPTP和L2TP协议工作在OSI模型的第二层，又称为二层隧道协议；IPSec是第三层隧道协议。</p>\n<h3 id=\"SSH\"><a href=\"#SSH\" class=\"headerlink\" title=\"SSH\"></a>SSH</h3><p>SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。windows 通过安装 putty等软件可以帮助安装 ssh 协议。</p>\n<a id=\"more\"></a>\n<h3 id=\"在VPN下使用SSH服务\"><a href=\"#在VPN下使用SSH服务\" class=\"headerlink\" title=\"在VPN下使用SSH服务\"></a>在VPN下使用SSH服务</h3><h4 id=\"github使用ssh协议：\"><a href=\"#github使用ssh协议：\" class=\"headerlink\" title=\"github使用ssh协议：\"></a>github使用ssh协议：</h4><ul>\n<li><p>我们可以本地推送而免输入账户名密码，这里不作为本文重点，相关网址教程如下：</p>\n<blockquote>\n<p><a href=\"http://playingfingers.com/2016/03/26/build-a-blog/\" target=\"_blank\" rel=\"external\">http://playingfingers.com/2016/03/26/build-a-blog/</a><br><a href=\"http://beiyuu.com/github-pages\" target=\"_blank\" rel=\"external\">http://beiyuu.com/github-pages</a><br><a href=\"http://www.cnblogs.com/ayseeing/p/3572582.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/ayseeing/p/3572582.html</a><br><a href=\"http://blog.csdn.net/renfufei/article/details/37725057/\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/renfufei/article/details/37725057/</a></p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"SSH无法推送\"><a href=\"#SSH无法推送\" class=\"headerlink\" title=\"SSH无法推送:\"></a>SSH无法推送:</h4><ul>\n<li><p>当一切操作就绪后，会偶然出现无法通过SSH推送：</p>\n<blockquote>\n<p>等待很长时间后，显示超时！</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"原理及方案：\"><a href=\"#原理及方案：\" class=\"headerlink\" title=\"原理及方案：\"></a>原理及方案：</h4><ul>\n<li><strong>通过排查发现主要是由于链接的VPN引起的，SSH协议和VPN本身存在不兼容，要想解决可以通过底层设置让需要使用SSH协议的IP地址不经过VPN服务器，由电脑主机网卡直接访问。</strong></li>\n</ul>\n<h4 id=\"具体步骤：\"><a href=\"#具体步骤：\" class=\"headerlink\" title=\"具体步骤：\"></a>具体步骤：</h4><ul>\n<li>查看网卡情况</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">输入指令：ifconfig</div><div class=\"line\">下面出现的ppp0就是虚拟出来的VPN网卡。</div></pre></td></tr></table></figure>\n<p>  <img src=\"http://tc.ffsky.net/images/2016/07/01/f358c182670c951780c5bf9c13266d77.png\" alt=\"f358c182670c951780c5bf9c13266d77.png\"></p>\n<ul>\n<li>查看ip列表,查看有哪些设置过了的IP地址</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ip route list</div></pre></td></tr></table></figure>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/df07d85a4866041cc61ca1591364a5c1.png\" alt=\"df07d85a4866041cc61ca1591364a5c1.png\"></p>\n<ul>\n<li>获取目标网站IP地址</li>\n</ul>\n<p><em>最简单的可以通过ping命令如下</em></p>\n<p>ping www.github.com 终端返回：64 bytes from github.com (192.30.252.131): icmp_seq=1 ttl=54 time=210 ms，一般来说192.30.252.131 则为我们目标IP地址。但可能push的地址不一定是同一个地址。即便通过<code>nslookup + 详细网址</code>也未必能够获取真正推送的ip地址。最终通过谷歌搜索<a href=\"https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/\" target=\"_blank\" rel=\"external\">网站</a>查看到github实际推送过程中ip地址为：192.30.252.0/22，（这边另外推荐可以使用wireshark进行抓包查看网络服务）</p>\n<ul>\n<li>将目标域名的IP地址加入到主机网卡中， 192.168.18.1为路由器网关的地址，通过上面ifconfig可以看到本机被路由器分配的ip地址为192.168.18.60，而eno1为计算机在访问外网中的实体网卡。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo ip route add 192.30.252.0/22 via 192.168.18.1 dev eno1</div></pre></td></tr></table></figure>\n<ul>\n<li>再次查看ip列表,查看有哪些设置过了的IP地址</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ip route list</div></pre></td></tr></table></figure>\n<ul>\n<li>最终完成推送</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/6e8f4d69e8d0fe0ea9aceb61834efd3f.png\" alt=\"6e8f4d69e8d0fe0ea9aceb61834efd3f.png\"></p>\n<hr>\n<blockquote>\n<p>参考网址：<br><a href=\"https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/\" target=\"_blank\" rel=\"external\">https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/</a></p>\n</blockquote>\n","excerpt":"<p>本文主要用于解决 VPN 和 SSH 两者冲突不兼容的问题。</p>\n<h3 id=\"VPN\"><a href=\"#VPN\" class=\"headerlink\" title=\"VPN\"></a>VPN</h3><p>虚拟专用网络的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN有多种分类方式，主要是按协议进行分类。VPN可通过服务器、硬件、软件等多种方式实现。</p>\n<p>VPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。让外地员工访问到内网资源，利用VPN的解决方法就是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网。为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了VPN技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用VPN访问内网资源，这就是VPN在企业中应用得如此广泛的原因。</p>\n<p>VPN的协议分类主要有三种，PPTP、L2TP和IPSec，其中PPTP和L2TP协议工作在OSI模型的第二层，又称为二层隧道协议；IPSec是第三层隧道协议。</p>\n<h3 id=\"SSH\"><a href=\"#SSH\" class=\"headerlink\" title=\"SSH\"></a>SSH</h3><p>SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。windows 通过安装 putty等软件可以帮助安装 ssh 协议。</p>","more":"<h3 id=\"在VPN下使用SSH服务\"><a href=\"#在VPN下使用SSH服务\" class=\"headerlink\" title=\"在VPN下使用SSH服务\"></a>在VPN下使用SSH服务</h3><h4 id=\"github使用ssh协议：\"><a href=\"#github使用ssh协议：\" class=\"headerlink\" title=\"github使用ssh协议：\"></a>github使用ssh协议：</h4><ul>\n<li><p>我们可以本地推送而免输入账户名密码，这里不作为本文重点，相关网址教程如下：</p>\n<blockquote>\n<p><a href=\"http://playingfingers.com/2016/03/26/build-a-blog/\">http://playingfingers.com/2016/03/26/build-a-blog/</a><br><a href=\"http://beiyuu.com/github-pages\">http://beiyuu.com/github-pages</a><br><a href=\"http://www.cnblogs.com/ayseeing/p/3572582.html\">http://www.cnblogs.com/ayseeing/p/3572582.html</a><br><a href=\"http://blog.csdn.net/renfufei/article/details/37725057/\">http://blog.csdn.net/renfufei/article/details/37725057/</a></p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"SSH无法推送\"><a href=\"#SSH无法推送\" class=\"headerlink\" title=\"SSH无法推送:\"></a>SSH无法推送:</h4><ul>\n<li><p>当一切操作就绪后，会偶然出现无法通过SSH推送：</p>\n<blockquote>\n<p>等待很长时间后，显示超时！</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"原理及方案：\"><a href=\"#原理及方案：\" class=\"headerlink\" title=\"原理及方案：\"></a>原理及方案：</h4><ul>\n<li><strong>通过排查发现主要是由于链接的VPN引起的，SSH协议和VPN本身存在不兼容，要想解决可以通过底层设置让需要使用SSH协议的IP地址不经过VPN服务器，由电脑主机网卡直接访问。</strong></li>\n</ul>\n<h4 id=\"具体步骤：\"><a href=\"#具体步骤：\" class=\"headerlink\" title=\"具体步骤：\"></a>具体步骤：</h4><ul>\n<li>查看网卡情况</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">输入指令：ifconfig</div><div class=\"line\">下面出现的ppp0就是虚拟出来的VPN网卡。</div></pre></td></tr></table></figure>\n<p>  <img src=\"http://tc.ffsky.net/images/2016/07/01/f358c182670c951780c5bf9c13266d77.png\" alt=\"f358c182670c951780c5bf9c13266d77.png\"></p>\n<ul>\n<li>查看ip列表,查看有哪些设置过了的IP地址</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ip route list</div></pre></td></tr></table></figure>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/df07d85a4866041cc61ca1591364a5c1.png\" alt=\"df07d85a4866041cc61ca1591364a5c1.png\"></p>\n<ul>\n<li>获取目标网站IP地址</li>\n</ul>\n<p><em>最简单的可以通过ping命令如下</em></p>\n<p>ping www.github.com 终端返回：64 bytes from github.com (192.30.252.131): icmp_seq=1 ttl=54 time=210 ms，一般来说192.30.252.131 则为我们目标IP地址。但可能push的地址不一定是同一个地址。即便通过<code>nslookup + 详细网址</code>也未必能够获取真正推送的ip地址。最终通过谷歌搜索<a href=\"https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/\">网站</a>查看到github实际推送过程中ip地址为：192.30.252.0/22，（这边另外推荐可以使用wireshark进行抓包查看网络服务）</p>\n<ul>\n<li>将目标域名的IP地址加入到主机网卡中， 192.168.18.1为路由器网关的地址，通过上面ifconfig可以看到本机被路由器分配的ip地址为192.168.18.60，而eno1为计算机在访问外网中的实体网卡。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo ip route add 192.30.252.0/22 via 192.168.18.1 dev eno1</div></pre></td></tr></table></figure>\n<ul>\n<li>再次查看ip列表,查看有哪些设置过了的IP地址</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ip route list</div></pre></td></tr></table></figure>\n<ul>\n<li>最终完成推送</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/6e8f4d69e8d0fe0ea9aceb61834efd3f.png\" alt=\"6e8f4d69e8d0fe0ea9aceb61834efd3f.png\"></p>\n<hr>\n<blockquote>\n<p>参考网址：<br><a href=\"https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/\">https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/</a></p>\n</blockquote>"},{"layout":"post","title":"linux下文件查找","date":"2016-07-01T08:12:00.000Z","_content":"\nlinux 使用 CLI 的情况下，如果要查找文件还是很方便的，本身提供了多个搜索查找工具，这边主要列出一般随系统自带的工具：\"find\"；\"locate\"；\"whereis\"；\"which\"；\"type\"，这几个工具，一般绝大多数 linux 发行版都会自带；linux 是一个小而美的系统，基于 linux 内核之上，肯定还有一些发行版或者个人会提供一些更加强大的检索工具，这边不做详细介绍。\n\n\n### 1. find\n\nfind是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。\nfind的使用格式如下：\n\n```\nfind <指定目录> <指定条件> <指定动作>\n<指定目录>： 所要搜索的目录及其所有子目录。默认为当前目录。\n<指定条件>： 所要搜索的文件的特征。\n<指定动作>： 对搜索结果进行特定的处理。\n```\n\n<!-- more -->\n\n如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。\n\n```\nfind的使用实例：\n$ find . -name 'my*'\n搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。\n$ find / -name 'my*' -ls\n搜索根目录中，所有文件名以my开头的文件，并显示它们的详细信息。\n$ find . -type f -mmin -10\n搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。\n```\n\n注意：find 每次会遍历你索要搜索的路径，然后查找文件名，另外 find 后面如果直接跟文件名如： find . -name myfile 则只会查找文件名为 myfile 的文件，如果需要搜索 myfile1 等文件，则需要加入 * 通配符。\n\n\n### 2. locate\n\nlocate 命令其实是 \"find -name\" 的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux 系统自动创建这个数据库，并且每天自动更新一次，所以使用 locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，**先使用 updatedb 命令**，手动更新数据库，ubuntu 下需要使用 sudo 才可以更新该数据库。\n\nlocate 相当于快速检索的 `find -name \"*name*\"` 写法，默认就带入模糊查找的功能，如果需要精准查找需要 `locate -b '\\NAME'` man 文档中有详细描述。\n\n```\nlocate命令的使用实例：\n$ locate /etc/sh\n搜索etc目录下所有以sh开头的文件。\n$ locate ~/m\n搜索用户主目录下，所有以m开头的文件。\n$ locate -i ~/m\n搜索用户主目录下，所有以m开头的文件，并且忽略大小写。\n```\n\n### 3. whereis\n\nwhereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。\n\n```\nwhereis命令的使用实例：\n$ whereis grep\n```\n\n### 4. which\n\nwhich命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n\n```\nwhich命令的使用实例：\n$ which grep\n```\n\n### 5. type\n\ntype命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。\ntype命令的使用实例：\n\n```\n$ type cd\n系统会提示，cd是shell的自带命令（build-in）。\n$ type grep\n系统会提示，grep是一个外部命令，并显示该命令的路径。\n$ type -p grep\n加上-p参数后，就相当于which命令。\n```\n\n\n> 参考链接：\n> http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html\n> http://jingyan.baidu.com/article/335530dab6fe0919ca41c365.htm\n","source":"_posts/2016/2016-07-01-linux下文件查找.md","raw":"---\nlayout: post\ncategory: \"read\"\ntitle:  linux下文件查找\ntags:   linux基础\ndate: \"2016-07-01 16:12\"\n---\n\nlinux 使用 CLI 的情况下，如果要查找文件还是很方便的，本身提供了多个搜索查找工具，这边主要列出一般随系统自带的工具：\"find\"；\"locate\"；\"whereis\"；\"which\"；\"type\"，这几个工具，一般绝大多数 linux 发行版都会自带；linux 是一个小而美的系统，基于 linux 内核之上，肯定还有一些发行版或者个人会提供一些更加强大的检索工具，这边不做详细介绍。\n\n\n### 1. find\n\nfind是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。\nfind的使用格式如下：\n\n```\nfind <指定目录> <指定条件> <指定动作>\n<指定目录>： 所要搜索的目录及其所有子目录。默认为当前目录。\n<指定条件>： 所要搜索的文件的特征。\n<指定动作>： 对搜索结果进行特定的处理。\n```\n\n<!-- more -->\n\n如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。\n\n```\nfind的使用实例：\n$ find . -name 'my*'\n搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。\n$ find / -name 'my*' -ls\n搜索根目录中，所有文件名以my开头的文件，并显示它们的详细信息。\n$ find . -type f -mmin -10\n搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。\n```\n\n注意：find 每次会遍历你索要搜索的路径，然后查找文件名，另外 find 后面如果直接跟文件名如： find . -name myfile 则只会查找文件名为 myfile 的文件，如果需要搜索 myfile1 等文件，则需要加入 * 通配符。\n\n\n### 2. locate\n\nlocate 命令其实是 \"find -name\" 的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux 系统自动创建这个数据库，并且每天自动更新一次，所以使用 locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，**先使用 updatedb 命令**，手动更新数据库，ubuntu 下需要使用 sudo 才可以更新该数据库。\n\nlocate 相当于快速检索的 `find -name \"*name*\"` 写法，默认就带入模糊查找的功能，如果需要精准查找需要 `locate -b '\\NAME'` man 文档中有详细描述。\n\n```\nlocate命令的使用实例：\n$ locate /etc/sh\n搜索etc目录下所有以sh开头的文件。\n$ locate ~/m\n搜索用户主目录下，所有以m开头的文件。\n$ locate -i ~/m\n搜索用户主目录下，所有以m开头的文件，并且忽略大小写。\n```\n\n### 3. whereis\n\nwhereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。\n\n```\nwhereis命令的使用实例：\n$ whereis grep\n```\n\n### 4. which\n\nwhich命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n\n```\nwhich命令的使用实例：\n$ which grep\n```\n\n### 5. type\n\ntype命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。\ntype命令的使用实例：\n\n```\n$ type cd\n系统会提示，cd是shell的自带命令（build-in）。\n$ type grep\n系统会提示，grep是一个外部命令，并显示该命令的路径。\n$ type -p grep\n加上-p参数后，就相当于which命令。\n```\n\n\n> 参考链接：\n> http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html\n> http://jingyan.baidu.com/article/335530dab6fe0919ca41c365.htm\n","slug":"2016/2016-07-01-linux下文件查找","published":1,"updated":"2017-01-12T03:20:18.068Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ag9000dmumulag1qk2p","content":"<p>linux 使用 CLI 的情况下，如果要查找文件还是很方便的，本身提供了多个搜索查找工具，这边主要列出一般随系统自带的工具：”find”；”locate”；”whereis”；”which”；”type”，这几个工具，一般绝大多数 linux 发行版都会自带；linux 是一个小而美的系统，基于 linux 内核之上，肯定还有一些发行版或者个人会提供一些更加强大的检索工具，这边不做详细介绍。</p>\n<h3 id=\"1-find\"><a href=\"#1-find\" class=\"headerlink\" title=\"1. find\"></a>1. find</h3><p>find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。<br>find的使用格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</div><div class=\"line\">&lt;指定目录&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。</div><div class=\"line\">&lt;指定条件&gt;： 所要搜索的文件的特征。</div><div class=\"line\">&lt;指定动作&gt;： 对搜索结果进行特定的处理。</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">find的使用实例：</div><div class=\"line\">$ find . -name &apos;my*&apos;</div><div class=\"line\">搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。</div><div class=\"line\">$ find / -name &apos;my*&apos; -ls</div><div class=\"line\">搜索根目录中，所有文件名以my开头的文件，并显示它们的详细信息。</div><div class=\"line\">$ find . -type f -mmin -10</div><div class=\"line\">搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。</div></pre></td></tr></table></figure>\n<p>注意：find 每次会遍历你索要搜索的路径，然后查找文件名，另外 find 后面如果直接跟文件名如： find . -name myfile 则只会查找文件名为 myfile 的文件，如果需要搜索 myfile1 等文件，则需要加入 * 通配符。</p>\n<h3 id=\"2-locate\"><a href=\"#2-locate\" class=\"headerlink\" title=\"2. locate\"></a>2. locate</h3><p>locate 命令其实是 “find -name” 的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux 系统自动创建这个数据库，并且每天自动更新一次，所以使用 locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，<strong>先使用 updatedb 命令</strong>，手动更新数据库，ubuntu 下需要使用 sudo 才可以更新该数据库。</p>\n<p>locate 相当于快速检索的 <code>find -name &quot;*name*&quot;</code> 写法，默认就带入模糊查找的功能，如果需要精准查找需要 <code>locate -b &#39;\\NAME&#39;</code> man 文档中有详细描述。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">locate命令的使用实例：</div><div class=\"line\">$ locate /etc/sh</div><div class=\"line\">搜索etc目录下所有以sh开头的文件。</div><div class=\"line\">$ locate ~/m</div><div class=\"line\">搜索用户主目录下，所有以m开头的文件。</div><div class=\"line\">$ locate -i ~/m</div><div class=\"line\">搜索用户主目录下，所有以m开头的文件，并且忽略大小写。</div></pre></td></tr></table></figure>\n<h3 id=\"3-whereis\"><a href=\"#3-whereis\" class=\"headerlink\" title=\"3. whereis\"></a>3. whereis</h3><p>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">whereis命令的使用实例：</div><div class=\"line\">$ whereis grep</div></pre></td></tr></table></figure>\n<h3 id=\"4-which\"><a href=\"#4-which\" class=\"headerlink\" title=\"4. which\"></a>4. which</h3><p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">which命令的使用实例：</div><div class=\"line\">$ which grep</div></pre></td></tr></table></figure>\n<h3 id=\"5-type\"><a href=\"#5-type\" class=\"headerlink\" title=\"5. type\"></a>5. type</h3><p>type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。<br>type命令的使用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ type cd</div><div class=\"line\">系统会提示，cd是shell的自带命令（build-in）。</div><div class=\"line\">$ type grep</div><div class=\"line\">系统会提示，grep是一个外部命令，并显示该命令的路径。</div><div class=\"line\">$ type -p grep</div><div class=\"line\">加上-p参数后，就相当于which命令。</div></pre></td></tr></table></figure>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html</a><br><a href=\"http://jingyan.baidu.com/article/335530dab6fe0919ca41c365.htm\" target=\"_blank\" rel=\"external\">http://jingyan.baidu.com/article/335530dab6fe0919ca41c365.htm</a></p>\n</blockquote>\n","excerpt":"<p>linux 使用 CLI 的情况下，如果要查找文件还是很方便的，本身提供了多个搜索查找工具，这边主要列出一般随系统自带的工具：”find”；”locate”；”whereis”；”which”；”type”，这几个工具，一般绝大多数 linux 发行版都会自带；linux 是一个小而美的系统，基于 linux 内核之上，肯定还有一些发行版或者个人会提供一些更加强大的检索工具，这边不做详细介绍。</p>\n<h3 id=\"1-find\"><a href=\"#1-find\" class=\"headerlink\" title=\"1. find\"></a>1. find</h3><p>find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。<br>find的使用格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</div><div class=\"line\">&lt;指定目录&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。</div><div class=\"line\">&lt;指定条件&gt;： 所要搜索的文件的特征。</div><div class=\"line\">&lt;指定动作&gt;： 对搜索结果进行特定的处理。</div></pre></td></tr></table></figure>","more":"<p>如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">find的使用实例：</div><div class=\"line\">$ find . -name &apos;my*&apos;</div><div class=\"line\">搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。</div><div class=\"line\">$ find / -name &apos;my*&apos; -ls</div><div class=\"line\">搜索根目录中，所有文件名以my开头的文件，并显示它们的详细信息。</div><div class=\"line\">$ find . -type f -mmin -10</div><div class=\"line\">搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。</div></pre></td></tr></table></figure>\n<p>注意：find 每次会遍历你索要搜索的路径，然后查找文件名，另外 find 后面如果直接跟文件名如： find . -name myfile 则只会查找文件名为 myfile 的文件，如果需要搜索 myfile1 等文件，则需要加入 * 通配符。</p>\n<h3 id=\"2-locate\"><a href=\"#2-locate\" class=\"headerlink\" title=\"2. locate\"></a>2. locate</h3><p>locate 命令其实是 “find -name” 的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux 系统自动创建这个数据库，并且每天自动更新一次，所以使用 locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，<strong>先使用 updatedb 命令</strong>，手动更新数据库，ubuntu 下需要使用 sudo 才可以更新该数据库。</p>\n<p>locate 相当于快速检索的 <code>find -name &quot;*name*&quot;</code> 写法，默认就带入模糊查找的功能，如果需要精准查找需要 <code>locate -b &#39;\\NAME&#39;</code> man 文档中有详细描述。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">locate命令的使用实例：</div><div class=\"line\">$ locate /etc/sh</div><div class=\"line\">搜索etc目录下所有以sh开头的文件。</div><div class=\"line\">$ locate ~/m</div><div class=\"line\">搜索用户主目录下，所有以m开头的文件。</div><div class=\"line\">$ locate -i ~/m</div><div class=\"line\">搜索用户主目录下，所有以m开头的文件，并且忽略大小写。</div></pre></td></tr></table></figure>\n<h3 id=\"3-whereis\"><a href=\"#3-whereis\" class=\"headerlink\" title=\"3. whereis\"></a>3. whereis</h3><p>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">whereis命令的使用实例：</div><div class=\"line\">$ whereis grep</div></pre></td></tr></table></figure>\n<h3 id=\"4-which\"><a href=\"#4-which\" class=\"headerlink\" title=\"4. which\"></a>4. which</h3><p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">which命令的使用实例：</div><div class=\"line\">$ which grep</div></pre></td></tr></table></figure>\n<h3 id=\"5-type\"><a href=\"#5-type\" class=\"headerlink\" title=\"5. type\"></a>5. type</h3><p>type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。<br>type命令的使用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ type cd</div><div class=\"line\">系统会提示，cd是shell的自带命令（build-in）。</div><div class=\"line\">$ type grep</div><div class=\"line\">系统会提示，grep是一个外部命令，并显示该命令的路径。</div><div class=\"line\">$ type -p grep</div><div class=\"line\">加上-p参数后，就相当于which命令。</div></pre></td></tr></table></figure>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html\">http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html</a><br><a href=\"http://jingyan.baidu.com/article/335530dab6fe0919ca41c365.htm\">http://jingyan.baidu.com/article/335530dab6fe0919ca41c365.htm</a></p>\n</blockquote>"},{"layout":"post","title":"linux的下载工具","date":"2016-06-29T04:00:00.000Z","_content":"\n\nlinux命令行下载外网文件或内网进行大文件传输，经常使用的文本下载工具wget、curl，今天给大家推荐支持Linux命令行多线程、断点续传下载工具axel和myget。\n\n### 系统环境\n\n#### Linux系统如何查看版本信息\n\n```\n输入\"uname -a \",可显示电脑以及操作系统的相关信息。\nLinux系统如何查看版本信息\n输入\"cat /proc/version\",说明正在运行的内核版本。\nLinux系统如何查看版本信息\n输入\"cat /etc/issue\", 显示的是发行版本信息\nLinux系统如何查看版本信息\nlsb_release -a (适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)\nLinux系统如何查看版本信息\n```\n\n<!-- more -->\n\n#### 查看本机的信息\n\n```\n# lsb_release -a(适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)\nDistributor ID:\tUbuntu\nDescription:\tUbuntu 16.04 LTS\nRelease:\t16.04\nCodename:\txenial\n```\n\n### 下载工具安装、使用方法介绍\n\n#### wget\n\n- ubuntu安装请运行\n\n```\n# sudo apt-get install wget\nwget版本信息\n# wget -V\nGNU Wget 1.17.1 built on linux-gnu.\n```\n\n- 此工具比较常用，使用方法、参数略\n\n\n\n#### Axel 下载 安装\n\n- 官方站点http://axel.alioth.debian.org/\n- 安装axel\n\n```\n# sudo apt-get install axel\naxel版本\n# axel -V\nAxel version 2.5 (Linux)\n\nCopyright 2001-2007 Wilmer van der Gaast,\n          2015      Joao Eriberto Mota Filho,\n                    and others.\nPlease, see the CREDITS file.\n```\n\n- axel命令使用方法：\n\n```\n    axel [选项参数] url1 [url2] [url……]\n    axel 参数：\n    --max-speed=x    #限速值最高速度\n     -s x\n    Specify maximum speed (bytes per second)\n     --num-connections=x\n     -n x #连接数\n    Specify maximum number of connections\n     --output=f #下载为本地文件\n     -o f\n    Specify local output file\n     --search[=x] #搜索镜像\n     -S [x]\n    Search for mirrors and download from x servers\n     --header=x  \n     -H x     #添加头文件字符串\n    Add header string\n     --user-agent=x #设置UA\n     -U x  \n    Set user agent\n     --no-proxy     #不使用代理服务器\n     -N  \n    Just don't use any proxy server --quiet  \n     --quiet, -q  \n    No output to stdout. #静默模式，不输出到标准输出  \n    --verbose  \n     -v  \n    More status information #更多状态信息  \n     --alternate  \n     --help #帮助  \n     -h  \n    --version #版本  \n     -V\n```\n\n#### myget 下载、安装\n\n```\n    wget http://myget.sourceforge.net/release/myget-0.1.2.tar.gz\n    tar -zxvf myget-0.1.2.tar.gz\n    cd myget-0.1.2\n    # ./configure && make && make install\n    mytget版本，注意myget命令为mytget\n    # mytget -v\n    myget 0.1.1\n```\n\n- 命令mytget用法\n\n```\n    mytget [选项] [url]\n    参数\n     -b, --debug          Show the debug message #看调试信息\n     -c, --count=num      Set the retry count to [num], no limit when \"0\", the default is \"99\" #设置重试次数，0为无限，默认是99次。\n     -d, --directory=dir Set the local direcotry to [dir], the default is \".\" #指定下载本地目录，默认是当前目录\n     -f, --file=file      Rename the file to [file] #重命名下载到本地的文件名\n     -h, --help           A brief summary of all the options #简短的帮助摘要\n     -i, --interval=num   Set the ftp retry interval to [num] seconds, the default is \"5\" #设置ftp重试间隔，单位s，默认5秒\n     -n, --number=num     Use [num] connections instead of the default (4) #指定连接数，默认4\n     -r, --referer=URL    Include `Referer: [URL]' header in HTTP request. #包含请求头 Referer\n     -t, --timeout=num    Set the connection timeout to [num] seconds, the default is \"30\" #设置连接超时时间，默认30秒\n     -v, --version        Show the version of the myget and exit #查看版本信息\n     -x, --proxy=URL      Set the proxy [URL]  #设置代理\n```\n\n### wget、axel、myget测试下载速度对比\n\n#### 下载速度对比\n\n说明：同一台机器下载同一个数据源链接\n\n- wget下载\n\n```\n    # wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    --2013-03-11 09:29:46-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Connecting to 10.0.251.154:80... connected.\n    HTTP request sent, awaiting response... 200 OK\n    Length: 4353378304 (4.1G) [application/octet-stream]\n    Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso'\n```\n\n- axel下载\n\n```\n    # axel http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    File size: 4353378304 bytes\n    Opening output file CentOS-6.4-x86_64-bin-DVD1.iso.0\n    Starting download\n\n    [ 0%] .......... .......... .......... .......... .......... [ 382.3KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [ 610.9KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [ 826.5KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [1003.1KB/s]\n    略\n    [ 0%] .......... .......... .......... .......... .......... [2055.8KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [2074.8KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [2093.6KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [2111.0KB/s]\n    [ 0%] .......... .......... .......... .......... ...\n    Downloaded 2693.8 kilobytes in 1 second. (2113.05 KB/s)\n    # rm -f CentOS-6.4-x86_64-bin-DVD1.iso*\n```\n\n- axel  使用10个线程下载\n\n```\n    # axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    File size: 4353378304 bytes\n    Opening output file CentOS-6.4-x86_64-bin-DVD1.iso\n    Starting download\n    [ 0%] .......... .......... .......... .......... .......... [ 440.9KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [ 707.9KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [ 935.1KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [1138.8KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [1310.5KB/s]\n    略\n    [ 0%] .......... .......... .......... .......... .......... [2180.3KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [2196.9KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [2189.7KB/s]\n    [ 0%] .......... .......... .........\n    Downloaded 4139.5 kilobytes in 1 second. (2176.65 KB/s)\n```\n\n#### myget下载\n\n```\n    # mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso\n    Filesize: 4.1G\n     0% [                       >                       >                       >                         ] [ 27M] [2.5M/s] [ETA:26:58]\n```\n\n- myget指定10个线程下载\n\n```\n    # mytget -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso\n    Filesize: 4.1G\n     0% [        >         >         >        >         >         >        >         >         >          ] [ 39M] [2.6M/s] [ETA:26:27]\n    # ll CentOS-6.4-x86_64-bin-DVD1.iso.mg\\!\n    -rw-r--r-- 1 root root 4353378404 Mar 11 12:53 CentOS-6.4-x86_64-bin-DVD1.iso.mg!\n    下载速度对比结论：axel、myget支持多线程，且速度较快都在2M。\n```\n\n### 断点续传对比测试\n\n#### axel\n\n```\n    # axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    File size: 4353378304 bytes\n    Opening output file CentOS-6.4-x86_64-bin-DVD1.iso\n    Starting download\n    [ 0%] .......... .......... .......... .......... .......... [ 491.8KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [ 748.4KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [1007.5KB/s]\n    略\n    [ 1%] .......... ........... .......... .......... .......... [2509.3KB/s]\n    [ 1%] .......... .......... .......... .......... .......... [2509.5KB/s]\n    [ 1%] .......... .......... .......... ....\n    Downloaded 45.3 megabytes in 18 seconds. (2510.95 KB/s)\n    中止下载，进度已经到1%，下载了45.3mb\n```\n\n- 再次运行下载命令，继续从1%断点续传\n\n```\n    # axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    File size: 4353378304 bytes\n    Opening output file CentOS-6.4-x86_64-bin-DVD1.iso\n    State file found: 47549233 bytes downloaded, 4305829071 to go.\n    Starting download\n            ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,...... .......... [ 314.4KB/s]\n    [ 1%] .......... .......... .......... .......... .......... [ 603.0KB/s]\n    [ 1%] .......... .......... .......... .......... .......... [ 839.7KB/s]\n                   略\n    [ 1%] .......... .......... .......... .......... .......... [1547.1KB/s]\n    [ 1%] .......... .......... .......... .......... .......... [1548.8KB/s]\n    # rm -f CentOS-6.4-x86_64-bin-DVD1.iso*\n```\n\n#### wget\n\n```\n    # wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    --2013-03-11 09:51:46-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Connecting to 10.0.251.154:80... connected.\n    HTTP request sent, awaiting response... 200 OK\n    Length: 4353378304 (4.1G) [application/octet-stream]\n    Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso'\n     1% [                                                                               ] 47,760,647 1.49M/s eta 47m 42s\n```\n\n- wget在进度1%中止已经下载47,760,647，再次运行命令，重新开始下载\n\n```\n    # wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    --2013-03-11 09:53:24-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Connecting to 10.0.251.154:80... connected.\n    HTTP request sent, awaiting response... 200 OK\n    Length: 4353378304 (4.1G) [application/octet-stream]\n    Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso.1'\n     0% [                                                                               ] 1,032,445   1.21M/s\n```\n\n- wget直接运行不支持断点续传\n\n`# rm -f CentOS-6.4-x86_64-bin-DVD1.iso*`\n\n- wget重新测试使其支持断点续传\n\n`# wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso`\n\n```\n    --2013-03-11 12:40:15-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Connecting to 10.0.251.154:80... connected.\n    HTTP request sent, awaiting response... 200 OK\n    Length: 4353378304 (4.1G) [application/octet-stream]\n    Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso'\n     1% [>                                                                                          ] 52,620,206  1.57M/s eta 44m 58s\n    在进度1%，已经下载52,620,206处停止\n```\n\n- wget 加-c再次下载，支持断点续传\n\n```\n    # wget -c http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    --2013-03-11 12:40:56-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Connecting to 10.0.251.154:80... connected.\n    HTTP request sent, awaiting response... 206 Partial Content\n    Length: 4353378304 (4.1G), 4300661972 (4.0G) remaining [application/octet-stream]\n    Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso'\n     1% [+                                                                                          ] 59,663,080 1.59M/s eta 44m 14s\n    # rm -f CentOS-6.4-x86_64-bin-DVD1.iso.mg\\!\n```\n\n4.3 myget\n\n```\n    # mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso\n    Filesize: 4.1G\n     1% [                       >                       >                        >                        ] [ 45M] [2.1M/s] [ETA:33:06]\n    下载进度到1% 文件大小45M\n    # ll CentOS-6.4-x86_64-bin-DVD1.iso.mg\\!\n    -rw-r--r-- 1 root root 4353378404 Mar 11 12:54 CentOS-6.4-x86_64-bin-DVD1.iso.mg!\n    再次执行命令，直接从进度1%开始下载\n    # mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso\n    Filesize: 4.1G\n     1% [                       >                       >                        >                        ] [ 51M] [2.9M/s] [ETA:23:57]\n```\n\n**断点续传对比，三个工具都支持，但wget需要增加-c参数，axel、myget再次执行命令即可。\n综上对比推荐大家工作中使用axel或myget提高效率，个人比较喜欢axel。\n注意内网传输根据隧道带宽进行限速，别影响线上生产服务数据传输。**\n\n### aria2c (The ultra fast download utility)\n\n强烈推荐这个下载工具，可以说是 linux 下的下载神器，速度比 windows 下的迅雷还要快不少。aria2c 并不仅是一个简单的下载工具，里面配置选项相当多，另外也有不少 GUI 工具支持 aria2c 这边不做详细的介绍，具体可以参考本博客中的 Aria2 详解这篇文章。\n\n\n*未完待续*\n\n> 相关链接：\n> http://dreamway.blog.51cto.com/1281816/1151886 (centos版本)\n> http://sydi.org/posts/linux/aria2c-usage-sample-cns.html\n","source":"_posts/2016/2016-06-29-linux下的下载.md","raw":"---\nlayout: post\ncategory: \"read\"\ntitle:  linux的下载工具\ntags:   问题总结\ndate: \"2016-06-29 12:00\"\n---\n\n\nlinux命令行下载外网文件或内网进行大文件传输，经常使用的文本下载工具wget、curl，今天给大家推荐支持Linux命令行多线程、断点续传下载工具axel和myget。\n\n### 系统环境\n\n#### Linux系统如何查看版本信息\n\n```\n输入\"uname -a \",可显示电脑以及操作系统的相关信息。\nLinux系统如何查看版本信息\n输入\"cat /proc/version\",说明正在运行的内核版本。\nLinux系统如何查看版本信息\n输入\"cat /etc/issue\", 显示的是发行版本信息\nLinux系统如何查看版本信息\nlsb_release -a (适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)\nLinux系统如何查看版本信息\n```\n\n<!-- more -->\n\n#### 查看本机的信息\n\n```\n# lsb_release -a(适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)\nDistributor ID:\tUbuntu\nDescription:\tUbuntu 16.04 LTS\nRelease:\t16.04\nCodename:\txenial\n```\n\n### 下载工具安装、使用方法介绍\n\n#### wget\n\n- ubuntu安装请运行\n\n```\n# sudo apt-get install wget\nwget版本信息\n# wget -V\nGNU Wget 1.17.1 built on linux-gnu.\n```\n\n- 此工具比较常用，使用方法、参数略\n\n\n\n#### Axel 下载 安装\n\n- 官方站点http://axel.alioth.debian.org/\n- 安装axel\n\n```\n# sudo apt-get install axel\naxel版本\n# axel -V\nAxel version 2.5 (Linux)\n\nCopyright 2001-2007 Wilmer van der Gaast,\n          2015      Joao Eriberto Mota Filho,\n                    and others.\nPlease, see the CREDITS file.\n```\n\n- axel命令使用方法：\n\n```\n    axel [选项参数] url1 [url2] [url……]\n    axel 参数：\n    --max-speed=x    #限速值最高速度\n     -s x\n    Specify maximum speed (bytes per second)\n     --num-connections=x\n     -n x #连接数\n    Specify maximum number of connections\n     --output=f #下载为本地文件\n     -o f\n    Specify local output file\n     --search[=x] #搜索镜像\n     -S [x]\n    Search for mirrors and download from x servers\n     --header=x  \n     -H x     #添加头文件字符串\n    Add header string\n     --user-agent=x #设置UA\n     -U x  \n    Set user agent\n     --no-proxy     #不使用代理服务器\n     -N  \n    Just don't use any proxy server --quiet  \n     --quiet, -q  \n    No output to stdout. #静默模式，不输出到标准输出  \n    --verbose  \n     -v  \n    More status information #更多状态信息  \n     --alternate  \n     --help #帮助  \n     -h  \n    --version #版本  \n     -V\n```\n\n#### myget 下载、安装\n\n```\n    wget http://myget.sourceforge.net/release/myget-0.1.2.tar.gz\n    tar -zxvf myget-0.1.2.tar.gz\n    cd myget-0.1.2\n    # ./configure && make && make install\n    mytget版本，注意myget命令为mytget\n    # mytget -v\n    myget 0.1.1\n```\n\n- 命令mytget用法\n\n```\n    mytget [选项] [url]\n    参数\n     -b, --debug          Show the debug message #看调试信息\n     -c, --count=num      Set the retry count to [num], no limit when \"0\", the default is \"99\" #设置重试次数，0为无限，默认是99次。\n     -d, --directory=dir Set the local direcotry to [dir], the default is \".\" #指定下载本地目录，默认是当前目录\n     -f, --file=file      Rename the file to [file] #重命名下载到本地的文件名\n     -h, --help           A brief summary of all the options #简短的帮助摘要\n     -i, --interval=num   Set the ftp retry interval to [num] seconds, the default is \"5\" #设置ftp重试间隔，单位s，默认5秒\n     -n, --number=num     Use [num] connections instead of the default (4) #指定连接数，默认4\n     -r, --referer=URL    Include `Referer: [URL]' header in HTTP request. #包含请求头 Referer\n     -t, --timeout=num    Set the connection timeout to [num] seconds, the default is \"30\" #设置连接超时时间，默认30秒\n     -v, --version        Show the version of the myget and exit #查看版本信息\n     -x, --proxy=URL      Set the proxy [URL]  #设置代理\n```\n\n### wget、axel、myget测试下载速度对比\n\n#### 下载速度对比\n\n说明：同一台机器下载同一个数据源链接\n\n- wget下载\n\n```\n    # wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    --2013-03-11 09:29:46-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Connecting to 10.0.251.154:80... connected.\n    HTTP request sent, awaiting response... 200 OK\n    Length: 4353378304 (4.1G) [application/octet-stream]\n    Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso'\n```\n\n- axel下载\n\n```\n    # axel http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    File size: 4353378304 bytes\n    Opening output file CentOS-6.4-x86_64-bin-DVD1.iso.0\n    Starting download\n\n    [ 0%] .......... .......... .......... .......... .......... [ 382.3KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [ 610.9KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [ 826.5KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [1003.1KB/s]\n    略\n    [ 0%] .......... .......... .......... .......... .......... [2055.8KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [2074.8KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [2093.6KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [2111.0KB/s]\n    [ 0%] .......... .......... .......... .......... ...\n    Downloaded 2693.8 kilobytes in 1 second. (2113.05 KB/s)\n    # rm -f CentOS-6.4-x86_64-bin-DVD1.iso*\n```\n\n- axel  使用10个线程下载\n\n```\n    # axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    File size: 4353378304 bytes\n    Opening output file CentOS-6.4-x86_64-bin-DVD1.iso\n    Starting download\n    [ 0%] .......... .......... .......... .......... .......... [ 440.9KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [ 707.9KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [ 935.1KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [1138.8KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [1310.5KB/s]\n    略\n    [ 0%] .......... .......... .......... .......... .......... [2180.3KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [2196.9KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [2189.7KB/s]\n    [ 0%] .......... .......... .........\n    Downloaded 4139.5 kilobytes in 1 second. (2176.65 KB/s)\n```\n\n#### myget下载\n\n```\n    # mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso\n    Filesize: 4.1G\n     0% [                       >                       >                       >                         ] [ 27M] [2.5M/s] [ETA:26:58]\n```\n\n- myget指定10个线程下载\n\n```\n    # mytget -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso\n    Filesize: 4.1G\n     0% [        >         >         >        >         >         >        >         >         >          ] [ 39M] [2.6M/s] [ETA:26:27]\n    # ll CentOS-6.4-x86_64-bin-DVD1.iso.mg\\!\n    -rw-r--r-- 1 root root 4353378404 Mar 11 12:53 CentOS-6.4-x86_64-bin-DVD1.iso.mg!\n    下载速度对比结论：axel、myget支持多线程，且速度较快都在2M。\n```\n\n### 断点续传对比测试\n\n#### axel\n\n```\n    # axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    File size: 4353378304 bytes\n    Opening output file CentOS-6.4-x86_64-bin-DVD1.iso\n    Starting download\n    [ 0%] .......... .......... .......... .......... .......... [ 491.8KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [ 748.4KB/s]\n    [ 0%] .......... .......... .......... .......... .......... [1007.5KB/s]\n    略\n    [ 1%] .......... ........... .......... .......... .......... [2509.3KB/s]\n    [ 1%] .......... .......... .......... .......... .......... [2509.5KB/s]\n    [ 1%] .......... .......... .......... ....\n    Downloaded 45.3 megabytes in 18 seconds. (2510.95 KB/s)\n    中止下载，进度已经到1%，下载了45.3mb\n```\n\n- 再次运行下载命令，继续从1%断点续传\n\n```\n    # axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    File size: 4353378304 bytes\n    Opening output file CentOS-6.4-x86_64-bin-DVD1.iso\n    State file found: 47549233 bytes downloaded, 4305829071 to go.\n    Starting download\n            ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,...... .......... [ 314.4KB/s]\n    [ 1%] .......... .......... .......... .......... .......... [ 603.0KB/s]\n    [ 1%] .......... .......... .......... .......... .......... [ 839.7KB/s]\n                   略\n    [ 1%] .......... .......... .......... .......... .......... [1547.1KB/s]\n    [ 1%] .......... .......... .......... .......... .......... [1548.8KB/s]\n    # rm -f CentOS-6.4-x86_64-bin-DVD1.iso*\n```\n\n#### wget\n\n```\n    # wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    --2013-03-11 09:51:46-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Connecting to 10.0.251.154:80... connected.\n    HTTP request sent, awaiting response... 200 OK\n    Length: 4353378304 (4.1G) [application/octet-stream]\n    Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso'\n     1% [                                                                               ] 47,760,647 1.49M/s eta 47m 42s\n```\n\n- wget在进度1%中止已经下载47,760,647，再次运行命令，重新开始下载\n\n```\n    # wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    --2013-03-11 09:53:24-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Connecting to 10.0.251.154:80... connected.\n    HTTP request sent, awaiting response... 200 OK\n    Length: 4353378304 (4.1G) [application/octet-stream]\n    Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso.1'\n     0% [                                                                               ] 1,032,445   1.21M/s\n```\n\n- wget直接运行不支持断点续传\n\n`# rm -f CentOS-6.4-x86_64-bin-DVD1.iso*`\n\n- wget重新测试使其支持断点续传\n\n`# wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso`\n\n```\n    --2013-03-11 12:40:15-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Connecting to 10.0.251.154:80... connected.\n    HTTP request sent, awaiting response... 200 OK\n    Length: 4353378304 (4.1G) [application/octet-stream]\n    Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso'\n     1% [>                                                                                          ] 52,620,206  1.57M/s eta 44m 58s\n    在进度1%，已经下载52,620,206处停止\n```\n\n- wget 加-c再次下载，支持断点续传\n\n```\n    # wget -c http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    --2013-03-11 12:40:56-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Connecting to 10.0.251.154:80... connected.\n    HTTP request sent, awaiting response... 206 Partial Content\n    Length: 4353378304 (4.1G), 4300661972 (4.0G) remaining [application/octet-stream]\n    Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso'\n     1% [+                                                                                          ] 59,663,080 1.59M/s eta 44m 14s\n    # rm -f CentOS-6.4-x86_64-bin-DVD1.iso.mg\\!\n```\n\n4.3 myget\n\n```\n    # mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso\n    Filesize: 4.1G\n     1% [                       >                       >                        >                        ] [ 45M] [2.1M/s] [ETA:33:06]\n    下载进度到1% 文件大小45M\n    # ll CentOS-6.4-x86_64-bin-DVD1.iso.mg\\!\n    -rw-r--r-- 1 root root 4353378404 Mar 11 12:54 CentOS-6.4-x86_64-bin-DVD1.iso.mg!\n    再次执行命令，直接从进度1%开始下载\n    # mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso\n    Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso\n    Filesize: 4.1G\n     1% [                       >                       >                        >                        ] [ 51M] [2.9M/s] [ETA:23:57]\n```\n\n**断点续传对比，三个工具都支持，但wget需要增加-c参数，axel、myget再次执行命令即可。\n综上对比推荐大家工作中使用axel或myget提高效率，个人比较喜欢axel。\n注意内网传输根据隧道带宽进行限速，别影响线上生产服务数据传输。**\n\n### aria2c (The ultra fast download utility)\n\n强烈推荐这个下载工具，可以说是 linux 下的下载神器，速度比 windows 下的迅雷还要快不少。aria2c 并不仅是一个简单的下载工具，里面配置选项相当多，另外也有不少 GUI 工具支持 aria2c 这边不做详细的介绍，具体可以参考本博客中的 Aria2 详解这篇文章。\n\n\n*未完待续*\n\n> 相关链接：\n> http://dreamway.blog.51cto.com/1281816/1151886 (centos版本)\n> http://sydi.org/posts/linux/aria2c-usage-sample-cns.html\n","slug":"2016/2016-06-29-linux下的下载","published":1,"updated":"2017-01-12T02:52:23.163Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aga000emumux3blqlro","content":"<p>linux命令行下载外网文件或内网进行大文件传输，经常使用的文本下载工具wget、curl，今天给大家推荐支持Linux命令行多线程、断点续传下载工具axel和myget。</p>\n<h3 id=\"系统环境\"><a href=\"#系统环境\" class=\"headerlink\" title=\"系统环境\"></a>系统环境</h3><h4 id=\"Linux系统如何查看版本信息\"><a href=\"#Linux系统如何查看版本信息\" class=\"headerlink\" title=\"Linux系统如何查看版本信息\"></a>Linux系统如何查看版本信息</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">输入&quot;uname -a &quot;,可显示电脑以及操作系统的相关信息。</div><div class=\"line\">Linux系统如何查看版本信息</div><div class=\"line\">输入&quot;cat /proc/version&quot;,说明正在运行的内核版本。</div><div class=\"line\">Linux系统如何查看版本信息</div><div class=\"line\">输入&quot;cat /etc/issue&quot;, 显示的是发行版本信息</div><div class=\"line\">Linux系统如何查看版本信息</div><div class=\"line\">lsb_release -a (适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)</div><div class=\"line\">Linux系统如何查看版本信息</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h4 id=\"查看本机的信息\"><a href=\"#查看本机的信息\" class=\"headerlink\" title=\"查看本机的信息\"></a>查看本机的信息</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># lsb_release -a(适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)</div><div class=\"line\">Distributor ID:\tUbuntu</div><div class=\"line\">Description:\tUbuntu 16.04 LTS</div><div class=\"line\">Release:\t16.04</div><div class=\"line\">Codename:\txenial</div></pre></td></tr></table></figure>\n<h3 id=\"下载工具安装、使用方法介绍\"><a href=\"#下载工具安装、使用方法介绍\" class=\"headerlink\" title=\"下载工具安装、使用方法介绍\"></a>下载工具安装、使用方法介绍</h3><h4 id=\"wget\"><a href=\"#wget\" class=\"headerlink\" title=\"wget\"></a>wget</h4><ul>\n<li>ubuntu安装请运行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"># sudo apt-get install wget</div><div class=\"line\">wget版本信息</div><div class=\"line\"># wget -V</div><div class=\"line\">GNU Wget 1.17.1 built on linux-gnu.</div></pre></td></tr></table></figure>\n<ul>\n<li>此工具比较常用，使用方法、参数略</li>\n</ul>\n<h4 id=\"Axel-下载-安装\"><a href=\"#Axel-下载-安装\" class=\"headerlink\" title=\"Axel 下载 安装\"></a>Axel 下载 安装</h4><ul>\n<li>官方站点<a href=\"http://axel.alioth.debian.org/\" target=\"_blank\" rel=\"external\">http://axel.alioth.debian.org/</a></li>\n<li>安装axel</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># sudo apt-get install axel</div><div class=\"line\">axel版本</div><div class=\"line\"># axel -V</div><div class=\"line\">Axel version 2.5 (Linux)</div><div class=\"line\"></div><div class=\"line\">Copyright 2001-2007 Wilmer van der Gaast,</div><div class=\"line\">          2015      Joao Eriberto Mota Filho,</div><div class=\"line\">                    and others.</div><div class=\"line\">Please, see the CREDITS file.</div></pre></td></tr></table></figure>\n<ul>\n<li>axel命令使用方法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">axel [选项参数] url1 [url2] [url……]</div><div class=\"line\">axel 参数：</div><div class=\"line\">--max-speed=x    #限速值最高速度</div><div class=\"line\"> -s x</div><div class=\"line\">Specify maximum speed (bytes per second)</div><div class=\"line\"> --num-connections=x</div><div class=\"line\"> -n x #连接数</div><div class=\"line\">Specify maximum number of connections</div><div class=\"line\"> --output=f #下载为本地文件</div><div class=\"line\"> -o f</div><div class=\"line\">Specify local output file</div><div class=\"line\"> --search[=x] #搜索镜像</div><div class=\"line\"> -S [x]</div><div class=\"line\">Search for mirrors and download from x servers</div><div class=\"line\"> --header=x  </div><div class=\"line\"> -H x     #添加头文件字符串</div><div class=\"line\">Add header string</div><div class=\"line\"> --user-agent=x #设置UA</div><div class=\"line\"> -U x  </div><div class=\"line\">Set user agent</div><div class=\"line\"> --no-proxy     #不使用代理服务器</div><div class=\"line\"> -N  </div><div class=\"line\">Just don&apos;t use any proxy server --quiet  </div><div class=\"line\"> --quiet, -q  </div><div class=\"line\">No output to stdout. #静默模式，不输出到标准输出  </div><div class=\"line\">--verbose  </div><div class=\"line\"> -v  </div><div class=\"line\">More status information #更多状态信息  </div><div class=\"line\"> --alternate  </div><div class=\"line\"> --help #帮助  </div><div class=\"line\"> -h  </div><div class=\"line\">--version #版本  </div><div class=\"line\"> -V</div></pre></td></tr></table></figure>\n<h4 id=\"myget-下载、安装\"><a href=\"#myget-下载、安装\" class=\"headerlink\" title=\"myget 下载、安装\"></a>myget 下载、安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://myget.sourceforge.net/release/myget-0.1.2.tar.gz</div><div class=\"line\">tar -zxvf myget-0.1.2.tar.gz</div><div class=\"line\">cd myget-0.1.2</div><div class=\"line\"># ./configure &amp;&amp; make &amp;&amp; make install</div><div class=\"line\">mytget版本，注意myget命令为mytget</div><div class=\"line\"># mytget -v</div><div class=\"line\">myget 0.1.1</div></pre></td></tr></table></figure>\n<ul>\n<li>命令mytget用法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">mytget [选项] [url]</div><div class=\"line\">参数</div><div class=\"line\"> -b, --debug          Show the debug message #看调试信息</div><div class=\"line\"> -c, --count=num      Set the retry count to [num], no limit when &quot;0&quot;, the default is &quot;99&quot; #设置重试次数，0为无限，默认是99次。</div><div class=\"line\"> -d, --directory=dir Set the local direcotry to [dir], the default is &quot;.&quot; #指定下载本地目录，默认是当前目录</div><div class=\"line\"> -f, --file=file      Rename the file to [file] #重命名下载到本地的文件名</div><div class=\"line\"> -h, --help           A brief summary of all the options #简短的帮助摘要</div><div class=\"line\"> -i, --interval=num   Set the ftp retry interval to [num] seconds, the default is &quot;5&quot; #设置ftp重试间隔，单位s，默认5秒</div><div class=\"line\"> -n, --number=num     Use [num] connections instead of the default (4) #指定连接数，默认4</div><div class=\"line\"> -r, --referer=URL    Include `Referer: [URL]&apos; header in HTTP request. #包含请求头 Referer</div><div class=\"line\"> -t, --timeout=num    Set the connection timeout to [num] seconds, the default is &quot;30&quot; #设置连接超时时间，默认30秒</div><div class=\"line\"> -v, --version        Show the version of the myget and exit #查看版本信息</div><div class=\"line\"> -x, --proxy=URL      Set the proxy [URL]  #设置代理</div></pre></td></tr></table></figure>\n<h3 id=\"wget、axel、myget测试下载速度对比\"><a href=\"#wget、axel、myget测试下载速度对比\" class=\"headerlink\" title=\"wget、axel、myget测试下载速度对比\"></a>wget、axel、myget测试下载速度对比</h3><h4 id=\"下载速度对比\"><a href=\"#下载速度对比\" class=\"headerlink\" title=\"下载速度对比\"></a>下载速度对比</h4><p>说明：同一台机器下载同一个数据源链接</p>\n<ul>\n<li>wget下载</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">--2013-03-11 09:29:46-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Connecting to 10.0.251.154:80... connected.</div><div class=\"line\">HTTP request sent, awaiting response... 200 OK</div><div class=\"line\">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class=\"line\">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso&apos;</div></pre></td></tr></table></figure>\n<ul>\n<li>axel下载</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"># axel http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">File size: 4353378304 bytes</div><div class=\"line\">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso.0</div><div class=\"line\">Starting download</div><div class=\"line\"></div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 382.3KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 610.9KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 826.5KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [1003.1KB/s]</div><div class=\"line\">略</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [2055.8KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [2074.8KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [2093.6KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [2111.0KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... ...</div><div class=\"line\">Downloaded 2693.8 kilobytes in 1 second. (2113.05 KB/s)</div><div class=\"line\"># rm -f CentOS-6.4-x86_64-bin-DVD1.iso*</div></pre></td></tr></table></figure>\n<ul>\n<li>axel  使用10个线程下载</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"># axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">File size: 4353378304 bytes</div><div class=\"line\">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Starting download</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 440.9KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 707.9KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 935.1KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [1138.8KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [1310.5KB/s]</div><div class=\"line\">略</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [2180.3KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [2196.9KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [2189.7KB/s]</div><div class=\"line\">[ 0%] .......... .......... .........</div><div class=\"line\">Downloaded 4139.5 kilobytes in 1 second. (2176.65 KB/s)</div></pre></td></tr></table></figure>\n<h4 id=\"myget下载\"><a href=\"#myget下载\" class=\"headerlink\" title=\"myget下载\"></a>myget下载</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"># mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Filesize: 4.1G</div><div class=\"line\"> 0% [                       &gt;                       &gt;                       &gt;                         ] [ 27M] [2.5M/s] [ETA:26:58]</div></pre></td></tr></table></figure>\n<ul>\n<li>myget指定10个线程下载</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># mytget -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Filesize: 4.1G</div><div class=\"line\"> 0% [        &gt;         &gt;         &gt;        &gt;         &gt;         &gt;        &gt;         &gt;         &gt;          ] [ 39M] [2.6M/s] [ETA:26:27]</div><div class=\"line\"># ll CentOS-6.4-x86_64-bin-DVD1.iso.mg\\!</div><div class=\"line\">-rw-r--r-- 1 root root 4353378404 Mar 11 12:53 CentOS-6.4-x86_64-bin-DVD1.iso.mg!</div><div class=\"line\">下载速度对比结论：axel、myget支持多线程，且速度较快都在2M。</div></pre></td></tr></table></figure>\n<h3 id=\"断点续传对比测试\"><a href=\"#断点续传对比测试\" class=\"headerlink\" title=\"断点续传对比测试\"></a>断点续传对比测试</h3><h4 id=\"axel\"><a href=\"#axel\" class=\"headerlink\" title=\"axel\"></a>axel</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"># axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">File size: 4353378304 bytes</div><div class=\"line\">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Starting download</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 491.8KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 748.4KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [1007.5KB/s]</div><div class=\"line\">略</div><div class=\"line\">[ 1%] .......... ........... .......... .......... .......... [2509.3KB/s]</div><div class=\"line\">[ 1%] .......... .......... .......... .......... .......... [2509.5KB/s]</div><div class=\"line\">[ 1%] .......... .......... .......... ....</div><div class=\"line\">Downloaded 45.3 megabytes in 18 seconds. (2510.95 KB/s)</div><div class=\"line\">中止下载，进度已经到1%，下载了45.3mb</div></pre></td></tr></table></figure>\n<ul>\n<li>再次运行下载命令，继续从1%断点续传</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"># axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">File size: 4353378304 bytes</div><div class=\"line\">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">State file found: 47549233 bytes downloaded, 4305829071 to go.</div><div class=\"line\">Starting download</div><div class=\"line\">        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,...... .......... [ 314.4KB/s]</div><div class=\"line\">[ 1%] .......... .......... .......... .......... .......... [ 603.0KB/s]</div><div class=\"line\">[ 1%] .......... .......... .......... .......... .......... [ 839.7KB/s]</div><div class=\"line\">               略</div><div class=\"line\">[ 1%] .......... .......... .......... .......... .......... [1547.1KB/s]</div><div class=\"line\">[ 1%] .......... .......... .......... .......... .......... [1548.8KB/s]</div><div class=\"line\"># rm -f CentOS-6.4-x86_64-bin-DVD1.iso*</div></pre></td></tr></table></figure>\n<h4 id=\"wget-1\"><a href=\"#wget-1\" class=\"headerlink\" title=\"wget\"></a>wget</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">--2013-03-11 09:51:46-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Connecting to 10.0.251.154:80... connected.</div><div class=\"line\">HTTP request sent, awaiting response... 200 OK</div><div class=\"line\">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class=\"line\">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso&apos;</div><div class=\"line\"> 1% [                                                                               ] 47,760,647 1.49M/s eta 47m 42s</div></pre></td></tr></table></figure>\n<ul>\n<li>wget在进度1%中止已经下载47,760,647，再次运行命令，重新开始下载</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">--2013-03-11 09:53:24-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Connecting to 10.0.251.154:80... connected.</div><div class=\"line\">HTTP request sent, awaiting response... 200 OK</div><div class=\"line\">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class=\"line\">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso.1&apos;</div><div class=\"line\"> 0% [                                                                               ] 1,032,445   1.21M/s</div></pre></td></tr></table></figure>\n<ul>\n<li>wget直接运行不支持断点续传</li>\n</ul>\n<p><code># rm -f CentOS-6.4-x86_64-bin-DVD1.iso*</code></p>\n<ul>\n<li>wget重新测试使其支持断点续传</li>\n</ul>\n<p><code># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">--2013-03-11 12:40:15-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Connecting to 10.0.251.154:80... connected.</div><div class=\"line\">HTTP request sent, awaiting response... 200 OK</div><div class=\"line\">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class=\"line\">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso&apos;</div><div class=\"line\"> 1% [&gt;                                                                                          ] 52,620,206  1.57M/s eta 44m 58s</div><div class=\"line\">在进度1%，已经下载52,620,206处停止</div></pre></td></tr></table></figure>\n<ul>\n<li>wget 加-c再次下载，支持断点续传</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"># wget -c http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">--2013-03-11 12:40:56-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Connecting to 10.0.251.154:80... connected.</div><div class=\"line\">HTTP request sent, awaiting response... 206 Partial Content</div><div class=\"line\">Length: 4353378304 (4.1G), 4300661972 (4.0G) remaining [application/octet-stream]</div><div class=\"line\">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso&apos;</div><div class=\"line\"> 1% [+                                                                                          ] 59,663,080 1.59M/s eta 44m 14s</div><div class=\"line\"># rm -f CentOS-6.4-x86_64-bin-DVD1.iso.mg\\!</div></pre></td></tr></table></figure>\n<p>4.3 myget</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"># mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Filesize: 4.1G</div><div class=\"line\"> 1% [                       &gt;                       &gt;                        &gt;                        ] [ 45M] [2.1M/s] [ETA:33:06]</div><div class=\"line\">下载进度到1% 文件大小45M</div><div class=\"line\"># ll CentOS-6.4-x86_64-bin-DVD1.iso.mg\\!</div><div class=\"line\">-rw-r--r-- 1 root root 4353378404 Mar 11 12:54 CentOS-6.4-x86_64-bin-DVD1.iso.mg!</div><div class=\"line\">再次执行命令，直接从进度1%开始下载</div><div class=\"line\"># mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Filesize: 4.1G</div><div class=\"line\"> 1% [                       &gt;                       &gt;                        &gt;                        ] [ 51M] [2.9M/s] [ETA:23:57]</div></pre></td></tr></table></figure>\n<p><strong>断点续传对比，三个工具都支持，但wget需要增加-c参数，axel、myget再次执行命令即可。<br>综上对比推荐大家工作中使用axel或myget提高效率，个人比较喜欢axel。<br>注意内网传输根据隧道带宽进行限速，别影响线上生产服务数据传输。</strong></p>\n<h3 id=\"aria2c-The-ultra-fast-download-utility\"><a href=\"#aria2c-The-ultra-fast-download-utility\" class=\"headerlink\" title=\"aria2c (The ultra fast download utility)\"></a>aria2c (The ultra fast download utility)</h3><p>强烈推荐这个下载工具，可以说是 linux 下的下载神器，速度比 windows 下的迅雷还要快不少。aria2c 并不仅是一个简单的下载工具，里面配置选项相当多，另外也有不少 GUI 工具支持 aria2c 这边不做详细的介绍，具体可以参考本博客中的 Aria2 详解这篇文章。</p>\n<p><em>未完待续</em></p>\n<blockquote>\n<p>相关链接：<br><a href=\"http://dreamway.blog.51cto.com/1281816/1151886\" target=\"_blank\" rel=\"external\">http://dreamway.blog.51cto.com/1281816/1151886</a> (centos版本)<br><a href=\"http://sydi.org/posts/linux/aria2c-usage-sample-cns.html\" target=\"_blank\" rel=\"external\">http://sydi.org/posts/linux/aria2c-usage-sample-cns.html</a></p>\n</blockquote>\n","excerpt":"<p>linux命令行下载外网文件或内网进行大文件传输，经常使用的文本下载工具wget、curl，今天给大家推荐支持Linux命令行多线程、断点续传下载工具axel和myget。</p>\n<h3 id=\"系统环境\"><a href=\"#系统环境\" class=\"headerlink\" title=\"系统环境\"></a>系统环境</h3><h4 id=\"Linux系统如何查看版本信息\"><a href=\"#Linux系统如何查看版本信息\" class=\"headerlink\" title=\"Linux系统如何查看版本信息\"></a>Linux系统如何查看版本信息</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">输入&quot;uname -a &quot;,可显示电脑以及操作系统的相关信息。</div><div class=\"line\">Linux系统如何查看版本信息</div><div class=\"line\">输入&quot;cat /proc/version&quot;,说明正在运行的内核版本。</div><div class=\"line\">Linux系统如何查看版本信息</div><div class=\"line\">输入&quot;cat /etc/issue&quot;, 显示的是发行版本信息</div><div class=\"line\">Linux系统如何查看版本信息</div><div class=\"line\">lsb_release -a (适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)</div><div class=\"line\">Linux系统如何查看版本信息</div></pre></td></tr></table></figure>","more":"<h4 id=\"查看本机的信息\"><a href=\"#查看本机的信息\" class=\"headerlink\" title=\"查看本机的信息\"></a>查看本机的信息</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># lsb_release -a(适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)</div><div class=\"line\">Distributor ID:\tUbuntu</div><div class=\"line\">Description:\tUbuntu 16.04 LTS</div><div class=\"line\">Release:\t16.04</div><div class=\"line\">Codename:\txenial</div></pre></td></tr></table></figure>\n<h3 id=\"下载工具安装、使用方法介绍\"><a href=\"#下载工具安装、使用方法介绍\" class=\"headerlink\" title=\"下载工具安装、使用方法介绍\"></a>下载工具安装、使用方法介绍</h3><h4 id=\"wget\"><a href=\"#wget\" class=\"headerlink\" title=\"wget\"></a>wget</h4><ul>\n<li>ubuntu安装请运行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"># sudo apt-get install wget</div><div class=\"line\">wget版本信息</div><div class=\"line\"># wget -V</div><div class=\"line\">GNU Wget 1.17.1 built on linux-gnu.</div></pre></td></tr></table></figure>\n<ul>\n<li>此工具比较常用，使用方法、参数略</li>\n</ul>\n<h4 id=\"Axel-下载-安装\"><a href=\"#Axel-下载-安装\" class=\"headerlink\" title=\"Axel 下载 安装\"></a>Axel 下载 安装</h4><ul>\n<li>官方站点<a href=\"http://axel.alioth.debian.org/\">http://axel.alioth.debian.org/</a></li>\n<li>安装axel</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># sudo apt-get install axel</div><div class=\"line\">axel版本</div><div class=\"line\"># axel -V</div><div class=\"line\">Axel version 2.5 (Linux)</div><div class=\"line\"></div><div class=\"line\">Copyright 2001-2007 Wilmer van der Gaast,</div><div class=\"line\">          2015      Joao Eriberto Mota Filho,</div><div class=\"line\">                    and others.</div><div class=\"line\">Please, see the CREDITS file.</div></pre></td></tr></table></figure>\n<ul>\n<li>axel命令使用方法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">axel [选项参数] url1 [url2] [url……]</div><div class=\"line\">axel 参数：</div><div class=\"line\">--max-speed=x    #限速值最高速度</div><div class=\"line\"> -s x</div><div class=\"line\">Specify maximum speed (bytes per second)</div><div class=\"line\"> --num-connections=x</div><div class=\"line\"> -n x #连接数</div><div class=\"line\">Specify maximum number of connections</div><div class=\"line\"> --output=f #下载为本地文件</div><div class=\"line\"> -o f</div><div class=\"line\">Specify local output file</div><div class=\"line\"> --search[=x] #搜索镜像</div><div class=\"line\"> -S [x]</div><div class=\"line\">Search for mirrors and download from x servers</div><div class=\"line\"> --header=x  </div><div class=\"line\"> -H x     #添加头文件字符串</div><div class=\"line\">Add header string</div><div class=\"line\"> --user-agent=x #设置UA</div><div class=\"line\"> -U x  </div><div class=\"line\">Set user agent</div><div class=\"line\"> --no-proxy     #不使用代理服务器</div><div class=\"line\"> -N  </div><div class=\"line\">Just don&apos;t use any proxy server --quiet  </div><div class=\"line\"> --quiet, -q  </div><div class=\"line\">No output to stdout. #静默模式，不输出到标准输出  </div><div class=\"line\">--verbose  </div><div class=\"line\"> -v  </div><div class=\"line\">More status information #更多状态信息  </div><div class=\"line\"> --alternate  </div><div class=\"line\"> --help #帮助  </div><div class=\"line\"> -h  </div><div class=\"line\">--version #版本  </div><div class=\"line\"> -V</div></pre></td></tr></table></figure>\n<h4 id=\"myget-下载、安装\"><a href=\"#myget-下载、安装\" class=\"headerlink\" title=\"myget 下载、安装\"></a>myget 下载、安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://myget.sourceforge.net/release/myget-0.1.2.tar.gz</div><div class=\"line\">tar -zxvf myget-0.1.2.tar.gz</div><div class=\"line\">cd myget-0.1.2</div><div class=\"line\"># ./configure &amp;&amp; make &amp;&amp; make install</div><div class=\"line\">mytget版本，注意myget命令为mytget</div><div class=\"line\"># mytget -v</div><div class=\"line\">myget 0.1.1</div></pre></td></tr></table></figure>\n<ul>\n<li>命令mytget用法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">mytget [选项] [url]</div><div class=\"line\">参数</div><div class=\"line\"> -b, --debug          Show the debug message #看调试信息</div><div class=\"line\"> -c, --count=num      Set the retry count to [num], no limit when &quot;0&quot;, the default is &quot;99&quot; #设置重试次数，0为无限，默认是99次。</div><div class=\"line\"> -d, --directory=dir Set the local direcotry to [dir], the default is &quot;.&quot; #指定下载本地目录，默认是当前目录</div><div class=\"line\"> -f, --file=file      Rename the file to [file] #重命名下载到本地的文件名</div><div class=\"line\"> -h, --help           A brief summary of all the options #简短的帮助摘要</div><div class=\"line\"> -i, --interval=num   Set the ftp retry interval to [num] seconds, the default is &quot;5&quot; #设置ftp重试间隔，单位s，默认5秒</div><div class=\"line\"> -n, --number=num     Use [num] connections instead of the default (4) #指定连接数，默认4</div><div class=\"line\"> -r, --referer=URL    Include `Referer: [URL]&apos; header in HTTP request. #包含请求头 Referer</div><div class=\"line\"> -t, --timeout=num    Set the connection timeout to [num] seconds, the default is &quot;30&quot; #设置连接超时时间，默认30秒</div><div class=\"line\"> -v, --version        Show the version of the myget and exit #查看版本信息</div><div class=\"line\"> -x, --proxy=URL      Set the proxy [URL]  #设置代理</div></pre></td></tr></table></figure>\n<h3 id=\"wget、axel、myget测试下载速度对比\"><a href=\"#wget、axel、myget测试下载速度对比\" class=\"headerlink\" title=\"wget、axel、myget测试下载速度对比\"></a>wget、axel、myget测试下载速度对比</h3><h4 id=\"下载速度对比\"><a href=\"#下载速度对比\" class=\"headerlink\" title=\"下载速度对比\"></a>下载速度对比</h4><p>说明：同一台机器下载同一个数据源链接</p>\n<ul>\n<li>wget下载</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">--2013-03-11 09:29:46-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Connecting to 10.0.251.154:80... connected.</div><div class=\"line\">HTTP request sent, awaiting response... 200 OK</div><div class=\"line\">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class=\"line\">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso&apos;</div></pre></td></tr></table></figure>\n<ul>\n<li>axel下载</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"># axel http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">File size: 4353378304 bytes</div><div class=\"line\">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso.0</div><div class=\"line\">Starting download</div><div class=\"line\"></div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 382.3KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 610.9KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 826.5KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [1003.1KB/s]</div><div class=\"line\">略</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [2055.8KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [2074.8KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [2093.6KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [2111.0KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... ...</div><div class=\"line\">Downloaded 2693.8 kilobytes in 1 second. (2113.05 KB/s)</div><div class=\"line\"># rm -f CentOS-6.4-x86_64-bin-DVD1.iso*</div></pre></td></tr></table></figure>\n<ul>\n<li>axel  使用10个线程下载</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"># axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">File size: 4353378304 bytes</div><div class=\"line\">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Starting download</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 440.9KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 707.9KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 935.1KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [1138.8KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [1310.5KB/s]</div><div class=\"line\">略</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [2180.3KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [2196.9KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [2189.7KB/s]</div><div class=\"line\">[ 0%] .......... .......... .........</div><div class=\"line\">Downloaded 4139.5 kilobytes in 1 second. (2176.65 KB/s)</div></pre></td></tr></table></figure>\n<h4 id=\"myget下载\"><a href=\"#myget下载\" class=\"headerlink\" title=\"myget下载\"></a>myget下载</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"># mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Filesize: 4.1G</div><div class=\"line\"> 0% [                       &gt;                       &gt;                       &gt;                         ] [ 27M] [2.5M/s] [ETA:26:58]</div></pre></td></tr></table></figure>\n<ul>\n<li>myget指定10个线程下载</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># mytget -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Filesize: 4.1G</div><div class=\"line\"> 0% [        &gt;         &gt;         &gt;        &gt;         &gt;         &gt;        &gt;         &gt;         &gt;          ] [ 39M] [2.6M/s] [ETA:26:27]</div><div class=\"line\"># ll CentOS-6.4-x86_64-bin-DVD1.iso.mg\\!</div><div class=\"line\">-rw-r--r-- 1 root root 4353378404 Mar 11 12:53 CentOS-6.4-x86_64-bin-DVD1.iso.mg!</div><div class=\"line\">下载速度对比结论：axel、myget支持多线程，且速度较快都在2M。</div></pre></td></tr></table></figure>\n<h3 id=\"断点续传对比测试\"><a href=\"#断点续传对比测试\" class=\"headerlink\" title=\"断点续传对比测试\"></a>断点续传对比测试</h3><h4 id=\"axel\"><a href=\"#axel\" class=\"headerlink\" title=\"axel\"></a>axel</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"># axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">File size: 4353378304 bytes</div><div class=\"line\">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Starting download</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 491.8KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [ 748.4KB/s]</div><div class=\"line\">[ 0%] .......... .......... .......... .......... .......... [1007.5KB/s]</div><div class=\"line\">略</div><div class=\"line\">[ 1%] .......... ........... .......... .......... .......... [2509.3KB/s]</div><div class=\"line\">[ 1%] .......... .......... .......... .......... .......... [2509.5KB/s]</div><div class=\"line\">[ 1%] .......... .......... .......... ....</div><div class=\"line\">Downloaded 45.3 megabytes in 18 seconds. (2510.95 KB/s)</div><div class=\"line\">中止下载，进度已经到1%，下载了45.3mb</div></pre></td></tr></table></figure>\n<ul>\n<li>再次运行下载命令，继续从1%断点续传</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"># axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">File size: 4353378304 bytes</div><div class=\"line\">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">State file found: 47549233 bytes downloaded, 4305829071 to go.</div><div class=\"line\">Starting download</div><div class=\"line\">        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,...... .......... [ 314.4KB/s]</div><div class=\"line\">[ 1%] .......... .......... .......... .......... .......... [ 603.0KB/s]</div><div class=\"line\">[ 1%] .......... .......... .......... .......... .......... [ 839.7KB/s]</div><div class=\"line\">               略</div><div class=\"line\">[ 1%] .......... .......... .......... .......... .......... [1547.1KB/s]</div><div class=\"line\">[ 1%] .......... .......... .......... .......... .......... [1548.8KB/s]</div><div class=\"line\"># rm -f CentOS-6.4-x86_64-bin-DVD1.iso*</div></pre></td></tr></table></figure>\n<h4 id=\"wget-1\"><a href=\"#wget-1\" class=\"headerlink\" title=\"wget\"></a>wget</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">--2013-03-11 09:51:46-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Connecting to 10.0.251.154:80... connected.</div><div class=\"line\">HTTP request sent, awaiting response... 200 OK</div><div class=\"line\">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class=\"line\">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso&apos;</div><div class=\"line\"> 1% [                                                                               ] 47,760,647 1.49M/s eta 47m 42s</div></pre></td></tr></table></figure>\n<ul>\n<li>wget在进度1%中止已经下载47,760,647，再次运行命令，重新开始下载</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">--2013-03-11 09:53:24-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Connecting to 10.0.251.154:80... connected.</div><div class=\"line\">HTTP request sent, awaiting response... 200 OK</div><div class=\"line\">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class=\"line\">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso.1&apos;</div><div class=\"line\"> 0% [                                                                               ] 1,032,445   1.21M/s</div></pre></td></tr></table></figure>\n<ul>\n<li>wget直接运行不支持断点续传</li>\n</ul>\n<p><code># rm -f CentOS-6.4-x86_64-bin-DVD1.iso*</code></p>\n<ul>\n<li>wget重新测试使其支持断点续传</li>\n</ul>\n<p><code># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">--2013-03-11 12:40:15-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Connecting to 10.0.251.154:80... connected.</div><div class=\"line\">HTTP request sent, awaiting response... 200 OK</div><div class=\"line\">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class=\"line\">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso&apos;</div><div class=\"line\"> 1% [&gt;                                                                                          ] 52,620,206  1.57M/s eta 44m 58s</div><div class=\"line\">在进度1%，已经下载52,620,206处停止</div></pre></td></tr></table></figure>\n<ul>\n<li>wget 加-c再次下载，支持断点续传</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"># wget -c http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">--2013-03-11 12:40:56-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Connecting to 10.0.251.154:80... connected.</div><div class=\"line\">HTTP request sent, awaiting response... 206 Partial Content</div><div class=\"line\">Length: 4353378304 (4.1G), 4300661972 (4.0G) remaining [application/octet-stream]</div><div class=\"line\">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso&apos;</div><div class=\"line\"> 1% [+                                                                                          ] 59,663,080 1.59M/s eta 44m 14s</div><div class=\"line\"># rm -f CentOS-6.4-x86_64-bin-DVD1.iso.mg\\!</div></pre></td></tr></table></figure>\n<p>4.3 myget</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"># mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Filesize: 4.1G</div><div class=\"line\"> 1% [                       &gt;                       &gt;                        &gt;                        ] [ 45M] [2.1M/s] [ETA:33:06]</div><div class=\"line\">下载进度到1% 文件大小45M</div><div class=\"line\"># ll CentOS-6.4-x86_64-bin-DVD1.iso.mg\\!</div><div class=\"line\">-rw-r--r-- 1 root root 4353378404 Mar 11 12:54 CentOS-6.4-x86_64-bin-DVD1.iso.mg!</div><div class=\"line\">再次执行命令，直接从进度1%开始下载</div><div class=\"line\"># mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso</div><div class=\"line\">Filesize: 4.1G</div><div class=\"line\"> 1% [                       &gt;                       &gt;                        &gt;                        ] [ 51M] [2.9M/s] [ETA:23:57]</div></pre></td></tr></table></figure>\n<p><strong>断点续传对比，三个工具都支持，但wget需要增加-c参数，axel、myget再次执行命令即可。<br>综上对比推荐大家工作中使用axel或myget提高效率，个人比较喜欢axel。<br>注意内网传输根据隧道带宽进行限速，别影响线上生产服务数据传输。</strong></p>\n<h3 id=\"aria2c-The-ultra-fast-download-utility\"><a href=\"#aria2c-The-ultra-fast-download-utility\" class=\"headerlink\" title=\"aria2c (The ultra fast download utility)\"></a>aria2c (The ultra fast download utility)</h3><p>强烈推荐这个下载工具，可以说是 linux 下的下载神器，速度比 windows 下的迅雷还要快不少。aria2c 并不仅是一个简单的下载工具，里面配置选项相当多，另外也有不少 GUI 工具支持 aria2c 这边不做详细的介绍，具体可以参考本博客中的 Aria2 详解这篇文章。</p>\n<p><em>未完待续</em></p>\n<blockquote>\n<p>相关链接：<br><a href=\"http://dreamway.blog.51cto.com/1281816/1151886\">http://dreamway.blog.51cto.com/1281816/1151886</a> (centos版本)<br><a href=\"http://sydi.org/posts/linux/aria2c-usage-sample-cns.html\">http://sydi.org/posts/linux/aria2c-usage-sample-cns.html</a></p>\n</blockquote>"},{"layout":"post","title":"u盘安装XP系统","date":"2016-06-30T10:12:00.000Z","_content":"\n> **如果仅需要优盘安装XP可以直接查看Windows XP安装部分**\n\n\n\n### 1.Why XP?\n\nwindows XP 这个系统微软早已停止服务了，一般现在也不再会有人会想着安装这个系统了。作为已经安装过各种系统多次的人而言，老实说我也只有最初不太懂电脑的中学时候用过XP，自从09年win7出来后，就开始转战 win7 了，个人写这篇文章主要出于以下几种原因：\n- 这个系统相当稳定，占用资源很少，可以作为老旧机器的不二选择。\n- 个人工作学习完全使用 Ubuntu 系统了，时不时会用 windows 平台下面的软件如：迅雷，百度云，photoshop 等，现在机器性能强劲，virtualbox 下的 xp 运行这些中小型软件完全没任何问题。\n- XP 安装与其他软件比较为特殊，通过文章的总结，下次便于参考。\n\n<!-- more -->\n\n#### windows XP简介：\nWindows XP，是微软公司（Microsoft）推出的供个人电脑使用的操作系统，包括商用及家用的台式电脑等。Windows XP率先使用双列菜单，为之后的Windows 版本的开始菜单提供了基础。其名字 \"XP\" 的意思是英文中的 \"体验（Experience）\"，现已退役，如果你在结束支持后继续使用 Windows XP，那么你的电脑仍可工作，但它可能更容易受到安全风险与病毒的攻击。\n\n*我们这边以纯净版的sp3中文专业版为例。*\n\n### 2.常规系统安装方法\n\n#### 2.1光驱安装\n\n以往的系统安装大多使用光驱安装，而电脑的 BIOS 引导项也都有光驱引导，但随着上网本，超极本等的流行，越来越多的电脑为了节省空间将光驱给去掉了。\n\n事实也是如此，光驱读取速度慢，且网络如此发达，现在很多厂家现在也都不再提供光盘，而是通过官方网站自行获取相关软件及驱动程序，或者直接提供优盘（优盘越来越廉价）。\n\n*光盘安装简单，但不作为本文的重点，以下将不会再涉及。*\n\n#### 2.2优盘安装\n\n##### 2.2.1windows下的PE安装方式\n\n大多数 windows 的产品都可以将优盘制作成一个 PE 启动盘，然后通过这个启动程序，引导需要安装的 ISO 文件，最终完成安装。\n\n###### 优点：\n\n- 通过 pe，在安装系统之前，可以执行相关备份，分区等操作。\n- 一次 pe 制作，下次可以重复反复使用，pe 一般通过软件制作在优盘中，很多都形成单独分区，不会影响优盘的正常使用。\n- 通过 pe 可以执行一些辅助的操作，可以将 pe 作为一个系统软件，即便不需要安装系统，可以通过 pe 做一些事情。\n\n###### 缺点：\n\n- 不同的 windows 系统，对应的 pe 不一样！！！没错确确实实不一样，例如： xp 的 pe 就基本上不可能帮你安装 win7 ，同样 win7 的 pe 也不可能让你安装的上 win10 或者 winXP 。\n- 现在 pe 越做越复杂，对于只需要安装系统的新手来说，弄清楚里面 ghost 安装，原版安装，优盘一键安装这都很费力。\n\n###### 小结：\n\n- pe 安装虽然可以解决大多数问题，但毕竟太过冗余，而且不同的系统安装还需要不同的PE，另外对于linux等其他系统也完全没办法解决。\n\n\n##### 2.2.2ultraISO制作u盘安装盘\n\n注意 ultraISO 并非一个免费的软件，且免费版本的功能极为有限，这边提供ultraISO大容量版安装程序：`http://pan.baidu.com/s/1hrXbQ7q`\n\n### 3.Windows XP安装\n\nxp的安装同以上安装略有不同，原因根据查找可能是xp本身系统是不完全支持优盘引导的，所以在制作优盘XP引导时，如果仅仅使用ultraISO是很可能无法成功的。如下图：\n\n[![7fcd28a57248aff4bd7b63fb5ae5bb7c.md.jpg](http://tc.ffsky.net/images/2016/07/01/7fcd28a57248aff4bd7b63fb5ae5bb7c.md.jpg)](http://tc.ffsky.net/image/Wbv)\n\n\n为了解决这个问题，我们通过另外一个软件 WinSetupFromUSB 来制作 XP 优盘引导。\n\n使用 WinSetupFromUSB 只需要下载一个 6.5MB 的绿色软件就可以制作好 windowsXP 的安装U盘，方便简捷。WinSetupFromUSB 不仅支持 WindowsXP 的，还支持 Win7/Vista 安装U盘的制作。\n\n#### 3.1准备工具：\n\n- 1G 以上 U 盘一枚，XP安装程序约为700M\n- WinSetupFromUSB 1.0 beta7：\n`http://pan.baidu.com/s/1geXdWyR`\n`http://download.csdn.net/detail/littlefang/3664196`\n- 下载 Windows XP 安装光盘或镜像：\n`http://pan.baidu.com/s/1bNeMp4`\n\n\n#### 3.2制作步骤：\n\n![b70b2a9e6f0757deb589cb07014d6402.jpg](http://tc.ffsky.net/images/2016/07/01/b70b2a9e6f0757deb589cb07014d6402.jpg)\n\n\n![b7d784d068cb293e6a74a5568ed9816e.jpg](http://tc.ffsky.net/images/2016/07/01/b7d784d068cb293e6a74a5568ed9816e.jpg)\n\n- 在 3 BootOption 栏目中选择 XP/BartPE bootable[NTLDR]，在 4 FILESYSTEM and OVERRIDES中选择 NTFS和BOOT as HDD，然后点击 6 Prepare Drive\n\n![c5c2a5552e243c750c972c552e7dba4b.jpg](http://tc.ffsky.net/images/2016/07/01/c5c2a5552e243c750c972c552e7dba4b.jpg)\n\n- 开始写入引导文件\n\n![1cc0d164d5c9fe753796104fce4c1e64.jpg](http://tc.ffsky.net/images/2016/07/01/1cc0d164d5c9fe753796104fce4c1e64.jpg)\n\n![d1574f68352799a6f217390b52ac4193.jpg](http://tc.ffsky.net/images/2016/07/01/d1574f68352799a6f217390b52ac4193.jpg)\n\n- 待窗口关闭后返回 RMPrepUSB 界面，点击 exit 退出\n\n![d041a1cd3f085fdf7ded088c6b3caa9e.jpg](http://tc.ffsky.net/images/2016/07/01/d041a1cd3f085fdf7ded088c6b3caa9e.jpg)\n\n- 指定安装文件路径回到 WinSetupFromUSB 主界面，选中 Windows 2000/XP/2003 Setup，指定安装盘所在盘符（I386文件夹的父目录），我使用虚拟光驱把xp的镜像加载到E盘。\n\n![5827c5290779337679ec2284a7fc5a69.jpg](http://tc.ffsky.net/images/2016/07/01/5827c5290779337679ec2284a7fc5a69.jpg)\n\n- 等待启动 U 盘制作完毕，这个过程极为漫长，参考资料说 10 分钟，但实际用了 40 分钟左右。\n\n![b1e63764034d7fbafbf04047718344ca.jpg](http://tc.ffsky.net/images/2016/07/01/b1e63764034d7fbafbf04047718344ca.jpg)\n\n- 完毕就绪\n\n![62656789586b865cd946fe922f35e9f5.jpg](http://tc.ffsky.net/images/2016/07/01/62656789586b865cd946fe922f35e9f5.jpg)\n\n#### 3.3安装步骤：\n\n- 开始安装系统，相关 bios 设置这边不详细列出，电脑的厂家不一样，设置也不相同，快速设置功能未必打开，全功能的 bios 设置一般台式机为 delete 按键，笔记本可能是 F2,F10,F12 等根据主板型号而定，修改 bios 主要是为了修改引导方式，电脑一般加载系统会从硬盘进行引导，如果你想从优盘或者光盘引导系统的话，就需要在 boot 中将优盘或者光盘放在最高的优先级（第一位）。这边我们因为使用优盘安装，所以将优盘放在最上面即可。注意：如果你电脑打开了快速设置，一般可以直接选择优盘进行引导，而如果你的电脑是 Lenovo 等在主板中启用了安全功能，则需要讲该功能关闭才可以修改 bios 的引导方式，另外 UEFI 模式这边也需要改成 BIOS/legacy 模式。\n\n- XP安装界面，如果是全新硬盘，需要分区等操作，先使用 winPE 等工具，安装位置选择 C 盘（主分区）默认选项安装即可。\n\n![09c20c79f0dd85293285271a02875f10.jpg](http://tc.ffsky.net/images/2016/07/01/09c20c79f0dd85293285271a02875f10.jpg)\n\n- 现在 CPU 和硬盘普遍读取速度快，XP 可能显示需要安装 30 分钟以上，但实际一个固态硬盘 +intel i5 以上的处理体只需要5分钟左右即可安装完毕。\n\n#### 3.4后续补充：\n- 因为安装的是纯净版的 XP，因此极有可能会缺少相关驱动程序，尤其是网卡驱动，因此建议系统安装完毕后，使用驱动精灵（网卡版）将网卡驱动补全，进一步将所有需要的驱动下载安装，如果比较冷门的旧机器建议可以去官网下载驱动，主要需要安装的是网卡，intel 相关和显卡驱动，其他驱动程序不会有太大的影响。\n\n\n> 参考链接：\n> http://blog.csdn.net/littlefang/article/details/6851864\n> http://jingyan.baidu.com/article/ca2d939df51697eb6d31ce10.html\n> http://blog.sina.com.cn/s/blog_4a22a65a0101e0tz.html\n","source":"_posts/2016/2016-06-30-windowsXP纯净版安装.md","raw":"---\nlayout: post\ncategory: \"read\"\ntitle:  u盘安装XP系统\ntags:   软件安装\ndate: \"2016-06-30 18:12\"\n---\n\n> **如果仅需要优盘安装XP可以直接查看Windows XP安装部分**\n\n\n\n### 1.Why XP?\n\nwindows XP 这个系统微软早已停止服务了，一般现在也不再会有人会想着安装这个系统了。作为已经安装过各种系统多次的人而言，老实说我也只有最初不太懂电脑的中学时候用过XP，自从09年win7出来后，就开始转战 win7 了，个人写这篇文章主要出于以下几种原因：\n- 这个系统相当稳定，占用资源很少，可以作为老旧机器的不二选择。\n- 个人工作学习完全使用 Ubuntu 系统了，时不时会用 windows 平台下面的软件如：迅雷，百度云，photoshop 等，现在机器性能强劲，virtualbox 下的 xp 运行这些中小型软件完全没任何问题。\n- XP 安装与其他软件比较为特殊，通过文章的总结，下次便于参考。\n\n<!-- more -->\n\n#### windows XP简介：\nWindows XP，是微软公司（Microsoft）推出的供个人电脑使用的操作系统，包括商用及家用的台式电脑等。Windows XP率先使用双列菜单，为之后的Windows 版本的开始菜单提供了基础。其名字 \"XP\" 的意思是英文中的 \"体验（Experience）\"，现已退役，如果你在结束支持后继续使用 Windows XP，那么你的电脑仍可工作，但它可能更容易受到安全风险与病毒的攻击。\n\n*我们这边以纯净版的sp3中文专业版为例。*\n\n### 2.常规系统安装方法\n\n#### 2.1光驱安装\n\n以往的系统安装大多使用光驱安装，而电脑的 BIOS 引导项也都有光驱引导，但随着上网本，超极本等的流行，越来越多的电脑为了节省空间将光驱给去掉了。\n\n事实也是如此，光驱读取速度慢，且网络如此发达，现在很多厂家现在也都不再提供光盘，而是通过官方网站自行获取相关软件及驱动程序，或者直接提供优盘（优盘越来越廉价）。\n\n*光盘安装简单，但不作为本文的重点，以下将不会再涉及。*\n\n#### 2.2优盘安装\n\n##### 2.2.1windows下的PE安装方式\n\n大多数 windows 的产品都可以将优盘制作成一个 PE 启动盘，然后通过这个启动程序，引导需要安装的 ISO 文件，最终完成安装。\n\n###### 优点：\n\n- 通过 pe，在安装系统之前，可以执行相关备份，分区等操作。\n- 一次 pe 制作，下次可以重复反复使用，pe 一般通过软件制作在优盘中，很多都形成单独分区，不会影响优盘的正常使用。\n- 通过 pe 可以执行一些辅助的操作，可以将 pe 作为一个系统软件，即便不需要安装系统，可以通过 pe 做一些事情。\n\n###### 缺点：\n\n- 不同的 windows 系统，对应的 pe 不一样！！！没错确确实实不一样，例如： xp 的 pe 就基本上不可能帮你安装 win7 ，同样 win7 的 pe 也不可能让你安装的上 win10 或者 winXP 。\n- 现在 pe 越做越复杂，对于只需要安装系统的新手来说，弄清楚里面 ghost 安装，原版安装，优盘一键安装这都很费力。\n\n###### 小结：\n\n- pe 安装虽然可以解决大多数问题，但毕竟太过冗余，而且不同的系统安装还需要不同的PE，另外对于linux等其他系统也完全没办法解决。\n\n\n##### 2.2.2ultraISO制作u盘安装盘\n\n注意 ultraISO 并非一个免费的软件，且免费版本的功能极为有限，这边提供ultraISO大容量版安装程序：`http://pan.baidu.com/s/1hrXbQ7q`\n\n### 3.Windows XP安装\n\nxp的安装同以上安装略有不同，原因根据查找可能是xp本身系统是不完全支持优盘引导的，所以在制作优盘XP引导时，如果仅仅使用ultraISO是很可能无法成功的。如下图：\n\n[![7fcd28a57248aff4bd7b63fb5ae5bb7c.md.jpg](http://tc.ffsky.net/images/2016/07/01/7fcd28a57248aff4bd7b63fb5ae5bb7c.md.jpg)](http://tc.ffsky.net/image/Wbv)\n\n\n为了解决这个问题，我们通过另外一个软件 WinSetupFromUSB 来制作 XP 优盘引导。\n\n使用 WinSetupFromUSB 只需要下载一个 6.5MB 的绿色软件就可以制作好 windowsXP 的安装U盘，方便简捷。WinSetupFromUSB 不仅支持 WindowsXP 的，还支持 Win7/Vista 安装U盘的制作。\n\n#### 3.1准备工具：\n\n- 1G 以上 U 盘一枚，XP安装程序约为700M\n- WinSetupFromUSB 1.0 beta7：\n`http://pan.baidu.com/s/1geXdWyR`\n`http://download.csdn.net/detail/littlefang/3664196`\n- 下载 Windows XP 安装光盘或镜像：\n`http://pan.baidu.com/s/1bNeMp4`\n\n\n#### 3.2制作步骤：\n\n![b70b2a9e6f0757deb589cb07014d6402.jpg](http://tc.ffsky.net/images/2016/07/01/b70b2a9e6f0757deb589cb07014d6402.jpg)\n\n\n![b7d784d068cb293e6a74a5568ed9816e.jpg](http://tc.ffsky.net/images/2016/07/01/b7d784d068cb293e6a74a5568ed9816e.jpg)\n\n- 在 3 BootOption 栏目中选择 XP/BartPE bootable[NTLDR]，在 4 FILESYSTEM and OVERRIDES中选择 NTFS和BOOT as HDD，然后点击 6 Prepare Drive\n\n![c5c2a5552e243c750c972c552e7dba4b.jpg](http://tc.ffsky.net/images/2016/07/01/c5c2a5552e243c750c972c552e7dba4b.jpg)\n\n- 开始写入引导文件\n\n![1cc0d164d5c9fe753796104fce4c1e64.jpg](http://tc.ffsky.net/images/2016/07/01/1cc0d164d5c9fe753796104fce4c1e64.jpg)\n\n![d1574f68352799a6f217390b52ac4193.jpg](http://tc.ffsky.net/images/2016/07/01/d1574f68352799a6f217390b52ac4193.jpg)\n\n- 待窗口关闭后返回 RMPrepUSB 界面，点击 exit 退出\n\n![d041a1cd3f085fdf7ded088c6b3caa9e.jpg](http://tc.ffsky.net/images/2016/07/01/d041a1cd3f085fdf7ded088c6b3caa9e.jpg)\n\n- 指定安装文件路径回到 WinSetupFromUSB 主界面，选中 Windows 2000/XP/2003 Setup，指定安装盘所在盘符（I386文件夹的父目录），我使用虚拟光驱把xp的镜像加载到E盘。\n\n![5827c5290779337679ec2284a7fc5a69.jpg](http://tc.ffsky.net/images/2016/07/01/5827c5290779337679ec2284a7fc5a69.jpg)\n\n- 等待启动 U 盘制作完毕，这个过程极为漫长，参考资料说 10 分钟，但实际用了 40 分钟左右。\n\n![b1e63764034d7fbafbf04047718344ca.jpg](http://tc.ffsky.net/images/2016/07/01/b1e63764034d7fbafbf04047718344ca.jpg)\n\n- 完毕就绪\n\n![62656789586b865cd946fe922f35e9f5.jpg](http://tc.ffsky.net/images/2016/07/01/62656789586b865cd946fe922f35e9f5.jpg)\n\n#### 3.3安装步骤：\n\n- 开始安装系统，相关 bios 设置这边不详细列出，电脑的厂家不一样，设置也不相同，快速设置功能未必打开，全功能的 bios 设置一般台式机为 delete 按键，笔记本可能是 F2,F10,F12 等根据主板型号而定，修改 bios 主要是为了修改引导方式，电脑一般加载系统会从硬盘进行引导，如果你想从优盘或者光盘引导系统的话，就需要在 boot 中将优盘或者光盘放在最高的优先级（第一位）。这边我们因为使用优盘安装，所以将优盘放在最上面即可。注意：如果你电脑打开了快速设置，一般可以直接选择优盘进行引导，而如果你的电脑是 Lenovo 等在主板中启用了安全功能，则需要讲该功能关闭才可以修改 bios 的引导方式，另外 UEFI 模式这边也需要改成 BIOS/legacy 模式。\n\n- XP安装界面，如果是全新硬盘，需要分区等操作，先使用 winPE 等工具，安装位置选择 C 盘（主分区）默认选项安装即可。\n\n![09c20c79f0dd85293285271a02875f10.jpg](http://tc.ffsky.net/images/2016/07/01/09c20c79f0dd85293285271a02875f10.jpg)\n\n- 现在 CPU 和硬盘普遍读取速度快，XP 可能显示需要安装 30 分钟以上，但实际一个固态硬盘 +intel i5 以上的处理体只需要5分钟左右即可安装完毕。\n\n#### 3.4后续补充：\n- 因为安装的是纯净版的 XP，因此极有可能会缺少相关驱动程序，尤其是网卡驱动，因此建议系统安装完毕后，使用驱动精灵（网卡版）将网卡驱动补全，进一步将所有需要的驱动下载安装，如果比较冷门的旧机器建议可以去官网下载驱动，主要需要安装的是网卡，intel 相关和显卡驱动，其他驱动程序不会有太大的影响。\n\n\n> 参考链接：\n> http://blog.csdn.net/littlefang/article/details/6851864\n> http://jingyan.baidu.com/article/ca2d939df51697eb6d31ce10.html\n> http://blog.sina.com.cn/s/blog_4a22a65a0101e0tz.html\n","slug":"2016/2016-06-30-windowsXP纯净版安装","published":1,"updated":"2017-01-12T03:09:37.293Z","comments":1,"photos":[],"link":"","_id":"ciyuv3agc000imumu3mf6mmdh","content":"<blockquote>\n<p><strong>如果仅需要优盘安装XP可以直接查看Windows XP安装部分</strong></p>\n</blockquote>\n<h3 id=\"1-Why-XP\"><a href=\"#1-Why-XP\" class=\"headerlink\" title=\"1.Why XP?\"></a>1.Why XP?</h3><p>windows XP 这个系统微软早已停止服务了，一般现在也不再会有人会想着安装这个系统了。作为已经安装过各种系统多次的人而言，老实说我也只有最初不太懂电脑的中学时候用过XP，自从09年win7出来后，就开始转战 win7 了，个人写这篇文章主要出于以下几种原因：</p>\n<ul>\n<li>这个系统相当稳定，占用资源很少，可以作为老旧机器的不二选择。</li>\n<li>个人工作学习完全使用 Ubuntu 系统了，时不时会用 windows 平台下面的软件如：迅雷，百度云，photoshop 等，现在机器性能强劲，virtualbox 下的 xp 运行这些中小型软件完全没任何问题。</li>\n<li>XP 安装与其他软件比较为特殊，通过文章的总结，下次便于参考。</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"windows-XP简介：\"><a href=\"#windows-XP简介：\" class=\"headerlink\" title=\"windows XP简介：\"></a>windows XP简介：</h4><p>Windows XP，是微软公司（Microsoft）推出的供个人电脑使用的操作系统，包括商用及家用的台式电脑等。Windows XP率先使用双列菜单，为之后的Windows 版本的开始菜单提供了基础。其名字 “XP” 的意思是英文中的 “体验（Experience）”，现已退役，如果你在结束支持后继续使用 Windows XP，那么你的电脑仍可工作，但它可能更容易受到安全风险与病毒的攻击。</p>\n<p><em>我们这边以纯净版的sp3中文专业版为例。</em></p>\n<h3 id=\"2-常规系统安装方法\"><a href=\"#2-常规系统安装方法\" class=\"headerlink\" title=\"2.常规系统安装方法\"></a>2.常规系统安装方法</h3><h4 id=\"2-1光驱安装\"><a href=\"#2-1光驱安装\" class=\"headerlink\" title=\"2.1光驱安装\"></a>2.1光驱安装</h4><p>以往的系统安装大多使用光驱安装，而电脑的 BIOS 引导项也都有光驱引导，但随着上网本，超极本等的流行，越来越多的电脑为了节省空间将光驱给去掉了。</p>\n<p>事实也是如此，光驱读取速度慢，且网络如此发达，现在很多厂家现在也都不再提供光盘，而是通过官方网站自行获取相关软件及驱动程序，或者直接提供优盘（优盘越来越廉价）。</p>\n<p><em>光盘安装简单，但不作为本文的重点，以下将不会再涉及。</em></p>\n<h4 id=\"2-2优盘安装\"><a href=\"#2-2优盘安装\" class=\"headerlink\" title=\"2.2优盘安装\"></a>2.2优盘安装</h4><h5 id=\"2-2-1windows下的PE安装方式\"><a href=\"#2-2-1windows下的PE安装方式\" class=\"headerlink\" title=\"2.2.1windows下的PE安装方式\"></a>2.2.1windows下的PE安装方式</h5><p>大多数 windows 的产品都可以将优盘制作成一个 PE 启动盘，然后通过这个启动程序，引导需要安装的 ISO 文件，最终完成安装。</p>\n<h6 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h6><ul>\n<li>通过 pe，在安装系统之前，可以执行相关备份，分区等操作。</li>\n<li>一次 pe 制作，下次可以重复反复使用，pe 一般通过软件制作在优盘中，很多都形成单独分区，不会影响优盘的正常使用。</li>\n<li>通过 pe 可以执行一些辅助的操作，可以将 pe 作为一个系统软件，即便不需要安装系统，可以通过 pe 做一些事情。</li>\n</ul>\n<h6 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h6><ul>\n<li>不同的 windows 系统，对应的 pe 不一样！！！没错确确实实不一样，例如： xp 的 pe 就基本上不可能帮你安装 win7 ，同样 win7 的 pe 也不可能让你安装的上 win10 或者 winXP 。</li>\n<li>现在 pe 越做越复杂，对于只需要安装系统的新手来说，弄清楚里面 ghost 安装，原版安装，优盘一键安装这都很费力。</li>\n</ul>\n<h6 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h6><ul>\n<li>pe 安装虽然可以解决大多数问题，但毕竟太过冗余，而且不同的系统安装还需要不同的PE，另外对于linux等其他系统也完全没办法解决。</li>\n</ul>\n<h5 id=\"2-2-2ultraISO制作u盘安装盘\"><a href=\"#2-2-2ultraISO制作u盘安装盘\" class=\"headerlink\" title=\"2.2.2ultraISO制作u盘安装盘\"></a>2.2.2ultraISO制作u盘安装盘</h5><p>注意 ultraISO 并非一个免费的软件，且免费版本的功能极为有限，这边提供ultraISO大容量版安装程序：<code>http://pan.baidu.com/s/1hrXbQ7q</code></p>\n<h3 id=\"3-Windows-XP安装\"><a href=\"#3-Windows-XP安装\" class=\"headerlink\" title=\"3.Windows XP安装\"></a>3.Windows XP安装</h3><p>xp的安装同以上安装略有不同，原因根据查找可能是xp本身系统是不完全支持优盘引导的，所以在制作优盘XP引导时，如果仅仅使用ultraISO是很可能无法成功的。如下图：</p>\n<p><a href=\"http://tc.ffsky.net/image/Wbv\" target=\"_blank\" rel=\"external\"><img src=\"http://tc.ffsky.net/images/2016/07/01/7fcd28a57248aff4bd7b63fb5ae5bb7c.md.jpg\" alt=\"7fcd28a57248aff4bd7b63fb5ae5bb7c.md.jpg\"></a></p>\n<p>为了解决这个问题，我们通过另外一个软件 WinSetupFromUSB 来制作 XP 优盘引导。</p>\n<p>使用 WinSetupFromUSB 只需要下载一个 6.5MB 的绿色软件就可以制作好 windowsXP 的安装U盘，方便简捷。WinSetupFromUSB 不仅支持 WindowsXP 的，还支持 Win7/Vista 安装U盘的制作。</p>\n<h4 id=\"3-1准备工具：\"><a href=\"#3-1准备工具：\" class=\"headerlink\" title=\"3.1准备工具：\"></a>3.1准备工具：</h4><ul>\n<li>1G 以上 U 盘一枚，XP安装程序约为700M</li>\n<li>WinSetupFromUSB 1.0 beta7：<br><code>http://pan.baidu.com/s/1geXdWyR</code><br><code>http://download.csdn.net/detail/littlefang/3664196</code></li>\n<li>下载 Windows XP 安装光盘或镜像：<br><code>http://pan.baidu.com/s/1bNeMp4</code></li>\n</ul>\n<h4 id=\"3-2制作步骤：\"><a href=\"#3-2制作步骤：\" class=\"headerlink\" title=\"3.2制作步骤：\"></a>3.2制作步骤：</h4><p><img src=\"http://tc.ffsky.net/images/2016/07/01/b70b2a9e6f0757deb589cb07014d6402.jpg\" alt=\"b70b2a9e6f0757deb589cb07014d6402.jpg\"></p>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/b7d784d068cb293e6a74a5568ed9816e.jpg\" alt=\"b7d784d068cb293e6a74a5568ed9816e.jpg\"></p>\n<ul>\n<li>在 3 BootOption 栏目中选择 XP/BartPE bootable[NTLDR]，在 4 FILESYSTEM and OVERRIDES中选择 NTFS和BOOT as HDD，然后点击 6 Prepare Drive</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/c5c2a5552e243c750c972c552e7dba4b.jpg\" alt=\"c5c2a5552e243c750c972c552e7dba4b.jpg\"></p>\n<ul>\n<li>开始写入引导文件</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/1cc0d164d5c9fe753796104fce4c1e64.jpg\" alt=\"1cc0d164d5c9fe753796104fce4c1e64.jpg\"></p>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/d1574f68352799a6f217390b52ac4193.jpg\" alt=\"d1574f68352799a6f217390b52ac4193.jpg\"></p>\n<ul>\n<li>待窗口关闭后返回 RMPrepUSB 界面，点击 exit 退出</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/d041a1cd3f085fdf7ded088c6b3caa9e.jpg\" alt=\"d041a1cd3f085fdf7ded088c6b3caa9e.jpg\"></p>\n<ul>\n<li>指定安装文件路径回到 WinSetupFromUSB 主界面，选中 Windows 2000/XP/2003 Setup，指定安装盘所在盘符（I386文件夹的父目录），我使用虚拟光驱把xp的镜像加载到E盘。</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/5827c5290779337679ec2284a7fc5a69.jpg\" alt=\"5827c5290779337679ec2284a7fc5a69.jpg\"></p>\n<ul>\n<li>等待启动 U 盘制作完毕，这个过程极为漫长，参考资料说 10 分钟，但实际用了 40 分钟左右。</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/b1e63764034d7fbafbf04047718344ca.jpg\" alt=\"b1e63764034d7fbafbf04047718344ca.jpg\"></p>\n<ul>\n<li>完毕就绪</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/62656789586b865cd946fe922f35e9f5.jpg\" alt=\"62656789586b865cd946fe922f35e9f5.jpg\"></p>\n<h4 id=\"3-3安装步骤：\"><a href=\"#3-3安装步骤：\" class=\"headerlink\" title=\"3.3安装步骤：\"></a>3.3安装步骤：</h4><ul>\n<li><p>开始安装系统，相关 bios 设置这边不详细列出，电脑的厂家不一样，设置也不相同，快速设置功能未必打开，全功能的 bios 设置一般台式机为 delete 按键，笔记本可能是 F2,F10,F12 等根据主板型号而定，修改 bios 主要是为了修改引导方式，电脑一般加载系统会从硬盘进行引导，如果你想从优盘或者光盘引导系统的话，就需要在 boot 中将优盘或者光盘放在最高的优先级（第一位）。这边我们因为使用优盘安装，所以将优盘放在最上面即可。注意：如果你电脑打开了快速设置，一般可以直接选择优盘进行引导，而如果你的电脑是 Lenovo 等在主板中启用了安全功能，则需要讲该功能关闭才可以修改 bios 的引导方式，另外 UEFI 模式这边也需要改成 BIOS/legacy 模式。</p>\n</li>\n<li><p>XP安装界面，如果是全新硬盘，需要分区等操作，先使用 winPE 等工具，安装位置选择 C 盘（主分区）默认选项安装即可。</p>\n</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/09c20c79f0dd85293285271a02875f10.jpg\" alt=\"09c20c79f0dd85293285271a02875f10.jpg\"></p>\n<ul>\n<li>现在 CPU 和硬盘普遍读取速度快，XP 可能显示需要安装 30 分钟以上，但实际一个固态硬盘 +intel i5 以上的处理体只需要5分钟左右即可安装完毕。</li>\n</ul>\n<h4 id=\"3-4后续补充：\"><a href=\"#3-4后续补充：\" class=\"headerlink\" title=\"3.4后续补充：\"></a>3.4后续补充：</h4><ul>\n<li>因为安装的是纯净版的 XP，因此极有可能会缺少相关驱动程序，尤其是网卡驱动，因此建议系统安装完毕后，使用驱动精灵（网卡版）将网卡驱动补全，进一步将所有需要的驱动下载安装，如果比较冷门的旧机器建议可以去官网下载驱动，主要需要安装的是网卡，intel 相关和显卡驱动，其他驱动程序不会有太大的影响。</li>\n</ul>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/littlefang/article/details/6851864\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/littlefang/article/details/6851864</a><br><a href=\"http://jingyan.baidu.com/article/ca2d939df51697eb6d31ce10.html\" target=\"_blank\" rel=\"external\">http://jingyan.baidu.com/article/ca2d939df51697eb6d31ce10.html</a><br><a href=\"http://blog.sina.com.cn/s/blog_4a22a65a0101e0tz.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_4a22a65a0101e0tz.html</a></p>\n</blockquote>\n","excerpt":"<blockquote>\n<p><strong>如果仅需要优盘安装XP可以直接查看Windows XP安装部分</strong></p>\n</blockquote>\n<h3 id=\"1-Why-XP\"><a href=\"#1-Why-XP\" class=\"headerlink\" title=\"1.Why XP?\"></a>1.Why XP?</h3><p>windows XP 这个系统微软早已停止服务了，一般现在也不再会有人会想着安装这个系统了。作为已经安装过各种系统多次的人而言，老实说我也只有最初不太懂电脑的中学时候用过XP，自从09年win7出来后，就开始转战 win7 了，个人写这篇文章主要出于以下几种原因：</p>\n<ul>\n<li>这个系统相当稳定，占用资源很少，可以作为老旧机器的不二选择。</li>\n<li>个人工作学习完全使用 Ubuntu 系统了，时不时会用 windows 平台下面的软件如：迅雷，百度云，photoshop 等，现在机器性能强劲，virtualbox 下的 xp 运行这些中小型软件完全没任何问题。</li>\n<li>XP 安装与其他软件比较为特殊，通过文章的总结，下次便于参考。</li>\n</ul>","more":"<h4 id=\"windows-XP简介：\"><a href=\"#windows-XP简介：\" class=\"headerlink\" title=\"windows XP简介：\"></a>windows XP简介：</h4><p>Windows XP，是微软公司（Microsoft）推出的供个人电脑使用的操作系统，包括商用及家用的台式电脑等。Windows XP率先使用双列菜单，为之后的Windows 版本的开始菜单提供了基础。其名字 “XP” 的意思是英文中的 “体验（Experience）”，现已退役，如果你在结束支持后继续使用 Windows XP，那么你的电脑仍可工作，但它可能更容易受到安全风险与病毒的攻击。</p>\n<p><em>我们这边以纯净版的sp3中文专业版为例。</em></p>\n<h3 id=\"2-常规系统安装方法\"><a href=\"#2-常规系统安装方法\" class=\"headerlink\" title=\"2.常规系统安装方法\"></a>2.常规系统安装方法</h3><h4 id=\"2-1光驱安装\"><a href=\"#2-1光驱安装\" class=\"headerlink\" title=\"2.1光驱安装\"></a>2.1光驱安装</h4><p>以往的系统安装大多使用光驱安装，而电脑的 BIOS 引导项也都有光驱引导，但随着上网本，超极本等的流行，越来越多的电脑为了节省空间将光驱给去掉了。</p>\n<p>事实也是如此，光驱读取速度慢，且网络如此发达，现在很多厂家现在也都不再提供光盘，而是通过官方网站自行获取相关软件及驱动程序，或者直接提供优盘（优盘越来越廉价）。</p>\n<p><em>光盘安装简单，但不作为本文的重点，以下将不会再涉及。</em></p>\n<h4 id=\"2-2优盘安装\"><a href=\"#2-2优盘安装\" class=\"headerlink\" title=\"2.2优盘安装\"></a>2.2优盘安装</h4><h5 id=\"2-2-1windows下的PE安装方式\"><a href=\"#2-2-1windows下的PE安装方式\" class=\"headerlink\" title=\"2.2.1windows下的PE安装方式\"></a>2.2.1windows下的PE安装方式</h5><p>大多数 windows 的产品都可以将优盘制作成一个 PE 启动盘，然后通过这个启动程序，引导需要安装的 ISO 文件，最终完成安装。</p>\n<h6 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h6><ul>\n<li>通过 pe，在安装系统之前，可以执行相关备份，分区等操作。</li>\n<li>一次 pe 制作，下次可以重复反复使用，pe 一般通过软件制作在优盘中，很多都形成单独分区，不会影响优盘的正常使用。</li>\n<li>通过 pe 可以执行一些辅助的操作，可以将 pe 作为一个系统软件，即便不需要安装系统，可以通过 pe 做一些事情。</li>\n</ul>\n<h6 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h6><ul>\n<li>不同的 windows 系统，对应的 pe 不一样！！！没错确确实实不一样，例如： xp 的 pe 就基本上不可能帮你安装 win7 ，同样 win7 的 pe 也不可能让你安装的上 win10 或者 winXP 。</li>\n<li>现在 pe 越做越复杂，对于只需要安装系统的新手来说，弄清楚里面 ghost 安装，原版安装，优盘一键安装这都很费力。</li>\n</ul>\n<h6 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h6><ul>\n<li>pe 安装虽然可以解决大多数问题，但毕竟太过冗余，而且不同的系统安装还需要不同的PE，另外对于linux等其他系统也完全没办法解决。</li>\n</ul>\n<h5 id=\"2-2-2ultraISO制作u盘安装盘\"><a href=\"#2-2-2ultraISO制作u盘安装盘\" class=\"headerlink\" title=\"2.2.2ultraISO制作u盘安装盘\"></a>2.2.2ultraISO制作u盘安装盘</h5><p>注意 ultraISO 并非一个免费的软件，且免费版本的功能极为有限，这边提供ultraISO大容量版安装程序：<code>http://pan.baidu.com/s/1hrXbQ7q</code></p>\n<h3 id=\"3-Windows-XP安装\"><a href=\"#3-Windows-XP安装\" class=\"headerlink\" title=\"3.Windows XP安装\"></a>3.Windows XP安装</h3><p>xp的安装同以上安装略有不同，原因根据查找可能是xp本身系统是不完全支持优盘引导的，所以在制作优盘XP引导时，如果仅仅使用ultraISO是很可能无法成功的。如下图：</p>\n<p><a href=\"http://tc.ffsky.net/image/Wbv\"><img src=\"http://tc.ffsky.net/images/2016/07/01/7fcd28a57248aff4bd7b63fb5ae5bb7c.md.jpg\" alt=\"7fcd28a57248aff4bd7b63fb5ae5bb7c.md.jpg\"></a></p>\n<p>为了解决这个问题，我们通过另外一个软件 WinSetupFromUSB 来制作 XP 优盘引导。</p>\n<p>使用 WinSetupFromUSB 只需要下载一个 6.5MB 的绿色软件就可以制作好 windowsXP 的安装U盘，方便简捷。WinSetupFromUSB 不仅支持 WindowsXP 的，还支持 Win7/Vista 安装U盘的制作。</p>\n<h4 id=\"3-1准备工具：\"><a href=\"#3-1准备工具：\" class=\"headerlink\" title=\"3.1准备工具：\"></a>3.1准备工具：</h4><ul>\n<li>1G 以上 U 盘一枚，XP安装程序约为700M</li>\n<li>WinSetupFromUSB 1.0 beta7：<br><code>http://pan.baidu.com/s/1geXdWyR</code><br><code>http://download.csdn.net/detail/littlefang/3664196</code></li>\n<li>下载 Windows XP 安装光盘或镜像：<br><code>http://pan.baidu.com/s/1bNeMp4</code></li>\n</ul>\n<h4 id=\"3-2制作步骤：\"><a href=\"#3-2制作步骤：\" class=\"headerlink\" title=\"3.2制作步骤：\"></a>3.2制作步骤：</h4><p><img src=\"http://tc.ffsky.net/images/2016/07/01/b70b2a9e6f0757deb589cb07014d6402.jpg\" alt=\"b70b2a9e6f0757deb589cb07014d6402.jpg\"></p>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/b7d784d068cb293e6a74a5568ed9816e.jpg\" alt=\"b7d784d068cb293e6a74a5568ed9816e.jpg\"></p>\n<ul>\n<li>在 3 BootOption 栏目中选择 XP/BartPE bootable[NTLDR]，在 4 FILESYSTEM and OVERRIDES中选择 NTFS和BOOT as HDD，然后点击 6 Prepare Drive</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/c5c2a5552e243c750c972c552e7dba4b.jpg\" alt=\"c5c2a5552e243c750c972c552e7dba4b.jpg\"></p>\n<ul>\n<li>开始写入引导文件</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/1cc0d164d5c9fe753796104fce4c1e64.jpg\" alt=\"1cc0d164d5c9fe753796104fce4c1e64.jpg\"></p>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/d1574f68352799a6f217390b52ac4193.jpg\" alt=\"d1574f68352799a6f217390b52ac4193.jpg\"></p>\n<ul>\n<li>待窗口关闭后返回 RMPrepUSB 界面，点击 exit 退出</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/d041a1cd3f085fdf7ded088c6b3caa9e.jpg\" alt=\"d041a1cd3f085fdf7ded088c6b3caa9e.jpg\"></p>\n<ul>\n<li>指定安装文件路径回到 WinSetupFromUSB 主界面，选中 Windows 2000/XP/2003 Setup，指定安装盘所在盘符（I386文件夹的父目录），我使用虚拟光驱把xp的镜像加载到E盘。</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/5827c5290779337679ec2284a7fc5a69.jpg\" alt=\"5827c5290779337679ec2284a7fc5a69.jpg\"></p>\n<ul>\n<li>等待启动 U 盘制作完毕，这个过程极为漫长，参考资料说 10 分钟，但实际用了 40 分钟左右。</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/b1e63764034d7fbafbf04047718344ca.jpg\" alt=\"b1e63764034d7fbafbf04047718344ca.jpg\"></p>\n<ul>\n<li>完毕就绪</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/62656789586b865cd946fe922f35e9f5.jpg\" alt=\"62656789586b865cd946fe922f35e9f5.jpg\"></p>\n<h4 id=\"3-3安装步骤：\"><a href=\"#3-3安装步骤：\" class=\"headerlink\" title=\"3.3安装步骤：\"></a>3.3安装步骤：</h4><ul>\n<li><p>开始安装系统，相关 bios 设置这边不详细列出，电脑的厂家不一样，设置也不相同，快速设置功能未必打开，全功能的 bios 设置一般台式机为 delete 按键，笔记本可能是 F2,F10,F12 等根据主板型号而定，修改 bios 主要是为了修改引导方式，电脑一般加载系统会从硬盘进行引导，如果你想从优盘或者光盘引导系统的话，就需要在 boot 中将优盘或者光盘放在最高的优先级（第一位）。这边我们因为使用优盘安装，所以将优盘放在最上面即可。注意：如果你电脑打开了快速设置，一般可以直接选择优盘进行引导，而如果你的电脑是 Lenovo 等在主板中启用了安全功能，则需要讲该功能关闭才可以修改 bios 的引导方式，另外 UEFI 模式这边也需要改成 BIOS/legacy 模式。</p>\n</li>\n<li><p>XP安装界面，如果是全新硬盘，需要分区等操作，先使用 winPE 等工具，安装位置选择 C 盘（主分区）默认选项安装即可。</p>\n</li>\n</ul>\n<p><img src=\"http://tc.ffsky.net/images/2016/07/01/09c20c79f0dd85293285271a02875f10.jpg\" alt=\"09c20c79f0dd85293285271a02875f10.jpg\"></p>\n<ul>\n<li>现在 CPU 和硬盘普遍读取速度快，XP 可能显示需要安装 30 分钟以上，但实际一个固态硬盘 +intel i5 以上的处理体只需要5分钟左右即可安装完毕。</li>\n</ul>\n<h4 id=\"3-4后续补充：\"><a href=\"#3-4后续补充：\" class=\"headerlink\" title=\"3.4后续补充：\"></a>3.4后续补充：</h4><ul>\n<li>因为安装的是纯净版的 XP，因此极有可能会缺少相关驱动程序，尤其是网卡驱动，因此建议系统安装完毕后，使用驱动精灵（网卡版）将网卡驱动补全，进一步将所有需要的驱动下载安装，如果比较冷门的旧机器建议可以去官网下载驱动，主要需要安装的是网卡，intel 相关和显卡驱动，其他驱动程序不会有太大的影响。</li>\n</ul>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/littlefang/article/details/6851864\">http://blog.csdn.net/littlefang/article/details/6851864</a><br><a href=\"http://jingyan.baidu.com/article/ca2d939df51697eb6d31ce10.html\">http://jingyan.baidu.com/article/ca2d939df51697eb6d31ce10.html</a><br><a href=\"http://blog.sina.com.cn/s/blog_4a22a65a0101e0tz.html\">http://blog.sina.com.cn/s/blog_4a22a65a0101e0tz.html</a></p>\n</blockquote>"},{"layout":"post","title":"（转）github_markdown","date":"2016-07-15T10:12:00.000Z","_content":"\n*本内容主要例举了github适用的markdown语法，类似于基于基础markdown定制的语法特性，并非适用于所有的其他markdown编辑器，尤其是下述表情包基本上其他编辑器都不一定能够支持，本人使用的是atom外加一些github的插件，基本能够显示大多数内容，但仍由部分不能支持，另外本文的主要适用范围：**在新建项目工程，书写readme时使用，其他如github page或者其他一些站点的markdown页面请勿参考本文。***\n\n#### [实现效果](https://github.com/guodongxiaren/README)\n\n<!-- more -->\n\n#### [源码地址](https://github.com/guodongxiaren)\n\n***\n\n> 参考链接：  \n> https://github.com/guodongxiaren/README （正文原始地址）\n> https://raw.githubusercontent.com/noparkinghere/README/master/README.md\n> http://blog.csdn.net/wqvbjhc/article/details/27349209\n","source":"_posts/2016/2016-07-05-（转）github_markdown.md","raw":"---\nlayout: post\ntitle:  （转）github_markdown\ncategory: \"read\"\ntags:   问题总结\ndate: \"2016-07-15 18:12\"\n---\n\n*本内容主要例举了github适用的markdown语法，类似于基于基础markdown定制的语法特性，并非适用于所有的其他markdown编辑器，尤其是下述表情包基本上其他编辑器都不一定能够支持，本人使用的是atom外加一些github的插件，基本能够显示大多数内容，但仍由部分不能支持，另外本文的主要适用范围：**在新建项目工程，书写readme时使用，其他如github page或者其他一些站点的markdown页面请勿参考本文。***\n\n#### [实现效果](https://github.com/guodongxiaren/README)\n\n<!-- more -->\n\n#### [源码地址](https://github.com/guodongxiaren)\n\n***\n\n> 参考链接：  \n> https://github.com/guodongxiaren/README （正文原始地址）\n> https://raw.githubusercontent.com/noparkinghere/README/master/README.md\n> http://blog.csdn.net/wqvbjhc/article/details/27349209\n","slug":"2016/2016-07-05-（转）github_markdown","published":1,"updated":"2017-01-03T02:30:41.347Z","comments":1,"photos":[],"link":"","_id":"ciyuv3age000kmumucmuqyljl","content":"<p><em>本内容主要例举了github适用的markdown语法，类似于基于基础markdown定制的语法特性，并非适用于所有的其他markdown编辑器，尤其是下述表情包基本上其他编辑器都不一定能够支持，本人使用的是atom外加一些github的插件，基本能够显示大多数内容，但仍由部分不能支持，另外本文的主要适用范围：<strong>在新建项目工程，书写readme时使用，其他如github page或者其他一些站点的markdown页面请勿参考本文。</strong></em></p>\n<h4 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a><a href=\"https://github.com/guodongxiaren/README\" target=\"_blank\" rel=\"external\">实现效果</a></h4><a id=\"more\"></a>\n<h4 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/guodongxiaren\" target=\"_blank\" rel=\"external\">源码地址</a></h4><hr>\n<blockquote>\n<p>参考链接：<br><a href=\"https://github.com/guodongxiaren/README\" target=\"_blank\" rel=\"external\">https://github.com/guodongxiaren/README</a> （正文原始地址）<br><a href=\"https://raw.githubusercontent.com/noparkinghere/README/master/README.md\" target=\"_blank\" rel=\"external\">https://raw.githubusercontent.com/noparkinghere/README/master/README.md</a><br><a href=\"http://blog.csdn.net/wqvbjhc/article/details/27349209\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/wqvbjhc/article/details/27349209</a></p>\n</blockquote>\n","excerpt":"<p><em>本内容主要例举了github适用的markdown语法，类似于基于基础markdown定制的语法特性，并非适用于所有的其他markdown编辑器，尤其是下述表情包基本上其他编辑器都不一定能够支持，本人使用的是atom外加一些github的插件，基本能够显示大多数内容，但仍由部分不能支持，另外本文的主要适用范围：<strong>在新建项目工程，书写readme时使用，其他如github page或者其他一些站点的markdown页面请勿参考本文。</strong></em></p>\n<h4 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a><a href=\"https://github.com/guodongxiaren/README\">实现效果</a></h4>","more":"<h4 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a><a href=\"https://github.com/guodongxiaren\">源码地址</a></h4><hr>\n<blockquote>\n<p>参考链接：<br><a href=\"https://github.com/guodongxiaren/README\">https://github.com/guodongxiaren/README</a> （正文原始地址）<br><a href=\"https://raw.githubusercontent.com/noparkinghere/README/master/README.md\">https://raw.githubusercontent.com/noparkinghere/README/master/README.md</a><br><a href=\"http://blog.csdn.net/wqvbjhc/article/details/27349209\">http://blog.csdn.net/wqvbjhc/article/details/27349209</a></p>\n</blockquote>"},{"layout":"post","title":"github本地推送","date":"2016-07-05T03:12:00.000Z","_content":"\n\n### 操作环境\n\n- ubuntu 16.04 终端输入： lsb_release -a\n\n```\nNo LSB modules are available.\nDistributor ID:\tUbuntu\nDescription:\tUbuntu 16.04 LTS\nRelease:\t16.04\nCodename:\txenial\n```\n\n<!-- more -->\n\n\n- git 和 ssh\n\n### 具体操作\n\n**github一般支持http和ssh两种传输协议（可能还有其他的，作为菜鸟暂时不作研究），而使用clone的时候，可以选择两者之一，生成地址，直接选用http的话，\n不需要输入密码和验证，如果采用ssh则需要将上传到github上面的公钥和本地的私钥进行匹配，验证成功后才能进行相关一系列的操作。**\n\n- 安装git 和 ssh `sudo apt-get install git ssh`\n\n- 为了和Github的远程仓库进行传输，需要进行SSH加密设置。\n\n```\nssh-keygen -t rsa -C \"{name@site.com}\"    // 用你的邮箱替换{name@site.com}\n可以不输入其他信息，一直敲回车直到命令完成。\n这时你的用户目录下会出现名为.ssh 的文件夹（默认隐藏），点进去能看到 id_rsa 和 id_rsa.pub 两个文件，其中 id_rsa 是私钥，不能让怪人拿走， id_rsa.pub 是公钥，无需保密\n```\n\n- 登录Github，点击右上角头像下的Settings -> SSH and GPG keys -> New SSH key ,在title中输入名称，Key中输入公钥（id_rsa.pub中的所有内容）\n\n- 终端下面设置git\n\n```\ngit config --global user.name \"{name}\"    // 用你的名字代替{name}\ngit config --global user.email \"{name@site.com}\"    // 用你的邮箱替换{name@site.com}\n```\n\n- 打开你需要下载目录，使用ssh协议远程下载你的项目\n\n```\ncd Documents\ngit clone git@github.com:xxx/yyy.git\n```\n\n> 参考链接：\n> http://playingfingers.com/2016/03/26/build-a-blog/#ssh\n> http://www.yiibai.com/git/git_environment.html\n","source":"_posts/2016/2016-07-05-github本地推送.md","raw":"---\nlayout: post\ncategory: \"read\"\ntitle:  github本地推送\ntags:   问题总结\ndate: \"2016-07-05 11:12\"\n---\n\n\n### 操作环境\n\n- ubuntu 16.04 终端输入： lsb_release -a\n\n```\nNo LSB modules are available.\nDistributor ID:\tUbuntu\nDescription:\tUbuntu 16.04 LTS\nRelease:\t16.04\nCodename:\txenial\n```\n\n<!-- more -->\n\n\n- git 和 ssh\n\n### 具体操作\n\n**github一般支持http和ssh两种传输协议（可能还有其他的，作为菜鸟暂时不作研究），而使用clone的时候，可以选择两者之一，生成地址，直接选用http的话，\n不需要输入密码和验证，如果采用ssh则需要将上传到github上面的公钥和本地的私钥进行匹配，验证成功后才能进行相关一系列的操作。**\n\n- 安装git 和 ssh `sudo apt-get install git ssh`\n\n- 为了和Github的远程仓库进行传输，需要进行SSH加密设置。\n\n```\nssh-keygen -t rsa -C \"{name@site.com}\"    // 用你的邮箱替换{name@site.com}\n可以不输入其他信息，一直敲回车直到命令完成。\n这时你的用户目录下会出现名为.ssh 的文件夹（默认隐藏），点进去能看到 id_rsa 和 id_rsa.pub 两个文件，其中 id_rsa 是私钥，不能让怪人拿走， id_rsa.pub 是公钥，无需保密\n```\n\n- 登录Github，点击右上角头像下的Settings -> SSH and GPG keys -> New SSH key ,在title中输入名称，Key中输入公钥（id_rsa.pub中的所有内容）\n\n- 终端下面设置git\n\n```\ngit config --global user.name \"{name}\"    // 用你的名字代替{name}\ngit config --global user.email \"{name@site.com}\"    // 用你的邮箱替换{name@site.com}\n```\n\n- 打开你需要下载目录，使用ssh协议远程下载你的项目\n\n```\ncd Documents\ngit clone git@github.com:xxx/yyy.git\n```\n\n> 参考链接：\n> http://playingfingers.com/2016/03/26/build-a-blog/#ssh\n> http://www.yiibai.com/git/git_environment.html\n","slug":"2016/2016-07-05-github本地推送","published":1,"updated":"2016-12-16T01:18:50.558Z","comments":1,"photos":[],"link":"","_id":"ciyuv3agh000pmumur4emrdoz","content":"<h3 id=\"操作环境\"><a href=\"#操作环境\" class=\"headerlink\" title=\"操作环境\"></a>操作环境</h3><ul>\n<li>ubuntu 16.04 终端输入： lsb_release -a</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">No LSB modules are available.</div><div class=\"line\">Distributor ID:\tUbuntu</div><div class=\"line\">Description:\tUbuntu 16.04 LTS</div><div class=\"line\">Release:\t16.04</div><div class=\"line\">Codename:\txenial</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<ul>\n<li>git 和 ssh</li>\n</ul>\n<h3 id=\"具体操作\"><a href=\"#具体操作\" class=\"headerlink\" title=\"具体操作\"></a>具体操作</h3><p><strong>github一般支持http和ssh两种传输协议（可能还有其他的，作为菜鸟暂时不作研究），而使用clone的时候，可以选择两者之一，生成地址，直接选用http的话，<br>不需要输入密码和验证，如果采用ssh则需要将上传到github上面的公钥和本地的私钥进行匹配，验证成功后才能进行相关一系列的操作。</strong></p>\n<ul>\n<li><p>安装git 和 ssh <code>sudo apt-get install git ssh</code></p>\n</li>\n<li><p>为了和Github的远程仓库进行传输，需要进行SSH加密设置。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen -t rsa -C &quot;&#123;name@site.com&#125;&quot;    // 用你的邮箱替换&#123;name@site.com&#125;</div><div class=\"line\">可以不输入其他信息，一直敲回车直到命令完成。</div><div class=\"line\">这时你的用户目录下会出现名为.ssh 的文件夹（默认隐藏），点进去能看到 id_rsa 和 id_rsa.pub 两个文件，其中 id_rsa 是私钥，不能让怪人拿走， id_rsa.pub 是公钥，无需保密</div></pre></td></tr></table></figure>\n<ul>\n<li><p>登录Github，点击右上角头像下的Settings -&gt; SSH and GPG keys -&gt; New SSH key ,在title中输入名称，Key中输入公钥（id_rsa.pub中的所有内容）</p>\n</li>\n<li><p>终端下面设置git</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global user.name &quot;&#123;name&#125;&quot;    // 用你的名字代替&#123;name&#125;</div><div class=\"line\">git config --global user.email &quot;&#123;name@site.com&#125;&quot;    // 用你的邮箱替换&#123;name@site.com&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>打开你需要下载目录，使用ssh协议远程下载你的项目</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd Documents</div><div class=\"line\">git clone git@github.com:xxx/yyy.git</div></pre></td></tr></table></figure>\n<blockquote>\n<p>参考链接：<br><a href=\"http://playingfingers.com/2016/03/26/build-a-blog/#ssh\" target=\"_blank\" rel=\"external\">http://playingfingers.com/2016/03/26/build-a-blog/#ssh</a><br><a href=\"http://www.yiibai.com/git/git_environment.html\" target=\"_blank\" rel=\"external\">http://www.yiibai.com/git/git_environment.html</a></p>\n</blockquote>\n","excerpt":"<h3 id=\"操作环境\"><a href=\"#操作环境\" class=\"headerlink\" title=\"操作环境\"></a>操作环境</h3><ul>\n<li>ubuntu 16.04 终端输入： lsb_release -a</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">No LSB modules are available.</div><div class=\"line\">Distributor ID:\tUbuntu</div><div class=\"line\">Description:\tUbuntu 16.04 LTS</div><div class=\"line\">Release:\t16.04</div><div class=\"line\">Codename:\txenial</div></pre></td></tr></table></figure>","more":"<ul>\n<li>git 和 ssh</li>\n</ul>\n<h3 id=\"具体操作\"><a href=\"#具体操作\" class=\"headerlink\" title=\"具体操作\"></a>具体操作</h3><p><strong>github一般支持http和ssh两种传输协议（可能还有其他的，作为菜鸟暂时不作研究），而使用clone的时候，可以选择两者之一，生成地址，直接选用http的话，<br>不需要输入密码和验证，如果采用ssh则需要将上传到github上面的公钥和本地的私钥进行匹配，验证成功后才能进行相关一系列的操作。</strong></p>\n<ul>\n<li><p>安装git 和 ssh <code>sudo apt-get install git ssh</code></p>\n</li>\n<li><p>为了和Github的远程仓库进行传输，需要进行SSH加密设置。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen -t rsa -C &quot;&#123;name@site.com&#125;&quot;    // 用你的邮箱替换&#123;name@site.com&#125;</div><div class=\"line\">可以不输入其他信息，一直敲回车直到命令完成。</div><div class=\"line\">这时你的用户目录下会出现名为.ssh 的文件夹（默认隐藏），点进去能看到 id_rsa 和 id_rsa.pub 两个文件，其中 id_rsa 是私钥，不能让怪人拿走， id_rsa.pub 是公钥，无需保密</div></pre></td></tr></table></figure>\n<ul>\n<li><p>登录Github，点击右上角头像下的Settings -&gt; SSH and GPG keys -&gt; New SSH key ,在title中输入名称，Key中输入公钥（id_rsa.pub中的所有内容）</p>\n</li>\n<li><p>终端下面设置git</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global user.name &quot;&#123;name&#125;&quot;    // 用你的名字代替&#123;name&#125;</div><div class=\"line\">git config --global user.email &quot;&#123;name@site.com&#125;&quot;    // 用你的邮箱替换&#123;name@site.com&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>打开你需要下载目录，使用ssh协议远程下载你的项目</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd Documents</div><div class=\"line\">git clone git@github.com:xxx/yyy.git</div></pre></td></tr></table></figure>\n<blockquote>\n<p>参考链接：<br><a href=\"http://playingfingers.com/2016/03/26/build-a-blog/#ssh\">http://playingfingers.com/2016/03/26/build-a-blog/#ssh</a><br><a href=\"http://www.yiibai.com/git/git_environment.html\">http://www.yiibai.com/git/git_environment.html</a></p>\n</blockquote>"},{"layout":"post","title":"linux下的virtualbox安装配置","date":"2016-07-06T17:12:00.000Z","_content":"\n### 背景分析\n\n随着计算机技术的发展，硬件配置越来越高，跨平台软件，手机以及浏览器越来越强大，目前可以说\nlinux下除了大型游戏意外，其他的办公学习娱乐基本都可以解决，比如：\n\n<!-- more -->\n\n\n- 购物可以电脑浏览，手机支付（很多win用户，估计也不怎么用u盾了）。\n- 音乐可以使用百度，qq在线音乐。\n- 至于编程等开发工具更是齐全。\n\n但仍然难免会有一些windows程序需要用户操心，个人主要需用使用的windows产品有：\n*迅雷，百度云，photoshop，illustrator，U盘系统制作工具等*\n\n解决办法主要有：\n\n- wine提供windows的类库，是软件windows软件直接可以在linux上面运行\n- 使用虚拟机，在linux上面虚拟一个windows xp出来，提供一定的硬件资源，运行需要使用的软件\n\n**这边我们选择虚拟机virtualbox，主要该软件开源小巧，且现在硬件强大，对资源的开销可以接收，外加wine向来不是太稳定，出现问题的几率高。**\n\n#### 系统环境\n\n- ubuntu 16.04 终端输入： lsb_release -a\n\n```\nNo LSB modules are available.\nDistributor ID:\tUbuntu\nDescription:\tUbuntu 16.04 LTS\nRelease:\t16.04\nCodename:\txenial\n```\n\n### 具体步骤\n\n步骤如下：\n\n1. 需要安装Oracle Virtualbox\n\n可以使用sudo apt-get install virutalbox 安装\n\n也可以通过官网下载地址：`https://www.virtualbox.org/wiki/Downloads`\n\n安装增强包的方法介绍：`http://gaoke0820.blog.163.com/blog/static/21664965201332802833510/`\n\n2. 安装完之后，U盘识别\n\n*如果如VirtualBox客户机挂载U盘中设置后，linux中还不能挂载u盘，而使用sudo启动virtualbox后里面的客户机可以挂载U盘，原因为 普通用户没有使用USB设备权限。*\n\n2.1 方法1：\n\n让GUEST识别USB设备\n\n```\n$ sudo gedit   /etc/fstab\n\n在末尾加上\n# the USB group\n# 对所有用户开放USB设备的读写权限\nnone /proc/bus/usb usbfs devmode=666 0 0\n然后就可以使用的USB设备了。\n```\n\n*但是把USB设备的读写权限开放给所有用户的方式在一些情况下不太安全*\n\n\n2.2 方法2：\n\n将用户名添加到vboxusers组,重启或注销后即可解决.\n\n```\nsudo adduser usrname vboxusers\n\n然后再输入：cat /etc/group |grep vboxusers\n这时可以看到显示：\nvboxusers:x:129:demon,hello\n```\n\n*该方法使用后，基本能够使用，但使用之前每次需要手动添加设备*\n\n2.3 方法3：\n\n```\n增加用户组usbfs\n$sudo groupadd usbfs\n\n查看usbfs用户组的gid\n$ cat /etc/group | grep usbfs\nusbfs:x:1002:\n\n把当前用户增加到usbfs组\nsudo adduser demon usbfs\n```\n\n为USB设备重新设置权限,编辑/etc/fstab文件，添加下面两行，注意你的gid可能不是1002\n\n```\n $   sudo gedit /etc/fstab\n在末尾加上\n# 1002 is the USB group IDI\nnone /proc/bus/usb usbfs devgid=1002,devmode=774 0 0\n```\n\n重新启动后，应该就可以在客户机中使用USB设备了。\n\n方法：插入一个USB设备后，如U盘、鼠标，右键点击虚拟机里右下脚的USB图标，选择已经识别的U盘，就可以正常使用了。\n注意： 在客户机里使用USB设备前要先在主机里卸载。\n\n﻿\n\n\n\n3. 在virtualbox里启动USB控制器\n\n\n\n\n4. 打开虚拟机，这时在虚拟机的设备-分配USB设备中就可以看到USB设备了\n\n\n\n> 相关参考：\n> http://blog.csdn.net/rongyongfeikai2/article/details/21795741\n> http://www.linuxidc.com/Linux/2012-01/52502.htm\n> http://xuantan.iteye.com/blog/1130808\n> http://www.iteedu.com/os/linux/mklinuxdiary/ch1tools/2.php\n","source":"_posts/2016/2016-07-07-linux下的virtualbox安装配置.md","raw":"---\nlayout: post\ncategory: \"read\"\ntitle:  \"linux下的virtualbox安装配置\"\ntags:   软件安装\ndate: \"2016-07-07 1:12\"\n---\n\n### 背景分析\n\n随着计算机技术的发展，硬件配置越来越高，跨平台软件，手机以及浏览器越来越强大，目前可以说\nlinux下除了大型游戏意外，其他的办公学习娱乐基本都可以解决，比如：\n\n<!-- more -->\n\n\n- 购物可以电脑浏览，手机支付（很多win用户，估计也不怎么用u盾了）。\n- 音乐可以使用百度，qq在线音乐。\n- 至于编程等开发工具更是齐全。\n\n但仍然难免会有一些windows程序需要用户操心，个人主要需用使用的windows产品有：\n*迅雷，百度云，photoshop，illustrator，U盘系统制作工具等*\n\n解决办法主要有：\n\n- wine提供windows的类库，是软件windows软件直接可以在linux上面运行\n- 使用虚拟机，在linux上面虚拟一个windows xp出来，提供一定的硬件资源，运行需要使用的软件\n\n**这边我们选择虚拟机virtualbox，主要该软件开源小巧，且现在硬件强大，对资源的开销可以接收，外加wine向来不是太稳定，出现问题的几率高。**\n\n#### 系统环境\n\n- ubuntu 16.04 终端输入： lsb_release -a\n\n```\nNo LSB modules are available.\nDistributor ID:\tUbuntu\nDescription:\tUbuntu 16.04 LTS\nRelease:\t16.04\nCodename:\txenial\n```\n\n### 具体步骤\n\n步骤如下：\n\n1. 需要安装Oracle Virtualbox\n\n可以使用sudo apt-get install virutalbox 安装\n\n也可以通过官网下载地址：`https://www.virtualbox.org/wiki/Downloads`\n\n安装增强包的方法介绍：`http://gaoke0820.blog.163.com/blog/static/21664965201332802833510/`\n\n2. 安装完之后，U盘识别\n\n*如果如VirtualBox客户机挂载U盘中设置后，linux中还不能挂载u盘，而使用sudo启动virtualbox后里面的客户机可以挂载U盘，原因为 普通用户没有使用USB设备权限。*\n\n2.1 方法1：\n\n让GUEST识别USB设备\n\n```\n$ sudo gedit   /etc/fstab\n\n在末尾加上\n# the USB group\n# 对所有用户开放USB设备的读写权限\nnone /proc/bus/usb usbfs devmode=666 0 0\n然后就可以使用的USB设备了。\n```\n\n*但是把USB设备的读写权限开放给所有用户的方式在一些情况下不太安全*\n\n\n2.2 方法2：\n\n将用户名添加到vboxusers组,重启或注销后即可解决.\n\n```\nsudo adduser usrname vboxusers\n\n然后再输入：cat /etc/group |grep vboxusers\n这时可以看到显示：\nvboxusers:x:129:demon,hello\n```\n\n*该方法使用后，基本能够使用，但使用之前每次需要手动添加设备*\n\n2.3 方法3：\n\n```\n增加用户组usbfs\n$sudo groupadd usbfs\n\n查看usbfs用户组的gid\n$ cat /etc/group | grep usbfs\nusbfs:x:1002:\n\n把当前用户增加到usbfs组\nsudo adduser demon usbfs\n```\n\n为USB设备重新设置权限,编辑/etc/fstab文件，添加下面两行，注意你的gid可能不是1002\n\n```\n $   sudo gedit /etc/fstab\n在末尾加上\n# 1002 is the USB group IDI\nnone /proc/bus/usb usbfs devgid=1002,devmode=774 0 0\n```\n\n重新启动后，应该就可以在客户机中使用USB设备了。\n\n方法：插入一个USB设备后，如U盘、鼠标，右键点击虚拟机里右下脚的USB图标，选择已经识别的U盘，就可以正常使用了。\n注意： 在客户机里使用USB设备前要先在主机里卸载。\n\n﻿\n\n\n\n3. 在virtualbox里启动USB控制器\n\n\n\n\n4. 打开虚拟机，这时在虚拟机的设备-分配USB设备中就可以看到USB设备了\n\n\n\n> 相关参考：\n> http://blog.csdn.net/rongyongfeikai2/article/details/21795741\n> http://www.linuxidc.com/Linux/2012-01/52502.htm\n> http://xuantan.iteye.com/blog/1130808\n> http://www.iteedu.com/os/linux/mklinuxdiary/ch1tools/2.php\n","slug":"2016/2016-07-07-linux下的virtualbox安装配置","published":1,"updated":"2016-12-16T01:18:55.902Z","comments":1,"photos":[],"link":"","_id":"ciyuv3agi000smumufh8sfoyf","content":"<h3 id=\"背景分析\"><a href=\"#背景分析\" class=\"headerlink\" title=\"背景分析\"></a>背景分析</h3><p>随着计算机技术的发展，硬件配置越来越高，跨平台软件，手机以及浏览器越来越强大，目前可以说<br>linux下除了大型游戏意外，其他的办公学习娱乐基本都可以解决，比如：</p>\n<a id=\"more\"></a>\n<ul>\n<li>购物可以电脑浏览，手机支付（很多win用户，估计也不怎么用u盾了）。</li>\n<li>音乐可以使用百度，qq在线音乐。</li>\n<li>至于编程等开发工具更是齐全。</li>\n</ul>\n<p>但仍然难免会有一些windows程序需要用户操心，个人主要需用使用的windows产品有：<br><em>迅雷，百度云，photoshop，illustrator，U盘系统制作工具等</em></p>\n<p>解决办法主要有：</p>\n<ul>\n<li>wine提供windows的类库，是软件windows软件直接可以在linux上面运行</li>\n<li>使用虚拟机，在linux上面虚拟一个windows xp出来，提供一定的硬件资源，运行需要使用的软件</li>\n</ul>\n<p><strong>这边我们选择虚拟机virtualbox，主要该软件开源小巧，且现在硬件强大，对资源的开销可以接收，外加wine向来不是太稳定，出现问题的几率高。</strong></p>\n<h4 id=\"系统环境\"><a href=\"#系统环境\" class=\"headerlink\" title=\"系统环境\"></a>系统环境</h4><ul>\n<li>ubuntu 16.04 终端输入： lsb_release -a</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">No LSB modules are available.</div><div class=\"line\">Distributor ID:\tUbuntu</div><div class=\"line\">Description:\tUbuntu 16.04 LTS</div><div class=\"line\">Release:\t16.04</div><div class=\"line\">Codename:\txenial</div></pre></td></tr></table></figure>\n<h3 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h3><p>步骤如下：</p>\n<ol>\n<li>需要安装Oracle Virtualbox</li>\n</ol>\n<p>可以使用sudo apt-get install virutalbox 安装</p>\n<p>也可以通过官网下载地址：<code>https://www.virtualbox.org/wiki/Downloads</code></p>\n<p>安装增强包的方法介绍：<code>http://gaoke0820.blog.163.com/blog/static/21664965201332802833510/</code></p>\n<ol>\n<li>安装完之后，U盘识别</li>\n</ol>\n<p><em>如果如VirtualBox客户机挂载U盘中设置后，linux中还不能挂载u盘，而使用sudo启动virtualbox后里面的客户机可以挂载U盘，原因为 普通用户没有使用USB设备权限。</em></p>\n<p>2.1 方法1：</p>\n<p>让GUEST识别USB设备</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo gedit   /etc/fstab</div><div class=\"line\"></div><div class=\"line\">在末尾加上</div><div class=\"line\"># the USB group</div><div class=\"line\"># 对所有用户开放USB设备的读写权限</div><div class=\"line\">none /proc/bus/usb usbfs devmode=666 0 0</div><div class=\"line\">然后就可以使用的USB设备了。</div></pre></td></tr></table></figure>\n<p><em>但是把USB设备的读写权限开放给所有用户的方式在一些情况下不太安全</em></p>\n<p>2.2 方法2：</p>\n<p>将用户名添加到vboxusers组,重启或注销后即可解决.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo adduser usrname vboxusers</div><div class=\"line\"></div><div class=\"line\">然后再输入：cat /etc/group |grep vboxusers</div><div class=\"line\">这时可以看到显示：</div><div class=\"line\">vboxusers:x:129:demon,hello</div></pre></td></tr></table></figure>\n<p><em>该方法使用后，基本能够使用，但使用之前每次需要手动添加设备</em></p>\n<p>2.3 方法3：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">增加用户组usbfs</div><div class=\"line\">$sudo groupadd usbfs</div><div class=\"line\"></div><div class=\"line\">查看usbfs用户组的gid</div><div class=\"line\">$ cat /etc/group | grep usbfs</div><div class=\"line\">usbfs:x:1002:</div><div class=\"line\"></div><div class=\"line\">把当前用户增加到usbfs组</div><div class=\"line\">sudo adduser demon usbfs</div></pre></td></tr></table></figure>\n<p>为USB设备重新设置权限,编辑/etc/fstab文件，添加下面两行，注意你的gid可能不是1002</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> $   sudo gedit /etc/fstab</div><div class=\"line\">在末尾加上</div><div class=\"line\"># 1002 is the USB group IDI</div><div class=\"line\">none /proc/bus/usb usbfs devgid=1002,devmode=774 0 0</div></pre></td></tr></table></figure>\n<p>重新启动后，应该就可以在客户机中使用USB设备了。</p>\n<p>方法：插入一个USB设备后，如U盘、鼠标，右键点击虚拟机里右下脚的USB图标，选择已经识别的U盘，就可以正常使用了。<br>注意： 在客户机里使用USB设备前要先在主机里卸载。</p>\n<p>﻿</p>\n<ol>\n<li>在virtualbox里启动USB控制器</li>\n</ol>\n<ol>\n<li>打开虚拟机，这时在虚拟机的设备-分配USB设备中就可以看到USB设备了</li>\n</ol>\n<blockquote>\n<p>相关参考：<br><a href=\"http://blog.csdn.net/rongyongfeikai2/article/details/21795741\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/rongyongfeikai2/article/details/21795741</a><br><a href=\"http://www.linuxidc.com/Linux/2012-01/52502.htm\" target=\"_blank\" rel=\"external\">http://www.linuxidc.com/Linux/2012-01/52502.htm</a><br><a href=\"http://xuantan.iteye.com/blog/1130808\" target=\"_blank\" rel=\"external\">http://xuantan.iteye.com/blog/1130808</a><br><a href=\"http://www.iteedu.com/os/linux/mklinuxdiary/ch1tools/2.php\" target=\"_blank\" rel=\"external\">http://www.iteedu.com/os/linux/mklinuxdiary/ch1tools/2.php</a></p>\n</blockquote>\n","excerpt":"<h3 id=\"背景分析\"><a href=\"#背景分析\" class=\"headerlink\" title=\"背景分析\"></a>背景分析</h3><p>随着计算机技术的发展，硬件配置越来越高，跨平台软件，手机以及浏览器越来越强大，目前可以说<br>linux下除了大型游戏意外，其他的办公学习娱乐基本都可以解决，比如：</p>","more":"<ul>\n<li>购物可以电脑浏览，手机支付（很多win用户，估计也不怎么用u盾了）。</li>\n<li>音乐可以使用百度，qq在线音乐。</li>\n<li>至于编程等开发工具更是齐全。</li>\n</ul>\n<p>但仍然难免会有一些windows程序需要用户操心，个人主要需用使用的windows产品有：<br><em>迅雷，百度云，photoshop，illustrator，U盘系统制作工具等</em></p>\n<p>解决办法主要有：</p>\n<ul>\n<li>wine提供windows的类库，是软件windows软件直接可以在linux上面运行</li>\n<li>使用虚拟机，在linux上面虚拟一个windows xp出来，提供一定的硬件资源，运行需要使用的软件</li>\n</ul>\n<p><strong>这边我们选择虚拟机virtualbox，主要该软件开源小巧，且现在硬件强大，对资源的开销可以接收，外加wine向来不是太稳定，出现问题的几率高。</strong></p>\n<h4 id=\"系统环境\"><a href=\"#系统环境\" class=\"headerlink\" title=\"系统环境\"></a>系统环境</h4><ul>\n<li>ubuntu 16.04 终端输入： lsb_release -a</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">No LSB modules are available.</div><div class=\"line\">Distributor ID:\tUbuntu</div><div class=\"line\">Description:\tUbuntu 16.04 LTS</div><div class=\"line\">Release:\t16.04</div><div class=\"line\">Codename:\txenial</div></pre></td></tr></table></figure>\n<h3 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h3><p>步骤如下：</p>\n<ol>\n<li>需要安装Oracle Virtualbox</li>\n</ol>\n<p>可以使用sudo apt-get install virutalbox 安装</p>\n<p>也可以通过官网下载地址：<code>https://www.virtualbox.org/wiki/Downloads</code></p>\n<p>安装增强包的方法介绍：<code>http://gaoke0820.blog.163.com/blog/static/21664965201332802833510/</code></p>\n<ol>\n<li>安装完之后，U盘识别</li>\n</ol>\n<p><em>如果如VirtualBox客户机挂载U盘中设置后，linux中还不能挂载u盘，而使用sudo启动virtualbox后里面的客户机可以挂载U盘，原因为 普通用户没有使用USB设备权限。</em></p>\n<p>2.1 方法1：</p>\n<p>让GUEST识别USB设备</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo gedit   /etc/fstab</div><div class=\"line\"></div><div class=\"line\">在末尾加上</div><div class=\"line\"># the USB group</div><div class=\"line\"># 对所有用户开放USB设备的读写权限</div><div class=\"line\">none /proc/bus/usb usbfs devmode=666 0 0</div><div class=\"line\">然后就可以使用的USB设备了。</div></pre></td></tr></table></figure>\n<p><em>但是把USB设备的读写权限开放给所有用户的方式在一些情况下不太安全</em></p>\n<p>2.2 方法2：</p>\n<p>将用户名添加到vboxusers组,重启或注销后即可解决.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo adduser usrname vboxusers</div><div class=\"line\"></div><div class=\"line\">然后再输入：cat /etc/group |grep vboxusers</div><div class=\"line\">这时可以看到显示：</div><div class=\"line\">vboxusers:x:129:demon,hello</div></pre></td></tr></table></figure>\n<p><em>该方法使用后，基本能够使用，但使用之前每次需要手动添加设备</em></p>\n<p>2.3 方法3：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">增加用户组usbfs</div><div class=\"line\">$sudo groupadd usbfs</div><div class=\"line\"></div><div class=\"line\">查看usbfs用户组的gid</div><div class=\"line\">$ cat /etc/group | grep usbfs</div><div class=\"line\">usbfs:x:1002:</div><div class=\"line\"></div><div class=\"line\">把当前用户增加到usbfs组</div><div class=\"line\">sudo adduser demon usbfs</div></pre></td></tr></table></figure>\n<p>为USB设备重新设置权限,编辑/etc/fstab文件，添加下面两行，注意你的gid可能不是1002</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> $   sudo gedit /etc/fstab</div><div class=\"line\">在末尾加上</div><div class=\"line\"># 1002 is the USB group IDI</div><div class=\"line\">none /proc/bus/usb usbfs devgid=1002,devmode=774 0 0</div></pre></td></tr></table></figure>\n<p>重新启动后，应该就可以在客户机中使用USB设备了。</p>\n<p>方法：插入一个USB设备后，如U盘、鼠标，右键点击虚拟机里右下脚的USB图标，选择已经识别的U盘，就可以正常使用了。<br>注意： 在客户机里使用USB设备前要先在主机里卸载。</p>\n<p>﻿</p>\n<ol>\n<li>在virtualbox里启动USB控制器</li>\n</ol>\n<ol>\n<li>打开虚拟机，这时在虚拟机的设备-分配USB设备中就可以看到USB设备了</li>\n</ol>\n<blockquote>\n<p>相关参考：<br><a href=\"http://blog.csdn.net/rongyongfeikai2/article/details/21795741\">http://blog.csdn.net/rongyongfeikai2/article/details/21795741</a><br><a href=\"http://www.linuxidc.com/Linux/2012-01/52502.htm\">http://www.linuxidc.com/Linux/2012-01/52502.htm</a><br><a href=\"http://xuantan.iteye.com/blog/1130808\">http://xuantan.iteye.com/blog/1130808</a><br><a href=\"http://www.iteedu.com/os/linux/mklinuxdiary/ch1tools/2.php\">http://www.iteedu.com/os/linux/mklinuxdiary/ch1tools/2.php</a></p>\n</blockquote>"},{"layout":"post","title":"chrome使用总结","date":"2016-07-09T17:28:00.000Z","_content":"\n*使用chrome虽然有好些年了，但其中的技巧种种，真的明白的并不多，本文着重总结chrome在日常使用中的一些快捷键，插件以及各种小技巧。*\n\n### 基本快捷键：\n\n- Ctrl+N 打开新窗口\n- Ctrl+T 打开新标签页\n- Ctrl+O，然后选择文件 在谷歌浏览器中打开计算机上的文件\n- **Ctrl+Shift+N 在隐身模式下打开新窗口**\n- **Ctrl+Shift+T 重新打开上次关闭的标签页。谷歌浏览器可记住最近关闭的 10 个标签页。**\n- Ctrl+W 或 Ctrl+F4 关闭当前标签页或弹出式窗口\n- Ctrl+H 查看”历史记录”页\n- Ctrl+J 查看”下载”页\n- **Shift+Escape 查看任务管理器**\n- F5 重新加载当前页\n- Ctrl+F 打开”在网页上查找”框\n- Ctrl+U 查看源代码\n- Ctrl+D 将当前网页加入书签\n- **Ctrl+0 将网页上的所有内容都恢复到正常大小**\n- ctrl+shift+T：这个快捷键组合可以打开你上次关闭的 tab 或者上次关闭窗口里面所有的 tab。\n\n**[更加详细的快捷键参考地址](https://support.google.com/chrome/answer/157179?hl=zh-Hans)**\n\n\n<!-- more -->\n\n### 扩展插件：\n![chrome插件预览图](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-14-chrome%E4%BD%BF%E7%94%A8%E6%8E%A8%E8%8D%90/DeepinScrot-5445.png)\n\n#### 必备插件：\n\n- 广告拦截：adblock plus 和 adblock pro，可以手动添加拦截，可以自动拦截，两个插件基本可以拦截腾讯视频的广告，但很多其他网站上的广告拦截不了。小黄瓜视频广告拦截，这个貌似可以拦截绝大多数的国内视频广告，但也存在一些副作用。\n- infinity new tab： 相当好用的一款tab插件，提供了不少针对chrome的扩展功能，重新规划了书签，扩展入口，历史记录等功能。Momentum：同infinity new tab类似，界面美观，但功能不够强大。\n- crxMouse Chrome Gestures：一款必备的定制手势的插件\n- Google Translate：一个小插件，用户体验不够好，提供了太多语言的选项，往往常用不是特别好，没有语言直接切换功能。翰林英汉双解词典：功能强大较多，但手动查找叫繁琐。\n- 惠惠购物助手：国内可以直观的购物比价的一个插件\n- hover zoom：鼠标悬停后自动放大图片，无论是浏览图片网站还是购物都是上佳的选择\n- Checker Plus for Gmail：很优秀的一款gmail邮箱插件，可以只支持gmail，其他邮箱并没有一款如此优秀的插件。\n- 有道云笔记网页剪报：快速将内容转入有道云笔记中。\n- Google Docs，sheet，slides：谷歌的office套件，基于web开发的，无须本地下载，功能齐全，线上可以实行多人同时阅览修改。\n- wechat： 可以登陆微信的一个app，版本太多，但只有个别几个比较好用。\n\n\n#### Github插件\n\n- GitHub Mate 这个插件使得单文件下载更加轻松，并且还提供了一些其他功能。\n- Isometric Contributions 这个插件允许你在普通的 Github 贡献表与等距像素艺术版之间切换。\n- Sourcegraph Chrome 扩展允许你像使用一个很好的 IDE 那样浏览源代码。它为 Github 上的代码添加了即时文档和类型提示，并为每一个标识符添加了跳转到定义处的链接。 \n- ZenHub 是一个 Github 的本地项目管理工具，可以无缝的集成。\n- GitHub Linker 是一个可以链接到 NPM、bower、Composer & Duo 依赖等项目主页的 Chrome 插件。\n- Github.Expandinizr 满屏显示项目\n- Avatars for Github 自动的为 GitHub 新闻和 Feed 页面添加显示用户头像。\n- Octotree 会为 Github 页面添加侧边栏，在浏览器中显示项目的目录结构，对于那些经常需要在 GitHub 阅读源代码的人非常有用。\n\n#### 图像插件\n\n- Fatkun图片批量下载：可以将一个或多个页面中的所有图片打包批量下载。对于\n- capture page，Capture, Explain and Send Screenshots：多功能的网页截图软件，所要的网页截图功能，这两款插件基本上全覆盖。\n- Pixlr Editor：在线版的photoshop，不解释。\n- ColorZilla：页面取色插件，速度快，功能强大。\n- hover zoom：鼠标悬停后自动放大图片，无论是浏览图片网站还是购物都是上佳的选择\n\n\n#### 其他\n\n- IP-Address：可以显示IP地址的小插件。\n- Proxy SwitchyOmega：\n- Marxico：书写markdown的一款chrome工具，可以本地使用，但不是免费，虽然界面美观，但大都基于web。\n\n\n\n#### chrome 插件推荐网站\n\n> http://www.cnplugins.com/\n> http://chromecj.com/\n\n\n\n\n\n### 小技巧：\n\n\n- 在网页标签处，单击鼠标中间键即可关闭网页，国内用户大都喜欢双击关闭页面，但大多数浏览器都支持中击关闭页面\n- Ctrl++，或者按住 Ctrl 键并向上滚动鼠标滚轮 放大网页上的所有内容,  Ctrl+-，或者按住 Ctrl 键并向下滚动鼠标滚轮 缩小网页上的所有内容，但一般**按住 ctrl 键转动鼠标滚轮实现页面缩放**, **Ctrl+0  将网页上的所有内容都恢复到正常大小**。\n- 地址栏输入错误内容后，每次提示错误内容很麻烦，可以如下操作，地址栏中选中你要删除的网址，按 shift+delete 就可以删除 chrome 浏览器地址栏输入过的记录，以免每次都自动补全错误地址。\n- Ctrl+Shift+N 在隐身模式下打开新窗口，隐身模式，是不会保存任何历史等记录的，默认也不会加载任何插件，但可以通过扩展插件手动设置某些插件在隐身下工作。\n- chrome批量删除书签:1.网址栏输入：`chrome://bookmarks` 2.`ctrl + A Delete`，但是注意这种方法仅仅删除了本地的书签，服务器的书签仍然存在，一单登陆账户仍然会同步过来。\n- 多台电脑数据重复冗余时，可以删除chrome的远程同步内容，打开设置，高级同步中点击了解更多，会出来chrome帮助网址，仔细阅读可以发现[网址](https://support.google.com/chrome/answer/1181035?hl=en&ref_topic=3421437)，可以清空云端设置，然后整理好本地内容，登陆账户重新上传本地同步。\n- 地址栏就是个计算器，输入你需要计算的公式（无需回车），下方直接出结果，非常方便，常用，输入方式**参考一般编程的公式输入方式**。\n- F12 按下后 ，刷新按钮可以右键或长按来选择刷新方式，普通刷新、硬性刷新和清空缓存硬性刷新。\n- 地址栏输入某网址，按 tab 键，对于像 baidu zhihu 这种自带检索能力的网址，直接可以完成站内检索，同样支持这样做的网址还有，taobao，优酷，土豆，stackoverflow，github等，似乎有搜索功能的知名网站都可以。\n\n\n### 高级操作\n\nchrome 的强大毋容置疑，与其说它是一个浏览网页的小工具，我们倒不如说它自己本身就是一个操作系统（只不过暂时依赖下层操作系统），事实上 Google 也确实基于网络应用开发了 chrome OS （一个完全独立的操作系统）。chrome 自己建立了完整的生态体系，各种强大的设置应用商城等等层出不穷，我们可以看做是一个网络操作系统，那么到底 chrome 隐藏了多少小秘密?打开( chrome://chrome-urls/ )查看chrome内部页面吧。\n\n- chrome://flags/#overlay-scrollbars 重叠式滚动条，开启后滚动条会自动缩放带有动画效果。\n- 保存网页本地阅读： 输入 `chrome://flags/` 然后开启 Save Page as MHTML 按照提示重启 chrome 之后右击网页保存即可。\n\n\n***\n\nTo be continued...\n\n\n> 参考链接：  \n> http://jingyan.baidu.com/article/359911f516583d57fe0306ae.html\n> http://zhidao.baidu.com/question/502291145.html\n> http://www.igooda.cn/jzjl/201604061075.html\n> http://jingyan.baidu.com/article/37bce2be1403ce1003f3a26d.html\n> https://www.zhihu.com/question/28531079?sort=created&page=2\n> https://www.zhihu.com/question/34682699\n> http://www.cnblogs.com/constantince/p/4565261.html\n","source":"_posts/2016/2016-07-10-chrome使用总结.md","raw":"---\nlayout: \"post\"\ntitle: \"chrome使用总结\"\ndate: \"2016-07-10 1:28\"\n---\n\n*使用chrome虽然有好些年了，但其中的技巧种种，真的明白的并不多，本文着重总结chrome在日常使用中的一些快捷键，插件以及各种小技巧。*\n\n### 基本快捷键：\n\n- Ctrl+N 打开新窗口\n- Ctrl+T 打开新标签页\n- Ctrl+O，然后选择文件 在谷歌浏览器中打开计算机上的文件\n- **Ctrl+Shift+N 在隐身模式下打开新窗口**\n- **Ctrl+Shift+T 重新打开上次关闭的标签页。谷歌浏览器可记住最近关闭的 10 个标签页。**\n- Ctrl+W 或 Ctrl+F4 关闭当前标签页或弹出式窗口\n- Ctrl+H 查看”历史记录”页\n- Ctrl+J 查看”下载”页\n- **Shift+Escape 查看任务管理器**\n- F5 重新加载当前页\n- Ctrl+F 打开”在网页上查找”框\n- Ctrl+U 查看源代码\n- Ctrl+D 将当前网页加入书签\n- **Ctrl+0 将网页上的所有内容都恢复到正常大小**\n- ctrl+shift+T：这个快捷键组合可以打开你上次关闭的 tab 或者上次关闭窗口里面所有的 tab。\n\n**[更加详细的快捷键参考地址](https://support.google.com/chrome/answer/157179?hl=zh-Hans)**\n\n\n<!-- more -->\n\n### 扩展插件：\n![chrome插件预览图](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-14-chrome%E4%BD%BF%E7%94%A8%E6%8E%A8%E8%8D%90/DeepinScrot-5445.png)\n\n#### 必备插件：\n\n- 广告拦截：adblock plus 和 adblock pro，可以手动添加拦截，可以自动拦截，两个插件基本可以拦截腾讯视频的广告，但很多其他网站上的广告拦截不了。小黄瓜视频广告拦截，这个貌似可以拦截绝大多数的国内视频广告，但也存在一些副作用。\n- infinity new tab： 相当好用的一款tab插件，提供了不少针对chrome的扩展功能，重新规划了书签，扩展入口，历史记录等功能。Momentum：同infinity new tab类似，界面美观，但功能不够强大。\n- crxMouse Chrome Gestures：一款必备的定制手势的插件\n- Google Translate：一个小插件，用户体验不够好，提供了太多语言的选项，往往常用不是特别好，没有语言直接切换功能。翰林英汉双解词典：功能强大较多，但手动查找叫繁琐。\n- 惠惠购物助手：国内可以直观的购物比价的一个插件\n- hover zoom：鼠标悬停后自动放大图片，无论是浏览图片网站还是购物都是上佳的选择\n- Checker Plus for Gmail：很优秀的一款gmail邮箱插件，可以只支持gmail，其他邮箱并没有一款如此优秀的插件。\n- 有道云笔记网页剪报：快速将内容转入有道云笔记中。\n- Google Docs，sheet，slides：谷歌的office套件，基于web开发的，无须本地下载，功能齐全，线上可以实行多人同时阅览修改。\n- wechat： 可以登陆微信的一个app，版本太多，但只有个别几个比较好用。\n\n\n#### Github插件\n\n- GitHub Mate 这个插件使得单文件下载更加轻松，并且还提供了一些其他功能。\n- Isometric Contributions 这个插件允许你在普通的 Github 贡献表与等距像素艺术版之间切换。\n- Sourcegraph Chrome 扩展允许你像使用一个很好的 IDE 那样浏览源代码。它为 Github 上的代码添加了即时文档和类型提示，并为每一个标识符添加了跳转到定义处的链接。 \n- ZenHub 是一个 Github 的本地项目管理工具，可以无缝的集成。\n- GitHub Linker 是一个可以链接到 NPM、bower、Composer & Duo 依赖等项目主页的 Chrome 插件。\n- Github.Expandinizr 满屏显示项目\n- Avatars for Github 自动的为 GitHub 新闻和 Feed 页面添加显示用户头像。\n- Octotree 会为 Github 页面添加侧边栏，在浏览器中显示项目的目录结构，对于那些经常需要在 GitHub 阅读源代码的人非常有用。\n\n#### 图像插件\n\n- Fatkun图片批量下载：可以将一个或多个页面中的所有图片打包批量下载。对于\n- capture page，Capture, Explain and Send Screenshots：多功能的网页截图软件，所要的网页截图功能，这两款插件基本上全覆盖。\n- Pixlr Editor：在线版的photoshop，不解释。\n- ColorZilla：页面取色插件，速度快，功能强大。\n- hover zoom：鼠标悬停后自动放大图片，无论是浏览图片网站还是购物都是上佳的选择\n\n\n#### 其他\n\n- IP-Address：可以显示IP地址的小插件。\n- Proxy SwitchyOmega：\n- Marxico：书写markdown的一款chrome工具，可以本地使用，但不是免费，虽然界面美观，但大都基于web。\n\n\n\n#### chrome 插件推荐网站\n\n> http://www.cnplugins.com/\n> http://chromecj.com/\n\n\n\n\n\n### 小技巧：\n\n\n- 在网页标签处，单击鼠标中间键即可关闭网页，国内用户大都喜欢双击关闭页面，但大多数浏览器都支持中击关闭页面\n- Ctrl++，或者按住 Ctrl 键并向上滚动鼠标滚轮 放大网页上的所有内容,  Ctrl+-，或者按住 Ctrl 键并向下滚动鼠标滚轮 缩小网页上的所有内容，但一般**按住 ctrl 键转动鼠标滚轮实现页面缩放**, **Ctrl+0  将网页上的所有内容都恢复到正常大小**。\n- 地址栏输入错误内容后，每次提示错误内容很麻烦，可以如下操作，地址栏中选中你要删除的网址，按 shift+delete 就可以删除 chrome 浏览器地址栏输入过的记录，以免每次都自动补全错误地址。\n- Ctrl+Shift+N 在隐身模式下打开新窗口，隐身模式，是不会保存任何历史等记录的，默认也不会加载任何插件，但可以通过扩展插件手动设置某些插件在隐身下工作。\n- chrome批量删除书签:1.网址栏输入：`chrome://bookmarks` 2.`ctrl + A Delete`，但是注意这种方法仅仅删除了本地的书签，服务器的书签仍然存在，一单登陆账户仍然会同步过来。\n- 多台电脑数据重复冗余时，可以删除chrome的远程同步内容，打开设置，高级同步中点击了解更多，会出来chrome帮助网址，仔细阅读可以发现[网址](https://support.google.com/chrome/answer/1181035?hl=en&ref_topic=3421437)，可以清空云端设置，然后整理好本地内容，登陆账户重新上传本地同步。\n- 地址栏就是个计算器，输入你需要计算的公式（无需回车），下方直接出结果，非常方便，常用，输入方式**参考一般编程的公式输入方式**。\n- F12 按下后 ，刷新按钮可以右键或长按来选择刷新方式，普通刷新、硬性刷新和清空缓存硬性刷新。\n- 地址栏输入某网址，按 tab 键，对于像 baidu zhihu 这种自带检索能力的网址，直接可以完成站内检索，同样支持这样做的网址还有，taobao，优酷，土豆，stackoverflow，github等，似乎有搜索功能的知名网站都可以。\n\n\n### 高级操作\n\nchrome 的强大毋容置疑，与其说它是一个浏览网页的小工具，我们倒不如说它自己本身就是一个操作系统（只不过暂时依赖下层操作系统），事实上 Google 也确实基于网络应用开发了 chrome OS （一个完全独立的操作系统）。chrome 自己建立了完整的生态体系，各种强大的设置应用商城等等层出不穷，我们可以看做是一个网络操作系统，那么到底 chrome 隐藏了多少小秘密?打开( chrome://chrome-urls/ )查看chrome内部页面吧。\n\n- chrome://flags/#overlay-scrollbars 重叠式滚动条，开启后滚动条会自动缩放带有动画效果。\n- 保存网页本地阅读： 输入 `chrome://flags/` 然后开启 Save Page as MHTML 按照提示重启 chrome 之后右击网页保存即可。\n\n\n***\n\nTo be continued...\n\n\n> 参考链接：  \n> http://jingyan.baidu.com/article/359911f516583d57fe0306ae.html\n> http://zhidao.baidu.com/question/502291145.html\n> http://www.igooda.cn/jzjl/201604061075.html\n> http://jingyan.baidu.com/article/37bce2be1403ce1003f3a26d.html\n> https://www.zhihu.com/question/28531079?sort=created&page=2\n> https://www.zhihu.com/question/34682699\n> http://www.cnblogs.com/constantince/p/4565261.html\n","slug":"2016/2016-07-10-chrome使用总结","published":1,"updated":"2016-12-16T01:19:00.518Z","comments":1,"photos":[],"link":"","_id":"ciyuv3agk000wmumugsvp0ixi","content":"<p><em>使用chrome虽然有好些年了，但其中的技巧种种，真的明白的并不多，本文着重总结chrome在日常使用中的一些快捷键，插件以及各种小技巧。</em></p>\n<h3 id=\"基本快捷键：\"><a href=\"#基本快捷键：\" class=\"headerlink\" title=\"基本快捷键：\"></a>基本快捷键：</h3><ul>\n<li>Ctrl+N 打开新窗口</li>\n<li>Ctrl+T 打开新标签页</li>\n<li>Ctrl+O，然后选择文件 在谷歌浏览器中打开计算机上的文件</li>\n<li><strong>Ctrl+Shift+N 在隐身模式下打开新窗口</strong></li>\n<li><strong>Ctrl+Shift+T 重新打开上次关闭的标签页。谷歌浏览器可记住最近关闭的 10 个标签页。</strong></li>\n<li>Ctrl+W 或 Ctrl+F4 关闭当前标签页或弹出式窗口</li>\n<li>Ctrl+H 查看”历史记录”页</li>\n<li>Ctrl+J 查看”下载”页</li>\n<li><strong>Shift+Escape 查看任务管理器</strong></li>\n<li>F5 重新加载当前页</li>\n<li>Ctrl+F 打开”在网页上查找”框</li>\n<li>Ctrl+U 查看源代码</li>\n<li>Ctrl+D 将当前网页加入书签</li>\n<li><strong>Ctrl+0 将网页上的所有内容都恢复到正常大小</strong></li>\n<li>ctrl+shift+T：这个快捷键组合可以打开你上次关闭的 tab 或者上次关闭窗口里面所有的 tab。</li>\n</ul>\n<p><strong><a href=\"https://support.google.com/chrome/answer/157179?hl=zh-Hans\" target=\"_blank\" rel=\"external\">更加详细的快捷键参考地址</a></strong></p>\n<a id=\"more\"></a>\n<h3 id=\"扩展插件：\"><a href=\"#扩展插件：\" class=\"headerlink\" title=\"扩展插件：\"></a>扩展插件：</h3><p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-14-chrome%E4%BD%BF%E7%94%A8%E6%8E%A8%E8%8D%90/DeepinScrot-5445.png\" alt=\"chrome插件预览图\"></p>\n<h4 id=\"必备插件：\"><a href=\"#必备插件：\" class=\"headerlink\" title=\"必备插件：\"></a>必备插件：</h4><ul>\n<li>广告拦截：adblock plus 和 adblock pro，可以手动添加拦截，可以自动拦截，两个插件基本可以拦截腾讯视频的广告，但很多其他网站上的广告拦截不了。小黄瓜视频广告拦截，这个貌似可以拦截绝大多数的国内视频广告，但也存在一些副作用。</li>\n<li>infinity new tab： 相当好用的一款tab插件，提供了不少针对chrome的扩展功能，重新规划了书签，扩展入口，历史记录等功能。Momentum：同infinity new tab类似，界面美观，但功能不够强大。</li>\n<li>crxMouse Chrome Gestures：一款必备的定制手势的插件</li>\n<li>Google Translate：一个小插件，用户体验不够好，提供了太多语言的选项，往往常用不是特别好，没有语言直接切换功能。翰林英汉双解词典：功能强大较多，但手动查找叫繁琐。</li>\n<li>惠惠购物助手：国内可以直观的购物比价的一个插件</li>\n<li>hover zoom：鼠标悬停后自动放大图片，无论是浏览图片网站还是购物都是上佳的选择</li>\n<li>Checker Plus for Gmail：很优秀的一款gmail邮箱插件，可以只支持gmail，其他邮箱并没有一款如此优秀的插件。</li>\n<li>有道云笔记网页剪报：快速将内容转入有道云笔记中。</li>\n<li>Google Docs，sheet，slides：谷歌的office套件，基于web开发的，无须本地下载，功能齐全，线上可以实行多人同时阅览修改。</li>\n<li>wechat： 可以登陆微信的一个app，版本太多，但只有个别几个比较好用。</li>\n</ul>\n<h4 id=\"Github插件\"><a href=\"#Github插件\" class=\"headerlink\" title=\"Github插件\"></a>Github插件</h4><ul>\n<li>GitHub Mate 这个插件使得单文件下载更加轻松，并且还提供了一些其他功能。</li>\n<li>Isometric Contributions 这个插件允许你在普通的 Github 贡献表与等距像素艺术版之间切换。</li>\n<li>Sourcegraph Chrome 扩展允许你像使用一个很好的 IDE 那样浏览源代码。它为 Github 上的代码添加了即时文档和类型提示，并为每一个标识符添加了跳转到定义处的链接。 </li>\n<li>ZenHub 是一个 Github 的本地项目管理工具，可以无缝的集成。</li>\n<li>GitHub Linker 是一个可以链接到 NPM、bower、Composer &amp; Duo 依赖等项目主页的 Chrome 插件。</li>\n<li>Github.Expandinizr 满屏显示项目</li>\n<li>Avatars for Github 自动的为 GitHub 新闻和 Feed 页面添加显示用户头像。</li>\n<li>Octotree 会为 Github 页面添加侧边栏，在浏览器中显示项目的目录结构，对于那些经常需要在 GitHub 阅读源代码的人非常有用。</li>\n</ul>\n<h4 id=\"图像插件\"><a href=\"#图像插件\" class=\"headerlink\" title=\"图像插件\"></a>图像插件</h4><ul>\n<li>Fatkun图片批量下载：可以将一个或多个页面中的所有图片打包批量下载。对于</li>\n<li>capture page，Capture, Explain and Send Screenshots：多功能的网页截图软件，所要的网页截图功能，这两款插件基本上全覆盖。</li>\n<li>Pixlr Editor：在线版的photoshop，不解释。</li>\n<li>ColorZilla：页面取色插件，速度快，功能强大。</li>\n<li>hover zoom：鼠标悬停后自动放大图片，无论是浏览图片网站还是购物都是上佳的选择</li>\n</ul>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><ul>\n<li>IP-Address：可以显示IP地址的小插件。</li>\n<li>Proxy SwitchyOmega：</li>\n<li>Marxico：书写markdown的一款chrome工具，可以本地使用，但不是免费，虽然界面美观，但大都基于web。</li>\n</ul>\n<h4 id=\"chrome-插件推荐网站\"><a href=\"#chrome-插件推荐网站\" class=\"headerlink\" title=\"chrome 插件推荐网站\"></a>chrome 插件推荐网站</h4><blockquote>\n<p><a href=\"http://www.cnplugins.com/\" target=\"_blank\" rel=\"external\">http://www.cnplugins.com/</a><br><a href=\"http://chromecj.com/\" target=\"_blank\" rel=\"external\">http://chromecj.com/</a></p>\n</blockquote>\n<h3 id=\"小技巧：\"><a href=\"#小技巧：\" class=\"headerlink\" title=\"小技巧：\"></a>小技巧：</h3><ul>\n<li>在网页标签处，单击鼠标中间键即可关闭网页，国内用户大都喜欢双击关闭页面，但大多数浏览器都支持中击关闭页面</li>\n<li>Ctrl++，或者按住 Ctrl 键并向上滚动鼠标滚轮 放大网页上的所有内容,  Ctrl+-，或者按住 Ctrl 键并向下滚动鼠标滚轮 缩小网页上的所有内容，但一般<strong>按住 ctrl 键转动鼠标滚轮实现页面缩放</strong>, <strong>Ctrl+0  将网页上的所有内容都恢复到正常大小</strong>。</li>\n<li>地址栏输入错误内容后，每次提示错误内容很麻烦，可以如下操作，地址栏中选中你要删除的网址，按 shift+delete 就可以删除 chrome 浏览器地址栏输入过的记录，以免每次都自动补全错误地址。</li>\n<li>Ctrl+Shift+N 在隐身模式下打开新窗口，隐身模式，是不会保存任何历史等记录的，默认也不会加载任何插件，但可以通过扩展插件手动设置某些插件在隐身下工作。</li>\n<li>chrome批量删除书签:1.网址栏输入：<code>chrome://bookmarks</code> 2.<code>ctrl + A Delete</code>，但是注意这种方法仅仅删除了本地的书签，服务器的书签仍然存在，一单登陆账户仍然会同步过来。</li>\n<li>多台电脑数据重复冗余时，可以删除chrome的远程同步内容，打开设置，高级同步中点击了解更多，会出来chrome帮助网址，仔细阅读可以发现<a href=\"https://support.google.com/chrome/answer/1181035?hl=en&amp;ref_topic=3421437\" target=\"_blank\" rel=\"external\">网址</a>，可以清空云端设置，然后整理好本地内容，登陆账户重新上传本地同步。</li>\n<li>地址栏就是个计算器，输入你需要计算的公式（无需回车），下方直接出结果，非常方便，常用，输入方式<strong>参考一般编程的公式输入方式</strong>。</li>\n<li>F12 按下后 ，刷新按钮可以右键或长按来选择刷新方式，普通刷新、硬性刷新和清空缓存硬性刷新。</li>\n<li>地址栏输入某网址，按 tab 键，对于像 baidu zhihu 这种自带检索能力的网址，直接可以完成站内检索，同样支持这样做的网址还有，taobao，优酷，土豆，stackoverflow，github等，似乎有搜索功能的知名网站都可以。</li>\n</ul>\n<h3 id=\"高级操作\"><a href=\"#高级操作\" class=\"headerlink\" title=\"高级操作\"></a>高级操作</h3><p>chrome 的强大毋容置疑，与其说它是一个浏览网页的小工具，我们倒不如说它自己本身就是一个操作系统（只不过暂时依赖下层操作系统），事实上 Google 也确实基于网络应用开发了 chrome OS （一个完全独立的操作系统）。chrome 自己建立了完整的生态体系，各种强大的设置应用商城等等层出不穷，我们可以看做是一个网络操作系统，那么到底 chrome 隐藏了多少小秘密?打开( chrome://chrome-urls/ )查看chrome内部页面吧。</p>\n<ul>\n<li>chrome://flags/#overlay-scrollbars 重叠式滚动条，开启后滚动条会自动缩放带有动画效果。</li>\n<li>保存网页本地阅读： 输入 <code>chrome://flags/</code> 然后开启 Save Page as MHTML 按照提示重启 chrome 之后右击网页保存即可。</li>\n</ul>\n<hr>\n<p>To be continued…</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://jingyan.baidu.com/article/359911f516583d57fe0306ae.html\" target=\"_blank\" rel=\"external\">http://jingyan.baidu.com/article/359911f516583d57fe0306ae.html</a><br><a href=\"http://zhidao.baidu.com/question/502291145.html\" target=\"_blank\" rel=\"external\">http://zhidao.baidu.com/question/502291145.html</a><br><a href=\"http://www.igooda.cn/jzjl/201604061075.html\" target=\"_blank\" rel=\"external\">http://www.igooda.cn/jzjl/201604061075.html</a><br><a href=\"http://jingyan.baidu.com/article/37bce2be1403ce1003f3a26d.html\" target=\"_blank\" rel=\"external\">http://jingyan.baidu.com/article/37bce2be1403ce1003f3a26d.html</a><br><a href=\"https://www.zhihu.com/question/28531079?sort=created&amp;page=2\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/28531079?sort=created&amp;page=2</a><br><a href=\"https://www.zhihu.com/question/34682699\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/34682699</a><br><a href=\"http://www.cnblogs.com/constantince/p/4565261.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/constantince/p/4565261.html</a></p>\n</blockquote>\n","excerpt":"<p><em>使用chrome虽然有好些年了，但其中的技巧种种，真的明白的并不多，本文着重总结chrome在日常使用中的一些快捷键，插件以及各种小技巧。</em></p>\n<h3 id=\"基本快捷键：\"><a href=\"#基本快捷键：\" class=\"headerlink\" title=\"基本快捷键：\"></a>基本快捷键：</h3><ul>\n<li>Ctrl+N 打开新窗口</li>\n<li>Ctrl+T 打开新标签页</li>\n<li>Ctrl+O，然后选择文件 在谷歌浏览器中打开计算机上的文件</li>\n<li><strong>Ctrl+Shift+N 在隐身模式下打开新窗口</strong></li>\n<li><strong>Ctrl+Shift+T 重新打开上次关闭的标签页。谷歌浏览器可记住最近关闭的 10 个标签页。</strong></li>\n<li>Ctrl+W 或 Ctrl+F4 关闭当前标签页或弹出式窗口</li>\n<li>Ctrl+H 查看”历史记录”页</li>\n<li>Ctrl+J 查看”下载”页</li>\n<li><strong>Shift+Escape 查看任务管理器</strong></li>\n<li>F5 重新加载当前页</li>\n<li>Ctrl+F 打开”在网页上查找”框</li>\n<li>Ctrl+U 查看源代码</li>\n<li>Ctrl+D 将当前网页加入书签</li>\n<li><strong>Ctrl+0 将网页上的所有内容都恢复到正常大小</strong></li>\n<li>ctrl+shift+T：这个快捷键组合可以打开你上次关闭的 tab 或者上次关闭窗口里面所有的 tab。</li>\n</ul>\n<p><strong><a href=\"https://support.google.com/chrome/answer/157179?hl=zh-Hans\">更加详细的快捷键参考地址</a></strong></p>","more":"<h3 id=\"扩展插件：\"><a href=\"#扩展插件：\" class=\"headerlink\" title=\"扩展插件：\"></a>扩展插件：</h3><p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-14-chrome%E4%BD%BF%E7%94%A8%E6%8E%A8%E8%8D%90/DeepinScrot-5445.png\" alt=\"chrome插件预览图\"></p>\n<h4 id=\"必备插件：\"><a href=\"#必备插件：\" class=\"headerlink\" title=\"必备插件：\"></a>必备插件：</h4><ul>\n<li>广告拦截：adblock plus 和 adblock pro，可以手动添加拦截，可以自动拦截，两个插件基本可以拦截腾讯视频的广告，但很多其他网站上的广告拦截不了。小黄瓜视频广告拦截，这个貌似可以拦截绝大多数的国内视频广告，但也存在一些副作用。</li>\n<li>infinity new tab： 相当好用的一款tab插件，提供了不少针对chrome的扩展功能，重新规划了书签，扩展入口，历史记录等功能。Momentum：同infinity new tab类似，界面美观，但功能不够强大。</li>\n<li>crxMouse Chrome Gestures：一款必备的定制手势的插件</li>\n<li>Google Translate：一个小插件，用户体验不够好，提供了太多语言的选项，往往常用不是特别好，没有语言直接切换功能。翰林英汉双解词典：功能强大较多，但手动查找叫繁琐。</li>\n<li>惠惠购物助手：国内可以直观的购物比价的一个插件</li>\n<li>hover zoom：鼠标悬停后自动放大图片，无论是浏览图片网站还是购物都是上佳的选择</li>\n<li>Checker Plus for Gmail：很优秀的一款gmail邮箱插件，可以只支持gmail，其他邮箱并没有一款如此优秀的插件。</li>\n<li>有道云笔记网页剪报：快速将内容转入有道云笔记中。</li>\n<li>Google Docs，sheet，slides：谷歌的office套件，基于web开发的，无须本地下载，功能齐全，线上可以实行多人同时阅览修改。</li>\n<li>wechat： 可以登陆微信的一个app，版本太多，但只有个别几个比较好用。</li>\n</ul>\n<h4 id=\"Github插件\"><a href=\"#Github插件\" class=\"headerlink\" title=\"Github插件\"></a>Github插件</h4><ul>\n<li>GitHub Mate 这个插件使得单文件下载更加轻松，并且还提供了一些其他功能。</li>\n<li>Isometric Contributions 这个插件允许你在普通的 Github 贡献表与等距像素艺术版之间切换。</li>\n<li>Sourcegraph Chrome 扩展允许你像使用一个很好的 IDE 那样浏览源代码。它为 Github 上的代码添加了即时文档和类型提示，并为每一个标识符添加了跳转到定义处的链接。 </li>\n<li>ZenHub 是一个 Github 的本地项目管理工具，可以无缝的集成。</li>\n<li>GitHub Linker 是一个可以链接到 NPM、bower、Composer &amp; Duo 依赖等项目主页的 Chrome 插件。</li>\n<li>Github.Expandinizr 满屏显示项目</li>\n<li>Avatars for Github 自动的为 GitHub 新闻和 Feed 页面添加显示用户头像。</li>\n<li>Octotree 会为 Github 页面添加侧边栏，在浏览器中显示项目的目录结构，对于那些经常需要在 GitHub 阅读源代码的人非常有用。</li>\n</ul>\n<h4 id=\"图像插件\"><a href=\"#图像插件\" class=\"headerlink\" title=\"图像插件\"></a>图像插件</h4><ul>\n<li>Fatkun图片批量下载：可以将一个或多个页面中的所有图片打包批量下载。对于</li>\n<li>capture page，Capture, Explain and Send Screenshots：多功能的网页截图软件，所要的网页截图功能，这两款插件基本上全覆盖。</li>\n<li>Pixlr Editor：在线版的photoshop，不解释。</li>\n<li>ColorZilla：页面取色插件，速度快，功能强大。</li>\n<li>hover zoom：鼠标悬停后自动放大图片，无论是浏览图片网站还是购物都是上佳的选择</li>\n</ul>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><ul>\n<li>IP-Address：可以显示IP地址的小插件。</li>\n<li>Proxy SwitchyOmega：</li>\n<li>Marxico：书写markdown的一款chrome工具，可以本地使用，但不是免费，虽然界面美观，但大都基于web。</li>\n</ul>\n<h4 id=\"chrome-插件推荐网站\"><a href=\"#chrome-插件推荐网站\" class=\"headerlink\" title=\"chrome 插件推荐网站\"></a>chrome 插件推荐网站</h4><blockquote>\n<p><a href=\"http://www.cnplugins.com/\">http://www.cnplugins.com/</a><br><a href=\"http://chromecj.com/\">http://chromecj.com/</a></p>\n</blockquote>\n<h3 id=\"小技巧：\"><a href=\"#小技巧：\" class=\"headerlink\" title=\"小技巧：\"></a>小技巧：</h3><ul>\n<li>在网页标签处，单击鼠标中间键即可关闭网页，国内用户大都喜欢双击关闭页面，但大多数浏览器都支持中击关闭页面</li>\n<li>Ctrl++，或者按住 Ctrl 键并向上滚动鼠标滚轮 放大网页上的所有内容,  Ctrl+-，或者按住 Ctrl 键并向下滚动鼠标滚轮 缩小网页上的所有内容，但一般<strong>按住 ctrl 键转动鼠标滚轮实现页面缩放</strong>, <strong>Ctrl+0  将网页上的所有内容都恢复到正常大小</strong>。</li>\n<li>地址栏输入错误内容后，每次提示错误内容很麻烦，可以如下操作，地址栏中选中你要删除的网址，按 shift+delete 就可以删除 chrome 浏览器地址栏输入过的记录，以免每次都自动补全错误地址。</li>\n<li>Ctrl+Shift+N 在隐身模式下打开新窗口，隐身模式，是不会保存任何历史等记录的，默认也不会加载任何插件，但可以通过扩展插件手动设置某些插件在隐身下工作。</li>\n<li>chrome批量删除书签:1.网址栏输入：<code>chrome://bookmarks</code> 2.<code>ctrl + A Delete</code>，但是注意这种方法仅仅删除了本地的书签，服务器的书签仍然存在，一单登陆账户仍然会同步过来。</li>\n<li>多台电脑数据重复冗余时，可以删除chrome的远程同步内容，打开设置，高级同步中点击了解更多，会出来chrome帮助网址，仔细阅读可以发现<a href=\"https://support.google.com/chrome/answer/1181035?hl=en&amp;ref_topic=3421437\">网址</a>，可以清空云端设置，然后整理好本地内容，登陆账户重新上传本地同步。</li>\n<li>地址栏就是个计算器，输入你需要计算的公式（无需回车），下方直接出结果，非常方便，常用，输入方式<strong>参考一般编程的公式输入方式</strong>。</li>\n<li>F12 按下后 ，刷新按钮可以右键或长按来选择刷新方式，普通刷新、硬性刷新和清空缓存硬性刷新。</li>\n<li>地址栏输入某网址，按 tab 键，对于像 baidu zhihu 这种自带检索能力的网址，直接可以完成站内检索，同样支持这样做的网址还有，taobao，优酷，土豆，stackoverflow，github等，似乎有搜索功能的知名网站都可以。</li>\n</ul>\n<h3 id=\"高级操作\"><a href=\"#高级操作\" class=\"headerlink\" title=\"高级操作\"></a>高级操作</h3><p>chrome 的强大毋容置疑，与其说它是一个浏览网页的小工具，我们倒不如说它自己本身就是一个操作系统（只不过暂时依赖下层操作系统），事实上 Google 也确实基于网络应用开发了 chrome OS （一个完全独立的操作系统）。chrome 自己建立了完整的生态体系，各种强大的设置应用商城等等层出不穷，我们可以看做是一个网络操作系统，那么到底 chrome 隐藏了多少小秘密?打开( chrome://chrome-urls/ )查看chrome内部页面吧。</p>\n<ul>\n<li>chrome://flags/#overlay-scrollbars 重叠式滚动条，开启后滚动条会自动缩放带有动画效果。</li>\n<li>保存网页本地阅读： 输入 <code>chrome://flags/</code> 然后开启 Save Page as MHTML 按照提示重启 chrome 之后右击网页保存即可。</li>\n</ul>\n<hr>\n<p>To be continued…</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://jingyan.baidu.com/article/359911f516583d57fe0306ae.html\">http://jingyan.baidu.com/article/359911f516583d57fe0306ae.html</a><br><a href=\"http://zhidao.baidu.com/question/502291145.html\">http://zhidao.baidu.com/question/502291145.html</a><br><a href=\"http://www.igooda.cn/jzjl/201604061075.html\">http://www.igooda.cn/jzjl/201604061075.html</a><br><a href=\"http://jingyan.baidu.com/article/37bce2be1403ce1003f3a26d.html\">http://jingyan.baidu.com/article/37bce2be1403ce1003f3a26d.html</a><br><a href=\"https://www.zhihu.com/question/28531079?sort=created&amp;page=2\">https://www.zhihu.com/question/28531079?sort=created&amp;page=2</a><br><a href=\"https://www.zhihu.com/question/34682699\">https://www.zhihu.com/question/34682699</a><br><a href=\"http://www.cnblogs.com/constantince/p/4565261.html\">http://www.cnblogs.com/constantince/p/4565261.html</a></p>\n</blockquote>"},{"layout":"post","title":"MDK5安装及配置","date":"2016-07-10T17:12:00.000Z","_content":"\n\n### MDK简介\n\n> Keil MDK，也称MDK-ARM，Realview MDK、I-MDK、uVision4 等。Keil C51 是美国 Keil Software 公司出品的 51 系列兼容单片机 C 语言软件开发系统，被 ARM（英国）公司收购，作为在 51 单片机时代相当流行的一个软件。\n\n*而如果你是一个嵌入式工作者，尤其是主要使用ST或者飞思卡尔等工业产品为主的芯片，在国内的话可以说你的选择要么是keil要么就是IAR。keil作为一个IDE来说编辑功能缺失恨薄弱，但是硬件调试能力还是毋容置疑的，而keil配置简单容易上手，该有的功能操作也都具备，本文主要讲述作者的一些keil配置及习惯。*\n\n#### 优点：\n\n- 界面友好，上手简单\n- 被ARM公司收购，编辑ARM相对友好，仿真功能十分强大\n- 官方提供各种芯片的启动代码，仿真库\n\n#### 缺点：\n\n- 自带编辑功能薄弱\n- 不支持/极少支持第三方插件\n\n<!-- more -->\n\n\n### KEIL 5配置\n\n#### 界面配置\n\n- Keil 5及之后的版本缺少相关的原件类库，需要额外安装。可以从官网下载芯片库\n- \n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture1.png)\n\n- Keil 4.6及之后的版本对中文字体支持依旧很差，通过修改成GB2312的简体中文编码，可以让注释的中文字体不会拆分，但默认的Courier New - 10不能够良好的显示所有字体，直接通过修改GB2312会形成字体锯齿化，缺少虚化的过渡。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture2.png)\n\n- 通过尝试多种字体以及添加fonts文件，发现要么中文字体显示不错，英文不行，要么英文显示不错，中文不行，很多情况代码字体偏大或者偏小，最终个人觉得较好的配置界面如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture3.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture4.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture5.png)\n\n- 如果需要修改背景颜色，需要对c/c++ Editor files 下的text，number等所有的background进行修改。配置如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture6.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture7.png)\n\n- 光标指向向的颜色修改如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture8.png)\n\n- 菜单栏view下面的所有工具栏颜色是跟随系统变化的，可以采用如果腾讯软件管家之类的工具开启护眼模式。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture9.png)\n\n\n#### KEIL建立单片机工程文件注意事项：：\n- 注意KEIL的配置详细可以参考“Keil 5配置”文档。\n- 工程文件建立目录结构需清晰可参考下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture10.png)\n\n该工具条中主要存放的是项目中需要使用到的C文件（注意并不包含任何头文件），只有加入这个工具中得.c文件才会进行项目的编译。\n下面仅作参考，根据个人的习惯而定制，相关存放内容说明：\n```\nCORE：存放SOC相关代码，包含.s启动文件，CMSIS的部分.c文件以及CPU相关的底层核心文件\nFWLIB：固件库，厂方提供的标准固件库，用于调用外设的函数。\nBSP：操作系统与芯片的中间层\nUSER：用户自己写的函数文件，包括main和用户定制的功能函数\nOS：具体名称为操作系统名称，可以是UCOS，uclinux等等嵌入式操作系统\nREADME：整个工程的相关项目说明\n```\n- 新建工程重点配置Define和Include Paths，如下图\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture12.png)\n\n\n*需强调的是 Define 中的选项不能少，这些选项一般都是如：stm32f10x.h（芯片寄存器定义文件） 或者内核中的宏定义，可以用来进行芯片选型等操作，可以用查找工具全局查找，会发现相关的 #ifdef 语句。本质上面来说，Define 加入的内容就相当于在 c 文件中手动的写入 #define xxx 语句。\nInclude Paths 中定义的都是头文件所在的路径，注意是头文件的路经，这边 ..\\CMSIS 等都是使用 windows 下相对路径的格式，如果头文件不在 Include Paths 下的路经中，则编译器无法找到相关头文件，会编译失败。*\n\n**其他注意点：**\nC99Mode如果不勾选，默认可能会使用C89的编译器，一些如 bool 类型或者定义申明可能会无法编译，C89对老版本兼容性更好，但C99加入的许多新特性让编程更“合理”。具体根据自己项目需求而定。\n\n- Debug 中进行相关模拟仿真下载器设置。一定要记得仿真设置 Reset and Run\n\n有仿真器的话，使用右边的仿真器选项，没有的话，则使用模拟。仿真器种类繁多，最常用的比如 JLINK，和 keil ulink 之类的，一些公司也会推出自己的仿真器，如silabs uda等\n\n*最好勾选setting->flash download下的Reset and Run，这样可以无需重新上电即可运行程序。*\n\nJLink 在连接 STM32F439 时，在勾选或者不勾选 Verify Code Download 时可能会出现下载错误，可能会是板子设计缺陷或者JLink版本过高。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture11.png)\n\n- Utilities：将Use Debug Driver勾选或者手动设置成相同的调试器。\n\n- 移植程序注意重点：\n\n```\nProject 的 USER 中一定要把 .c 源文件添加进去 \nFWLIB一定要记得添加 stm32f10x_xxx 相关的外设库文件\nStm32xxx_conf.h 中需取消相关注释\n用户定义的.h头文件需加入 #include \"stm32f10x.h\"，且不需要加入 Stm32xxx_conf.h 因为该头文件已经在 #include \"stm32f10x.h\" 中包含了。\n添加用户自定义 .c 文件时，记得把其头文件写入到 main 函数所在文件中\n```\n\n\n> 参考链接：\n> http://www.jb51.net/os/windows/211837.html\n> http://comm.chinaaet.com/adi/blogdetail/32471.html\n","source":"_posts/2016/2016-07-11-MDK5安装及配置.md","raw":"---\nlayout: post\ncategory: \"软件安装\"\ntitle:  MDK5安装及配置\ntags:   软件安装\ndate: \"2016-07-11 1:12\"\n---\n\n\n### MDK简介\n\n> Keil MDK，也称MDK-ARM，Realview MDK、I-MDK、uVision4 等。Keil C51 是美国 Keil Software 公司出品的 51 系列兼容单片机 C 语言软件开发系统，被 ARM（英国）公司收购，作为在 51 单片机时代相当流行的一个软件。\n\n*而如果你是一个嵌入式工作者，尤其是主要使用ST或者飞思卡尔等工业产品为主的芯片，在国内的话可以说你的选择要么是keil要么就是IAR。keil作为一个IDE来说编辑功能缺失恨薄弱，但是硬件调试能力还是毋容置疑的，而keil配置简单容易上手，该有的功能操作也都具备，本文主要讲述作者的一些keil配置及习惯。*\n\n#### 优点：\n\n- 界面友好，上手简单\n- 被ARM公司收购，编辑ARM相对友好，仿真功能十分强大\n- 官方提供各种芯片的启动代码，仿真库\n\n#### 缺点：\n\n- 自带编辑功能薄弱\n- 不支持/极少支持第三方插件\n\n<!-- more -->\n\n\n### KEIL 5配置\n\n#### 界面配置\n\n- Keil 5及之后的版本缺少相关的原件类库，需要额外安装。可以从官网下载芯片库\n- \n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture1.png)\n\n- Keil 4.6及之后的版本对中文字体支持依旧很差，通过修改成GB2312的简体中文编码，可以让注释的中文字体不会拆分，但默认的Courier New - 10不能够良好的显示所有字体，直接通过修改GB2312会形成字体锯齿化，缺少虚化的过渡。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture2.png)\n\n- 通过尝试多种字体以及添加fonts文件，发现要么中文字体显示不错，英文不行，要么英文显示不错，中文不行，很多情况代码字体偏大或者偏小，最终个人觉得较好的配置界面如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture3.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture4.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture5.png)\n\n- 如果需要修改背景颜色，需要对c/c++ Editor files 下的text，number等所有的background进行修改。配置如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture6.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture7.png)\n\n- 光标指向向的颜色修改如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture8.png)\n\n- 菜单栏view下面的所有工具栏颜色是跟随系统变化的，可以采用如果腾讯软件管家之类的工具开启护眼模式。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture9.png)\n\n\n#### KEIL建立单片机工程文件注意事项：：\n- 注意KEIL的配置详细可以参考“Keil 5配置”文档。\n- 工程文件建立目录结构需清晰可参考下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture10.png)\n\n该工具条中主要存放的是项目中需要使用到的C文件（注意并不包含任何头文件），只有加入这个工具中得.c文件才会进行项目的编译。\n下面仅作参考，根据个人的习惯而定制，相关存放内容说明：\n```\nCORE：存放SOC相关代码，包含.s启动文件，CMSIS的部分.c文件以及CPU相关的底层核心文件\nFWLIB：固件库，厂方提供的标准固件库，用于调用外设的函数。\nBSP：操作系统与芯片的中间层\nUSER：用户自己写的函数文件，包括main和用户定制的功能函数\nOS：具体名称为操作系统名称，可以是UCOS，uclinux等等嵌入式操作系统\nREADME：整个工程的相关项目说明\n```\n- 新建工程重点配置Define和Include Paths，如下图\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture12.png)\n\n\n*需强调的是 Define 中的选项不能少，这些选项一般都是如：stm32f10x.h（芯片寄存器定义文件） 或者内核中的宏定义，可以用来进行芯片选型等操作，可以用查找工具全局查找，会发现相关的 #ifdef 语句。本质上面来说，Define 加入的内容就相当于在 c 文件中手动的写入 #define xxx 语句。\nInclude Paths 中定义的都是头文件所在的路径，注意是头文件的路经，这边 ..\\CMSIS 等都是使用 windows 下相对路径的格式，如果头文件不在 Include Paths 下的路经中，则编译器无法找到相关头文件，会编译失败。*\n\n**其他注意点：**\nC99Mode如果不勾选，默认可能会使用C89的编译器，一些如 bool 类型或者定义申明可能会无法编译，C89对老版本兼容性更好，但C99加入的许多新特性让编程更“合理”。具体根据自己项目需求而定。\n\n- Debug 中进行相关模拟仿真下载器设置。一定要记得仿真设置 Reset and Run\n\n有仿真器的话，使用右边的仿真器选项，没有的话，则使用模拟。仿真器种类繁多，最常用的比如 JLINK，和 keil ulink 之类的，一些公司也会推出自己的仿真器，如silabs uda等\n\n*最好勾选setting->flash download下的Reset and Run，这样可以无需重新上电即可运行程序。*\n\nJLink 在连接 STM32F439 时，在勾选或者不勾选 Verify Code Download 时可能会出现下载错误，可能会是板子设计缺陷或者JLink版本过高。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture11.png)\n\n- Utilities：将Use Debug Driver勾选或者手动设置成相同的调试器。\n\n- 移植程序注意重点：\n\n```\nProject 的 USER 中一定要把 .c 源文件添加进去 \nFWLIB一定要记得添加 stm32f10x_xxx 相关的外设库文件\nStm32xxx_conf.h 中需取消相关注释\n用户定义的.h头文件需加入 #include \"stm32f10x.h\"，且不需要加入 Stm32xxx_conf.h 因为该头文件已经在 #include \"stm32f10x.h\" 中包含了。\n添加用户自定义 .c 文件时，记得把其头文件写入到 main 函数所在文件中\n```\n\n\n> 参考链接：\n> http://www.jb51.net/os/windows/211837.html\n> http://comm.chinaaet.com/adi/blogdetail/32471.html\n","slug":"2016/2016-07-11-MDK5安装及配置","published":1,"updated":"2017-01-12T03:26:54.117Z","comments":1,"photos":[],"link":"","_id":"ciyuv3agn000zmumuwlwxhuy2","content":"<h3 id=\"MDK简介\"><a href=\"#MDK简介\" class=\"headerlink\" title=\"MDK简介\"></a>MDK简介</h3><blockquote>\n<p>Keil MDK，也称MDK-ARM，Realview MDK、I-MDK、uVision4 等。Keil C51 是美国 Keil Software 公司出品的 51 系列兼容单片机 C 语言软件开发系统，被 ARM（英国）公司收购，作为在 51 单片机时代相当流行的一个软件。</p>\n</blockquote>\n<p><em>而如果你是一个嵌入式工作者，尤其是主要使用ST或者飞思卡尔等工业产品为主的芯片，在国内的话可以说你的选择要么是keil要么就是IAR。keil作为一个IDE来说编辑功能缺失恨薄弱，但是硬件调试能力还是毋容置疑的，而keil配置简单容易上手，该有的功能操作也都具备，本文主要讲述作者的一些keil配置及习惯。</em></p>\n<h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>界面友好，上手简单</li>\n<li>被ARM公司收购，编辑ARM相对友好，仿真功能十分强大</li>\n<li>官方提供各种芯片的启动代码，仿真库</li>\n</ul>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ul>\n<li>自带编辑功能薄弱</li>\n<li>不支持/极少支持第三方插件</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"KEIL-5配置\"><a href=\"#KEIL-5配置\" class=\"headerlink\" title=\"KEIL 5配置\"></a>KEIL 5配置</h3><h4 id=\"界面配置\"><a href=\"#界面配置\" class=\"headerlink\" title=\"界面配置\"></a>界面配置</h4><ul>\n<li>Keil 5及之后的版本缺少相关的原件类库，需要额外安装。可以从官网下载芯片库</li>\n<li><p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture1.png\" alt=\"\"></p>\n</li>\n<li><p>Keil 4.6及之后的版本对中文字体支持依旧很差，通过修改成GB2312的简体中文编码，可以让注释的中文字体不会拆分，但默认的Courier New - 10不能够良好的显示所有字体，直接通过修改GB2312会形成字体锯齿化，缺少虚化的过渡。</p>\n</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture2.png\" alt=\"\"></p>\n<ul>\n<li>通过尝试多种字体以及添加fonts文件，发现要么中文字体显示不错，英文不行，要么英文显示不错，中文不行，很多情况代码字体偏大或者偏小，最终个人觉得较好的配置界面如下：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture3.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture4.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture5.png\" alt=\"\"></p>\n<ul>\n<li>如果需要修改背景颜色，需要对c/c++ Editor files 下的text，number等所有的background进行修改。配置如下：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture6.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture7.png\" alt=\"\"></p>\n<ul>\n<li>光标指向向的颜色修改如下：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture8.png\" alt=\"\"></p>\n<ul>\n<li>菜单栏view下面的所有工具栏颜色是跟随系统变化的，可以采用如果腾讯软件管家之类的工具开启护眼模式。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture9.png\" alt=\"\"></p>\n<h4 id=\"KEIL建立单片机工程文件注意事项：：\"><a href=\"#KEIL建立单片机工程文件注意事项：：\" class=\"headerlink\" title=\"KEIL建立单片机工程文件注意事项：：\"></a>KEIL建立单片机工程文件注意事项：：</h4><ul>\n<li>注意KEIL的配置详细可以参考“Keil 5配置”文档。</li>\n<li>工程文件建立目录结构需清晰可参考下图：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture10.png\" alt=\"\"></p>\n<p>该工具条中主要存放的是项目中需要使用到的C文件（注意并不包含任何头文件），只有加入这个工具中得.c文件才会进行项目的编译。<br>下面仅作参考，根据个人的习惯而定制，相关存放内容说明：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">CORE：存放SOC相关代码，包含.s启动文件，CMSIS的部分.c文件以及CPU相关的底层核心文件</div><div class=\"line\">FWLIB：固件库，厂方提供的标准固件库，用于调用外设的函数。</div><div class=\"line\">BSP：操作系统与芯片的中间层</div><div class=\"line\">USER：用户自己写的函数文件，包括main和用户定制的功能函数</div><div class=\"line\">OS：具体名称为操作系统名称，可以是UCOS，uclinux等等嵌入式操作系统</div><div class=\"line\">README：整个工程的相关项目说明</div></pre></td></tr></table></figure></p>\n<ul>\n<li>新建工程重点配置Define和Include Paths，如下图</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture12.png\" alt=\"\"></p>\n<p><em>需强调的是 Define 中的选项不能少，这些选项一般都是如：stm32f10x.h（芯片寄存器定义文件） 或者内核中的宏定义，可以用来进行芯片选型等操作，可以用查找工具全局查找，会发现相关的 #ifdef 语句。本质上面来说，Define 加入的内容就相当于在 c 文件中手动的写入 #define xxx 语句。<br>Include Paths 中定义的都是头文件所在的路径，注意是头文件的路经，这边 ..\\CMSIS 等都是使用 windows 下相对路径的格式，如果头文件不在 Include Paths 下的路经中，则编译器无法找到相关头文件，会编译失败。</em></p>\n<p><strong>其他注意点：</strong><br>C99Mode如果不勾选，默认可能会使用C89的编译器，一些如 bool 类型或者定义申明可能会无法编译，C89对老版本兼容性更好，但C99加入的许多新特性让编程更“合理”。具体根据自己项目需求而定。</p>\n<ul>\n<li>Debug 中进行相关模拟仿真下载器设置。一定要记得仿真设置 Reset and Run</li>\n</ul>\n<p>有仿真器的话，使用右边的仿真器选项，没有的话，则使用模拟。仿真器种类繁多，最常用的比如 JLINK，和 keil ulink 之类的，一些公司也会推出自己的仿真器，如silabs uda等</p>\n<p><em>最好勾选setting-&gt;flash download下的Reset and Run，这样可以无需重新上电即可运行程序。</em></p>\n<p>JLink 在连接 STM32F439 时，在勾选或者不勾选 Verify Code Download 时可能会出现下载错误，可能会是板子设计缺陷或者JLink版本过高。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture11.png\" alt=\"\"></p>\n<ul>\n<li><p>Utilities：将Use Debug Driver勾选或者手动设置成相同的调试器。</p>\n</li>\n<li><p>移植程序注意重点：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Project 的 USER 中一定要把 .c 源文件添加进去 </div><div class=\"line\">FWLIB一定要记得添加 stm32f10x_xxx 相关的外设库文件</div><div class=\"line\">Stm32xxx_conf.h 中需取消相关注释</div><div class=\"line\">用户定义的.h头文件需加入 #include &quot;stm32f10x.h&quot;，且不需要加入 Stm32xxx_conf.h 因为该头文件已经在 #include &quot;stm32f10x.h&quot; 中包含了。</div><div class=\"line\">添加用户自定义 .c 文件时，记得把其头文件写入到 main 函数所在文件中</div></pre></td></tr></table></figure>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.jb51.net/os/windows/211837.html\" target=\"_blank\" rel=\"external\">http://www.jb51.net/os/windows/211837.html</a><br><a href=\"http://comm.chinaaet.com/adi/blogdetail/32471.html\" target=\"_blank\" rel=\"external\">http://comm.chinaaet.com/adi/blogdetail/32471.html</a></p>\n</blockquote>\n","excerpt":"<h3 id=\"MDK简介\"><a href=\"#MDK简介\" class=\"headerlink\" title=\"MDK简介\"></a>MDK简介</h3><blockquote>\n<p>Keil MDK，也称MDK-ARM，Realview MDK、I-MDK、uVision4 等。Keil C51 是美国 Keil Software 公司出品的 51 系列兼容单片机 C 语言软件开发系统，被 ARM（英国）公司收购，作为在 51 单片机时代相当流行的一个软件。</p>\n</blockquote>\n<p><em>而如果你是一个嵌入式工作者，尤其是主要使用ST或者飞思卡尔等工业产品为主的芯片，在国内的话可以说你的选择要么是keil要么就是IAR。keil作为一个IDE来说编辑功能缺失恨薄弱，但是硬件调试能力还是毋容置疑的，而keil配置简单容易上手，该有的功能操作也都具备，本文主要讲述作者的一些keil配置及习惯。</em></p>\n<h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>界面友好，上手简单</li>\n<li>被ARM公司收购，编辑ARM相对友好，仿真功能十分强大</li>\n<li>官方提供各种芯片的启动代码，仿真库</li>\n</ul>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ul>\n<li>自带编辑功能薄弱</li>\n<li>不支持/极少支持第三方插件</li>\n</ul>","more":"<h3 id=\"KEIL-5配置\"><a href=\"#KEIL-5配置\" class=\"headerlink\" title=\"KEIL 5配置\"></a>KEIL 5配置</h3><h4 id=\"界面配置\"><a href=\"#界面配置\" class=\"headerlink\" title=\"界面配置\"></a>界面配置</h4><ul>\n<li>Keil 5及之后的版本缺少相关的原件类库，需要额外安装。可以从官网下载芯片库</li>\n<li><p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture1.png\" alt=\"\"></p>\n</li>\n<li><p>Keil 4.6及之后的版本对中文字体支持依旧很差，通过修改成GB2312的简体中文编码，可以让注释的中文字体不会拆分，但默认的Courier New - 10不能够良好的显示所有字体，直接通过修改GB2312会形成字体锯齿化，缺少虚化的过渡。</p>\n</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture2.png\" alt=\"\"></p>\n<ul>\n<li>通过尝试多种字体以及添加fonts文件，发现要么中文字体显示不错，英文不行，要么英文显示不错，中文不行，很多情况代码字体偏大或者偏小，最终个人觉得较好的配置界面如下：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture3.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture4.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture5.png\" alt=\"\"></p>\n<ul>\n<li>如果需要修改背景颜色，需要对c/c++ Editor files 下的text，number等所有的background进行修改。配置如下：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture6.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture7.png\" alt=\"\"></p>\n<ul>\n<li>光标指向向的颜色修改如下：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture8.png\" alt=\"\"></p>\n<ul>\n<li>菜单栏view下面的所有工具栏颜色是跟随系统变化的，可以采用如果腾讯软件管家之类的工具开启护眼模式。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture9.png\" alt=\"\"></p>\n<h4 id=\"KEIL建立单片机工程文件注意事项：：\"><a href=\"#KEIL建立单片机工程文件注意事项：：\" class=\"headerlink\" title=\"KEIL建立单片机工程文件注意事项：：\"></a>KEIL建立单片机工程文件注意事项：：</h4><ul>\n<li>注意KEIL的配置详细可以参考“Keil 5配置”文档。</li>\n<li>工程文件建立目录结构需清晰可参考下图：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture10.png\" alt=\"\"></p>\n<p>该工具条中主要存放的是项目中需要使用到的C文件（注意并不包含任何头文件），只有加入这个工具中得.c文件才会进行项目的编译。<br>下面仅作参考，根据个人的习惯而定制，相关存放内容说明：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">CORE：存放SOC相关代码，包含.s启动文件，CMSIS的部分.c文件以及CPU相关的底层核心文件</div><div class=\"line\">FWLIB：固件库，厂方提供的标准固件库，用于调用外设的函数。</div><div class=\"line\">BSP：操作系统与芯片的中间层</div><div class=\"line\">USER：用户自己写的函数文件，包括main和用户定制的功能函数</div><div class=\"line\">OS：具体名称为操作系统名称，可以是UCOS，uclinux等等嵌入式操作系统</div><div class=\"line\">README：整个工程的相关项目说明</div></pre></td></tr></table></figure></p>\n<ul>\n<li>新建工程重点配置Define和Include Paths，如下图</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture12.png\" alt=\"\"></p>\n<p><em>需强调的是 Define 中的选项不能少，这些选项一般都是如：stm32f10x.h（芯片寄存器定义文件） 或者内核中的宏定义，可以用来进行芯片选型等操作，可以用查找工具全局查找，会发现相关的 #ifdef 语句。本质上面来说，Define 加入的内容就相当于在 c 文件中手动的写入 #define xxx 语句。<br>Include Paths 中定义的都是头文件所在的路径，注意是头文件的路经，这边 ..\\CMSIS 等都是使用 windows 下相对路径的格式，如果头文件不在 Include Paths 下的路经中，则编译器无法找到相关头文件，会编译失败。</em></p>\n<p><strong>其他注意点：</strong><br>C99Mode如果不勾选，默认可能会使用C89的编译器，一些如 bool 类型或者定义申明可能会无法编译，C89对老版本兼容性更好，但C99加入的许多新特性让编程更“合理”。具体根据自己项目需求而定。</p>\n<ul>\n<li>Debug 中进行相关模拟仿真下载器设置。一定要记得仿真设置 Reset and Run</li>\n</ul>\n<p>有仿真器的话，使用右边的仿真器选项，没有的话，则使用模拟。仿真器种类繁多，最常用的比如 JLINK，和 keil ulink 之类的，一些公司也会推出自己的仿真器，如silabs uda等</p>\n<p><em>最好勾选setting-&gt;flash download下的Reset and Run，这样可以无需重新上电即可运行程序。</em></p>\n<p>JLink 在连接 STM32F439 时，在勾选或者不勾选 Verify Code Download 时可能会出现下载错误，可能会是板子设计缺陷或者JLink版本过高。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture11.png\" alt=\"\"></p>\n<ul>\n<li><p>Utilities：将Use Debug Driver勾选或者手动设置成相同的调试器。</p>\n</li>\n<li><p>移植程序注意重点：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Project 的 USER 中一定要把 .c 源文件添加进去 </div><div class=\"line\">FWLIB一定要记得添加 stm32f10x_xxx 相关的外设库文件</div><div class=\"line\">Stm32xxx_conf.h 中需取消相关注释</div><div class=\"line\">用户定义的.h头文件需加入 #include &quot;stm32f10x.h&quot;，且不需要加入 Stm32xxx_conf.h 因为该头文件已经在 #include &quot;stm32f10x.h&quot; 中包含了。</div><div class=\"line\">添加用户自定义 .c 文件时，记得把其头文件写入到 main 函数所在文件中</div></pre></td></tr></table></figure>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.jb51.net/os/windows/211837.html\">http://www.jb51.net/os/windows/211837.html</a><br><a href=\"http://comm.chinaaet.com/adi/blogdetail/32471.html\">http://comm.chinaaet.com/adi/blogdetail/32471.html</a></p>\n</blockquote>"},{"layout":"post","title":"GitHub_Page页面无法更新","date":"2016-07-10T17:00:00.000Z","_content":"\n### 详细问题：\n- 文章会在github的工程目录中出现，但github page中首页和存档都无法显示。\n- 仔细查看过套用的html等模板，未能发现有问题。\n- 连续多次都是某一次推送下，突然问题就解决了。\n- 通过github page提供的jekyll服务进行更新文章时，经常会出现文章已经上传到了github的远程库中，但github page却无法显示内容出来，这样的问题出现了很多差，但不断的上传或者某一次传输一个文章，突然就成功了。\n\n<!-- more -->\n\n\n### 具体原因：\n\nGitHub_Page 使用的是jekyll服务生成page页面的。由于jekyll 3（github目前的jekyll版本）默认对于认定为\"未来\"的post，是不生成的，详情可以参考[Future posts - Jekyll](http://jekyllrb.com/docs/upgrading/2-to-3/#future-posts)。这极有可能与github服务在美国有关,本人使用的是VPN在美国，不知道是否对此也有影响。\n\n### 解决方法：\n\n- 网上说可以修改feed.xml文件，具体看参考链接。（本人没有实验成功）\n- 我使用的方法改写时间：\n\n```\n---\nlayout: \"post\"\ntitle: \"GitHub_Page页面无法更新\"\ntags: \"问题总结\"\ncategory: \"read\"\ndate: \"2016-07-11 18:00\"\n---\n将date中的时间改写，可以将18:00改为1:00，这样也能够有效解决问题。\n```\n\n\n> 参考链接：\n> https://segmentfault.com/q/1010000004584816\n","source":"_posts/2016/2016-07-11-github-page页面无法更新.md","raw":"---\nlayout: \"post\"\ntitle: \"GitHub_Page页面无法更新\"\ntags: \"问题总结\"\ncategory: \"read\"\ndate: \"2016-07-11 1:00\"\n---\n\n### 详细问题：\n- 文章会在github的工程目录中出现，但github page中首页和存档都无法显示。\n- 仔细查看过套用的html等模板，未能发现有问题。\n- 连续多次都是某一次推送下，突然问题就解决了。\n- 通过github page提供的jekyll服务进行更新文章时，经常会出现文章已经上传到了github的远程库中，但github page却无法显示内容出来，这样的问题出现了很多差，但不断的上传或者某一次传输一个文章，突然就成功了。\n\n<!-- more -->\n\n\n### 具体原因：\n\nGitHub_Page 使用的是jekyll服务生成page页面的。由于jekyll 3（github目前的jekyll版本）默认对于认定为\"未来\"的post，是不生成的，详情可以参考[Future posts - Jekyll](http://jekyllrb.com/docs/upgrading/2-to-3/#future-posts)。这极有可能与github服务在美国有关,本人使用的是VPN在美国，不知道是否对此也有影响。\n\n### 解决方法：\n\n- 网上说可以修改feed.xml文件，具体看参考链接。（本人没有实验成功）\n- 我使用的方法改写时间：\n\n```\n---\nlayout: \"post\"\ntitle: \"GitHub_Page页面无法更新\"\ntags: \"问题总结\"\ncategory: \"read\"\ndate: \"2016-07-11 18:00\"\n---\n将date中的时间改写，可以将18:00改为1:00，这样也能够有效解决问题。\n```\n\n\n> 参考链接：\n> https://segmentfault.com/q/1010000004584816\n","slug":"2016/2016-07-11-github-page页面无法更新","published":1,"updated":"2016-12-16T01:19:05.470Z","comments":1,"photos":[],"link":"","_id":"ciyuv3agp0013mumu2d52hxrt","content":"<h3 id=\"详细问题：\"><a href=\"#详细问题：\" class=\"headerlink\" title=\"详细问题：\"></a>详细问题：</h3><ul>\n<li>文章会在github的工程目录中出现，但github page中首页和存档都无法显示。</li>\n<li>仔细查看过套用的html等模板，未能发现有问题。</li>\n<li>连续多次都是某一次推送下，突然问题就解决了。</li>\n<li>通过github page提供的jekyll服务进行更新文章时，经常会出现文章已经上传到了github的远程库中，但github page却无法显示内容出来，这样的问题出现了很多差，但不断的上传或者某一次传输一个文章，突然就成功了。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"具体原因：\"><a href=\"#具体原因：\" class=\"headerlink\" title=\"具体原因：\"></a>具体原因：</h3><p>GitHub_Page 使用的是jekyll服务生成page页面的。由于jekyll 3（github目前的jekyll版本）默认对于认定为”未来”的post，是不生成的，详情可以参考<a href=\"http://jekyllrb.com/docs/upgrading/2-to-3/#future-posts\" target=\"_blank\" rel=\"external\">Future posts - Jekyll</a>。这极有可能与github服务在美国有关,本人使用的是VPN在美国，不知道是否对此也有影响。</p>\n<h3 id=\"解决方法：\"><a href=\"#解决方法：\" class=\"headerlink\" title=\"解决方法：\"></a>解决方法：</h3><ul>\n<li>网上说可以修改feed.xml文件，具体看参考链接。（本人没有实验成功）</li>\n<li>我使用的方法改写时间：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">layout: &quot;post&quot;</div><div class=\"line\">title: &quot;GitHub_Page页面无法更新&quot;</div><div class=\"line\">tags: &quot;问题总结&quot;</div><div class=\"line\">category: &quot;read&quot;</div><div class=\"line\">date: &quot;2016-07-11 18:00&quot;</div><div class=\"line\">---</div><div class=\"line\">将date中的时间改写，可以将18:00改为1:00，这样也能够有效解决问题。</div></pre></td></tr></table></figure>\n<blockquote>\n<p>参考链接：<br><a href=\"https://segmentfault.com/q/1010000004584816\" target=\"_blank\" rel=\"external\">https://segmentfault.com/q/1010000004584816</a></p>\n</blockquote>\n","excerpt":"<h3 id=\"详细问题：\"><a href=\"#详细问题：\" class=\"headerlink\" title=\"详细问题：\"></a>详细问题：</h3><ul>\n<li>文章会在github的工程目录中出现，但github page中首页和存档都无法显示。</li>\n<li>仔细查看过套用的html等模板，未能发现有问题。</li>\n<li>连续多次都是某一次推送下，突然问题就解决了。</li>\n<li>通过github page提供的jekyll服务进行更新文章时，经常会出现文章已经上传到了github的远程库中，但github page却无法显示内容出来，这样的问题出现了很多差，但不断的上传或者某一次传输一个文章，突然就成功了。</li>\n</ul>","more":"<h3 id=\"具体原因：\"><a href=\"#具体原因：\" class=\"headerlink\" title=\"具体原因：\"></a>具体原因：</h3><p>GitHub_Page 使用的是jekyll服务生成page页面的。由于jekyll 3（github目前的jekyll版本）默认对于认定为”未来”的post，是不生成的，详情可以参考<a href=\"http://jekyllrb.com/docs/upgrading/2-to-3/#future-posts\">Future posts - Jekyll</a>。这极有可能与github服务在美国有关,本人使用的是VPN在美国，不知道是否对此也有影响。</p>\n<h3 id=\"解决方法：\"><a href=\"#解决方法：\" class=\"headerlink\" title=\"解决方法：\"></a>解决方法：</h3><ul>\n<li>网上说可以修改feed.xml文件，具体看参考链接。（本人没有实验成功）</li>\n<li>我使用的方法改写时间：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">layout: &quot;post&quot;</div><div class=\"line\">title: &quot;GitHub_Page页面无法更新&quot;</div><div class=\"line\">tags: &quot;问题总结&quot;</div><div class=\"line\">category: &quot;read&quot;</div><div class=\"line\">date: &quot;2016-07-11 18:00&quot;</div><div class=\"line\">---</div><div class=\"line\">将date中的时间改写，可以将18:00改为1:00，这样也能够有效解决问题。</div></pre></td></tr></table></figure>\n<blockquote>\n<p>参考链接：<br><a href=\"https://segmentfault.com/q/1010000004584816\">https://segmentfault.com/q/1010000004584816</a></p>\n</blockquote>"},{"layout":"post","title":"git常用指令详解","date":"2016-07-11T04:12:00.000Z","_content":"\n用git这个版本控制器也有一段时间了，但奈何一直停留在初浅的使用阶段，对诸如：分支，远程库，log，reflog，pull，clone等命令一直无法清晰的认识，仅仅是简单的add，commit，push，出了问题再查找。\n始终无法串接成自有的知识体系，git 作为当下最流行的版本控制器，不得不说我对她真是既爱又恨，喜欢她的小巧高效功能强大；恨上手困难，虽然也有了一些简单易懂的教程，但在在实际使用时，始终不能形成自己的知识体系，原因可能还是项目中实际用的过少，这篇文章，会花一段时间，详细的介绍git的大概工作过程，对一些常用命令精简的介绍，然后从我个人的角度来认识git，总结自己的经验。*\n\n<!-- more -->\n\n\n**这篇文章的过程意在记录自己使用git的学习经历，并不断的总结推荐一些良好的配置以及相关软件。**\n\n### GIT介绍：\n\nGit是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\n\n#### 版本控制器介绍：\n\n版本控制透过文档控制（documentation control）记录程序各个模组的改动，并为每次改动编上序号。这种方法是工程图（engineering drawings）维护（maintenance）的标准做法， 它伴随着工程图从图的诞生一直到图的定型。 一种简单的版本控制形式，例如，赋给图的初版一个版本等级“A”。当做了第一次改变后，版本等级改为“B”，以此类推等等。\n\n#### GIT特点：\n\n*GIT采用分支的结构形式来记录所有文本的修改，可以看出分支和指针是git的核心，git因为指针的高速切换而高效。所有的分支名都是指针，且该指针无条件的指向这条分支的最末端，例如：master指针永远指向master这条分支的最后一个节点，而HEAD指针则指向的是当前位置，即用户目前所在的工作位置。在git的工作过程中最主要使用的是：add,commit,log,checkout这几个命令，而诸如reflog，reset等其实用的并不算多，如果有远程库的话还需要注意pull,push,remote。*\n\n\n### 常用GIT指令：\n\n- git add filename:将相关文件加入到暂存区stage中，注意有新文件的话，add步骤不能少。如果是一个人做的项目，一般如果整个项目加入可以使用git add . 或者git add * 。\n\n- git commit -m \"commment\"：git的版本提交，执行完这步骤，你就完成了版本的创建提交了，也是最常用的步骤。*建议：使用git commit -m 即可，去配置文件中修改editor，这样可以调用如vim之类的编辑器，否则备注写起来麻烦，且字数有限制。*\n\n- git branch：查看分支结构，git的颇有c语言和数据结构的风格，整个git的版本控制，类似于一颗数，可以不断创建新的分支，然后分支名称类似于一个tag指针，始终指向分支的末尾处，而head这个指针指向的地方就是当前你所能看到的处在的版本位置，**严格的来说并不是指向当前，而是上一个提交了的版本的位置，当前如果做了一些修改，而没去提交，则使用reset会回到上一个提交的版本，修改的内容会丢失**。\n\n- **git checkout**(*该命令的理解贯穿git的始终，如果理解不精准，往往会遇到很多莫名其妙的错误。)*：**用于控制head指针所指向的位置**，也就是说控制当前用户的工作位置。该指令尤为重要，**一般都是通过checkout找到过去的某个版本，然后在该位置创建分支结构，再进行相应修改。**(*注意是切换HEAD的位置，此时仅仅用于查看该版本，而如果你没有在该位置建立新的分支，则无法对改版本进行修改，git的所有修改都是基于分支进行的，每条枝干的前后各个版本都是存在强关联性的，所有枝干的后一个节点都是基于前一个节点建立的，如果checkout到前一个节点对它进行了破坏，则后面也必然会受影响，这种情况一般是不允许发生的，因此checkout的每次修改都是要求该节点必须要重新开枝散叶，这样新的修改会在新的枝干上面进行，不会影响原有的内容。*)checkout的好处在于不会破坏原有的分支结构，可以任意在整个的目录树上面对head进行移动，方便用户查看各个版本。（**再次注意：checkout只是用来控制head的，如果head通过checkout发生了移动，不再指向原有分支的末尾如：master，则必须建立新分支，才可以对文件进行提交修改。另外即便checkout指向原有分支的末尾，但如果是版本号的话也是没法进行修改的，必须要是指向master这个分支名才可以进行修改，类似于HEAD必须指向指针才可以，而不是指向某一个节点，这一点有指针操作经验的话，较容易理解。**），*checkout -- filename：回退某一个文件，注意需要加--，这一步并不是更改HEAD指向，而仅仅是回退某一个错误修改了的文件，这也是撤销修改文件最常用的命令。*\n\n- git reset \"branchname/editionnum\"：事实上这个指令很少用的，或者说谨慎使用，一旦使用了就会破坏原有的分支结构，reset是一个回退功能，会将原有的分支剪掉，虽然仍然可以通过reflog查找出版本信息，强制指向某个回退之前的版本，但这并不是该有的操作，且很可能因为误操作造成更大麻烦。建议：*只有在确定很清楚自己要进行的操作和上次提交错误的情况下使用该指令，其他时候都不使用。*版本回退使用reset后面一般加上--hard彻底回退，否则有些修改了的未建立版本的文件仍然会保留。\n\n- git merge \"branchname\"：将两个分支进行合并，也是比较常用的操作，如果没有文件冲突，一般git会快速自动合并，如果有冲突，会需要你进行比较手动修改冲突，合并的过程是当前HEAD指向的分支名，会跳转到branchname的位置。\n\n- git branch -d dev：合并分支后，可以将被合并了的分支号删除。\n\n- git tag ：这个也是个比较有用的方法，毕竟版本号是一大串随机数字，即便只要输入前4个，你也很难记得，对某个特别的版本加入tag标签名，之后可以直接使用git checkout tagname来指向该版本。\n- git diff : 将当前所有状态同指令后面对应的版本状态进行比较。\n\n\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/265643011.jpg)\n\n\n\n#### 简述分支策略：\n\n**在实际开发中，我们应该按照几个基本原则进行分支管理：**\n- master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n- 干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；\n- 每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。\n\n**团队合作示意图：**\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/0.png)\n\n> 参考链接：\n> http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\n> http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_\n","source":"_posts/2016/2016-07-11-git常用指令详解.md","raw":"---\nlayout: post\ncategory: \"read\"\ntitle:  \"git常用指令详解\"\ntags:   软件安装\ndate: \"2016-07-11 12:12\"\n---\n\n用git这个版本控制器也有一段时间了，但奈何一直停留在初浅的使用阶段，对诸如：分支，远程库，log，reflog，pull，clone等命令一直无法清晰的认识，仅仅是简单的add，commit，push，出了问题再查找。\n始终无法串接成自有的知识体系，git 作为当下最流行的版本控制器，不得不说我对她真是既爱又恨，喜欢她的小巧高效功能强大；恨上手困难，虽然也有了一些简单易懂的教程，但在在实际使用时，始终不能形成自己的知识体系，原因可能还是项目中实际用的过少，这篇文章，会花一段时间，详细的介绍git的大概工作过程，对一些常用命令精简的介绍，然后从我个人的角度来认识git，总结自己的经验。*\n\n<!-- more -->\n\n\n**这篇文章的过程意在记录自己使用git的学习经历，并不断的总结推荐一些良好的配置以及相关软件。**\n\n### GIT介绍：\n\nGit是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\n\n#### 版本控制器介绍：\n\n版本控制透过文档控制（documentation control）记录程序各个模组的改动，并为每次改动编上序号。这种方法是工程图（engineering drawings）维护（maintenance）的标准做法， 它伴随着工程图从图的诞生一直到图的定型。 一种简单的版本控制形式，例如，赋给图的初版一个版本等级“A”。当做了第一次改变后，版本等级改为“B”，以此类推等等。\n\n#### GIT特点：\n\n*GIT采用分支的结构形式来记录所有文本的修改，可以看出分支和指针是git的核心，git因为指针的高速切换而高效。所有的分支名都是指针，且该指针无条件的指向这条分支的最末端，例如：master指针永远指向master这条分支的最后一个节点，而HEAD指针则指向的是当前位置，即用户目前所在的工作位置。在git的工作过程中最主要使用的是：add,commit,log,checkout这几个命令，而诸如reflog，reset等其实用的并不算多，如果有远程库的话还需要注意pull,push,remote。*\n\n\n### 常用GIT指令：\n\n- git add filename:将相关文件加入到暂存区stage中，注意有新文件的话，add步骤不能少。如果是一个人做的项目，一般如果整个项目加入可以使用git add . 或者git add * 。\n\n- git commit -m \"commment\"：git的版本提交，执行完这步骤，你就完成了版本的创建提交了，也是最常用的步骤。*建议：使用git commit -m 即可，去配置文件中修改editor，这样可以调用如vim之类的编辑器，否则备注写起来麻烦，且字数有限制。*\n\n- git branch：查看分支结构，git的颇有c语言和数据结构的风格，整个git的版本控制，类似于一颗数，可以不断创建新的分支，然后分支名称类似于一个tag指针，始终指向分支的末尾处，而head这个指针指向的地方就是当前你所能看到的处在的版本位置，**严格的来说并不是指向当前，而是上一个提交了的版本的位置，当前如果做了一些修改，而没去提交，则使用reset会回到上一个提交的版本，修改的内容会丢失**。\n\n- **git checkout**(*该命令的理解贯穿git的始终，如果理解不精准，往往会遇到很多莫名其妙的错误。)*：**用于控制head指针所指向的位置**，也就是说控制当前用户的工作位置。该指令尤为重要，**一般都是通过checkout找到过去的某个版本，然后在该位置创建分支结构，再进行相应修改。**(*注意是切换HEAD的位置，此时仅仅用于查看该版本，而如果你没有在该位置建立新的分支，则无法对改版本进行修改，git的所有修改都是基于分支进行的，每条枝干的前后各个版本都是存在强关联性的，所有枝干的后一个节点都是基于前一个节点建立的，如果checkout到前一个节点对它进行了破坏，则后面也必然会受影响，这种情况一般是不允许发生的，因此checkout的每次修改都是要求该节点必须要重新开枝散叶，这样新的修改会在新的枝干上面进行，不会影响原有的内容。*)checkout的好处在于不会破坏原有的分支结构，可以任意在整个的目录树上面对head进行移动，方便用户查看各个版本。（**再次注意：checkout只是用来控制head的，如果head通过checkout发生了移动，不再指向原有分支的末尾如：master，则必须建立新分支，才可以对文件进行提交修改。另外即便checkout指向原有分支的末尾，但如果是版本号的话也是没法进行修改的，必须要是指向master这个分支名才可以进行修改，类似于HEAD必须指向指针才可以，而不是指向某一个节点，这一点有指针操作经验的话，较容易理解。**），*checkout -- filename：回退某一个文件，注意需要加--，这一步并不是更改HEAD指向，而仅仅是回退某一个错误修改了的文件，这也是撤销修改文件最常用的命令。*\n\n- git reset \"branchname/editionnum\"：事实上这个指令很少用的，或者说谨慎使用，一旦使用了就会破坏原有的分支结构，reset是一个回退功能，会将原有的分支剪掉，虽然仍然可以通过reflog查找出版本信息，强制指向某个回退之前的版本，但这并不是该有的操作，且很可能因为误操作造成更大麻烦。建议：*只有在确定很清楚自己要进行的操作和上次提交错误的情况下使用该指令，其他时候都不使用。*版本回退使用reset后面一般加上--hard彻底回退，否则有些修改了的未建立版本的文件仍然会保留。\n\n- git merge \"branchname\"：将两个分支进行合并，也是比较常用的操作，如果没有文件冲突，一般git会快速自动合并，如果有冲突，会需要你进行比较手动修改冲突，合并的过程是当前HEAD指向的分支名，会跳转到branchname的位置。\n\n- git branch -d dev：合并分支后，可以将被合并了的分支号删除。\n\n- git tag ：这个也是个比较有用的方法，毕竟版本号是一大串随机数字，即便只要输入前4个，你也很难记得，对某个特别的版本加入tag标签名，之后可以直接使用git checkout tagname来指向该版本。\n- git diff : 将当前所有状态同指令后面对应的版本状态进行比较。\n\n\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/265643011.jpg)\n\n\n\n#### 简述分支策略：\n\n**在实际开发中，我们应该按照几个基本原则进行分支管理：**\n- master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n- 干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；\n- 每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。\n\n**团队合作示意图：**\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/0.png)\n\n> 参考链接：\n> http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\n> http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_\n","slug":"2016/2016-07-11-git常用指令详解","published":1,"updated":"2017-01-03T02:32:17.428Z","comments":1,"photos":[],"link":"","_id":"ciyuv3agq0017mumuqpccgixf","content":"<p>用git这个版本控制器也有一段时间了，但奈何一直停留在初浅的使用阶段，对诸如：分支，远程库，log，reflog，pull，clone等命令一直无法清晰的认识，仅仅是简单的add，commit，push，出了问题再查找。<br>始终无法串接成自有的知识体系，git 作为当下最流行的版本控制器，不得不说我对她真是既爱又恨，喜欢她的小巧高效功能强大；恨上手困难，虽然也有了一些简单易懂的教程，但在在实际使用时，始终不能形成自己的知识体系，原因可能还是项目中实际用的过少，这篇文章，会花一段时间，详细的介绍git的大概工作过程，对一些常用命令精简的介绍，然后从我个人的角度来认识git，总结自己的经验。*</p>\n<a id=\"more\"></a>\n<p><strong>这篇文章的过程意在记录自己使用git的学习经历，并不断的总结推荐一些良好的配置以及相关软件。</strong></p>\n<h3 id=\"GIT介绍：\"><a href=\"#GIT介绍：\" class=\"headerlink\" title=\"GIT介绍：\"></a>GIT介绍：</h3><p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>\n<h4 id=\"版本控制器介绍：\"><a href=\"#版本控制器介绍：\" class=\"headerlink\" title=\"版本控制器介绍：\"></a>版本控制器介绍：</h4><p>版本控制透过文档控制（documentation control）记录程序各个模组的改动，并为每次改动编上序号。这种方法是工程图（engineering drawings）维护（maintenance）的标准做法， 它伴随着工程图从图的诞生一直到图的定型。 一种简单的版本控制形式，例如，赋给图的初版一个版本等级“A”。当做了第一次改变后，版本等级改为“B”，以此类推等等。</p>\n<h4 id=\"GIT特点：\"><a href=\"#GIT特点：\" class=\"headerlink\" title=\"GIT特点：\"></a>GIT特点：</h4><p><em>GIT采用分支的结构形式来记录所有文本的修改，可以看出分支和指针是git的核心，git因为指针的高速切换而高效。所有的分支名都是指针，且该指针无条件的指向这条分支的最末端，例如：master指针永远指向master这条分支的最后一个节点，而HEAD指针则指向的是当前位置，即用户目前所在的工作位置。在git的工作过程中最主要使用的是：add,commit,log,checkout这几个命令，而诸如reflog，reset等其实用的并不算多，如果有远程库的话还需要注意pull,push,remote。</em></p>\n<h3 id=\"常用GIT指令：\"><a href=\"#常用GIT指令：\" class=\"headerlink\" title=\"常用GIT指令：\"></a>常用GIT指令：</h3><ul>\n<li><p>git add filename:将相关文件加入到暂存区stage中，注意有新文件的话，add步骤不能少。如果是一个人做的项目，一般如果整个项目加入可以使用git add . 或者git add * 。</p>\n</li>\n<li><p>git commit -m “commment”：git的版本提交，执行完这步骤，你就完成了版本的创建提交了，也是最常用的步骤。<em>建议：使用git commit -m 即可，去配置文件中修改editor，这样可以调用如vim之类的编辑器，否则备注写起来麻烦，且字数有限制。</em></p>\n</li>\n<li><p>git branch：查看分支结构，git的颇有c语言和数据结构的风格，整个git的版本控制，类似于一颗数，可以不断创建新的分支，然后分支名称类似于一个tag指针，始终指向分支的末尾处，而head这个指针指向的地方就是当前你所能看到的处在的版本位置，<strong>严格的来说并不是指向当前，而是上一个提交了的版本的位置，当前如果做了一些修改，而没去提交，则使用reset会回到上一个提交的版本，修改的内容会丢失</strong>。</p>\n</li>\n<li><p><strong>git checkout</strong>(<em>该命令的理解贯穿git的始终，如果理解不精准，往往会遇到很多莫名其妙的错误。)</em>：<strong>用于控制head指针所指向的位置</strong>，也就是说控制当前用户的工作位置。该指令尤为重要，<strong>一般都是通过checkout找到过去的某个版本，然后在该位置创建分支结构，再进行相应修改。</strong>(<em>注意是切换HEAD的位置，此时仅仅用于查看该版本，而如果你没有在该位置建立新的分支，则无法对改版本进行修改，git的所有修改都是基于分支进行的，每条枝干的前后各个版本都是存在强关联性的，所有枝干的后一个节点都是基于前一个节点建立的，如果checkout到前一个节点对它进行了破坏，则后面也必然会受影响，这种情况一般是不允许发生的，因此checkout的每次修改都是要求该节点必须要重新开枝散叶，这样新的修改会在新的枝干上面进行，不会影响原有的内容。</em>)checkout的好处在于不会破坏原有的分支结构，可以任意在整个的目录树上面对head进行移动，方便用户查看各个版本。（<strong>再次注意：checkout只是用来控制head的，如果head通过checkout发生了移动，不再指向原有分支的末尾如：master，则必须建立新分支，才可以对文件进行提交修改。另外即便checkout指向原有分支的末尾，但如果是版本号的话也是没法进行修改的，必须要是指向master这个分支名才可以进行修改，类似于HEAD必须指向指针才可以，而不是指向某一个节点，这一点有指针操作经验的话，较容易理解。</strong>），<em>checkout – filename：回退某一个文件，注意需要加–，这一步并不是更改HEAD指向，而仅仅是回退某一个错误修改了的文件，这也是撤销修改文件最常用的命令。</em></p>\n</li>\n<li><p>git reset “branchname/editionnum”：事实上这个指令很少用的，或者说谨慎使用，一旦使用了就会破坏原有的分支结构，reset是一个回退功能，会将原有的分支剪掉，虽然仍然可以通过reflog查找出版本信息，强制指向某个回退之前的版本，但这并不是该有的操作，且很可能因为误操作造成更大麻烦。建议：<em>只有在确定很清楚自己要进行的操作和上次提交错误的情况下使用该指令，其他时候都不使用。</em>版本回退使用reset后面一般加上–hard彻底回退，否则有些修改了的未建立版本的文件仍然会保留。</p>\n</li>\n<li><p>git merge “branchname”：将两个分支进行合并，也是比较常用的操作，如果没有文件冲突，一般git会快速自动合并，如果有冲突，会需要你进行比较手动修改冲突，合并的过程是当前HEAD指向的分支名，会跳转到branchname的位置。</p>\n</li>\n<li><p>git branch -d dev：合并分支后，可以将被合并了的分支号删除。</p>\n</li>\n<li><p>git tag ：这个也是个比较有用的方法，毕竟版本号是一大串随机数字，即便只要输入前4个，你也很难记得，对某个特别的版本加入tag标签名，之后可以直接使用git checkout tagname来指向该版本。</p>\n</li>\n<li>git diff : 将当前所有状态同指令后面对应的版本状态进行比较。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/265643011.jpg\" alt=\"\"></p>\n<h4 id=\"简述分支策略：\"><a href=\"#简述分支策略：\" class=\"headerlink\" title=\"简述分支策略：\"></a>简述分支策略：</h4><p><strong>在实际开发中，我们应该按照几个基本原则进行分支管理：</strong></p>\n<ul>\n<li>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</li>\n<li>干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</li>\n<li>每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</li>\n</ul>\n<p><strong>团队合作示意图：</strong></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/0.png\" alt=\"\"></p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"external\">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a><br><a href=\"http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_\" target=\"_blank\" rel=\"external\">http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_</a></p>\n</blockquote>\n","excerpt":"<p>用git这个版本控制器也有一段时间了，但奈何一直停留在初浅的使用阶段，对诸如：分支，远程库，log，reflog，pull，clone等命令一直无法清晰的认识，仅仅是简单的add，commit，push，出了问题再查找。<br>始终无法串接成自有的知识体系，git 作为当下最流行的版本控制器，不得不说我对她真是既爱又恨，喜欢她的小巧高效功能强大；恨上手困难，虽然也有了一些简单易懂的教程，但在在实际使用时，始终不能形成自己的知识体系，原因可能还是项目中实际用的过少，这篇文章，会花一段时间，详细的介绍git的大概工作过程，对一些常用命令精简的介绍，然后从我个人的角度来认识git，总结自己的经验。*</p>","more":"<p><strong>这篇文章的过程意在记录自己使用git的学习经历，并不断的总结推荐一些良好的配置以及相关软件。</strong></p>\n<h3 id=\"GIT介绍：\"><a href=\"#GIT介绍：\" class=\"headerlink\" title=\"GIT介绍：\"></a>GIT介绍：</h3><p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>\n<h4 id=\"版本控制器介绍：\"><a href=\"#版本控制器介绍：\" class=\"headerlink\" title=\"版本控制器介绍：\"></a>版本控制器介绍：</h4><p>版本控制透过文档控制（documentation control）记录程序各个模组的改动，并为每次改动编上序号。这种方法是工程图（engineering drawings）维护（maintenance）的标准做法， 它伴随着工程图从图的诞生一直到图的定型。 一种简单的版本控制形式，例如，赋给图的初版一个版本等级“A”。当做了第一次改变后，版本等级改为“B”，以此类推等等。</p>\n<h4 id=\"GIT特点：\"><a href=\"#GIT特点：\" class=\"headerlink\" title=\"GIT特点：\"></a>GIT特点：</h4><p><em>GIT采用分支的结构形式来记录所有文本的修改，可以看出分支和指针是git的核心，git因为指针的高速切换而高效。所有的分支名都是指针，且该指针无条件的指向这条分支的最末端，例如：master指针永远指向master这条分支的最后一个节点，而HEAD指针则指向的是当前位置，即用户目前所在的工作位置。在git的工作过程中最主要使用的是：add,commit,log,checkout这几个命令，而诸如reflog，reset等其实用的并不算多，如果有远程库的话还需要注意pull,push,remote。</em></p>\n<h3 id=\"常用GIT指令：\"><a href=\"#常用GIT指令：\" class=\"headerlink\" title=\"常用GIT指令：\"></a>常用GIT指令：</h3><ul>\n<li><p>git add filename:将相关文件加入到暂存区stage中，注意有新文件的话，add步骤不能少。如果是一个人做的项目，一般如果整个项目加入可以使用git add . 或者git add * 。</p>\n</li>\n<li><p>git commit -m “commment”：git的版本提交，执行完这步骤，你就完成了版本的创建提交了，也是最常用的步骤。<em>建议：使用git commit -m 即可，去配置文件中修改editor，这样可以调用如vim之类的编辑器，否则备注写起来麻烦，且字数有限制。</em></p>\n</li>\n<li><p>git branch：查看分支结构，git的颇有c语言和数据结构的风格，整个git的版本控制，类似于一颗数，可以不断创建新的分支，然后分支名称类似于一个tag指针，始终指向分支的末尾处，而head这个指针指向的地方就是当前你所能看到的处在的版本位置，<strong>严格的来说并不是指向当前，而是上一个提交了的版本的位置，当前如果做了一些修改，而没去提交，则使用reset会回到上一个提交的版本，修改的内容会丢失</strong>。</p>\n</li>\n<li><p><strong>git checkout</strong>(<em>该命令的理解贯穿git的始终，如果理解不精准，往往会遇到很多莫名其妙的错误。)</em>：<strong>用于控制head指针所指向的位置</strong>，也就是说控制当前用户的工作位置。该指令尤为重要，<strong>一般都是通过checkout找到过去的某个版本，然后在该位置创建分支结构，再进行相应修改。</strong>(<em>注意是切换HEAD的位置，此时仅仅用于查看该版本，而如果你没有在该位置建立新的分支，则无法对改版本进行修改，git的所有修改都是基于分支进行的，每条枝干的前后各个版本都是存在强关联性的，所有枝干的后一个节点都是基于前一个节点建立的，如果checkout到前一个节点对它进行了破坏，则后面也必然会受影响，这种情况一般是不允许发生的，因此checkout的每次修改都是要求该节点必须要重新开枝散叶，这样新的修改会在新的枝干上面进行，不会影响原有的内容。</em>)checkout的好处在于不会破坏原有的分支结构，可以任意在整个的目录树上面对head进行移动，方便用户查看各个版本。（<strong>再次注意：checkout只是用来控制head的，如果head通过checkout发生了移动，不再指向原有分支的末尾如：master，则必须建立新分支，才可以对文件进行提交修改。另外即便checkout指向原有分支的末尾，但如果是版本号的话也是没法进行修改的，必须要是指向master这个分支名才可以进行修改，类似于HEAD必须指向指针才可以，而不是指向某一个节点，这一点有指针操作经验的话，较容易理解。</strong>），<em>checkout – filename：回退某一个文件，注意需要加–，这一步并不是更改HEAD指向，而仅仅是回退某一个错误修改了的文件，这也是撤销修改文件最常用的命令。</em></p>\n</li>\n<li><p>git reset “branchname/editionnum”：事实上这个指令很少用的，或者说谨慎使用，一旦使用了就会破坏原有的分支结构，reset是一个回退功能，会将原有的分支剪掉，虽然仍然可以通过reflog查找出版本信息，强制指向某个回退之前的版本，但这并不是该有的操作，且很可能因为误操作造成更大麻烦。建议：<em>只有在确定很清楚自己要进行的操作和上次提交错误的情况下使用该指令，其他时候都不使用。</em>版本回退使用reset后面一般加上–hard彻底回退，否则有些修改了的未建立版本的文件仍然会保留。</p>\n</li>\n<li><p>git merge “branchname”：将两个分支进行合并，也是比较常用的操作，如果没有文件冲突，一般git会快速自动合并，如果有冲突，会需要你进行比较手动修改冲突，合并的过程是当前HEAD指向的分支名，会跳转到branchname的位置。</p>\n</li>\n<li><p>git branch -d dev：合并分支后，可以将被合并了的分支号删除。</p>\n</li>\n<li><p>git tag ：这个也是个比较有用的方法，毕竟版本号是一大串随机数字，即便只要输入前4个，你也很难记得，对某个特别的版本加入tag标签名，之后可以直接使用git checkout tagname来指向该版本。</p>\n</li>\n<li>git diff : 将当前所有状态同指令后面对应的版本状态进行比较。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/265643011.jpg\" alt=\"\"></p>\n<h4 id=\"简述分支策略：\"><a href=\"#简述分支策略：\" class=\"headerlink\" title=\"简述分支策略：\"></a>简述分支策略：</h4><p><strong>在实际开发中，我们应该按照几个基本原则进行分支管理：</strong></p>\n<ul>\n<li>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</li>\n<li>干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</li>\n<li>每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</li>\n</ul>\n<p><strong>团队合作示意图：</strong></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/0.png\" alt=\"\"></p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a><br><a href=\"http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_\">http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_</a></p>\n</blockquote>"},{"layout":"post","title":"(转)回车、换行、和文件末尾空行","description":"回车和换行在不同系统下面定义不同，时不时会有一些小问题出来，git 经常出现的 No new line at the end of file 也让很多人费解，需要梳理一下","date":"2016-07-10T17:12:00.000Z","_content":"\n## 回车和换行\n\n回车 (Carriage Return) 和换行 (Line Feed) 的区别，[这里](http://stackoverflow.com/questions/1761051/difference-between-n-and-r)有一个历史原因可参考：\n\n> 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。\n\n> 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做\"回车\"，告诉打字机把打印头定位在左边界；另一个叫做\"换行\"，告诉打字机把纸向下移一行。\n\n发明计算机时，这个概念被沿用下来，但因为条件的限制和设计者的喜好，有了一些分歧：\n\n- Unix 系统里，每行结尾只有\"<换行>\"，即 \"\\n\"\n- Windows 系统里面，每行结尾是\"<回车><换行>\"，即 \"\\r\\n\"\n- 在老的 Mac 系统里，每行结尾是\"<回车>\"，即 \"\\r\"\n\n我们来验证一下，我在 Windows 下用记事本新建一个文本文件，它的二进制编码如下：\n\n    //源文件内容\n    hello\n    hello2\n\n    //二进制内容\n    0000000: 6865 6c6c 6f0d 0a68 656c 6c6f 32         hello..hello2\n\n同样在 Mac 下用 Vim 新建一个：\n\n    //源文件内容\n    hello\n    hello2\n\n    //二进制内容\n    0000000: 6865 6c6c 6f0a 6865 6c6c 6f32 0a         hello.hello2.\n\n`0a`是 LF 的 ASCII 编码, `0d`是 CR 的 ASCII 编码。区别很明显了\n\n- Mac 下的文本文件在 Windows 下打开会成为一行，因为 Windows 只认识 `\\r\\n`，也就是 `0d0a`\n- Windows 下的文本文件在 Mac 下打开，Vim 中会在每行末尾显示一个 `^M`，(不是两个字符组成的)\n\n<!-- more -->\n\n\n\n## 文件末尾空行\n\n[POSIX](https://zh.wikipedia.org/zh-sg/POSIX)对行的[定义](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_206)如下：\n\n  > 3.206 Line\n\n  > A sequence of zero or more non- <newline\\> characters plus a terminating <newline\\> character.\n\n  > 行是由0个或者多个非 \"换行\" 符的字符组成，并且以 \"换行\" 符结尾。\n\n这样做有什么好处呢，举个例子：\n\n    //hello.c\n    #include head.h\n    print('hello')\n\n    //world.c\n    #include tail.h\n    print('hello')\n\n如果这两个文件都按 POSIX 规范来写， 在`cat *.c`之后，是没有问题的：\n\n    //cat.c\n\n    #include head.h\n    print('hello')\n    #include tail.h\n    print('hello')\n\n如果缺少最后一行的换行符（如 Windows 文件那样的定义），`cat`之后，就有问题了：\n\n    //error.c\n\n    #include head.h\n    print('hello')#include tail.h\n    print('hello')\n\n所以，从这点去理解 POSIX 对行的定义，非常合理，对于任意文件的拼接，也各自保持了文件的完整性。\n\n不遵守标准带来的则是：在一些编辑器下面，比如 Sublime，他把`\\n`的当做了行之间的分隔符，于是文件最后一行的`\\n`就看上去成了一个新的空行，这就是错误解读标准造成的，拼接文件时也会产生不必要的麻烦，比如上例。\n\n## \\ No new line at end of file\n\n基于上面的原因，再去看 git diff 的`\\ No new line at end of file`信息，就很好解释了。\n\n各编辑器对于换行符的理解偏差，导致的文件确实发生了变化，多了或少了最后的`0a`，那么对于 diff 程序来说，这当然是不可忽略的，但因为`0a`是不可见字符，并且是长久以来的历史原因，所以 diff 程序有个专门的标记来说明这个变化，就是：\n\n`\\ No new line at end of file`\n\n各编辑器也有相应的办法去解决这个问题，比如 Sublime，在`Default/Preferences.sublime-settings`中设置：\n\n    // Set to true to ensure the last line of the file ends in a newline\n    // character when saving\n    \"ensure_newline_at_eof_on_save\": true,\n\n所以，请遵守规范。\n\n[BeiYuu]:    http://beiyuu.com  \"BeiYuu\"\n","source":"_posts/2016/2016-07-11-换车_换行_文件末尾空行.md","raw":"---\nlayout: post\ntitle: (转)回车、换行、和文件末尾空行\ndescription: 回车和换行在不同系统下面定义不同，时不时会有一些小问题出来，git 经常出现的 No new line at the end of file 也让很多人费解，需要梳理一下\ncategory: “问题总结”\ntags:   问题总结\ndate: \"2016-07-11 1:12\"\n---\n\n## 回车和换行\n\n回车 (Carriage Return) 和换行 (Line Feed) 的区别，[这里](http://stackoverflow.com/questions/1761051/difference-between-n-and-r)有一个历史原因可参考：\n\n> 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。\n\n> 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做\"回车\"，告诉打字机把打印头定位在左边界；另一个叫做\"换行\"，告诉打字机把纸向下移一行。\n\n发明计算机时，这个概念被沿用下来，但因为条件的限制和设计者的喜好，有了一些分歧：\n\n- Unix 系统里，每行结尾只有\"<换行>\"，即 \"\\n\"\n- Windows 系统里面，每行结尾是\"<回车><换行>\"，即 \"\\r\\n\"\n- 在老的 Mac 系统里，每行结尾是\"<回车>\"，即 \"\\r\"\n\n我们来验证一下，我在 Windows 下用记事本新建一个文本文件，它的二进制编码如下：\n\n    //源文件内容\n    hello\n    hello2\n\n    //二进制内容\n    0000000: 6865 6c6c 6f0d 0a68 656c 6c6f 32         hello..hello2\n\n同样在 Mac 下用 Vim 新建一个：\n\n    //源文件内容\n    hello\n    hello2\n\n    //二进制内容\n    0000000: 6865 6c6c 6f0a 6865 6c6c 6f32 0a         hello.hello2.\n\n`0a`是 LF 的 ASCII 编码, `0d`是 CR 的 ASCII 编码。区别很明显了\n\n- Mac 下的文本文件在 Windows 下打开会成为一行，因为 Windows 只认识 `\\r\\n`，也就是 `0d0a`\n- Windows 下的文本文件在 Mac 下打开，Vim 中会在每行末尾显示一个 `^M`，(不是两个字符组成的)\n\n<!-- more -->\n\n\n\n## 文件末尾空行\n\n[POSIX](https://zh.wikipedia.org/zh-sg/POSIX)对行的[定义](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_206)如下：\n\n  > 3.206 Line\n\n  > A sequence of zero or more non- <newline\\> characters plus a terminating <newline\\> character.\n\n  > 行是由0个或者多个非 \"换行\" 符的字符组成，并且以 \"换行\" 符结尾。\n\n这样做有什么好处呢，举个例子：\n\n    //hello.c\n    #include head.h\n    print('hello')\n\n    //world.c\n    #include tail.h\n    print('hello')\n\n如果这两个文件都按 POSIX 规范来写， 在`cat *.c`之后，是没有问题的：\n\n    //cat.c\n\n    #include head.h\n    print('hello')\n    #include tail.h\n    print('hello')\n\n如果缺少最后一行的换行符（如 Windows 文件那样的定义），`cat`之后，就有问题了：\n\n    //error.c\n\n    #include head.h\n    print('hello')#include tail.h\n    print('hello')\n\n所以，从这点去理解 POSIX 对行的定义，非常合理，对于任意文件的拼接，也各自保持了文件的完整性。\n\n不遵守标准带来的则是：在一些编辑器下面，比如 Sublime，他把`\\n`的当做了行之间的分隔符，于是文件最后一行的`\\n`就看上去成了一个新的空行，这就是错误解读标准造成的，拼接文件时也会产生不必要的麻烦，比如上例。\n\n## \\ No new line at end of file\n\n基于上面的原因，再去看 git diff 的`\\ No new line at end of file`信息，就很好解释了。\n\n各编辑器对于换行符的理解偏差，导致的文件确实发生了变化，多了或少了最后的`0a`，那么对于 diff 程序来说，这当然是不可忽略的，但因为`0a`是不可见字符，并且是长久以来的历史原因，所以 diff 程序有个专门的标记来说明这个变化，就是：\n\n`\\ No new line at end of file`\n\n各编辑器也有相应的办法去解决这个问题，比如 Sublime，在`Default/Preferences.sublime-settings`中设置：\n\n    // Set to true to ensure the last line of the file ends in a newline\n    // character when saving\n    \"ensure_newline_at_eof_on_save\": true,\n\n所以，请遵守规范。\n\n[BeiYuu]:    http://beiyuu.com  \"BeiYuu\"\n","slug":"2016/2016-07-11-换车_换行_文件末尾空行","published":1,"updated":"2017-01-12T03:27:26.470Z","comments":1,"photos":[],"link":"","_id":"ciyuv3agt001bmumuifd6vt6t","content":"<h2 id=\"回车和换行\"><a href=\"#回车和换行\" class=\"headerlink\" title=\"回车和换行\"></a>回车和换行</h2><p>回车 (Carriage Return) 和换行 (Line Feed) 的区别，<a href=\"http://stackoverflow.com/questions/1761051/difference-between-n-and-r\" target=\"_blank\" rel=\"external\">这里</a>有一个历史原因可参考：</p>\n<blockquote>\n<p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</p>\n<p>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做”回车”，告诉打字机把打印头定位在左边界；另一个叫做”换行”，告诉打字机把纸向下移一行。</p>\n</blockquote>\n<p>发明计算机时，这个概念被沿用下来，但因为条件的限制和设计者的喜好，有了一些分歧：</p>\n<ul>\n<li>Unix 系统里，每行结尾只有”&lt;换行&gt;”，即 “\\n”</li>\n<li>Windows 系统里面，每行结尾是”&lt;回车&gt;&lt;换行&gt;”，即 “\\r\\n”</li>\n<li>在老的 Mac 系统里，每行结尾是”&lt;回车&gt;”，即 “\\r”</li>\n</ul>\n<p>我们来验证一下，我在 Windows 下用记事本新建一个文本文件，它的二进制编码如下：</p>\n<pre><code>//源文件内容\nhello\nhello2\n\n//二进制内容\n0000000: 6865 6c6c 6f0d 0a68 656c 6c6f 32         hello..hello2\n</code></pre><p>同样在 Mac 下用 Vim 新建一个：</p>\n<pre><code>//源文件内容\nhello\nhello2\n\n//二进制内容\n0000000: 6865 6c6c 6f0a 6865 6c6c 6f32 0a         hello.hello2.\n</code></pre><p><code>0a</code>是 LF 的 ASCII 编码, <code>0d</code>是 CR 的 ASCII 编码。区别很明显了</p>\n<ul>\n<li>Mac 下的文本文件在 Windows 下打开会成为一行，因为 Windows 只认识 <code>\\r\\n</code>，也就是 <code>0d0a</code></li>\n<li>Windows 下的文本文件在 Mac 下打开，Vim 中会在每行末尾显示一个 <code>^M</code>，(不是两个字符组成的)</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"文件末尾空行\"><a href=\"#文件末尾空行\" class=\"headerlink\" title=\"文件末尾空行\"></a>文件末尾空行</h2><p><a href=\"https://zh.wikipedia.org/zh-sg/POSIX\" target=\"_blank\" rel=\"external\">POSIX</a>对行的<a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_206\" target=\"_blank\" rel=\"external\">定义</a>如下：</p>\n<blockquote>\n<p>3.206 Line</p>\n<p>A sequence of zero or more non- <newline\\> characters plus a terminating <newline\\> character.</newline\\></newline\\></p>\n<p>行是由0个或者多个非 “换行” 符的字符组成，并且以 “换行” 符结尾。</p>\n</blockquote>\n<p>这样做有什么好处呢，举个例子：</p>\n<pre><code>//hello.c\n#include head.h\nprint(&apos;hello&apos;)\n\n//world.c\n#include tail.h\nprint(&apos;hello&apos;)\n</code></pre><p>如果这两个文件都按 POSIX 规范来写， 在<code>cat *.c</code>之后，是没有问题的：</p>\n<pre><code>//cat.c\n\n#include head.h\nprint(&apos;hello&apos;)\n#include tail.h\nprint(&apos;hello&apos;)\n</code></pre><p>如果缺少最后一行的换行符（如 Windows 文件那样的定义），<code>cat</code>之后，就有问题了：</p>\n<pre><code>//error.c\n\n#include head.h\nprint(&apos;hello&apos;)#include tail.h\nprint(&apos;hello&apos;)\n</code></pre><p>所以，从这点去理解 POSIX 对行的定义，非常合理，对于任意文件的拼接，也各自保持了文件的完整性。</p>\n<p>不遵守标准带来的则是：在一些编辑器下面，比如 Sublime，他把<code>\\n</code>的当做了行之间的分隔符，于是文件最后一行的<code>\\n</code>就看上去成了一个新的空行，这就是错误解读标准造成的，拼接文件时也会产生不必要的麻烦，比如上例。</p>\n<h2 id=\"No-new-line-at-end-of-file\"><a href=\"#No-new-line-at-end-of-file\" class=\"headerlink\" title=\"\\ No new line at end of file\"></a>\\ No new line at end of file</h2><p>基于上面的原因，再去看 git diff 的<code>\\ No new line at end of file</code>信息，就很好解释了。</p>\n<p>各编辑器对于换行符的理解偏差，导致的文件确实发生了变化，多了或少了最后的<code>0a</code>，那么对于 diff 程序来说，这当然是不可忽略的，但因为<code>0a</code>是不可见字符，并且是长久以来的历史原因，所以 diff 程序有个专门的标记来说明这个变化，就是：</p>\n<p><code>\\ No new line at end of file</code></p>\n<p>各编辑器也有相应的办法去解决这个问题，比如 Sublime，在<code>Default/Preferences.sublime-settings</code>中设置：</p>\n<pre><code>// Set to true to ensure the last line of the file ends in a newline\n// character when saving\n&quot;ensure_newline_at_eof_on_save&quot;: true,\n</code></pre><p>所以，请遵守规范。</p>\n","excerpt":"<h2 id=\"回车和换行\"><a href=\"#回车和换行\" class=\"headerlink\" title=\"回车和换行\"></a>回车和换行</h2><p>回车 (Carriage Return) 和换行 (Line Feed) 的区别，<a href=\"http://stackoverflow.com/questions/1761051/difference-between-n-and-r\">这里</a>有一个历史原因可参考：</p>\n<blockquote>\n<p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</p>\n<p>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做”回车”，告诉打字机把打印头定位在左边界；另一个叫做”换行”，告诉打字机把纸向下移一行。</p>\n</blockquote>\n<p>发明计算机时，这个概念被沿用下来，但因为条件的限制和设计者的喜好，有了一些分歧：</p>\n<ul>\n<li>Unix 系统里，每行结尾只有”&lt;换行&gt;”，即 “\\n”</li>\n<li>Windows 系统里面，每行结尾是”&lt;回车&gt;&lt;换行&gt;”，即 “\\r\\n”</li>\n<li>在老的 Mac 系统里，每行结尾是”&lt;回车&gt;”，即 “\\r”</li>\n</ul>\n<p>我们来验证一下，我在 Windows 下用记事本新建一个文本文件，它的二进制编码如下：</p>\n<pre><code>//源文件内容\nhello\nhello2\n\n//二进制内容\n0000000: 6865 6c6c 6f0d 0a68 656c 6c6f 32         hello..hello2\n</code></pre><p>同样在 Mac 下用 Vim 新建一个：</p>\n<pre><code>//源文件内容\nhello\nhello2\n\n//二进制内容\n0000000: 6865 6c6c 6f0a 6865 6c6c 6f32 0a         hello.hello2.\n</code></pre><p><code>0a</code>是 LF 的 ASCII 编码, <code>0d</code>是 CR 的 ASCII 编码。区别很明显了</p>\n<ul>\n<li>Mac 下的文本文件在 Windows 下打开会成为一行，因为 Windows 只认识 <code>\\r\\n</code>，也就是 <code>0d0a</code></li>\n<li>Windows 下的文本文件在 Mac 下打开，Vim 中会在每行末尾显示一个 <code>^M</code>，(不是两个字符组成的)</li>\n</ul>","more":"<h2 id=\"文件末尾空行\"><a href=\"#文件末尾空行\" class=\"headerlink\" title=\"文件末尾空行\"></a>文件末尾空行</h2><p><a href=\"https://zh.wikipedia.org/zh-sg/POSIX\">POSIX</a>对行的<a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_206\">定义</a>如下：</p>\n<blockquote>\n<p>3.206 Line</p>\n<p>A sequence of zero or more non- <newline\\> characters plus a terminating <newline\\> character.</p>\n<p>行是由0个或者多个非 “换行” 符的字符组成，并且以 “换行” 符结尾。</p>\n</blockquote>\n<p>这样做有什么好处呢，举个例子：</p>\n<pre><code>//hello.c\n#include head.h\nprint(&apos;hello&apos;)\n\n//world.c\n#include tail.h\nprint(&apos;hello&apos;)\n</code></pre><p>如果这两个文件都按 POSIX 规范来写， 在<code>cat *.c</code>之后，是没有问题的：</p>\n<pre><code>//cat.c\n\n#include head.h\nprint(&apos;hello&apos;)\n#include tail.h\nprint(&apos;hello&apos;)\n</code></pre><p>如果缺少最后一行的换行符（如 Windows 文件那样的定义），<code>cat</code>之后，就有问题了：</p>\n<pre><code>//error.c\n\n#include head.h\nprint(&apos;hello&apos;)#include tail.h\nprint(&apos;hello&apos;)\n</code></pre><p>所以，从这点去理解 POSIX 对行的定义，非常合理，对于任意文件的拼接，也各自保持了文件的完整性。</p>\n<p>不遵守标准带来的则是：在一些编辑器下面，比如 Sublime，他把<code>\\n</code>的当做了行之间的分隔符，于是文件最后一行的<code>\\n</code>就看上去成了一个新的空行，这就是错误解读标准造成的，拼接文件时也会产生不必要的麻烦，比如上例。</p>\n<h2 id=\"No-new-line-at-end-of-file\"><a href=\"#No-new-line-at-end-of-file\" class=\"headerlink\" title=\"\\ No new line at end of file\"></a>\\ No new line at end of file</h2><p>基于上面的原因，再去看 git diff 的<code>\\ No new line at end of file</code>信息，就很好解释了。</p>\n<p>各编辑器对于换行符的理解偏差，导致的文件确实发生了变化，多了或少了最后的<code>0a</code>，那么对于 diff 程序来说，这当然是不可忽略的，但因为<code>0a</code>是不可见字符，并且是长久以来的历史原因，所以 diff 程序有个专门的标记来说明这个变化，就是：</p>\n<p><code>\\ No new line at end of file</code></p>\n<p>各编辑器也有相应的办法去解决这个问题，比如 Sublime，在<code>Default/Preferences.sublime-settings</code>中设置：</p>\n<pre><code>// Set to true to ensure the last line of the file ends in a newline\n// character when saving\n&quot;ensure_newline_at_eof_on_save&quot;: true,\n</code></pre><p>所以，请遵守规范。</p>"},{"layout":"post","title":"linux正常学习办公","date":"2016-07-11T06:06:00.000Z","_content":"\n本文章在于总结自己如何使用 linux 完成正常的办公学习。linux 向来以它的可定制性强，稳定性高而出名，但 linux 常用领域大多也只限制在个别的一些如服务器领域，而民用领域即便是安卓系统也是 linux 经过层层封装之后的产物，早已逝去了该系统的原汁原味。linux 从发展至今也已经有了20多年的历史，但桌面版本一致被大家诟病，非专业人事不能使用，自从 ubuntu 这个发行版出来后，确实可以说是降低了新人使用的门槛，但是这个发行版的 GUI 定制性差，不够稳定等一系列的问题也让用户体验直线下降。这边我是以 ubuntu 的系统为基础采用 awesome 这儿 WM 进行图形化管理，目前使用了数个月时间，体验还算是良好。\n\n\n## 1. 系统选择：\n\n### 1.1 为何选择ubuntu？\n\n*现如今linux发行版很多，但真如ubuntu一样的美观，稳定又方便的真不多。说一下我用过的各个系统的体验吧：*\n\n- centOS 系统不够美观，本身使命就是等同 REDHAT 用于服务器的，虽然可以预装的软件比较多，但大都是用于开发及运维的。\n- arch 更像是一个 geek 玩的玩具，更新频率过快，该版本接触不是过多，但用于正常工作生活的系统，没有人愿意一天折腾几次吧？用不上一年就非得重装的吧？\n- deepin 这个是一个国产 linux，也只用过很短的一段时间，就界面各方面而言，感觉还是满美观，满人性化的，但用户太少，社区看起来也不是太活跃，虽然好像也是基于debian的衍生产品，但还是再观望一段时间再说吧。\n- ubuntu 出来时间也比较久了，本身一直专注于做桌面系统，gnome 的一整套组建目前来看也比较完善，各种自带软件，用户体验都还不错，有些甚至比 MS 的更好用。当然作为一个正常办公学习使用的人来说，最满意的还是 apt-get 可以直接管理获取各种资源了。也就是说，如果你是需要用 linux 来办公学习，写写程序的话，ubuntu 应该来说会是首选。\n\n<!-- more -->\n\n\n\n### 1.2 为何选择awesome？\n\n- gnome 的不稳定*ubuntu 下的 gnome 如果作为日常使用的话，很难满足要求，虽然经过这么多年的发展，但仍然会经常出现不响应。*试问，如果一个 GUI 连基本的稳定都没法保障，即便功能再完善，外观再美，用户长久用下来，最终会抛弃她。使用 gnome 两周，尽管尝试着去更改设置了不少东西，但度过了最开始的新奇感后，永无止境的不响应，从错误中恢复等等，最终让我还是选择更换一个新的图形化用户界面。\n\n- awesome 的轻便小巧，且可定制话极强（当然其他 linux 也都可以定制，只不过，其他的起点过高，对于普通用户而言，上手不易），awesome 即便是新手，在 github 上找个模板，稍加摸索也可以定制出自己满意的 GUI。\n\n\n\n## 2. linux软件：\n\n### 2.1 必备软件\n#### chrome:\n这个不做过多解释，简而言之就是好用，chrome 支持多个平台，而且用户体验都相近，关键 linux 下的 chrome 还相当稳定，远胜过 ubuntu 下自带的 firefox 等浏览器，使用体验可能更甚于 windows 下的 chrome。插件扩展等功能应有尽有。chrome 的使用和技巧内容很多，关于 chrome 可以参考本博客中专门的文章。\n\n#### virtualbox:\n算是使用 windows 软件的必备工具了。\n\n#### deepin-scrot截图：\n效果虽然可以达到 windows 下的截图工具大部分功能，但不够稳定。速度慢，虽然截图功能不是什么大的应用，但奈何之前在 win 平台下的截图都太好用了，暂时还没有在 linux 平台下面找到能够完全满意的截图软件。\n\n#### gthumb:\n一款轻巧好用的图片查看编辑工具，基本具备大多数常用功能，但仍然不能算是满足日常工作需要，最起码标记涂鸦功能都没有。\n\n#### xmind:\n一款和freemind类似的思维导图软件，据说是国产的。\n\n#### 分屏功能\nxrandr命令，这是一个命令行软件，并非图形界面软件，但很实用，用于分屏驱动多个显示器，一般是底层控制的，虽然是显示功能，但分屏并非GUI的独享。\n\n#### [录屏软件recordmydesktop](http://jingyan.baidu.com/article/7908e85c91f834af491ad241.html)\n\n\n### 3. 开发套件：\n\n#### atom:\ngithub 出品，算是现代 IDE 中的一个精品吧，结合了 vim 和 sublimeTEXT 一些特征特点，优缺点可谓见仁见智，反正在我看来vim能够实现的它也都可以实现，长期使用 vim mod 插件，且各种第三方插件应有尽有。\n\n\n### 4. 私人定制：\n\n私人订制主要是基于以上的系统和 GUI，为了完成更好的体验效果和方便操作，所以个人增加了一些小功能。\n\n#### 输入法，Caps_Lock与右Ctrl互换（有相关详细文章）\n\n在当前的用户根目录下～创建 .Xmodmap 文件(尤其注意:这边名称是Xmodmap首字母大写,很多教程都忽略了这个问题,往往导致配置出来有问题)，书写内容如下：\n\n```\nremove Lock = Caps_Lock\nremove Control = Control_R\nkeysym Control_R = Caps_Lock\nkeysym Caps_Lock = Control_R\nadd Lock = Caps_Lock\nadd Control = Control_R\n```\n\n这样，caps lock 和 ctrl 就都是 ctrl 的功能。执行下`xmodmap ~/.Xmodmap  2>/dev/null`即可立即生效，每次开机启动系统会自动加载.Xmodmap，无需相关设置。\n\n\n#### github网站可以同时使用ssh和VPN（有相关详细文章）\n\n`sudo ip route add 192.30.252.0/22 via 192.168.18.1 dev eno1` 命令作用主要是过滤部分IP地址，让他们直接从路由器网关发送，而不从 VPN 上面走，通过上面 ifconfig 可以看到本机被路由器分配的ip地址为 192.168.18.60，而 eno1 为计算机在访问外网中的实体网卡。通过谷歌搜索网站查看到 github 实际推送的ip地址为： 192.30.252.0/22\n\n#### 关闭笔记本中的触摸板（有相关详细文章）\n\n- sudo rmmod psmouse    这个是禁用触摸板\n- sudo modprobe psmouse 这个是启用触摸板\n\n#### gnome下调网络管理小控件\n\nubuntu 的 GUI 在状态栏提供了一个网络管理的小工具，这边如果使用 awesome 可使用 nm-applet 命令将该工具打开，可以每次开机时自动启动该命令。\n\n\n***\n\n*linux下向来不缺少优秀的办公学习开发类软件，很多软件都是开源项目，需要大家共同去维护，只要你需要，想得到的功能，基本都可以在网上找到。*\n\n\n> 参考链接：\n> https://awesome.naquadah.org\n> http://www.hahack.com/tools/awesome/\n> https://www.gitbook.com/book/voluong/awesome-linux-software/details\n> https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***\nTo be continued...\n","source":"_posts/2016/2016-07-11-linux正常学习办公.md","raw":"---\nlayout: \"post\"\ntitle: \"linux正常学习办公\"\ncategory: \"read\"\ntags:   软件安装\ndate: \"2016-07-11 14:06\"\n---\n\n本文章在于总结自己如何使用 linux 完成正常的办公学习。linux 向来以它的可定制性强，稳定性高而出名，但 linux 常用领域大多也只限制在个别的一些如服务器领域，而民用领域即便是安卓系统也是 linux 经过层层封装之后的产物，早已逝去了该系统的原汁原味。linux 从发展至今也已经有了20多年的历史，但桌面版本一致被大家诟病，非专业人事不能使用，自从 ubuntu 这个发行版出来后，确实可以说是降低了新人使用的门槛，但是这个发行版的 GUI 定制性差，不够稳定等一系列的问题也让用户体验直线下降。这边我是以 ubuntu 的系统为基础采用 awesome 这儿 WM 进行图形化管理，目前使用了数个月时间，体验还算是良好。\n\n\n## 1. 系统选择：\n\n### 1.1 为何选择ubuntu？\n\n*现如今linux发行版很多，但真如ubuntu一样的美观，稳定又方便的真不多。说一下我用过的各个系统的体验吧：*\n\n- centOS 系统不够美观，本身使命就是等同 REDHAT 用于服务器的，虽然可以预装的软件比较多，但大都是用于开发及运维的。\n- arch 更像是一个 geek 玩的玩具，更新频率过快，该版本接触不是过多，但用于正常工作生活的系统，没有人愿意一天折腾几次吧？用不上一年就非得重装的吧？\n- deepin 这个是一个国产 linux，也只用过很短的一段时间，就界面各方面而言，感觉还是满美观，满人性化的，但用户太少，社区看起来也不是太活跃，虽然好像也是基于debian的衍生产品，但还是再观望一段时间再说吧。\n- ubuntu 出来时间也比较久了，本身一直专注于做桌面系统，gnome 的一整套组建目前来看也比较完善，各种自带软件，用户体验都还不错，有些甚至比 MS 的更好用。当然作为一个正常办公学习使用的人来说，最满意的还是 apt-get 可以直接管理获取各种资源了。也就是说，如果你是需要用 linux 来办公学习，写写程序的话，ubuntu 应该来说会是首选。\n\n<!-- more -->\n\n\n\n### 1.2 为何选择awesome？\n\n- gnome 的不稳定*ubuntu 下的 gnome 如果作为日常使用的话，很难满足要求，虽然经过这么多年的发展，但仍然会经常出现不响应。*试问，如果一个 GUI 连基本的稳定都没法保障，即便功能再完善，外观再美，用户长久用下来，最终会抛弃她。使用 gnome 两周，尽管尝试着去更改设置了不少东西，但度过了最开始的新奇感后，永无止境的不响应，从错误中恢复等等，最终让我还是选择更换一个新的图形化用户界面。\n\n- awesome 的轻便小巧，且可定制话极强（当然其他 linux 也都可以定制，只不过，其他的起点过高，对于普通用户而言，上手不易），awesome 即便是新手，在 github 上找个模板，稍加摸索也可以定制出自己满意的 GUI。\n\n\n\n## 2. linux软件：\n\n### 2.1 必备软件\n#### chrome:\n这个不做过多解释，简而言之就是好用，chrome 支持多个平台，而且用户体验都相近，关键 linux 下的 chrome 还相当稳定，远胜过 ubuntu 下自带的 firefox 等浏览器，使用体验可能更甚于 windows 下的 chrome。插件扩展等功能应有尽有。chrome 的使用和技巧内容很多，关于 chrome 可以参考本博客中专门的文章。\n\n#### virtualbox:\n算是使用 windows 软件的必备工具了。\n\n#### deepin-scrot截图：\n效果虽然可以达到 windows 下的截图工具大部分功能，但不够稳定。速度慢，虽然截图功能不是什么大的应用，但奈何之前在 win 平台下的截图都太好用了，暂时还没有在 linux 平台下面找到能够完全满意的截图软件。\n\n#### gthumb:\n一款轻巧好用的图片查看编辑工具，基本具备大多数常用功能，但仍然不能算是满足日常工作需要，最起码标记涂鸦功能都没有。\n\n#### xmind:\n一款和freemind类似的思维导图软件，据说是国产的。\n\n#### 分屏功能\nxrandr命令，这是一个命令行软件，并非图形界面软件，但很实用，用于分屏驱动多个显示器，一般是底层控制的，虽然是显示功能，但分屏并非GUI的独享。\n\n#### [录屏软件recordmydesktop](http://jingyan.baidu.com/article/7908e85c91f834af491ad241.html)\n\n\n### 3. 开发套件：\n\n#### atom:\ngithub 出品，算是现代 IDE 中的一个精品吧，结合了 vim 和 sublimeTEXT 一些特征特点，优缺点可谓见仁见智，反正在我看来vim能够实现的它也都可以实现，长期使用 vim mod 插件，且各种第三方插件应有尽有。\n\n\n### 4. 私人定制：\n\n私人订制主要是基于以上的系统和 GUI，为了完成更好的体验效果和方便操作，所以个人增加了一些小功能。\n\n#### 输入法，Caps_Lock与右Ctrl互换（有相关详细文章）\n\n在当前的用户根目录下～创建 .Xmodmap 文件(尤其注意:这边名称是Xmodmap首字母大写,很多教程都忽略了这个问题,往往导致配置出来有问题)，书写内容如下：\n\n```\nremove Lock = Caps_Lock\nremove Control = Control_R\nkeysym Control_R = Caps_Lock\nkeysym Caps_Lock = Control_R\nadd Lock = Caps_Lock\nadd Control = Control_R\n```\n\n这样，caps lock 和 ctrl 就都是 ctrl 的功能。执行下`xmodmap ~/.Xmodmap  2>/dev/null`即可立即生效，每次开机启动系统会自动加载.Xmodmap，无需相关设置。\n\n\n#### github网站可以同时使用ssh和VPN（有相关详细文章）\n\n`sudo ip route add 192.30.252.0/22 via 192.168.18.1 dev eno1` 命令作用主要是过滤部分IP地址，让他们直接从路由器网关发送，而不从 VPN 上面走，通过上面 ifconfig 可以看到本机被路由器分配的ip地址为 192.168.18.60，而 eno1 为计算机在访问外网中的实体网卡。通过谷歌搜索网站查看到 github 实际推送的ip地址为： 192.30.252.0/22\n\n#### 关闭笔记本中的触摸板（有相关详细文章）\n\n- sudo rmmod psmouse    这个是禁用触摸板\n- sudo modprobe psmouse 这个是启用触摸板\n\n#### gnome下调网络管理小控件\n\nubuntu 的 GUI 在状态栏提供了一个网络管理的小工具，这边如果使用 awesome 可使用 nm-applet 命令将该工具打开，可以每次开机时自动启动该命令。\n\n\n***\n\n*linux下向来不缺少优秀的办公学习开发类软件，很多软件都是开源项目，需要大家共同去维护，只要你需要，想得到的功能，基本都可以在网上找到。*\n\n\n> 参考链接：\n> https://awesome.naquadah.org\n> http://www.hahack.com/tools/awesome/\n> https://www.gitbook.com/book/voluong/awesome-linux-software/details\n> https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***\nTo be continued...\n","slug":"2016/2016-07-11-linux正常学习办公","published":1,"updated":"2017-01-12T02:40:51.457Z","comments":1,"photos":[],"link":"","_id":"ciyuv3agw001emumuzuj1zxm2","content":"<p>本文章在于总结自己如何使用 linux 完成正常的办公学习。linux 向来以它的可定制性强，稳定性高而出名，但 linux 常用领域大多也只限制在个别的一些如服务器领域，而民用领域即便是安卓系统也是 linux 经过层层封装之后的产物，早已逝去了该系统的原汁原味。linux 从发展至今也已经有了20多年的历史，但桌面版本一致被大家诟病，非专业人事不能使用，自从 ubuntu 这个发行版出来后，确实可以说是降低了新人使用的门槛，但是这个发行版的 GUI 定制性差，不够稳定等一系列的问题也让用户体验直线下降。这边我是以 ubuntu 的系统为基础采用 awesome 这儿 WM 进行图形化管理，目前使用了数个月时间，体验还算是良好。</p>\n<h2 id=\"1-系统选择：\"><a href=\"#1-系统选择：\" class=\"headerlink\" title=\"1. 系统选择：\"></a>1. 系统选择：</h2><h3 id=\"1-1-为何选择ubuntu？\"><a href=\"#1-1-为何选择ubuntu？\" class=\"headerlink\" title=\"1.1 为何选择ubuntu？\"></a>1.1 为何选择ubuntu？</h3><p><em>现如今linux发行版很多，但真如ubuntu一样的美观，稳定又方便的真不多。说一下我用过的各个系统的体验吧：</em></p>\n<ul>\n<li>centOS 系统不够美观，本身使命就是等同 REDHAT 用于服务器的，虽然可以预装的软件比较多，但大都是用于开发及运维的。</li>\n<li>arch 更像是一个 geek 玩的玩具，更新频率过快，该版本接触不是过多，但用于正常工作生活的系统，没有人愿意一天折腾几次吧？用不上一年就非得重装的吧？</li>\n<li>deepin 这个是一个国产 linux，也只用过很短的一段时间，就界面各方面而言，感觉还是满美观，满人性化的，但用户太少，社区看起来也不是太活跃，虽然好像也是基于debian的衍生产品，但还是再观望一段时间再说吧。</li>\n<li>ubuntu 出来时间也比较久了，本身一直专注于做桌面系统，gnome 的一整套组建目前来看也比较完善，各种自带软件，用户体验都还不错，有些甚至比 MS 的更好用。当然作为一个正常办公学习使用的人来说，最满意的还是 apt-get 可以直接管理获取各种资源了。也就是说，如果你是需要用 linux 来办公学习，写写程序的话，ubuntu 应该来说会是首选。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"1-2-为何选择awesome？\"><a href=\"#1-2-为何选择awesome？\" class=\"headerlink\" title=\"1.2 为何选择awesome？\"></a>1.2 为何选择awesome？</h3><ul>\n<li><p>gnome 的不稳定<em>ubuntu 下的 gnome 如果作为日常使用的话，很难满足要求，虽然经过这么多年的发展，但仍然会经常出现不响应。</em>试问，如果一个 GUI 连基本的稳定都没法保障，即便功能再完善，外观再美，用户长久用下来，最终会抛弃她。使用 gnome 两周，尽管尝试着去更改设置了不少东西，但度过了最开始的新奇感后，永无止境的不响应，从错误中恢复等等，最终让我还是选择更换一个新的图形化用户界面。</p>\n</li>\n<li><p>awesome 的轻便小巧，且可定制话极强（当然其他 linux 也都可以定制，只不过，其他的起点过高，对于普通用户而言，上手不易），awesome 即便是新手，在 github 上找个模板，稍加摸索也可以定制出自己满意的 GUI。</p>\n</li>\n</ul>\n<h2 id=\"2-linux软件：\"><a href=\"#2-linux软件：\" class=\"headerlink\" title=\"2. linux软件：\"></a>2. linux软件：</h2><h3 id=\"2-1-必备软件\"><a href=\"#2-1-必备软件\" class=\"headerlink\" title=\"2.1 必备软件\"></a>2.1 必备软件</h3><h4 id=\"chrome\"><a href=\"#chrome\" class=\"headerlink\" title=\"chrome:\"></a>chrome:</h4><p>这个不做过多解释，简而言之就是好用，chrome 支持多个平台，而且用户体验都相近，关键 linux 下的 chrome 还相当稳定，远胜过 ubuntu 下自带的 firefox 等浏览器，使用体验可能更甚于 windows 下的 chrome。插件扩展等功能应有尽有。chrome 的使用和技巧内容很多，关于 chrome 可以参考本博客中专门的文章。</p>\n<h4 id=\"virtualbox\"><a href=\"#virtualbox\" class=\"headerlink\" title=\"virtualbox:\"></a>virtualbox:</h4><p>算是使用 windows 软件的必备工具了。</p>\n<h4 id=\"deepin-scrot截图：\"><a href=\"#deepin-scrot截图：\" class=\"headerlink\" title=\"deepin-scrot截图：\"></a>deepin-scrot截图：</h4><p>效果虽然可以达到 windows 下的截图工具大部分功能，但不够稳定。速度慢，虽然截图功能不是什么大的应用，但奈何之前在 win 平台下的截图都太好用了，暂时还没有在 linux 平台下面找到能够完全满意的截图软件。</p>\n<h4 id=\"gthumb\"><a href=\"#gthumb\" class=\"headerlink\" title=\"gthumb:\"></a>gthumb:</h4><p>一款轻巧好用的图片查看编辑工具，基本具备大多数常用功能，但仍然不能算是满足日常工作需要，最起码标记涂鸦功能都没有。</p>\n<h4 id=\"xmind\"><a href=\"#xmind\" class=\"headerlink\" title=\"xmind:\"></a>xmind:</h4><p>一款和freemind类似的思维导图软件，据说是国产的。</p>\n<h4 id=\"分屏功能\"><a href=\"#分屏功能\" class=\"headerlink\" title=\"分屏功能\"></a>分屏功能</h4><p>xrandr命令，这是一个命令行软件，并非图形界面软件，但很实用，用于分屏驱动多个显示器，一般是底层控制的，虽然是显示功能，但分屏并非GUI的独享。</p>\n<h4 id=\"录屏软件recordmydesktop\"><a href=\"#录屏软件recordmydesktop\" class=\"headerlink\" title=\"录屏软件recordmydesktop\"></a><a href=\"http://jingyan.baidu.com/article/7908e85c91f834af491ad241.html\" target=\"_blank\" rel=\"external\">录屏软件recordmydesktop</a></h4><h3 id=\"3-开发套件：\"><a href=\"#3-开发套件：\" class=\"headerlink\" title=\"3. 开发套件：\"></a>3. 开发套件：</h3><h4 id=\"atom\"><a href=\"#atom\" class=\"headerlink\" title=\"atom:\"></a>atom:</h4><p>github 出品，算是现代 IDE 中的一个精品吧，结合了 vim 和 sublimeTEXT 一些特征特点，优缺点可谓见仁见智，反正在我看来vim能够实现的它也都可以实现，长期使用 vim mod 插件，且各种第三方插件应有尽有。</p>\n<h3 id=\"4-私人定制：\"><a href=\"#4-私人定制：\" class=\"headerlink\" title=\"4. 私人定制：\"></a>4. 私人定制：</h3><p>私人订制主要是基于以上的系统和 GUI，为了完成更好的体验效果和方便操作，所以个人增加了一些小功能。</p>\n<h4 id=\"输入法，Caps-Lock与右Ctrl互换（有相关详细文章）\"><a href=\"#输入法，Caps-Lock与右Ctrl互换（有相关详细文章）\" class=\"headerlink\" title=\"输入法，Caps_Lock与右Ctrl互换（有相关详细文章）\"></a>输入法，Caps_Lock与右Ctrl互换（有相关详细文章）</h4><p>在当前的用户根目录下～创建 .Xmodmap 文件(尤其注意:这边名称是Xmodmap首字母大写,很多教程都忽略了这个问题,往往导致配置出来有问题)，书写内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">remove Lock = Caps_Lock</div><div class=\"line\">remove Control = Control_R</div><div class=\"line\">keysym Control_R = Caps_Lock</div><div class=\"line\">keysym Caps_Lock = Control_R</div><div class=\"line\">add Lock = Caps_Lock</div><div class=\"line\">add Control = Control_R</div></pre></td></tr></table></figure>\n<p>这样，caps lock 和 ctrl 就都是 ctrl 的功能。执行下<code>xmodmap ~/.Xmodmap  2&gt;/dev/null</code>即可立即生效，每次开机启动系统会自动加载.Xmodmap，无需相关设置。</p>\n<h4 id=\"github网站可以同时使用ssh和VPN（有相关详细文章）\"><a href=\"#github网站可以同时使用ssh和VPN（有相关详细文章）\" class=\"headerlink\" title=\"github网站可以同时使用ssh和VPN（有相关详细文章）\"></a>github网站可以同时使用ssh和VPN（有相关详细文章）</h4><p><code>sudo ip route add 192.30.252.0/22 via 192.168.18.1 dev eno1</code> 命令作用主要是过滤部分IP地址，让他们直接从路由器网关发送，而不从 VPN 上面走，通过上面 ifconfig 可以看到本机被路由器分配的ip地址为 192.168.18.60，而 eno1 为计算机在访问外网中的实体网卡。通过谷歌搜索网站查看到 github 实际推送的ip地址为： 192.30.252.0/22</p>\n<h4 id=\"关闭笔记本中的触摸板（有相关详细文章）\"><a href=\"#关闭笔记本中的触摸板（有相关详细文章）\" class=\"headerlink\" title=\"关闭笔记本中的触摸板（有相关详细文章）\"></a>关闭笔记本中的触摸板（有相关详细文章）</h4><ul>\n<li>sudo rmmod psmouse    这个是禁用触摸板</li>\n<li>sudo modprobe psmouse 这个是启用触摸板</li>\n</ul>\n<h4 id=\"gnome下调网络管理小控件\"><a href=\"#gnome下调网络管理小控件\" class=\"headerlink\" title=\"gnome下调网络管理小控件\"></a>gnome下调网络管理小控件</h4><p>ubuntu 的 GUI 在状态栏提供了一个网络管理的小工具，这边如果使用 awesome 可使用 nm-applet 命令将该工具打开，可以每次开机时自动启动该命令。</p>\n<hr>\n<p><em>linux下向来不缺少优秀的办公学习开发类软件，很多软件都是开源项目，需要大家共同去维护，只要你需要，想得到的功能，基本都可以在网上找到。</em></p>\n<blockquote>\n<p>参考链接：<br><a href=\"https://awesome.naquadah.org\" target=\"_blank\" rel=\"external\">https://awesome.naquadah.org</a><br><a href=\"http://www.hahack.com/tools/awesome/\" target=\"_blank\" rel=\"external\">http://www.hahack.com/tools/awesome/</a><br><a href=\"https://www.gitbook.com/book/voluong/awesome-linux-software/details\" target=\"_blank\" rel=\"external\">https://www.gitbook.com/book/voluong/awesome-linux-software/details</a><br><a href=\"https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content/\" target=\"_blank\" rel=\"external\">https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content/</a></p>\n</blockquote>\n<hr>\n<p>To be continued…</p>\n","excerpt":"<p>本文章在于总结自己如何使用 linux 完成正常的办公学习。linux 向来以它的可定制性强，稳定性高而出名，但 linux 常用领域大多也只限制在个别的一些如服务器领域，而民用领域即便是安卓系统也是 linux 经过层层封装之后的产物，早已逝去了该系统的原汁原味。linux 从发展至今也已经有了20多年的历史，但桌面版本一致被大家诟病，非专业人事不能使用，自从 ubuntu 这个发行版出来后，确实可以说是降低了新人使用的门槛，但是这个发行版的 GUI 定制性差，不够稳定等一系列的问题也让用户体验直线下降。这边我是以 ubuntu 的系统为基础采用 awesome 这儿 WM 进行图形化管理，目前使用了数个月时间，体验还算是良好。</p>\n<h2 id=\"1-系统选择：\"><a href=\"#1-系统选择：\" class=\"headerlink\" title=\"1. 系统选择：\"></a>1. 系统选择：</h2><h3 id=\"1-1-为何选择ubuntu？\"><a href=\"#1-1-为何选择ubuntu？\" class=\"headerlink\" title=\"1.1 为何选择ubuntu？\"></a>1.1 为何选择ubuntu？</h3><p><em>现如今linux发行版很多，但真如ubuntu一样的美观，稳定又方便的真不多。说一下我用过的各个系统的体验吧：</em></p>\n<ul>\n<li>centOS 系统不够美观，本身使命就是等同 REDHAT 用于服务器的，虽然可以预装的软件比较多，但大都是用于开发及运维的。</li>\n<li>arch 更像是一个 geek 玩的玩具，更新频率过快，该版本接触不是过多，但用于正常工作生活的系统，没有人愿意一天折腾几次吧？用不上一年就非得重装的吧？</li>\n<li>deepin 这个是一个国产 linux，也只用过很短的一段时间，就界面各方面而言，感觉还是满美观，满人性化的，但用户太少，社区看起来也不是太活跃，虽然好像也是基于debian的衍生产品，但还是再观望一段时间再说吧。</li>\n<li>ubuntu 出来时间也比较久了，本身一直专注于做桌面系统，gnome 的一整套组建目前来看也比较完善，各种自带软件，用户体验都还不错，有些甚至比 MS 的更好用。当然作为一个正常办公学习使用的人来说，最满意的还是 apt-get 可以直接管理获取各种资源了。也就是说，如果你是需要用 linux 来办公学习，写写程序的话，ubuntu 应该来说会是首选。</li>\n</ul>","more":"<h3 id=\"1-2-为何选择awesome？\"><a href=\"#1-2-为何选择awesome？\" class=\"headerlink\" title=\"1.2 为何选择awesome？\"></a>1.2 为何选择awesome？</h3><ul>\n<li><p>gnome 的不稳定<em>ubuntu 下的 gnome 如果作为日常使用的话，很难满足要求，虽然经过这么多年的发展，但仍然会经常出现不响应。</em>试问，如果一个 GUI 连基本的稳定都没法保障，即便功能再完善，外观再美，用户长久用下来，最终会抛弃她。使用 gnome 两周，尽管尝试着去更改设置了不少东西，但度过了最开始的新奇感后，永无止境的不响应，从错误中恢复等等，最终让我还是选择更换一个新的图形化用户界面。</p>\n</li>\n<li><p>awesome 的轻便小巧，且可定制话极强（当然其他 linux 也都可以定制，只不过，其他的起点过高，对于普通用户而言，上手不易），awesome 即便是新手，在 github 上找个模板，稍加摸索也可以定制出自己满意的 GUI。</p>\n</li>\n</ul>\n<h2 id=\"2-linux软件：\"><a href=\"#2-linux软件：\" class=\"headerlink\" title=\"2. linux软件：\"></a>2. linux软件：</h2><h3 id=\"2-1-必备软件\"><a href=\"#2-1-必备软件\" class=\"headerlink\" title=\"2.1 必备软件\"></a>2.1 必备软件</h3><h4 id=\"chrome\"><a href=\"#chrome\" class=\"headerlink\" title=\"chrome:\"></a>chrome:</h4><p>这个不做过多解释，简而言之就是好用，chrome 支持多个平台，而且用户体验都相近，关键 linux 下的 chrome 还相当稳定，远胜过 ubuntu 下自带的 firefox 等浏览器，使用体验可能更甚于 windows 下的 chrome。插件扩展等功能应有尽有。chrome 的使用和技巧内容很多，关于 chrome 可以参考本博客中专门的文章。</p>\n<h4 id=\"virtualbox\"><a href=\"#virtualbox\" class=\"headerlink\" title=\"virtualbox:\"></a>virtualbox:</h4><p>算是使用 windows 软件的必备工具了。</p>\n<h4 id=\"deepin-scrot截图：\"><a href=\"#deepin-scrot截图：\" class=\"headerlink\" title=\"deepin-scrot截图：\"></a>deepin-scrot截图：</h4><p>效果虽然可以达到 windows 下的截图工具大部分功能，但不够稳定。速度慢，虽然截图功能不是什么大的应用，但奈何之前在 win 平台下的截图都太好用了，暂时还没有在 linux 平台下面找到能够完全满意的截图软件。</p>\n<h4 id=\"gthumb\"><a href=\"#gthumb\" class=\"headerlink\" title=\"gthumb:\"></a>gthumb:</h4><p>一款轻巧好用的图片查看编辑工具，基本具备大多数常用功能，但仍然不能算是满足日常工作需要，最起码标记涂鸦功能都没有。</p>\n<h4 id=\"xmind\"><a href=\"#xmind\" class=\"headerlink\" title=\"xmind:\"></a>xmind:</h4><p>一款和freemind类似的思维导图软件，据说是国产的。</p>\n<h4 id=\"分屏功能\"><a href=\"#分屏功能\" class=\"headerlink\" title=\"分屏功能\"></a>分屏功能</h4><p>xrandr命令，这是一个命令行软件，并非图形界面软件，但很实用，用于分屏驱动多个显示器，一般是底层控制的，虽然是显示功能，但分屏并非GUI的独享。</p>\n<h4 id=\"录屏软件recordmydesktop\"><a href=\"#录屏软件recordmydesktop\" class=\"headerlink\" title=\"录屏软件recordmydesktop\"></a><a href=\"http://jingyan.baidu.com/article/7908e85c91f834af491ad241.html\">录屏软件recordmydesktop</a></h4><h3 id=\"3-开发套件：\"><a href=\"#3-开发套件：\" class=\"headerlink\" title=\"3. 开发套件：\"></a>3. 开发套件：</h3><h4 id=\"atom\"><a href=\"#atom\" class=\"headerlink\" title=\"atom:\"></a>atom:</h4><p>github 出品，算是现代 IDE 中的一个精品吧，结合了 vim 和 sublimeTEXT 一些特征特点，优缺点可谓见仁见智，反正在我看来vim能够实现的它也都可以实现，长期使用 vim mod 插件，且各种第三方插件应有尽有。</p>\n<h3 id=\"4-私人定制：\"><a href=\"#4-私人定制：\" class=\"headerlink\" title=\"4. 私人定制：\"></a>4. 私人定制：</h3><p>私人订制主要是基于以上的系统和 GUI，为了完成更好的体验效果和方便操作，所以个人增加了一些小功能。</p>\n<h4 id=\"输入法，Caps-Lock与右Ctrl互换（有相关详细文章）\"><a href=\"#输入法，Caps-Lock与右Ctrl互换（有相关详细文章）\" class=\"headerlink\" title=\"输入法，Caps_Lock与右Ctrl互换（有相关详细文章）\"></a>输入法，Caps_Lock与右Ctrl互换（有相关详细文章）</h4><p>在当前的用户根目录下～创建 .Xmodmap 文件(尤其注意:这边名称是Xmodmap首字母大写,很多教程都忽略了这个问题,往往导致配置出来有问题)，书写内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">remove Lock = Caps_Lock</div><div class=\"line\">remove Control = Control_R</div><div class=\"line\">keysym Control_R = Caps_Lock</div><div class=\"line\">keysym Caps_Lock = Control_R</div><div class=\"line\">add Lock = Caps_Lock</div><div class=\"line\">add Control = Control_R</div></pre></td></tr></table></figure>\n<p>这样，caps lock 和 ctrl 就都是 ctrl 的功能。执行下<code>xmodmap ~/.Xmodmap  2&gt;/dev/null</code>即可立即生效，每次开机启动系统会自动加载.Xmodmap，无需相关设置。</p>\n<h4 id=\"github网站可以同时使用ssh和VPN（有相关详细文章）\"><a href=\"#github网站可以同时使用ssh和VPN（有相关详细文章）\" class=\"headerlink\" title=\"github网站可以同时使用ssh和VPN（有相关详细文章）\"></a>github网站可以同时使用ssh和VPN（有相关详细文章）</h4><p><code>sudo ip route add 192.30.252.0/22 via 192.168.18.1 dev eno1</code> 命令作用主要是过滤部分IP地址，让他们直接从路由器网关发送，而不从 VPN 上面走，通过上面 ifconfig 可以看到本机被路由器分配的ip地址为 192.168.18.60，而 eno1 为计算机在访问外网中的实体网卡。通过谷歌搜索网站查看到 github 实际推送的ip地址为： 192.30.252.0/22</p>\n<h4 id=\"关闭笔记本中的触摸板（有相关详细文章）\"><a href=\"#关闭笔记本中的触摸板（有相关详细文章）\" class=\"headerlink\" title=\"关闭笔记本中的触摸板（有相关详细文章）\"></a>关闭笔记本中的触摸板（有相关详细文章）</h4><ul>\n<li>sudo rmmod psmouse    这个是禁用触摸板</li>\n<li>sudo modprobe psmouse 这个是启用触摸板</li>\n</ul>\n<h4 id=\"gnome下调网络管理小控件\"><a href=\"#gnome下调网络管理小控件\" class=\"headerlink\" title=\"gnome下调网络管理小控件\"></a>gnome下调网络管理小控件</h4><p>ubuntu 的 GUI 在状态栏提供了一个网络管理的小工具，这边如果使用 awesome 可使用 nm-applet 命令将该工具打开，可以每次开机时自动启动该命令。</p>\n<hr>\n<p><em>linux下向来不缺少优秀的办公学习开发类软件，很多软件都是开源项目，需要大家共同去维护，只要你需要，想得到的功能，基本都可以在网上找到。</em></p>\n<blockquote>\n<p>参考链接：<br><a href=\"https://awesome.naquadah.org\">https://awesome.naquadah.org</a><br><a href=\"http://www.hahack.com/tools/awesome/\">http://www.hahack.com/tools/awesome/</a><br><a href=\"https://www.gitbook.com/book/voluong/awesome-linux-software/details\">https://www.gitbook.com/book/voluong/awesome-linux-software/details</a><br><a href=\"https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content/\">https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content/</a></p>\n</blockquote>\n<hr>\n<p>To be continued…</p>"},{"layout":"post","title":"stm32F439案例汇总","date":"2016-07-10T17:12:00.000Z","_content":"\n\n*使用神州开发板，stm32F439芯片，但由于某种原因，配备资料(尤其是案例)并不齐全，且2014年之后相关网站也暂停了访问\n本工程目的，只要是深入学习研究这块芯片，通过参考其他M4内核的历程，将这块开发板的相关案例完善，同时去除原历程中\n模糊，难懂冗余的案例，尽量做到代码规范，案例可取，便于进一步的学习研究。*\n\n\n> www.armjishu.com(无法访问)\n\n\n### 注意事项\n\n- 使用芯片为stm32F439IG，市面基于这块M4内核的st芯片比较少，一般多为407\n- 烧录工具位jlink或ulink，正常情况下为jlink\n- 开发板的原理图可见根目录，该开发板可以在某宝找到。\n\n<!-- more -->\n\n\n### 案例列表\n\n\n- 实验0 Template工程模板\n- 实验1 跑马灯\n- 实验2 蜂鸣器\n- 实验3 按键和外部中断\n- 实验4 看门狗（独立和窗口）\n- 实验5 待机唤醒\n- 实验6 串口通讯（232和485）\n- 实验7 定时器中断（含有RTC，SYSTICK，TIM）\n- 实验8 PWM输出和输入捕获\n\n\n\n### 注意说明\n\n\n### 详细地址\n\n> https://github.com/noparkinghere/stm32_test\n\n******\n_未完待续_\n","source":"_posts/2016/2016-07-11-神州stm32案例练习.md","raw":"---\nlayout: \"post\"\ntitle: \"stm32F439案例汇总\"\ndate: \"2016-07-11 1:12\"\n---\n\n\n*使用神州开发板，stm32F439芯片，但由于某种原因，配备资料(尤其是案例)并不齐全，且2014年之后相关网站也暂停了访问\n本工程目的，只要是深入学习研究这块芯片，通过参考其他M4内核的历程，将这块开发板的相关案例完善，同时去除原历程中\n模糊，难懂冗余的案例，尽量做到代码规范，案例可取，便于进一步的学习研究。*\n\n\n> www.armjishu.com(无法访问)\n\n\n### 注意事项\n\n- 使用芯片为stm32F439IG，市面基于这块M4内核的st芯片比较少，一般多为407\n- 烧录工具位jlink或ulink，正常情况下为jlink\n- 开发板的原理图可见根目录，该开发板可以在某宝找到。\n\n<!-- more -->\n\n\n### 案例列表\n\n\n- 实验0 Template工程模板\n- 实验1 跑马灯\n- 实验2 蜂鸣器\n- 实验3 按键和外部中断\n- 实验4 看门狗（独立和窗口）\n- 实验5 待机唤醒\n- 实验6 串口通讯（232和485）\n- 实验7 定时器中断（含有RTC，SYSTICK，TIM）\n- 实验8 PWM输出和输入捕获\n\n\n\n### 注意说明\n\n\n### 详细地址\n\n> https://github.com/noparkinghere/stm32_test\n\n******\n_未完待续_\n","slug":"2016/2016-07-11-神州stm32案例练习","published":1,"updated":"2016-12-16T01:42:12.611Z","comments":1,"photos":[],"link":"","_id":"ciyuv3agx001imumul1kyh01h","content":"<p><em>使用神州开发板，stm32F439芯片，但由于某种原因，配备资料(尤其是案例)并不齐全，且2014年之后相关网站也暂停了访问<br>本工程目的，只要是深入学习研究这块芯片，通过参考其他M4内核的历程，将这块开发板的相关案例完善，同时去除原历程中<br>模糊，难懂冗余的案例，尽量做到代码规范，案例可取，便于进一步的学习研究。</em></p>\n<blockquote>\n<p>www.armjishu.com(无法访问)</p>\n</blockquote>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>使用芯片为stm32F439IG，市面基于这块M4内核的st芯片比较少，一般多为407</li>\n<li>烧录工具位jlink或ulink，正常情况下为jlink</li>\n<li>开发板的原理图可见根目录，该开发板可以在某宝找到。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"案例列表\"><a href=\"#案例列表\" class=\"headerlink\" title=\"案例列表\"></a>案例列表</h3><ul>\n<li>实验0 Template工程模板</li>\n<li>实验1 跑马灯</li>\n<li>实验2 蜂鸣器</li>\n<li>实验3 按键和外部中断</li>\n<li>实验4 看门狗（独立和窗口）</li>\n<li>实验5 待机唤醒</li>\n<li>实验6 串口通讯（232和485）</li>\n<li>实验7 定时器中断（含有RTC，SYSTICK，TIM）</li>\n<li>实验8 PWM输出和输入捕获</li>\n</ul>\n<h3 id=\"注意说明\"><a href=\"#注意说明\" class=\"headerlink\" title=\"注意说明\"></a>注意说明</h3><h3 id=\"详细地址\"><a href=\"#详细地址\" class=\"headerlink\" title=\"详细地址\"></a>详细地址</h3><blockquote>\n<p><a href=\"https://github.com/noparkinghere/stm32_test\" target=\"_blank\" rel=\"external\">https://github.com/noparkinghere/stm32_test</a></p>\n</blockquote>\n<hr>\n<p><em>未完待续</em></p>\n","excerpt":"<p><em>使用神州开发板，stm32F439芯片，但由于某种原因，配备资料(尤其是案例)并不齐全，且2014年之后相关网站也暂停了访问<br>本工程目的，只要是深入学习研究这块芯片，通过参考其他M4内核的历程，将这块开发板的相关案例完善，同时去除原历程中<br>模糊，难懂冗余的案例，尽量做到代码规范，案例可取，便于进一步的学习研究。</em></p>\n<blockquote>\n<p>www.armjishu.com(无法访问)</p>\n</blockquote>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>使用芯片为stm32F439IG，市面基于这块M4内核的st芯片比较少，一般多为407</li>\n<li>烧录工具位jlink或ulink，正常情况下为jlink</li>\n<li>开发板的原理图可见根目录，该开发板可以在某宝找到。</li>\n</ul>","more":"<h3 id=\"案例列表\"><a href=\"#案例列表\" class=\"headerlink\" title=\"案例列表\"></a>案例列表</h3><ul>\n<li>实验0 Template工程模板</li>\n<li>实验1 跑马灯</li>\n<li>实验2 蜂鸣器</li>\n<li>实验3 按键和外部中断</li>\n<li>实验4 看门狗（独立和窗口）</li>\n<li>实验5 待机唤醒</li>\n<li>实验6 串口通讯（232和485）</li>\n<li>实验7 定时器中断（含有RTC，SYSTICK，TIM）</li>\n<li>实验8 PWM输出和输入捕获</li>\n</ul>\n<h3 id=\"注意说明\"><a href=\"#注意说明\" class=\"headerlink\" title=\"注意说明\"></a>注意说明</h3><h3 id=\"详细地址\"><a href=\"#详细地址\" class=\"headerlink\" title=\"详细地址\"></a>详细地址</h3><blockquote>\n<p><a href=\"https://github.com/noparkinghere/stm32_test\">https://github.com/noparkinghere/stm32_test</a></p>\n</blockquote>\n<hr>\n<p><em>未完待续</em></p>"},{"layout":"post","title":"jlink相关问题汇总","date":"2016-07-12T08:09:00.000Z","_content":"\n### jlink简介\n\n### MDK如何让jlink不跳出升级\n有三种方法(注意盗版的 jlink 谨慎升级),推荐方法3。\n1. 升级 Keil 自带的 J-link 程序,新版本 jlink 的一般盗版的 v8 都没法直接升级。\n2. 使用之前版本 keil 自带的 J-link 驱动替换掉现在的,也就是将 ..\\Keil\\ARM\\Segger 文件夹替换为老版本的,这样里面的 J-Link 驱动也是老版本的,就不会提示 J-Link 更新了,这种需要有之前的 keil 才可以,如果是直接安装新版的 keil 5 默认自带为 4.8 的版本。\n3. 卸载 segger，下载了比较新的驱动重新安装，并将 segger/jlinkarm_v440 目录下的 jlinkarm。dll 拷贝到 keil/arm/segger 的目录下。再次使用 MDK，提示升级，确定升级，但这次升级后，jlink 确实可以识别。这个版本需要注意的是 jlink 的版本必须在 4.4 以后(如 4.1x 的复制 jlinkarm.dll 软件会出错),另外复制前做好 jlinkarm.dll 的备份。\n\n<!-- more -->\n\n\n### JLINK刷固件步骤\n*如果通过上面的方法,结果盗版jlink变板砖了,可以使用下面方法重新烧录固件。*\n\n#### 清除原有固件,烧录新固件\n- 下载安装提供的相关软件: jlink, Install AT91-ISP v1.13, 以及固件。\n- 按照说明文档一步步操作,烧录固件,**步骤先后顺序一定要完全一致,如果失败则重复多次**。[JLinkV8固件烧录指导][3d1523be]\n\n  [3d1523be]: https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-13-jlink%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/JLinkV8%E5%9B%BA%E4%BB%B6%E7%83%A7%E5%BD%95%E6%8C%87%E5%AF%BC.pdf \"JLinkV8固件烧录指导\"\n\n```\n#### 升级方法:\n- 使用XP的环境, win7 大多都不行。\n- 打开 jLink command 软件,注意不要升级固件。\n- 在命令行下输入: Exec SetSN=XXXXXXXX  回车。**注：XXXXXXXX 为你自己想要的 SN,SN 必须是8个数字。**\n- 关闭 jLink command 软件再从新打开。即可生效。\n*注意:只能设置一次 SN,设置前请想好你的SN。*\n\n然后就可以正常升级了。\n```\n\n\n\n### 出现问题\n\n#### MDK 用 JTAG 仿真器下载代码时，提示 cannot load flash device description！\n- 如果 jlink 链接没有问题,且能够找到芯片的话,一般为 flash programming algorithm 丢失。\n[参考网址 ](http://www.openedv.com/posts/list/50048.htm)\n\n\n> 参考链接:\n> http://zhidao.baidu.com/link?url=jM6YRhn1aPQe7uPfdmIDP9-_k4Hl8XTWvAnBMJV0TE176gUBb5kGXK_XksirP6xdXkUkMofUD5YIhrNbYTxiBBQpSKZ_4QJWjj64vJT7xXu\n> http://www.openedv.com/posts/list/50048.htm\n\n\n***\nTO be continued...\n","source":"_posts/2016/2016-07-12-jlink相关问题汇总.md","raw":"---\nlayout: \"post\"\ntitle: \"jlink相关问题汇总\"\ncategory: \"read\"\ntags:   问题总结\ndate: \"2016-07-12 16:09\"\n---\n\n### jlink简介\n\n### MDK如何让jlink不跳出升级\n有三种方法(注意盗版的 jlink 谨慎升级),推荐方法3。\n1. 升级 Keil 自带的 J-link 程序,新版本 jlink 的一般盗版的 v8 都没法直接升级。\n2. 使用之前版本 keil 自带的 J-link 驱动替换掉现在的,也就是将 ..\\Keil\\ARM\\Segger 文件夹替换为老版本的,这样里面的 J-Link 驱动也是老版本的,就不会提示 J-Link 更新了,这种需要有之前的 keil 才可以,如果是直接安装新版的 keil 5 默认自带为 4.8 的版本。\n3. 卸载 segger，下载了比较新的驱动重新安装，并将 segger/jlinkarm_v440 目录下的 jlinkarm。dll 拷贝到 keil/arm/segger 的目录下。再次使用 MDK，提示升级，确定升级，但这次升级后，jlink 确实可以识别。这个版本需要注意的是 jlink 的版本必须在 4.4 以后(如 4.1x 的复制 jlinkarm.dll 软件会出错),另外复制前做好 jlinkarm.dll 的备份。\n\n<!-- more -->\n\n\n### JLINK刷固件步骤\n*如果通过上面的方法,结果盗版jlink变板砖了,可以使用下面方法重新烧录固件。*\n\n#### 清除原有固件,烧录新固件\n- 下载安装提供的相关软件: jlink, Install AT91-ISP v1.13, 以及固件。\n- 按照说明文档一步步操作,烧录固件,**步骤先后顺序一定要完全一致,如果失败则重复多次**。[JLinkV8固件烧录指导][3d1523be]\n\n  [3d1523be]: https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-13-jlink%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/JLinkV8%E5%9B%BA%E4%BB%B6%E7%83%A7%E5%BD%95%E6%8C%87%E5%AF%BC.pdf \"JLinkV8固件烧录指导\"\n\n```\n#### 升级方法:\n- 使用XP的环境, win7 大多都不行。\n- 打开 jLink command 软件,注意不要升级固件。\n- 在命令行下输入: Exec SetSN=XXXXXXXX  回车。**注：XXXXXXXX 为你自己想要的 SN,SN 必须是8个数字。**\n- 关闭 jLink command 软件再从新打开。即可生效。\n*注意:只能设置一次 SN,设置前请想好你的SN。*\n\n然后就可以正常升级了。\n```\n\n\n\n### 出现问题\n\n#### MDK 用 JTAG 仿真器下载代码时，提示 cannot load flash device description！\n- 如果 jlink 链接没有问题,且能够找到芯片的话,一般为 flash programming algorithm 丢失。\n[参考网址 ](http://www.openedv.com/posts/list/50048.htm)\n\n\n> 参考链接:\n> http://zhidao.baidu.com/link?url=jM6YRhn1aPQe7uPfdmIDP9-_k4Hl8XTWvAnBMJV0TE176gUBb5kGXK_XksirP6xdXkUkMofUD5YIhrNbYTxiBBQpSKZ_4QJWjj64vJT7xXu\n> http://www.openedv.com/posts/list/50048.htm\n\n\n***\nTO be continued...\n","slug":"2016/2016-07-12-jlink相关问题汇总","published":1,"updated":"2017-01-12T03:29:59.959Z","comments":1,"photos":[],"link":"","_id":"ciyuv3agz001lmumuy5esjuhs","content":"<h3 id=\"jlink简介\"><a href=\"#jlink简介\" class=\"headerlink\" title=\"jlink简介\"></a>jlink简介</h3><h3 id=\"MDK如何让jlink不跳出升级\"><a href=\"#MDK如何让jlink不跳出升级\" class=\"headerlink\" title=\"MDK如何让jlink不跳出升级\"></a>MDK如何让jlink不跳出升级</h3><p>有三种方法(注意盗版的 jlink 谨慎升级),推荐方法3。</p>\n<ol>\n<li>升级 Keil 自带的 J-link 程序,新版本 jlink 的一般盗版的 v8 都没法直接升级。</li>\n<li>使用之前版本 keil 自带的 J-link 驱动替换掉现在的,也就是将 ..\\Keil\\ARM\\Segger 文件夹替换为老版本的,这样里面的 J-Link 驱动也是老版本的,就不会提示 J-Link 更新了,这种需要有之前的 keil 才可以,如果是直接安装新版的 keil 5 默认自带为 4.8 的版本。</li>\n<li>卸载 segger，下载了比较新的驱动重新安装，并将 segger/jlinkarm_v440 目录下的 jlinkarm。dll 拷贝到 keil/arm/segger 的目录下。再次使用 MDK，提示升级，确定升级，但这次升级后，jlink 确实可以识别。这个版本需要注意的是 jlink 的版本必须在 4.4 以后(如 4.1x 的复制 jlinkarm.dll 软件会出错),另外复制前做好 jlinkarm.dll 的备份。</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"JLINK刷固件步骤\"><a href=\"#JLINK刷固件步骤\" class=\"headerlink\" title=\"JLINK刷固件步骤\"></a>JLINK刷固件步骤</h3><p><em>如果通过上面的方法,结果盗版jlink变板砖了,可以使用下面方法重新烧录固件。</em></p>\n<h4 id=\"清除原有固件-烧录新固件\"><a href=\"#清除原有固件-烧录新固件\" class=\"headerlink\" title=\"清除原有固件,烧录新固件\"></a>清除原有固件,烧录新固件</h4><ul>\n<li>下载安装提供的相关软件: jlink, Install AT91-ISP v1.13, 以及固件。</li>\n<li>按照说明文档一步步操作,烧录固件,<strong>步骤先后顺序一定要完全一致,如果失败则重复多次</strong>。<a href=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-13-jlink%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/JLinkV8%E5%9B%BA%E4%BB%B6%E7%83%A7%E5%BD%95%E6%8C%87%E5%AF%BC.pdf\" title=\"JLinkV8固件烧录指导\" target=\"_blank\" rel=\"external\">JLinkV8固件烧录指导</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 升级方法:</div><div class=\"line\">- 使用XP的环境, win7 大多都不行。</div><div class=\"line\">- 打开 jLink command 软件,注意不要升级固件。</div><div class=\"line\">- 在命令行下输入: Exec SetSN=XXXXXXXX  回车。**注：XXXXXXXX 为你自己想要的 SN,SN 必须是8个数字。**</div><div class=\"line\">- 关闭 jLink command 软件再从新打开。即可生效。</div><div class=\"line\">*注意:只能设置一次 SN,设置前请想好你的SN。*</div><div class=\"line\"></div><div class=\"line\">然后就可以正常升级了。</div></pre></td></tr></table></figure>\n<h3 id=\"出现问题\"><a href=\"#出现问题\" class=\"headerlink\" title=\"出现问题\"></a>出现问题</h3><h4 id=\"MDK-用-JTAG-仿真器下载代码时，提示-cannot-load-flash-device-description！\"><a href=\"#MDK-用-JTAG-仿真器下载代码时，提示-cannot-load-flash-device-description！\" class=\"headerlink\" title=\"MDK 用 JTAG 仿真器下载代码时，提示 cannot load flash device description！\"></a>MDK 用 JTAG 仿真器下载代码时，提示 cannot load flash device description！</h4><ul>\n<li>如果 jlink 链接没有问题,且能够找到芯片的话,一般为 flash programming algorithm 丢失。<br><a href=\"http://www.openedv.com/posts/list/50048.htm\" target=\"_blank\" rel=\"external\">参考网址 </a></li>\n</ul>\n<blockquote>\n<p>参考链接:<br><a href=\"http://zhidao.baidu.com/link?url=jM6YRhn1aPQe7uPfdmIDP9-_k4Hl8XTWvAnBMJV0TE176gUBb5kGXK_XksirP6xdXkUkMofUD5YIhrNbYTxiBBQpSKZ_4QJWjj64vJT7xXu\" target=\"_blank\" rel=\"external\">http://zhidao.baidu.com/link?url=jM6YRhn1aPQe7uPfdmIDP9-_k4Hl8XTWvAnBMJV0TE176gUBb5kGXK_XksirP6xdXkUkMofUD5YIhrNbYTxiBBQpSKZ_4QJWjj64vJT7xXu</a><br><a href=\"http://www.openedv.com/posts/list/50048.htm\" target=\"_blank\" rel=\"external\">http://www.openedv.com/posts/list/50048.htm</a></p>\n</blockquote>\n<hr>\n<p>TO be continued…</p>\n","excerpt":"<h3 id=\"jlink简介\"><a href=\"#jlink简介\" class=\"headerlink\" title=\"jlink简介\"></a>jlink简介</h3><h3 id=\"MDK如何让jlink不跳出升级\"><a href=\"#MDK如何让jlink不跳出升级\" class=\"headerlink\" title=\"MDK如何让jlink不跳出升级\"></a>MDK如何让jlink不跳出升级</h3><p>有三种方法(注意盗版的 jlink 谨慎升级),推荐方法3。</p>\n<ol>\n<li>升级 Keil 自带的 J-link 程序,新版本 jlink 的一般盗版的 v8 都没法直接升级。</li>\n<li>使用之前版本 keil 自带的 J-link 驱动替换掉现在的,也就是将 ..\\Keil\\ARM\\Segger 文件夹替换为老版本的,这样里面的 J-Link 驱动也是老版本的,就不会提示 J-Link 更新了,这种需要有之前的 keil 才可以,如果是直接安装新版的 keil 5 默认自带为 4.8 的版本。</li>\n<li>卸载 segger，下载了比较新的驱动重新安装，并将 segger/jlinkarm_v440 目录下的 jlinkarm。dll 拷贝到 keil/arm/segger 的目录下。再次使用 MDK，提示升级，确定升级，但这次升级后，jlink 确实可以识别。这个版本需要注意的是 jlink 的版本必须在 4.4 以后(如 4.1x 的复制 jlinkarm.dll 软件会出错),另外复制前做好 jlinkarm.dll 的备份。</li>\n</ol>","more":"<h3 id=\"JLINK刷固件步骤\"><a href=\"#JLINK刷固件步骤\" class=\"headerlink\" title=\"JLINK刷固件步骤\"></a>JLINK刷固件步骤</h3><p><em>如果通过上面的方法,结果盗版jlink变板砖了,可以使用下面方法重新烧录固件。</em></p>\n<h4 id=\"清除原有固件-烧录新固件\"><a href=\"#清除原有固件-烧录新固件\" class=\"headerlink\" title=\"清除原有固件,烧录新固件\"></a>清除原有固件,烧录新固件</h4><ul>\n<li>下载安装提供的相关软件: jlink, Install AT91-ISP v1.13, 以及固件。</li>\n<li>按照说明文档一步步操作,烧录固件,<strong>步骤先后顺序一定要完全一致,如果失败则重复多次</strong>。<a href=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-13-jlink%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/JLinkV8%E5%9B%BA%E4%BB%B6%E7%83%A7%E5%BD%95%E6%8C%87%E5%AF%BC.pdf\" title=\"JLinkV8固件烧录指导\">JLinkV8固件烧录指导</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 升级方法:</div><div class=\"line\">- 使用XP的环境, win7 大多都不行。</div><div class=\"line\">- 打开 jLink command 软件,注意不要升级固件。</div><div class=\"line\">- 在命令行下输入: Exec SetSN=XXXXXXXX  回车。**注：XXXXXXXX 为你自己想要的 SN,SN 必须是8个数字。**</div><div class=\"line\">- 关闭 jLink command 软件再从新打开。即可生效。</div><div class=\"line\">*注意:只能设置一次 SN,设置前请想好你的SN。*</div><div class=\"line\"></div><div class=\"line\">然后就可以正常升级了。</div></pre></td></tr></table></figure>\n<h3 id=\"出现问题\"><a href=\"#出现问题\" class=\"headerlink\" title=\"出现问题\"></a>出现问题</h3><h4 id=\"MDK-用-JTAG-仿真器下载代码时，提示-cannot-load-flash-device-description！\"><a href=\"#MDK-用-JTAG-仿真器下载代码时，提示-cannot-load-flash-device-description！\" class=\"headerlink\" title=\"MDK 用 JTAG 仿真器下载代码时，提示 cannot load flash device description！\"></a>MDK 用 JTAG 仿真器下载代码时，提示 cannot load flash device description！</h4><ul>\n<li>如果 jlink 链接没有问题,且能够找到芯片的话,一般为 flash programming algorithm 丢失。<br><a href=\"http://www.openedv.com/posts/list/50048.htm\">参考网址 </a></li>\n</ul>\n<blockquote>\n<p>参考链接:<br><a href=\"http://zhidao.baidu.com/link?url=jM6YRhn1aPQe7uPfdmIDP9-_k4Hl8XTWvAnBMJV0TE176gUBb5kGXK_XksirP6xdXkUkMofUD5YIhrNbYTxiBBQpSKZ_4QJWjj64vJT7xXu\">http://zhidao.baidu.com/link?url=jM6YRhn1aPQe7uPfdmIDP9-_k4Hl8XTWvAnBMJV0TE176gUBb5kGXK_XksirP6xdXkUkMofUD5YIhrNbYTxiBBQpSKZ_4QJWjj64vJT7xXu</a><br><a href=\"http://www.openedv.com/posts/list/50048.htm\">http://www.openedv.com/posts/list/50048.htm</a></p>\n</blockquote>\n<hr>\n<p>TO be continued…</p>"},{"layout":"post","title":"linux下vpn配置","date":"2016-07-12T00:26:00.000Z","_content":"\n由于众所周知的原因，国内用户无法访问外网，或者即便可以访问，也会遇到访问速度慢，网页无法刷新等问题。因此如果你要访问谷歌，Facebook等网站，就需要学会科学上网，本文主要使用 VPN 的方式来绕过 GFW 的过滤，让小伙伴们能够轻松畅游天地，无拘无束。\n\n### 推荐 VPN\n\n这边首推国内最出名的 [Green VPN](http://gjsq.me/web)，域名经常会被查封，以上给出的这个网址一般会自动跳转，大多数情况不会变化。Green VPN 的费用一般在 ￥150/year 左右，可以两个客户端同时使用，特点是使用起来方便，速度稳定，一般带宽在 4M 以上，但不能长期链接，每天可能会断线一次。Green VPN 算是一家老牌的 VPN 了，价格虽然不算最便宜，但稳定性服务等都比较有保证，市面上面冒充 Green VPN 诈骗的也比较多，购买时需要当心注意。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/1.png)\n\n<!-- more -->\n\n\n### linux 下的 VPN 配置\n\nGreen VPN 上面的参考文档很多，其实已经给出了详细步骤，一般采用[Ubuntu 设置方法 (PPTP)配置](https://www.getgreenjsq.co/shiyong/67.html)，该步骤也适用于其他地方购买的 VPN，下面列出详细设置：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/2.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/3.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/4.png)\n\n网关填写服务器地址，该地址是 VPN 网站提供给你的连接地址，用户名密码填写在 VPN 网站注册的信息，验证通过即可登录，但有时连接未必稳定，需要尝试多次才可以连接成功。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/5.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/6.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/7.png)\n\n### VPN 和 ssh 兼容\n\nVPN 的所用的协议和 SSH 协议是互不兼容的，也就是说，如果你登陆了 VPN ，这时使用 SSH 命令想完成一些操作的话，会出现不响应的状况。如果遇到这种问题可以参考本博客的**linux下ssh通过VPN推送失败**文章。\n\n### VPN 的开机自启动\n\n***\n\nTo be continued...\n\n> 参考链接：\n> https://www.getgreenjsq.co/shiyong/67.html\n","source":"_posts/2016/2016-07-12-linux下vpn配置.md","raw":"---\nlayout: \"post\"\ntitle: \"linux下vpn配置\"\ndate: \"2016-07-12 08:26\"\n---\n\n由于众所周知的原因，国内用户无法访问外网，或者即便可以访问，也会遇到访问速度慢，网页无法刷新等问题。因此如果你要访问谷歌，Facebook等网站，就需要学会科学上网，本文主要使用 VPN 的方式来绕过 GFW 的过滤，让小伙伴们能够轻松畅游天地，无拘无束。\n\n### 推荐 VPN\n\n这边首推国内最出名的 [Green VPN](http://gjsq.me/web)，域名经常会被查封，以上给出的这个网址一般会自动跳转，大多数情况不会变化。Green VPN 的费用一般在 ￥150/year 左右，可以两个客户端同时使用，特点是使用起来方便，速度稳定，一般带宽在 4M 以上，但不能长期链接，每天可能会断线一次。Green VPN 算是一家老牌的 VPN 了，价格虽然不算最便宜，但稳定性服务等都比较有保证，市面上面冒充 Green VPN 诈骗的也比较多，购买时需要当心注意。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/1.png)\n\n<!-- more -->\n\n\n### linux 下的 VPN 配置\n\nGreen VPN 上面的参考文档很多，其实已经给出了详细步骤，一般采用[Ubuntu 设置方法 (PPTP)配置](https://www.getgreenjsq.co/shiyong/67.html)，该步骤也适用于其他地方购买的 VPN，下面列出详细设置：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/2.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/3.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/4.png)\n\n网关填写服务器地址，该地址是 VPN 网站提供给你的连接地址，用户名密码填写在 VPN 网站注册的信息，验证通过即可登录，但有时连接未必稳定，需要尝试多次才可以连接成功。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/5.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/6.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/7.png)\n\n### VPN 和 ssh 兼容\n\nVPN 的所用的协议和 SSH 协议是互不兼容的，也就是说，如果你登陆了 VPN ，这时使用 SSH 命令想完成一些操作的话，会出现不响应的状况。如果遇到这种问题可以参考本博客的**linux下ssh通过VPN推送失败**文章。\n\n### VPN 的开机自启动\n\n***\n\nTo be continued...\n\n> 参考链接：\n> https://www.getgreenjsq.co/shiyong/67.html\n","slug":"2016/2016-07-12-linux下vpn配置","published":1,"updated":"2017-01-12T05:40:33.436Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ah3001omumusjdvz6nt","content":"<p>由于众所周知的原因，国内用户无法访问外网，或者即便可以访问，也会遇到访问速度慢，网页无法刷新等问题。因此如果你要访问谷歌，Facebook等网站，就需要学会科学上网，本文主要使用 VPN 的方式来绕过 GFW 的过滤，让小伙伴们能够轻松畅游天地，无拘无束。</p>\n<h3 id=\"推荐-VPN\"><a href=\"#推荐-VPN\" class=\"headerlink\" title=\"推荐 VPN\"></a>推荐 VPN</h3><p>这边首推国内最出名的 <a href=\"http://gjsq.me/web\" target=\"_blank\" rel=\"external\">Green VPN</a>，域名经常会被查封，以上给出的这个网址一般会自动跳转，大多数情况不会变化。Green VPN 的费用一般在 ￥150/year 左右，可以两个客户端同时使用，特点是使用起来方便，速度稳定，一般带宽在 4M 以上，但不能长期链接，每天可能会断线一次。Green VPN 算是一家老牌的 VPN 了，价格虽然不算最便宜，但稳定性服务等都比较有保证，市面上面冒充 Green VPN 诈骗的也比较多，购买时需要当心注意。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/1.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"linux-下的-VPN-配置\"><a href=\"#linux-下的-VPN-配置\" class=\"headerlink\" title=\"linux 下的 VPN 配置\"></a>linux 下的 VPN 配置</h3><p>Green VPN 上面的参考文档很多，其实已经给出了详细步骤，一般采用<a href=\"https://www.getgreenjsq.co/shiyong/67.html\" target=\"_blank\" rel=\"external\">Ubuntu 设置方法 (PPTP)配置</a>，该步骤也适用于其他地方购买的 VPN，下面列出详细设置：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/2.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/3.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/4.png\" alt=\"\"></p>\n<p>网关填写服务器地址，该地址是 VPN 网站提供给你的连接地址，用户名密码填写在 VPN 网站注册的信息，验证通过即可登录，但有时连接未必稳定，需要尝试多次才可以连接成功。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/5.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/6.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/7.png\" alt=\"\"></p>\n<h3 id=\"VPN-和-ssh-兼容\"><a href=\"#VPN-和-ssh-兼容\" class=\"headerlink\" title=\"VPN 和 ssh 兼容\"></a>VPN 和 ssh 兼容</h3><p>VPN 的所用的协议和 SSH 协议是互不兼容的，也就是说，如果你登陆了 VPN ，这时使用 SSH 命令想完成一些操作的话，会出现不响应的状况。如果遇到这种问题可以参考本博客的<strong>linux下ssh通过VPN推送失败</strong>文章。</p>\n<h3 id=\"VPN-的开机自启动\"><a href=\"#VPN-的开机自启动\" class=\"headerlink\" title=\"VPN 的开机自启动\"></a>VPN 的开机自启动</h3><hr>\n<p>To be continued…</p>\n<blockquote>\n<p>参考链接：<br><a href=\"https://www.getgreenjsq.co/shiyong/67.html\" target=\"_blank\" rel=\"external\">https://www.getgreenjsq.co/shiyong/67.html</a></p>\n</blockquote>\n","excerpt":"<p>由于众所周知的原因，国内用户无法访问外网，或者即便可以访问，也会遇到访问速度慢，网页无法刷新等问题。因此如果你要访问谷歌，Facebook等网站，就需要学会科学上网，本文主要使用 VPN 的方式来绕过 GFW 的过滤，让小伙伴们能够轻松畅游天地，无拘无束。</p>\n<h3 id=\"推荐-VPN\"><a href=\"#推荐-VPN\" class=\"headerlink\" title=\"推荐 VPN\"></a>推荐 VPN</h3><p>这边首推国内最出名的 <a href=\"http://gjsq.me/web\">Green VPN</a>，域名经常会被查封，以上给出的这个网址一般会自动跳转，大多数情况不会变化。Green VPN 的费用一般在 ￥150/year 左右，可以两个客户端同时使用，特点是使用起来方便，速度稳定，一般带宽在 4M 以上，但不能长期链接，每天可能会断线一次。Green VPN 算是一家老牌的 VPN 了，价格虽然不算最便宜，但稳定性服务等都比较有保证，市面上面冒充 Green VPN 诈骗的也比较多，购买时需要当心注意。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/1.png\" alt=\"\"></p>","more":"<h3 id=\"linux-下的-VPN-配置\"><a href=\"#linux-下的-VPN-配置\" class=\"headerlink\" title=\"linux 下的 VPN 配置\"></a>linux 下的 VPN 配置</h3><p>Green VPN 上面的参考文档很多，其实已经给出了详细步骤，一般采用<a href=\"https://www.getgreenjsq.co/shiyong/67.html\">Ubuntu 设置方法 (PPTP)配置</a>，该步骤也适用于其他地方购买的 VPN，下面列出详细设置：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/2.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/3.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/4.png\" alt=\"\"></p>\n<p>网关填写服务器地址，该地址是 VPN 网站提供给你的连接地址，用户名密码填写在 VPN 网站注册的信息，验证通过即可登录，但有时连接未必稳定，需要尝试多次才可以连接成功。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/5.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/6.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/7.png\" alt=\"\"></p>\n<h3 id=\"VPN-和-ssh-兼容\"><a href=\"#VPN-和-ssh-兼容\" class=\"headerlink\" title=\"VPN 和 ssh 兼容\"></a>VPN 和 ssh 兼容</h3><p>VPN 的所用的协议和 SSH 协议是互不兼容的，也就是说，如果你登陆了 VPN ，这时使用 SSH 命令想完成一些操作的话，会出现不响应的状况。如果遇到这种问题可以参考本博客的<strong>linux下ssh通过VPN推送失败</strong>文章。</p>\n<h3 id=\"VPN-的开机自启动\"><a href=\"#VPN-的开机自启动\" class=\"headerlink\" title=\"VPN 的开机自启动\"></a>VPN 的开机自启动</h3><hr>\n<p>To be continued…</p>\n<blockquote>\n<p>参考链接：<br><a href=\"https://www.getgreenjsq.co/shiyong/67.html\">https://www.getgreenjsq.co/shiyong/67.html</a></p>\n</blockquote>"},{"layout":"post","title":"Caps_Lock与右Ctrl互换","date":"2016-07-14T00:59:00.000Z","_content":"\n*实现该功能的目的主要是切换中英文输入法，在使用 ctrl 或者 shift 切换时，很明显这两个键的位置远不如caps按起来方便，且 shift 往往作为大小写功能使用，用来作为切换中英文输入会恨混乱，而 caps 作为大小写时用起来相当罕见，作为中文输入来说更可以说完全是鸡肋的功能。大写完全可以用 shift 代替的用户群中，无疑是占用了一个最好的位置，却几乎完全被遗忘的一个按键。下面将会总结一个既保留 Caps_Lock 键功能，又可以充分利用这个最好位置的按键映射方法。*\n\n### linux系统下的实现\n\n#### 按键值查询\n\nlinux 下可以通过命令小程序对绝大多数按键值进行查找，要想修改键值映射, 先要知道按键的键值. 用如下命令查看: `xev | grep keycode`。\n\n同时我们可以查看需要映射的按键的映射名称：\n\n```\n例如, 执行命令查看 Menu 键相关的按键名:\n\nxmodmap -pke | grep menu -i\n显示结果为:\n\nkeycode 135 = Menu NoSymbol Menu\nkeycode 147 = XF86MenuKB NoSymbol XF86MenuKB\n\n```\n\n比如想把键盘的右边的 Alt 改为 Menu : `xmodmap -e \"keycode 108=Menu\"`，简而言之 xmodmap 程序就是用来控制系统按键的，需要详细了解这个软件的操作，可以查看帮助文档。\n\n<!-- more -->\n\n\n#### 将Caps_Lock和键盘右边的Ctrl调换\n在当前的用户根目录下～创建 .Xmodmap 文件(尤其注意:这边名称是Xmodmap首字母大写,很多教程都忽略了这个问题,往往导致配置出来有问题)，书写内容如下：\n\n```\nremove Lock = Caps_Lock\nremove Control = Control_R\nkeysym Control_R = Caps_Lock\nkeysym Caps_Lock = Control_R\nadd Lock = Caps_Lock\nadd Control = Control_R\n```\n\n这样，caps lock 和 ctrl 就都是 ctrl 的功能。执行下`xmodmap ~/.Xmodmap  2>/dev/null`即可立即生效。实际上，每次开机启动后，系统会通过 xmodmap 程序自动加载 .Xmodmap 程序，也就是一次创建更改 .Xmodmap 文件，终身配置有效。\n\n**注意:完成上述步骤即可，以下步骤为最初设置时,出现的问题,可以忽略不看。**\n\n#### 加入开机自启\n同大多数开机自启并没有太大区别，将`xmodmap ~/.xmodmap  2>/dev/null`写入到 /etc/rc.local 中即可。该方法经常失效，不是太灵验，因此我设置了快捷键 ctrl+space ，每次按下这个快捷键时，会自动执行`xmodmap ~/.xmodmap  2>/dev/null`。\n\n解决:由于上面命名错误, .Xmodmap 文件的首字母是大写，因此加载总是出错，另外使用 `xmodmap ~/.Xmodmap  2>/dev/null` 命令后，每次无需再加入启动项了，一次配置成功即可。\n\n\n### windows下的更换按键\n\n打开注册表，在运行（win+R）中输入 regedit ，注册表位置：[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Keyboard Layout]  （注意： KeyBoard Layout, 而不是 KeyBoard Layouts）如果没有此键，就新建一个二进制值的 Key，名叫： Scancode Map（注意名称不能够写错，错一个字母都没法实现功能）。\n\n```\n输入如下的值：\n　　00,00,00,00\n　　00,00,00,00\n　　03,00,00,00\n　　3A,00,1D,E0\n　　1D,E0,3A,00\n　　00,00,00,00\n```\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-14-Caps_Lock%E4%B8%8E%E5%8F%B3Ctrl%E4%BA%92%E6%8D%A2/BaiduShurufa_2016-8-10_14-5-24.png)\n\n#### windows 各个键位值的参考：\n\n```\n　　Escape 01 00\n　　Tab 0F 00\n　　Caps Lock 3A 00\n　　Left Alt 38 00\n　　Left Ctrl 1D 00\n　　Left Shift 2A 00\n　　Left Windows 5B E0\n　　Right Alt 38 E0\n　　Right Ctrl 1D E0\n　　Right Shift 36 00\n　　Right Windows 5C E0\n　　Backspace 0E 00\n　　Delete 53 E0\n　　Enter 1C 00\n　　Space 39 00\n　　Insert 52 E0\n　　HOME 47 E0\n　　End 4F E0\n　　Num Lock 45 00\n　　Page Down 51 E0\n　　Page Up 49 E0\n　　Scroll Lock 46 00\n```\n\n以上 windows 的按键更改仅在 windows 7 下实验过，其他系统有待验证。\n\n\n\n> 参考链接：\n> http://www.cnblogs.com/xiaobaibuhei/p/3629133.html\n> http://hanjc.me/post/2015-09-14-win7-exchange-capslock-and-ctrl/\n> http://www.mikewootc.com/wiki/linux/usage/linux_xmodmap_change_keyboard_map.html\n> http://baohaojun.github.io/blog/2015/01/12/0-How-to-swap-Escape-and-Caps-Lock-on-mainstream-PCs.html\n> http://www.xiaozhou.net/exchange_ctrl_and_capslock_key-2012-07-20.html\n> http://xahlee.info/kbd/linux_make_capslock_esc_key.html\n","source":"_posts/2016/2016-07-14-Caps_Lock与右Ctrl互换.md","raw":"---\nlayout: \"post\"\ntitle: \"Caps_Lock与右Ctrl互换\"\ndate: \"2016-07-14 08:59\"\n---\n\n*实现该功能的目的主要是切换中英文输入法，在使用 ctrl 或者 shift 切换时，很明显这两个键的位置远不如caps按起来方便，且 shift 往往作为大小写功能使用，用来作为切换中英文输入会恨混乱，而 caps 作为大小写时用起来相当罕见，作为中文输入来说更可以说完全是鸡肋的功能。大写完全可以用 shift 代替的用户群中，无疑是占用了一个最好的位置，却几乎完全被遗忘的一个按键。下面将会总结一个既保留 Caps_Lock 键功能，又可以充分利用这个最好位置的按键映射方法。*\n\n### linux系统下的实现\n\n#### 按键值查询\n\nlinux 下可以通过命令小程序对绝大多数按键值进行查找，要想修改键值映射, 先要知道按键的键值. 用如下命令查看: `xev | grep keycode`。\n\n同时我们可以查看需要映射的按键的映射名称：\n\n```\n例如, 执行命令查看 Menu 键相关的按键名:\n\nxmodmap -pke | grep menu -i\n显示结果为:\n\nkeycode 135 = Menu NoSymbol Menu\nkeycode 147 = XF86MenuKB NoSymbol XF86MenuKB\n\n```\n\n比如想把键盘的右边的 Alt 改为 Menu : `xmodmap -e \"keycode 108=Menu\"`，简而言之 xmodmap 程序就是用来控制系统按键的，需要详细了解这个软件的操作，可以查看帮助文档。\n\n<!-- more -->\n\n\n#### 将Caps_Lock和键盘右边的Ctrl调换\n在当前的用户根目录下～创建 .Xmodmap 文件(尤其注意:这边名称是Xmodmap首字母大写,很多教程都忽略了这个问题,往往导致配置出来有问题)，书写内容如下：\n\n```\nremove Lock = Caps_Lock\nremove Control = Control_R\nkeysym Control_R = Caps_Lock\nkeysym Caps_Lock = Control_R\nadd Lock = Caps_Lock\nadd Control = Control_R\n```\n\n这样，caps lock 和 ctrl 就都是 ctrl 的功能。执行下`xmodmap ~/.Xmodmap  2>/dev/null`即可立即生效。实际上，每次开机启动后，系统会通过 xmodmap 程序自动加载 .Xmodmap 程序，也就是一次创建更改 .Xmodmap 文件，终身配置有效。\n\n**注意:完成上述步骤即可，以下步骤为最初设置时,出现的问题,可以忽略不看。**\n\n#### 加入开机自启\n同大多数开机自启并没有太大区别，将`xmodmap ~/.xmodmap  2>/dev/null`写入到 /etc/rc.local 中即可。该方法经常失效，不是太灵验，因此我设置了快捷键 ctrl+space ，每次按下这个快捷键时，会自动执行`xmodmap ~/.xmodmap  2>/dev/null`。\n\n解决:由于上面命名错误, .Xmodmap 文件的首字母是大写，因此加载总是出错，另外使用 `xmodmap ~/.Xmodmap  2>/dev/null` 命令后，每次无需再加入启动项了，一次配置成功即可。\n\n\n### windows下的更换按键\n\n打开注册表，在运行（win+R）中输入 regedit ，注册表位置：[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Keyboard Layout]  （注意： KeyBoard Layout, 而不是 KeyBoard Layouts）如果没有此键，就新建一个二进制值的 Key，名叫： Scancode Map（注意名称不能够写错，错一个字母都没法实现功能）。\n\n```\n输入如下的值：\n　　00,00,00,00\n　　00,00,00,00\n　　03,00,00,00\n　　3A,00,1D,E0\n　　1D,E0,3A,00\n　　00,00,00,00\n```\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-14-Caps_Lock%E4%B8%8E%E5%8F%B3Ctrl%E4%BA%92%E6%8D%A2/BaiduShurufa_2016-8-10_14-5-24.png)\n\n#### windows 各个键位值的参考：\n\n```\n　　Escape 01 00\n　　Tab 0F 00\n　　Caps Lock 3A 00\n　　Left Alt 38 00\n　　Left Ctrl 1D 00\n　　Left Shift 2A 00\n　　Left Windows 5B E0\n　　Right Alt 38 E0\n　　Right Ctrl 1D E0\n　　Right Shift 36 00\n　　Right Windows 5C E0\n　　Backspace 0E 00\n　　Delete 53 E0\n　　Enter 1C 00\n　　Space 39 00\n　　Insert 52 E0\n　　HOME 47 E0\n　　End 4F E0\n　　Num Lock 45 00\n　　Page Down 51 E0\n　　Page Up 49 E0\n　　Scroll Lock 46 00\n```\n\n以上 windows 的按键更改仅在 windows 7 下实验过，其他系统有待验证。\n\n\n\n> 参考链接：\n> http://www.cnblogs.com/xiaobaibuhei/p/3629133.html\n> http://hanjc.me/post/2015-09-14-win7-exchange-capslock-and-ctrl/\n> http://www.mikewootc.com/wiki/linux/usage/linux_xmodmap_change_keyboard_map.html\n> http://baohaojun.github.io/blog/2015/01/12/0-How-to-swap-Escape-and-Caps-Lock-on-mainstream-PCs.html\n> http://www.xiaozhou.net/exchange_ctrl_and_capslock_key-2012-07-20.html\n> http://xahlee.info/kbd/linux_make_capslock_esc_key.html\n","slug":"2016/2016-07-14-Caps_Lock与右Ctrl互换","published":1,"updated":"2017-01-12T05:37:37.686Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ah5001rmumuqrhw7y3u","content":"<p><em>实现该功能的目的主要是切换中英文输入法，在使用 ctrl 或者 shift 切换时，很明显这两个键的位置远不如caps按起来方便，且 shift 往往作为大小写功能使用，用来作为切换中英文输入会恨混乱，而 caps 作为大小写时用起来相当罕见，作为中文输入来说更可以说完全是鸡肋的功能。大写完全可以用 shift 代替的用户群中，无疑是占用了一个最好的位置，却几乎完全被遗忘的一个按键。下面将会总结一个既保留 Caps_Lock 键功能，又可以充分利用这个最好位置的按键映射方法。</em></p>\n<h3 id=\"linux系统下的实现\"><a href=\"#linux系统下的实现\" class=\"headerlink\" title=\"linux系统下的实现\"></a>linux系统下的实现</h3><h4 id=\"按键值查询\"><a href=\"#按键值查询\" class=\"headerlink\" title=\"按键值查询\"></a>按键值查询</h4><p>linux 下可以通过命令小程序对绝大多数按键值进行查找，要想修改键值映射, 先要知道按键的键值. 用如下命令查看: <code>xev | grep keycode</code>。</p>\n<p>同时我们可以查看需要映射的按键的映射名称：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">例如, 执行命令查看 Menu 键相关的按键名:</div><div class=\"line\"></div><div class=\"line\">xmodmap -pke | grep menu -i</div><div class=\"line\">显示结果为:</div><div class=\"line\"></div><div class=\"line\">keycode 135 = Menu NoSymbol Menu</div><div class=\"line\">keycode 147 = XF86MenuKB NoSymbol XF86MenuKB</div></pre></td></tr></table></figure>\n<p>比如想把键盘的右边的 Alt 改为 Menu : <code>xmodmap -e &quot;keycode 108=Menu&quot;</code>，简而言之 xmodmap 程序就是用来控制系统按键的，需要详细了解这个软件的操作，可以查看帮助文档。</p>\n<a id=\"more\"></a>\n<h4 id=\"将Caps-Lock和键盘右边的Ctrl调换\"><a href=\"#将Caps-Lock和键盘右边的Ctrl调换\" class=\"headerlink\" title=\"将Caps_Lock和键盘右边的Ctrl调换\"></a>将Caps_Lock和键盘右边的Ctrl调换</h4><p>在当前的用户根目录下～创建 .Xmodmap 文件(尤其注意:这边名称是Xmodmap首字母大写,很多教程都忽略了这个问题,往往导致配置出来有问题)，书写内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">remove Lock = Caps_Lock</div><div class=\"line\">remove Control = Control_R</div><div class=\"line\">keysym Control_R = Caps_Lock</div><div class=\"line\">keysym Caps_Lock = Control_R</div><div class=\"line\">add Lock = Caps_Lock</div><div class=\"line\">add Control = Control_R</div></pre></td></tr></table></figure>\n<p>这样，caps lock 和 ctrl 就都是 ctrl 的功能。执行下<code>xmodmap ~/.Xmodmap  2&gt;/dev/null</code>即可立即生效。实际上，每次开机启动后，系统会通过 xmodmap 程序自动加载 .Xmodmap 程序，也就是一次创建更改 .Xmodmap 文件，终身配置有效。</p>\n<p><strong>注意:完成上述步骤即可，以下步骤为最初设置时,出现的问题,可以忽略不看。</strong></p>\n<h4 id=\"加入开机自启\"><a href=\"#加入开机自启\" class=\"headerlink\" title=\"加入开机自启\"></a>加入开机自启</h4><p>同大多数开机自启并没有太大区别，将<code>xmodmap ~/.xmodmap  2&gt;/dev/null</code>写入到 /etc/rc.local 中即可。该方法经常失效，不是太灵验，因此我设置了快捷键 ctrl+space ，每次按下这个快捷键时，会自动执行<code>xmodmap ~/.xmodmap  2&gt;/dev/null</code>。</p>\n<p>解决:由于上面命名错误, .Xmodmap 文件的首字母是大写，因此加载总是出错，另外使用 <code>xmodmap ~/.Xmodmap  2&gt;/dev/null</code> 命令后，每次无需再加入启动项了，一次配置成功即可。</p>\n<h3 id=\"windows下的更换按键\"><a href=\"#windows下的更换按键\" class=\"headerlink\" title=\"windows下的更换按键\"></a>windows下的更换按键</h3><p>打开注册表，在运行（win+R）中输入 regedit ，注册表位置：[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Keyboard Layout]  （注意： KeyBoard Layout, 而不是 KeyBoard Layouts）如果没有此键，就新建一个二进制值的 Key，名叫： Scancode Map（注意名称不能够写错，错一个字母都没法实现功能）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">输入如下的值：</div><div class=\"line\">　　00,00,00,00</div><div class=\"line\">　　00,00,00,00</div><div class=\"line\">　　03,00,00,00</div><div class=\"line\">　　3A,00,1D,E0</div><div class=\"line\">　　1D,E0,3A,00</div><div class=\"line\">　　00,00,00,00</div></pre></td></tr></table></figure>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-14-Caps_Lock%E4%B8%8E%E5%8F%B3Ctrl%E4%BA%92%E6%8D%A2/BaiduShurufa_2016-8-10_14-5-24.png\" alt=\"\"></p>\n<h4 id=\"windows-各个键位值的参考：\"><a href=\"#windows-各个键位值的参考：\" class=\"headerlink\" title=\"windows 各个键位值的参考：\"></a>windows 各个键位值的参考：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　Escape 01 00</div><div class=\"line\">　　Tab 0F 00</div><div class=\"line\">　　Caps Lock 3A 00</div><div class=\"line\">　　Left Alt 38 00</div><div class=\"line\">　　Left Ctrl 1D 00</div><div class=\"line\">　　Left Shift 2A 00</div><div class=\"line\">　　Left Windows 5B E0</div><div class=\"line\">　　Right Alt 38 E0</div><div class=\"line\">　　Right Ctrl 1D E0</div><div class=\"line\">　　Right Shift 36 00</div><div class=\"line\">　　Right Windows 5C E0</div><div class=\"line\">　　Backspace 0E 00</div><div class=\"line\">　　Delete 53 E0</div><div class=\"line\">　　Enter 1C 00</div><div class=\"line\">　　Space 39 00</div><div class=\"line\">　　Insert 52 E0</div><div class=\"line\">　　HOME 47 E0</div><div class=\"line\">　　End 4F E0</div><div class=\"line\">　　Num Lock 45 00</div><div class=\"line\">　　Page Down 51 E0</div><div class=\"line\">　　Page Up 49 E0</div><div class=\"line\">　　Scroll Lock 46 00</div></pre></td></tr></table></figure>\n<p>以上 windows 的按键更改仅在 windows 7 下实验过，其他系统有待验证。</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.cnblogs.com/xiaobaibuhei/p/3629133.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/xiaobaibuhei/p/3629133.html</a><br><a href=\"http://hanjc.me/post/2015-09-14-win7-exchange-capslock-and-ctrl/\" target=\"_blank\" rel=\"external\">http://hanjc.me/post/2015-09-14-win7-exchange-capslock-and-ctrl/</a><br><a href=\"http://www.mikewootc.com/wiki/linux/usage/linux_xmodmap_change_keyboard_map.html\" target=\"_blank\" rel=\"external\">http://www.mikewootc.com/wiki/linux/usage/linux_xmodmap_change_keyboard_map.html</a><br><a href=\"http://baohaojun.github.io/blog/2015/01/12/0-How-to-swap-Escape-and-Caps-Lock-on-mainstream-PCs.html\" target=\"_blank\" rel=\"external\">http://baohaojun.github.io/blog/2015/01/12/0-How-to-swap-Escape-and-Caps-Lock-on-mainstream-PCs.html</a><br><a href=\"http://www.xiaozhou.net/exchange_ctrl_and_capslock_key-2012-07-20.html\" target=\"_blank\" rel=\"external\">http://www.xiaozhou.net/exchange_ctrl_and_capslock_key-2012-07-20.html</a><br><a href=\"http://xahlee.info/kbd/linux_make_capslock_esc_key.html\" target=\"_blank\" rel=\"external\">http://xahlee.info/kbd/linux_make_capslock_esc_key.html</a></p>\n</blockquote>\n","excerpt":"<p><em>实现该功能的目的主要是切换中英文输入法，在使用 ctrl 或者 shift 切换时，很明显这两个键的位置远不如caps按起来方便，且 shift 往往作为大小写功能使用，用来作为切换中英文输入会恨混乱，而 caps 作为大小写时用起来相当罕见，作为中文输入来说更可以说完全是鸡肋的功能。大写完全可以用 shift 代替的用户群中，无疑是占用了一个最好的位置，却几乎完全被遗忘的一个按键。下面将会总结一个既保留 Caps_Lock 键功能，又可以充分利用这个最好位置的按键映射方法。</em></p>\n<h3 id=\"linux系统下的实现\"><a href=\"#linux系统下的实现\" class=\"headerlink\" title=\"linux系统下的实现\"></a>linux系统下的实现</h3><h4 id=\"按键值查询\"><a href=\"#按键值查询\" class=\"headerlink\" title=\"按键值查询\"></a>按键值查询</h4><p>linux 下可以通过命令小程序对绝大多数按键值进行查找，要想修改键值映射, 先要知道按键的键值. 用如下命令查看: <code>xev | grep keycode</code>。</p>\n<p>同时我们可以查看需要映射的按键的映射名称：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">例如, 执行命令查看 Menu 键相关的按键名:</div><div class=\"line\"></div><div class=\"line\">xmodmap -pke | grep menu -i</div><div class=\"line\">显示结果为:</div><div class=\"line\"></div><div class=\"line\">keycode 135 = Menu NoSymbol Menu</div><div class=\"line\">keycode 147 = XF86MenuKB NoSymbol XF86MenuKB</div></pre></td></tr></table></figure>\n<p>比如想把键盘的右边的 Alt 改为 Menu : <code>xmodmap -e &quot;keycode 108=Menu&quot;</code>，简而言之 xmodmap 程序就是用来控制系统按键的，需要详细了解这个软件的操作，可以查看帮助文档。</p>","more":"<h4 id=\"将Caps-Lock和键盘右边的Ctrl调换\"><a href=\"#将Caps-Lock和键盘右边的Ctrl调换\" class=\"headerlink\" title=\"将Caps_Lock和键盘右边的Ctrl调换\"></a>将Caps_Lock和键盘右边的Ctrl调换</h4><p>在当前的用户根目录下～创建 .Xmodmap 文件(尤其注意:这边名称是Xmodmap首字母大写,很多教程都忽略了这个问题,往往导致配置出来有问题)，书写内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">remove Lock = Caps_Lock</div><div class=\"line\">remove Control = Control_R</div><div class=\"line\">keysym Control_R = Caps_Lock</div><div class=\"line\">keysym Caps_Lock = Control_R</div><div class=\"line\">add Lock = Caps_Lock</div><div class=\"line\">add Control = Control_R</div></pre></td></tr></table></figure>\n<p>这样，caps lock 和 ctrl 就都是 ctrl 的功能。执行下<code>xmodmap ~/.Xmodmap  2&gt;/dev/null</code>即可立即生效。实际上，每次开机启动后，系统会通过 xmodmap 程序自动加载 .Xmodmap 程序，也就是一次创建更改 .Xmodmap 文件，终身配置有效。</p>\n<p><strong>注意:完成上述步骤即可，以下步骤为最初设置时,出现的问题,可以忽略不看。</strong></p>\n<h4 id=\"加入开机自启\"><a href=\"#加入开机自启\" class=\"headerlink\" title=\"加入开机自启\"></a>加入开机自启</h4><p>同大多数开机自启并没有太大区别，将<code>xmodmap ~/.xmodmap  2&gt;/dev/null</code>写入到 /etc/rc.local 中即可。该方法经常失效，不是太灵验，因此我设置了快捷键 ctrl+space ，每次按下这个快捷键时，会自动执行<code>xmodmap ~/.xmodmap  2&gt;/dev/null</code>。</p>\n<p>解决:由于上面命名错误, .Xmodmap 文件的首字母是大写，因此加载总是出错，另外使用 <code>xmodmap ~/.Xmodmap  2&gt;/dev/null</code> 命令后，每次无需再加入启动项了，一次配置成功即可。</p>\n<h3 id=\"windows下的更换按键\"><a href=\"#windows下的更换按键\" class=\"headerlink\" title=\"windows下的更换按键\"></a>windows下的更换按键</h3><p>打开注册表，在运行（win+R）中输入 regedit ，注册表位置：[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Keyboard Layout]  （注意： KeyBoard Layout, 而不是 KeyBoard Layouts）如果没有此键，就新建一个二进制值的 Key，名叫： Scancode Map（注意名称不能够写错，错一个字母都没法实现功能）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">输入如下的值：</div><div class=\"line\">　　00,00,00,00</div><div class=\"line\">　　00,00,00,00</div><div class=\"line\">　　03,00,00,00</div><div class=\"line\">　　3A,00,1D,E0</div><div class=\"line\">　　1D,E0,3A,00</div><div class=\"line\">　　00,00,00,00</div></pre></td></tr></table></figure>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-14-Caps_Lock%E4%B8%8E%E5%8F%B3Ctrl%E4%BA%92%E6%8D%A2/BaiduShurufa_2016-8-10_14-5-24.png\" alt=\"\"></p>\n<h4 id=\"windows-各个键位值的参考：\"><a href=\"#windows-各个键位值的参考：\" class=\"headerlink\" title=\"windows 各个键位值的参考：\"></a>windows 各个键位值的参考：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　Escape 01 00</div><div class=\"line\">　　Tab 0F 00</div><div class=\"line\">　　Caps Lock 3A 00</div><div class=\"line\">　　Left Alt 38 00</div><div class=\"line\">　　Left Ctrl 1D 00</div><div class=\"line\">　　Left Shift 2A 00</div><div class=\"line\">　　Left Windows 5B E0</div><div class=\"line\">　　Right Alt 38 E0</div><div class=\"line\">　　Right Ctrl 1D E0</div><div class=\"line\">　　Right Shift 36 00</div><div class=\"line\">　　Right Windows 5C E0</div><div class=\"line\">　　Backspace 0E 00</div><div class=\"line\">　　Delete 53 E0</div><div class=\"line\">　　Enter 1C 00</div><div class=\"line\">　　Space 39 00</div><div class=\"line\">　　Insert 52 E0</div><div class=\"line\">　　HOME 47 E0</div><div class=\"line\">　　End 4F E0</div><div class=\"line\">　　Num Lock 45 00</div><div class=\"line\">　　Page Down 51 E0</div><div class=\"line\">　　Page Up 49 E0</div><div class=\"line\">　　Scroll Lock 46 00</div></pre></td></tr></table></figure>\n<p>以上 windows 的按键更改仅在 windows 7 下实验过，其他系统有待验证。</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.cnblogs.com/xiaobaibuhei/p/3629133.html\">http://www.cnblogs.com/xiaobaibuhei/p/3629133.html</a><br><a href=\"http://hanjc.me/post/2015-09-14-win7-exchange-capslock-and-ctrl/\">http://hanjc.me/post/2015-09-14-win7-exchange-capslock-and-ctrl/</a><br><a href=\"http://www.mikewootc.com/wiki/linux/usage/linux_xmodmap_change_keyboard_map.html\">http://www.mikewootc.com/wiki/linux/usage/linux_xmodmap_change_keyboard_map.html</a><br><a href=\"http://baohaojun.github.io/blog/2015/01/12/0-How-to-swap-Escape-and-Caps-Lock-on-mainstream-PCs.html\">http://baohaojun.github.io/blog/2015/01/12/0-How-to-swap-Escape-and-Caps-Lock-on-mainstream-PCs.html</a><br><a href=\"http://www.xiaozhou.net/exchange_ctrl_and_capslock_key-2012-07-20.html\">http://www.xiaozhou.net/exchange_ctrl_and_capslock_key-2012-07-20.html</a><br><a href=\"http://xahlee.info/kbd/linux_make_capslock_esc_key.html\">http://xahlee.info/kbd/linux_make_capslock_esc_key.html</a></p>\n</blockquote>"},{"layout":"post","title":"windows7安装详解","date":"2016-07-16T08:41:00.000Z","_content":"\n*早在上学时,就安装过很多次win7,老是说,win7出了略微的比xp多占用了点资源外,确实好用。外观美观，性能也算不错。*\n\n### windows 7简介：\n\nWindows 7 是由微软公司（Microsoft）开发的操作系统，版本有：入门版（Starter）、家庭普通版（Home Basic）、家庭高级版（Home Premium）、专业版（Professional）、企业版（Enterprise）（非零售）、旗舰版（Ultimate）。Windows 7 的设计主要围绕五个重点——针对笔记本电脑的特有设计；基于应用服务的设计；用户的个性化；视听娱乐的优化；用户易用性的新引擎。 跳跃列表，系统故障快速修复等，这些新功能令Windows 7成为比较美观易用的操作系统。\n\n\n\n### 必要的软件下载：\n\n- [windows 7 64位]\n`ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/`\n- [windows 7 32位]\n`ed2k://|file|cn_windows_7_ultimate_with_sp1_x86_dvd_u_677486.iso|2653276160|7503E4B9B8738DFCB95872445C72AEFB|/`\n- [大白菜windows PE](https://pan.baidu.com/s/1o8GRTb0)\n- [驱动精灵2015网卡版](https://pan.baidu.com/s/1micuzrE)\n\n<!-- more -->\n\n\n### windows PE安装步骤：\n\n- 安装软件\n\n![1](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_10-53-18.png)\n\n- 点击上图中的*请选择*，选中你的优盘，**注意一定要是格式化的优盘，看大小和名称，千万不能选错，否则里面数据会全部丢失**。\n\n- 选中后直接点击一键制作usb启动盘，其他不需要修改，同图上即可。\n\n![2](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_10-54-24.png)\n\n- 等待5分钟左右的时间，制作完成，弹出的提示信息点击否。\n\n![3](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_11-23-6.png)\n\n- 到这边，优盘的PE制作则已经完成。\n\n\n\n\n### PC引导设置：\n\nUEFI :这边不讨论 UEFI 下的安装，如果你的电脑设置为了 UEFI，则直接在改成传统设置。\n\n**BIOS:传统设置，在主板中改成Legacy BIOS，则切换到这个模式。**\n\n#### BIOS下的设置步骤：\n- 方法1：可以在 BIOS 中设置启动顺序，将优盘 HDD 或者你的优盘名称对应的那个选项移到最上方。\n- 方法2：如果电脑开启了快速启动的选项，则可以一键选择引导的盘符，例如戴尔的一般是 F12 选项。\n\n\n\n### 系统分区操作\n\n*分区涉及到的学问很多，对于一个系统来说分区以及文件系统类型很重要。*\n\n*这边以windows系统为例，大概简单介绍下：*\n**windows 系统现在主要使用的是 ntfs 和 fat32 两种格式，fat32 在大文件传输，以及分区容量多有限制，但是兼容性较好，所以我们优盘就格式化成了 fat32 格式。而 ntfs 格式现在 PC 上面普遍选用这种格式，我们的系统也会格式化成这种格式。**\n\n\n#### 进入windowsPE系统\n\n- 安装时选择 12. 安装原版 win 系统\n- 再选择 04. 进去后使用点击安装\n- 进入 windows PE 系统\n\n#### 开始分区\n\n- 前提是确保已经进入了 windows PE 系统之后。\n- 打开桌面上的分区工具，可以使用推荐分区方式，建议所有软件都安装在 C 盘。\n- 新建分区，点击**快速分区**\n\n![新建分区](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G4111Z2E6.jpg)\n\n- 在弹出的窗口中选择“分区数目”，在高级设置中可以设置磁盘格式、大小、卷标以及主分区，修改完成后点击“确定”即可；如下图所示：（注意分区的大小，按照我上面提出的第一个是主分区至少40G，文件系统为NTFS，如果是总大小为120G的固态硬盘，可以只分两到三个区，对齐分区到此扇区的倍数选择4096。）\n\n![](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G411191b25.jpg)\n- 接着系统会弹出警告的提示窗口，我们确认无误后，单击“是”即可；如下图所示：\n\n![](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G411193B09.jpg)\n- 接下来系统会自动的进行格式化分区。\n\n![](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G4111953b7.jpg)\n\n\n```\n安装在 C 盘的原因：如果重装系统的话，很多软件虽然仍然能用，但未必用起来稳定，加上软件默认的安装位置也是 C 盘，下次如果升级不注意可能会装重复，较少一部分软件是只能安装在C盘使用的，现在硬盘容量大，和系统装在一起不会有影响，另外重装系统的时候格 C 盘可以一次性清理干净,总而言之，个人认为装在C盘较好。（32 位 win7 的 C 盘分区在 40G 左右，64 位 win7 的 C 盘分区为 50-60G）。\n\n一般分区最多为 4 个分区，但后续的分区表中仍然能够存储其他分区，所以并不仅仅限于 4 个。windows 下的分区多半是一个主分区，和一个扩展分区，注意主分区就是 C 盘，用来安装操作系统的，扩展分区就是所有其他盘的总和，扩展分区是不可以直接使用的，因此分完扩展分区后，需要进一步将扩展分区分成多个逻辑分区，值得注意的是主分区可以有最多四个，但扩展分区有且只能有一个。\n\n格式化的时候扇区大小选择 4096，根据某些测评机构的数据，现在操作系统尤其是 windows 以及固态硬盘的情况下 4K 对齐能够有效的提升硬盘的各种性能。4K 对齐意味这大文件占用更少的扇区个数，数据在检索读取时往往会更快，但这无疑也是一种牺牲空间来换取时间的结果。\n```\n\n### 正式安装windows 7系统\n\n*在 windowsPE 的环境下，且确定以上操作都没有错误的话，这一步反而是最简单的一步*\n\n- 将下载好了的 windows 镜像文件复制到你刚刚分区完的电脑中，**一定要复制过去，不能通过优盘加载读取，另外复制在除了 C 盘以外的任意盘上面。**\n- 安装方法1：复制完成后，直接双击这个文件，windows PE 会自动加载，这时候回到根目录会看到多出了一个类似光盘的盘，点击进入，然后找到可执行文件双击打卡，按照步骤一步步安装即可。\n- 安装方法2：使用大白菜 PE 装机工具，浏览到选择哪个 windows 镜像文件，选择 C 盘点击确定即可。\n- 系统会重启两次，这个过程不用过分担忧。大约 10-20 分钟后，系统自动安装完成。\n\n*如果以上操作不能完成，可以参考该[视频](http://www.dabaicai.tv/videos/2015/0424/941.html)*\n\n\n### 驱动安装\n\n*对于一个系统而言，固然应用软件很重要，但它们都依赖于一个良好的驱动环境。*刚装完的windows，尤其我们安装的是纯净版，这时候缺少很多驱动程序，可能上不了网，也显示效果很差，下面我们一一来解决。\n\n- 安装我们上面提供的驱动精灵完整版，安装完后进行一次检查，它会帮你自动更新你的网卡驱动。（不排除特殊超极本仍然没法更新驱动，这时候使用能够联网的电脑，去官网搜索型号，下载最新网卡驱动。）\n- 如果第一步能够解决上网问题，则进行这一步，使用驱动精灵联网更新驱动，必备的驱动是 intel 组件，网卡驱动以及显卡驱动，这边推荐再安装更新一个 usb 驱动，如果你的键盘比较特殊也可以更新键盘驱动，其他驱动看个人喜好而定。\n\n**至此整个的windows 7安装基本写完，如果不是很清晰的，后续可能会补充说明。**\n\n***\n> http://www.dabaicai.tv/\n> http://baike.baidu.com/link?url=AcECxARhjvZl-2381l31s4okBHXbuwj-GMoeTeKF_O-oqOVU2ESvN94HpOZ2xOEpCsEljGO1KUybDtqUeE4kra\n> http://www.laomaotao.org/lmtjc/245.html\n","source":"_posts/2016/2016-07-16-windows7安装详解.md","raw":"---\nlayout: \"post\"\ntitle: \"windows7安装详解\"\ndate: \"2016-07-16 16:41\"\n---\n\n*早在上学时,就安装过很多次win7,老是说,win7出了略微的比xp多占用了点资源外,确实好用。外观美观，性能也算不错。*\n\n### windows 7简介：\n\nWindows 7 是由微软公司（Microsoft）开发的操作系统，版本有：入门版（Starter）、家庭普通版（Home Basic）、家庭高级版（Home Premium）、专业版（Professional）、企业版（Enterprise）（非零售）、旗舰版（Ultimate）。Windows 7 的设计主要围绕五个重点——针对笔记本电脑的特有设计；基于应用服务的设计；用户的个性化；视听娱乐的优化；用户易用性的新引擎。 跳跃列表，系统故障快速修复等，这些新功能令Windows 7成为比较美观易用的操作系统。\n\n\n\n### 必要的软件下载：\n\n- [windows 7 64位]\n`ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/`\n- [windows 7 32位]\n`ed2k://|file|cn_windows_7_ultimate_with_sp1_x86_dvd_u_677486.iso|2653276160|7503E4B9B8738DFCB95872445C72AEFB|/`\n- [大白菜windows PE](https://pan.baidu.com/s/1o8GRTb0)\n- [驱动精灵2015网卡版](https://pan.baidu.com/s/1micuzrE)\n\n<!-- more -->\n\n\n### windows PE安装步骤：\n\n- 安装软件\n\n![1](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_10-53-18.png)\n\n- 点击上图中的*请选择*，选中你的优盘，**注意一定要是格式化的优盘，看大小和名称，千万不能选错，否则里面数据会全部丢失**。\n\n- 选中后直接点击一键制作usb启动盘，其他不需要修改，同图上即可。\n\n![2](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_10-54-24.png)\n\n- 等待5分钟左右的时间，制作完成，弹出的提示信息点击否。\n\n![3](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_11-23-6.png)\n\n- 到这边，优盘的PE制作则已经完成。\n\n\n\n\n### PC引导设置：\n\nUEFI :这边不讨论 UEFI 下的安装，如果你的电脑设置为了 UEFI，则直接在改成传统设置。\n\n**BIOS:传统设置，在主板中改成Legacy BIOS，则切换到这个模式。**\n\n#### BIOS下的设置步骤：\n- 方法1：可以在 BIOS 中设置启动顺序，将优盘 HDD 或者你的优盘名称对应的那个选项移到最上方。\n- 方法2：如果电脑开启了快速启动的选项，则可以一键选择引导的盘符，例如戴尔的一般是 F12 选项。\n\n\n\n### 系统分区操作\n\n*分区涉及到的学问很多，对于一个系统来说分区以及文件系统类型很重要。*\n\n*这边以windows系统为例，大概简单介绍下：*\n**windows 系统现在主要使用的是 ntfs 和 fat32 两种格式，fat32 在大文件传输，以及分区容量多有限制，但是兼容性较好，所以我们优盘就格式化成了 fat32 格式。而 ntfs 格式现在 PC 上面普遍选用这种格式，我们的系统也会格式化成这种格式。**\n\n\n#### 进入windowsPE系统\n\n- 安装时选择 12. 安装原版 win 系统\n- 再选择 04. 进去后使用点击安装\n- 进入 windows PE 系统\n\n#### 开始分区\n\n- 前提是确保已经进入了 windows PE 系统之后。\n- 打开桌面上的分区工具，可以使用推荐分区方式，建议所有软件都安装在 C 盘。\n- 新建分区，点击**快速分区**\n\n![新建分区](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G4111Z2E6.jpg)\n\n- 在弹出的窗口中选择“分区数目”，在高级设置中可以设置磁盘格式、大小、卷标以及主分区，修改完成后点击“确定”即可；如下图所示：（注意分区的大小，按照我上面提出的第一个是主分区至少40G，文件系统为NTFS，如果是总大小为120G的固态硬盘，可以只分两到三个区，对齐分区到此扇区的倍数选择4096。）\n\n![](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G411191b25.jpg)\n- 接着系统会弹出警告的提示窗口，我们确认无误后，单击“是”即可；如下图所示：\n\n![](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G411193B09.jpg)\n- 接下来系统会自动的进行格式化分区。\n\n![](https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G4111953b7.jpg)\n\n\n```\n安装在 C 盘的原因：如果重装系统的话，很多软件虽然仍然能用，但未必用起来稳定，加上软件默认的安装位置也是 C 盘，下次如果升级不注意可能会装重复，较少一部分软件是只能安装在C盘使用的，现在硬盘容量大，和系统装在一起不会有影响，另外重装系统的时候格 C 盘可以一次性清理干净,总而言之，个人认为装在C盘较好。（32 位 win7 的 C 盘分区在 40G 左右，64 位 win7 的 C 盘分区为 50-60G）。\n\n一般分区最多为 4 个分区，但后续的分区表中仍然能够存储其他分区，所以并不仅仅限于 4 个。windows 下的分区多半是一个主分区，和一个扩展分区，注意主分区就是 C 盘，用来安装操作系统的，扩展分区就是所有其他盘的总和，扩展分区是不可以直接使用的，因此分完扩展分区后，需要进一步将扩展分区分成多个逻辑分区，值得注意的是主分区可以有最多四个，但扩展分区有且只能有一个。\n\n格式化的时候扇区大小选择 4096，根据某些测评机构的数据，现在操作系统尤其是 windows 以及固态硬盘的情况下 4K 对齐能够有效的提升硬盘的各种性能。4K 对齐意味这大文件占用更少的扇区个数，数据在检索读取时往往会更快，但这无疑也是一种牺牲空间来换取时间的结果。\n```\n\n### 正式安装windows 7系统\n\n*在 windowsPE 的环境下，且确定以上操作都没有错误的话，这一步反而是最简单的一步*\n\n- 将下载好了的 windows 镜像文件复制到你刚刚分区完的电脑中，**一定要复制过去，不能通过优盘加载读取，另外复制在除了 C 盘以外的任意盘上面。**\n- 安装方法1：复制完成后，直接双击这个文件，windows PE 会自动加载，这时候回到根目录会看到多出了一个类似光盘的盘，点击进入，然后找到可执行文件双击打卡，按照步骤一步步安装即可。\n- 安装方法2：使用大白菜 PE 装机工具，浏览到选择哪个 windows 镜像文件，选择 C 盘点击确定即可。\n- 系统会重启两次，这个过程不用过分担忧。大约 10-20 分钟后，系统自动安装完成。\n\n*如果以上操作不能完成，可以参考该[视频](http://www.dabaicai.tv/videos/2015/0424/941.html)*\n\n\n### 驱动安装\n\n*对于一个系统而言，固然应用软件很重要，但它们都依赖于一个良好的驱动环境。*刚装完的windows，尤其我们安装的是纯净版，这时候缺少很多驱动程序，可能上不了网，也显示效果很差，下面我们一一来解决。\n\n- 安装我们上面提供的驱动精灵完整版，安装完后进行一次检查，它会帮你自动更新你的网卡驱动。（不排除特殊超极本仍然没法更新驱动，这时候使用能够联网的电脑，去官网搜索型号，下载最新网卡驱动。）\n- 如果第一步能够解决上网问题，则进行这一步，使用驱动精灵联网更新驱动，必备的驱动是 intel 组件，网卡驱动以及显卡驱动，这边推荐再安装更新一个 usb 驱动，如果你的键盘比较特殊也可以更新键盘驱动，其他驱动看个人喜好而定。\n\n**至此整个的windows 7安装基本写完，如果不是很清晰的，后续可能会补充说明。**\n\n***\n> http://www.dabaicai.tv/\n> http://baike.baidu.com/link?url=AcECxARhjvZl-2381l31s4okBHXbuwj-GMoeTeKF_O-oqOVU2ESvN94HpOZ2xOEpCsEljGO1KUybDtqUeE4kra\n> http://www.laomaotao.org/lmtjc/245.html\n","slug":"2016/2016-07-16-windows7安装详解","published":1,"updated":"2017-01-12T05:36:04.101Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ah7001umumubwp968mk","content":"<p><em>早在上学时,就安装过很多次win7,老是说,win7出了略微的比xp多占用了点资源外,确实好用。外观美观，性能也算不错。</em></p>\n<h3 id=\"windows-7简介：\"><a href=\"#windows-7简介：\" class=\"headerlink\" title=\"windows 7简介：\"></a>windows 7简介：</h3><p>Windows 7 是由微软公司（Microsoft）开发的操作系统，版本有：入门版（Starter）、家庭普通版（Home Basic）、家庭高级版（Home Premium）、专业版（Professional）、企业版（Enterprise）（非零售）、旗舰版（Ultimate）。Windows 7 的设计主要围绕五个重点——针对笔记本电脑的特有设计；基于应用服务的设计；用户的个性化；视听娱乐的优化；用户易用性的新引擎。 跳跃列表，系统故障快速修复等，这些新功能令Windows 7成为比较美观易用的操作系统。</p>\n<h3 id=\"必要的软件下载：\"><a href=\"#必要的软件下载：\" class=\"headerlink\" title=\"必要的软件下载：\"></a>必要的软件下载：</h3><ul>\n<li>[windows 7 64位]<br><code>ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/</code></li>\n<li>[windows 7 32位]<br><code>ed2k://|file|cn_windows_7_ultimate_with_sp1_x86_dvd_u_677486.iso|2653276160|7503E4B9B8738DFCB95872445C72AEFB|/</code></li>\n<li><a href=\"https://pan.baidu.com/s/1o8GRTb0\" target=\"_blank\" rel=\"external\">大白菜windows PE</a></li>\n<li><a href=\"https://pan.baidu.com/s/1micuzrE\" target=\"_blank\" rel=\"external\">驱动精灵2015网卡版</a></li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"windows-PE安装步骤：\"><a href=\"#windows-PE安装步骤：\" class=\"headerlink\" title=\"windows PE安装步骤：\"></a>windows PE安装步骤：</h3><ul>\n<li>安装软件</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_10-53-18.png\" alt=\"1\"></p>\n<ul>\n<li><p>点击上图中的<em>请选择</em>，选中你的优盘，<strong>注意一定要是格式化的优盘，看大小和名称，千万不能选错，否则里面数据会全部丢失</strong>。</p>\n</li>\n<li><p>选中后直接点击一键制作usb启动盘，其他不需要修改，同图上即可。</p>\n</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_10-54-24.png\" alt=\"2\"></p>\n<ul>\n<li>等待5分钟左右的时间，制作完成，弹出的提示信息点击否。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_11-23-6.png\" alt=\"3\"></p>\n<ul>\n<li>到这边，优盘的PE制作则已经完成。</li>\n</ul>\n<h3 id=\"PC引导设置：\"><a href=\"#PC引导设置：\" class=\"headerlink\" title=\"PC引导设置：\"></a>PC引导设置：</h3><p>UEFI :这边不讨论 UEFI 下的安装，如果你的电脑设置为了 UEFI，则直接在改成传统设置。</p>\n<p><strong>BIOS:传统设置，在主板中改成Legacy BIOS，则切换到这个模式。</strong></p>\n<h4 id=\"BIOS下的设置步骤：\"><a href=\"#BIOS下的设置步骤：\" class=\"headerlink\" title=\"BIOS下的设置步骤：\"></a>BIOS下的设置步骤：</h4><ul>\n<li>方法1：可以在 BIOS 中设置启动顺序，将优盘 HDD 或者你的优盘名称对应的那个选项移到最上方。</li>\n<li>方法2：如果电脑开启了快速启动的选项，则可以一键选择引导的盘符，例如戴尔的一般是 F12 选项。</li>\n</ul>\n<h3 id=\"系统分区操作\"><a href=\"#系统分区操作\" class=\"headerlink\" title=\"系统分区操作\"></a>系统分区操作</h3><p><em>分区涉及到的学问很多，对于一个系统来说分区以及文件系统类型很重要。</em></p>\n<p><em>这边以windows系统为例，大概简单介绍下：</em><br><strong>windows 系统现在主要使用的是 ntfs 和 fat32 两种格式，fat32 在大文件传输，以及分区容量多有限制，但是兼容性较好，所以我们优盘就格式化成了 fat32 格式。而 ntfs 格式现在 PC 上面普遍选用这种格式，我们的系统也会格式化成这种格式。</strong></p>\n<h4 id=\"进入windowsPE系统\"><a href=\"#进入windowsPE系统\" class=\"headerlink\" title=\"进入windowsPE系统\"></a>进入windowsPE系统</h4><ul>\n<li>安装时选择 12. 安装原版 win 系统</li>\n<li>再选择 04. 进去后使用点击安装</li>\n<li>进入 windows PE 系统</li>\n</ul>\n<h4 id=\"开始分区\"><a href=\"#开始分区\" class=\"headerlink\" title=\"开始分区\"></a>开始分区</h4><ul>\n<li>前提是确保已经进入了 windows PE 系统之后。</li>\n<li>打开桌面上的分区工具，可以使用推荐分区方式，建议所有软件都安装在 C 盘。</li>\n<li>新建分区，点击<strong>快速分区</strong></li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G4111Z2E6.jpg\" alt=\"新建分区\"></p>\n<ul>\n<li>在弹出的窗口中选择“分区数目”，在高级设置中可以设置磁盘格式、大小、卷标以及主分区，修改完成后点击“确定”即可；如下图所示：（注意分区的大小，按照我上面提出的第一个是主分区至少40G，文件系统为NTFS，如果是总大小为120G的固态硬盘，可以只分两到三个区，对齐分区到此扇区的倍数选择4096。）</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G411191b25.jpg\" alt=\"\"></p>\n<ul>\n<li>接着系统会弹出警告的提示窗口，我们确认无误后，单击“是”即可；如下图所示：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G411193B09.jpg\" alt=\"\"></p>\n<ul>\n<li>接下来系统会自动的进行格式化分区。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G4111953b7.jpg\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">安装在 C 盘的原因：如果重装系统的话，很多软件虽然仍然能用，但未必用起来稳定，加上软件默认的安装位置也是 C 盘，下次如果升级不注意可能会装重复，较少一部分软件是只能安装在C盘使用的，现在硬盘容量大，和系统装在一起不会有影响，另外重装系统的时候格 C 盘可以一次性清理干净,总而言之，个人认为装在C盘较好。（32 位 win7 的 C 盘分区在 40G 左右，64 位 win7 的 C 盘分区为 50-60G）。</div><div class=\"line\"></div><div class=\"line\">一般分区最多为 4 个分区，但后续的分区表中仍然能够存储其他分区，所以并不仅仅限于 4 个。windows 下的分区多半是一个主分区，和一个扩展分区，注意主分区就是 C 盘，用来安装操作系统的，扩展分区就是所有其他盘的总和，扩展分区是不可以直接使用的，因此分完扩展分区后，需要进一步将扩展分区分成多个逻辑分区，值得注意的是主分区可以有最多四个，但扩展分区有且只能有一个。</div><div class=\"line\"></div><div class=\"line\">格式化的时候扇区大小选择 4096，根据某些测评机构的数据，现在操作系统尤其是 windows 以及固态硬盘的情况下 4K 对齐能够有效的提升硬盘的各种性能。4K 对齐意味这大文件占用更少的扇区个数，数据在检索读取时往往会更快，但这无疑也是一种牺牲空间来换取时间的结果。</div></pre></td></tr></table></figure>\n<h3 id=\"正式安装windows-7系统\"><a href=\"#正式安装windows-7系统\" class=\"headerlink\" title=\"正式安装windows 7系统\"></a>正式安装windows 7系统</h3><p><em>在 windowsPE 的环境下，且确定以上操作都没有错误的话，这一步反而是最简单的一步</em></p>\n<ul>\n<li>将下载好了的 windows 镜像文件复制到你刚刚分区完的电脑中，<strong>一定要复制过去，不能通过优盘加载读取，另外复制在除了 C 盘以外的任意盘上面。</strong></li>\n<li>安装方法1：复制完成后，直接双击这个文件，windows PE 会自动加载，这时候回到根目录会看到多出了一个类似光盘的盘，点击进入，然后找到可执行文件双击打卡，按照步骤一步步安装即可。</li>\n<li>安装方法2：使用大白菜 PE 装机工具，浏览到选择哪个 windows 镜像文件，选择 C 盘点击确定即可。</li>\n<li>系统会重启两次，这个过程不用过分担忧。大约 10-20 分钟后，系统自动安装完成。</li>\n</ul>\n<p><em>如果以上操作不能完成，可以参考该<a href=\"http://www.dabaicai.tv/videos/2015/0424/941.html\" target=\"_blank\" rel=\"external\">视频</a></em></p>\n<h3 id=\"驱动安装\"><a href=\"#驱动安装\" class=\"headerlink\" title=\"驱动安装\"></a>驱动安装</h3><p><em>对于一个系统而言，固然应用软件很重要，但它们都依赖于一个良好的驱动环境。</em>刚装完的windows，尤其我们安装的是纯净版，这时候缺少很多驱动程序，可能上不了网，也显示效果很差，下面我们一一来解决。</p>\n<ul>\n<li>安装我们上面提供的驱动精灵完整版，安装完后进行一次检查，它会帮你自动更新你的网卡驱动。（不排除特殊超极本仍然没法更新驱动，这时候使用能够联网的电脑，去官网搜索型号，下载最新网卡驱动。）</li>\n<li>如果第一步能够解决上网问题，则进行这一步，使用驱动精灵联网更新驱动，必备的驱动是 intel 组件，网卡驱动以及显卡驱动，这边推荐再安装更新一个 usb 驱动，如果你的键盘比较特殊也可以更新键盘驱动，其他驱动看个人喜好而定。</li>\n</ul>\n<p><strong>至此整个的windows 7安装基本写完，如果不是很清晰的，后续可能会补充说明。</strong></p>\n<hr>\n<blockquote>\n<p><a href=\"http://www.dabaicai.tv/\" target=\"_blank\" rel=\"external\">http://www.dabaicai.tv/</a><br><a href=\"http://baike.baidu.com/link?url=AcECxARhjvZl-2381l31s4okBHXbuwj-GMoeTeKF_O-oqOVU2ESvN94HpOZ2xOEpCsEljGO1KUybDtqUeE4kra\" target=\"_blank\" rel=\"external\">http://baike.baidu.com/link?url=AcECxARhjvZl-2381l31s4okBHXbuwj-GMoeTeKF_O-oqOVU2ESvN94HpOZ2xOEpCsEljGO1KUybDtqUeE4kra</a><br><a href=\"http://www.laomaotao.org/lmtjc/245.html\" target=\"_blank\" rel=\"external\">http://www.laomaotao.org/lmtjc/245.html</a></p>\n</blockquote>\n","excerpt":"<p><em>早在上学时,就安装过很多次win7,老是说,win7出了略微的比xp多占用了点资源外,确实好用。外观美观，性能也算不错。</em></p>\n<h3 id=\"windows-7简介：\"><a href=\"#windows-7简介：\" class=\"headerlink\" title=\"windows 7简介：\"></a>windows 7简介：</h3><p>Windows 7 是由微软公司（Microsoft）开发的操作系统，版本有：入门版（Starter）、家庭普通版（Home Basic）、家庭高级版（Home Premium）、专业版（Professional）、企业版（Enterprise）（非零售）、旗舰版（Ultimate）。Windows 7 的设计主要围绕五个重点——针对笔记本电脑的特有设计；基于应用服务的设计；用户的个性化；视听娱乐的优化；用户易用性的新引擎。 跳跃列表，系统故障快速修复等，这些新功能令Windows 7成为比较美观易用的操作系统。</p>\n<h3 id=\"必要的软件下载：\"><a href=\"#必要的软件下载：\" class=\"headerlink\" title=\"必要的软件下载：\"></a>必要的软件下载：</h3><ul>\n<li>[windows 7 64位]<br><code>ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/</code></li>\n<li>[windows 7 32位]<br><code>ed2k://|file|cn_windows_7_ultimate_with_sp1_x86_dvd_u_677486.iso|2653276160|7503E4B9B8738DFCB95872445C72AEFB|/</code></li>\n<li><a href=\"https://pan.baidu.com/s/1o8GRTb0\">大白菜windows PE</a></li>\n<li><a href=\"https://pan.baidu.com/s/1micuzrE\">驱动精灵2015网卡版</a></li>\n</ul>","more":"<h3 id=\"windows-PE安装步骤：\"><a href=\"#windows-PE安装步骤：\" class=\"headerlink\" title=\"windows PE安装步骤：\"></a>windows PE安装步骤：</h3><ul>\n<li>安装软件</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_10-53-18.png\" alt=\"1\"></p>\n<ul>\n<li><p>点击上图中的<em>请选择</em>，选中你的优盘，<strong>注意一定要是格式化的优盘，看大小和名称，千万不能选错，否则里面数据会全部丢失</strong>。</p>\n</li>\n<li><p>选中后直接点击一键制作usb启动盘，其他不需要修改，同图上即可。</p>\n</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_10-54-24.png\" alt=\"2\"></p>\n<ul>\n<li>等待5分钟左右的时间，制作完成，弹出的提示信息点击否。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_11-23-6.png\" alt=\"3\"></p>\n<ul>\n<li>到这边，优盘的PE制作则已经完成。</li>\n</ul>\n<h3 id=\"PC引导设置：\"><a href=\"#PC引导设置：\" class=\"headerlink\" title=\"PC引导设置：\"></a>PC引导设置：</h3><p>UEFI :这边不讨论 UEFI 下的安装，如果你的电脑设置为了 UEFI，则直接在改成传统设置。</p>\n<p><strong>BIOS:传统设置，在主板中改成Legacy BIOS，则切换到这个模式。</strong></p>\n<h4 id=\"BIOS下的设置步骤：\"><a href=\"#BIOS下的设置步骤：\" class=\"headerlink\" title=\"BIOS下的设置步骤：\"></a>BIOS下的设置步骤：</h4><ul>\n<li>方法1：可以在 BIOS 中设置启动顺序，将优盘 HDD 或者你的优盘名称对应的那个选项移到最上方。</li>\n<li>方法2：如果电脑开启了快速启动的选项，则可以一键选择引导的盘符，例如戴尔的一般是 F12 选项。</li>\n</ul>\n<h3 id=\"系统分区操作\"><a href=\"#系统分区操作\" class=\"headerlink\" title=\"系统分区操作\"></a>系统分区操作</h3><p><em>分区涉及到的学问很多，对于一个系统来说分区以及文件系统类型很重要。</em></p>\n<p><em>这边以windows系统为例，大概简单介绍下：</em><br><strong>windows 系统现在主要使用的是 ntfs 和 fat32 两种格式，fat32 在大文件传输，以及分区容量多有限制，但是兼容性较好，所以我们优盘就格式化成了 fat32 格式。而 ntfs 格式现在 PC 上面普遍选用这种格式，我们的系统也会格式化成这种格式。</strong></p>\n<h4 id=\"进入windowsPE系统\"><a href=\"#进入windowsPE系统\" class=\"headerlink\" title=\"进入windowsPE系统\"></a>进入windowsPE系统</h4><ul>\n<li>安装时选择 12. 安装原版 win 系统</li>\n<li>再选择 04. 进去后使用点击安装</li>\n<li>进入 windows PE 系统</li>\n</ul>\n<h4 id=\"开始分区\"><a href=\"#开始分区\" class=\"headerlink\" title=\"开始分区\"></a>开始分区</h4><ul>\n<li>前提是确保已经进入了 windows PE 系统之后。</li>\n<li>打开桌面上的分区工具，可以使用推荐分区方式，建议所有软件都安装在 C 盘。</li>\n<li>新建分区，点击<strong>快速分区</strong></li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G4111Z2E6.jpg\" alt=\"新建分区\"></p>\n<ul>\n<li>在弹出的窗口中选择“分区数目”，在高级设置中可以设置磁盘格式、大小、卷标以及主分区，修改完成后点击“确定”即可；如下图所示：（注意分区的大小，按照我上面提出的第一个是主分区至少40G，文件系统为NTFS，如果是总大小为120G的固态硬盘，可以只分两到三个区，对齐分区到此扇区的倍数选择4096。）</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G411191b25.jpg\" alt=\"\"></p>\n<ul>\n<li>接着系统会弹出警告的提示窗口，我们确认无误后，单击“是”即可；如下图所示：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G411193B09.jpg\" alt=\"\"></p>\n<ul>\n<li>接下来系统会自动的进行格式化分区。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G4111953b7.jpg\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">安装在 C 盘的原因：如果重装系统的话，很多软件虽然仍然能用，但未必用起来稳定，加上软件默认的安装位置也是 C 盘，下次如果升级不注意可能会装重复，较少一部分软件是只能安装在C盘使用的，现在硬盘容量大，和系统装在一起不会有影响，另外重装系统的时候格 C 盘可以一次性清理干净,总而言之，个人认为装在C盘较好。（32 位 win7 的 C 盘分区在 40G 左右，64 位 win7 的 C 盘分区为 50-60G）。</div><div class=\"line\"></div><div class=\"line\">一般分区最多为 4 个分区，但后续的分区表中仍然能够存储其他分区，所以并不仅仅限于 4 个。windows 下的分区多半是一个主分区，和一个扩展分区，注意主分区就是 C 盘，用来安装操作系统的，扩展分区就是所有其他盘的总和，扩展分区是不可以直接使用的，因此分完扩展分区后，需要进一步将扩展分区分成多个逻辑分区，值得注意的是主分区可以有最多四个，但扩展分区有且只能有一个。</div><div class=\"line\"></div><div class=\"line\">格式化的时候扇区大小选择 4096，根据某些测评机构的数据，现在操作系统尤其是 windows 以及固态硬盘的情况下 4K 对齐能够有效的提升硬盘的各种性能。4K 对齐意味这大文件占用更少的扇区个数，数据在检索读取时往往会更快，但这无疑也是一种牺牲空间来换取时间的结果。</div></pre></td></tr></table></figure>\n<h3 id=\"正式安装windows-7系统\"><a href=\"#正式安装windows-7系统\" class=\"headerlink\" title=\"正式安装windows 7系统\"></a>正式安装windows 7系统</h3><p><em>在 windowsPE 的环境下，且确定以上操作都没有错误的话，这一步反而是最简单的一步</em></p>\n<ul>\n<li>将下载好了的 windows 镜像文件复制到你刚刚分区完的电脑中，<strong>一定要复制过去，不能通过优盘加载读取，另外复制在除了 C 盘以外的任意盘上面。</strong></li>\n<li>安装方法1：复制完成后，直接双击这个文件，windows PE 会自动加载，这时候回到根目录会看到多出了一个类似光盘的盘，点击进入，然后找到可执行文件双击打卡，按照步骤一步步安装即可。</li>\n<li>安装方法2：使用大白菜 PE 装机工具，浏览到选择哪个 windows 镜像文件，选择 C 盘点击确定即可。</li>\n<li>系统会重启两次，这个过程不用过分担忧。大约 10-20 分钟后，系统自动安装完成。</li>\n</ul>\n<p><em>如果以上操作不能完成，可以参考该<a href=\"http://www.dabaicai.tv/videos/2015/0424/941.html\">视频</a></em></p>\n<h3 id=\"驱动安装\"><a href=\"#驱动安装\" class=\"headerlink\" title=\"驱动安装\"></a>驱动安装</h3><p><em>对于一个系统而言，固然应用软件很重要，但它们都依赖于一个良好的驱动环境。</em>刚装完的windows，尤其我们安装的是纯净版，这时候缺少很多驱动程序，可能上不了网，也显示效果很差，下面我们一一来解决。</p>\n<ul>\n<li>安装我们上面提供的驱动精灵完整版，安装完后进行一次检查，它会帮你自动更新你的网卡驱动。（不排除特殊超极本仍然没法更新驱动，这时候使用能够联网的电脑，去官网搜索型号，下载最新网卡驱动。）</li>\n<li>如果第一步能够解决上网问题，则进行这一步，使用驱动精灵联网更新驱动，必备的驱动是 intel 组件，网卡驱动以及显卡驱动，这边推荐再安装更新一个 usb 驱动，如果你的键盘比较特殊也可以更新键盘驱动，其他驱动看个人喜好而定。</li>\n</ul>\n<p><strong>至此整个的windows 7安装基本写完，如果不是很清晰的，后续可能会补充说明。</strong></p>\n<hr>\n<blockquote>\n<p><a href=\"http://www.dabaicai.tv/\">http://www.dabaicai.tv/</a><br><a href=\"http://baike.baidu.com/link?url=AcECxARhjvZl-2381l31s4okBHXbuwj-GMoeTeKF_O-oqOVU2ESvN94HpOZ2xOEpCsEljGO1KUybDtqUeE4kra\">http://baike.baidu.com/link?url=AcECxARhjvZl-2381l31s4okBHXbuwj-GMoeTeKF_O-oqOVU2ESvN94HpOZ2xOEpCsEljGO1KUybDtqUeE4kra</a><br><a href=\"http://www.laomaotao.org/lmtjc/245.html\">http://www.laomaotao.org/lmtjc/245.html</a></p>\n</blockquote>"},{"layout":"post","title":"githubpage+jekyll搭建博客","date":"2016-07-21T11:03:00.000Z","_content":"\n使用 githubpage+jekyll 搭建博客也有半年时间了，这篇文章早该写好，但一致迟迟没有下笔。怎么说呢，githubpage+jekyll 搭建博客的静态博客，操作起来可视化成都较低，缺少 wordpress 等知名博客酷炫的管理后台，也很少能够找到炫酷的模板（文章下方链接给出了 jekyll 的一些模板），以上缺点也是显而易见，简而言之就是 jekyll 的界面丑陋用起来麻烦。但因为 githubpage 是 jekyll 提供的服务，所以好处就是 jekyll 文件无需每次本地编译，直接 push 到 github 上面，就可以生成页面，另外本地也会同时保存一份完整的源文件，书写时只需要按照 markdown 语法码字，更换平台博客搬家更是轻松。\n\n\n\n<!-- more -->\n\n> 参考链接：\n> http://www.perfectlyrandom.org/2014/06/29/adding-disqus-to-your-jekyll-powered-github-pages/\n> http://jekyll.com.cn/\n> http://playingfingers.com/2016/03/26/build-a-blog/\n> https://github.com/jekyll/jekyll/wiki/sites\n> http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html\n> http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/\n","source":"_posts/2016/2016-07-21-githubpage-jekyll搭建博客.md","raw":"---\nlayout: \"post\"\ntitle: \"githubpage+jekyll搭建博客\"\ndate: \"2016-07-21 19:03\"\n---\n\n使用 githubpage+jekyll 搭建博客也有半年时间了，这篇文章早该写好，但一致迟迟没有下笔。怎么说呢，githubpage+jekyll 搭建博客的静态博客，操作起来可视化成都较低，缺少 wordpress 等知名博客酷炫的管理后台，也很少能够找到炫酷的模板（文章下方链接给出了 jekyll 的一些模板），以上缺点也是显而易见，简而言之就是 jekyll 的界面丑陋用起来麻烦。但因为 githubpage 是 jekyll 提供的服务，所以好处就是 jekyll 文件无需每次本地编译，直接 push 到 github 上面，就可以生成页面，另外本地也会同时保存一份完整的源文件，书写时只需要按照 markdown 语法码字，更换平台博客搬家更是轻松。\n\n\n\n<!-- more -->\n\n> 参考链接：\n> http://www.perfectlyrandom.org/2014/06/29/adding-disqus-to-your-jekyll-powered-github-pages/\n> http://jekyll.com.cn/\n> http://playingfingers.com/2016/03/26/build-a-blog/\n> https://github.com/jekyll/jekyll/wiki/sites\n> http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html\n> http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/\n","slug":"2016/2016-07-21-githubpage-jekyll搭建博客","published":1,"updated":"2017-01-24T12:32:03.100Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ah9001xmumuqpp11axm","content":"<p>使用 githubpage+jekyll 搭建博客也有半年时间了，这篇文章早该写好，但一致迟迟没有下笔。怎么说呢，githubpage+jekyll 搭建博客的静态博客，操作起来可视化成都较低，缺少 wordpress 等知名博客酷炫的管理后台，也很少能够找到炫酷的模板（文章下方链接给出了 jekyll 的一些模板），以上缺点也是显而易见，简而言之就是 jekyll 的界面丑陋用起来麻烦。但因为 githubpage 是 jekyll 提供的服务，所以好处就是 jekyll 文件无需每次本地编译，直接 push 到 github 上面，就可以生成页面，另外本地也会同时保存一份完整的源文件，书写时只需要按照 markdown 语法码字，更换平台博客搬家更是轻松。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.perfectlyrandom.org/2014/06/29/adding-disqus-to-your-jekyll-powered-github-pages/\" target=\"_blank\" rel=\"external\">http://www.perfectlyrandom.org/2014/06/29/adding-disqus-to-your-jekyll-powered-github-pages/</a><br><a href=\"http://jekyll.com.cn/\" target=\"_blank\" rel=\"external\">http://jekyll.com.cn/</a><br><a href=\"http://playingfingers.com/2016/03/26/build-a-blog/\" target=\"_blank\" rel=\"external\">http://playingfingers.com/2016/03/26/build-a-blog/</a><br><a href=\"https://github.com/jekyll/jekyll/wiki/sites\" target=\"_blank\" rel=\"external\">https://github.com/jekyll/jekyll/wiki/sites</a><br><a href=\"http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html</a><br><a href=\"http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/\" target=\"_blank\" rel=\"external\">http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/</a></p>\n</blockquote>\n","excerpt":"<p>使用 githubpage+jekyll 搭建博客也有半年时间了，这篇文章早该写好，但一致迟迟没有下笔。怎么说呢，githubpage+jekyll 搭建博客的静态博客，操作起来可视化成都较低，缺少 wordpress 等知名博客酷炫的管理后台，也很少能够找到炫酷的模板（文章下方链接给出了 jekyll 的一些模板），以上缺点也是显而易见，简而言之就是 jekyll 的界面丑陋用起来麻烦。但因为 githubpage 是 jekyll 提供的服务，所以好处就是 jekyll 文件无需每次本地编译，直接 push 到 github 上面，就可以生成页面，另外本地也会同时保存一份完整的源文件，书写时只需要按照 markdown 语法码字，更换平台博客搬家更是轻松。</p>","more":"<blockquote>\n<p>参考链接：<br><a href=\"http://www.perfectlyrandom.org/2014/06/29/adding-disqus-to-your-jekyll-powered-github-pages/\">http://www.perfectlyrandom.org/2014/06/29/adding-disqus-to-your-jekyll-powered-github-pages/</a><br><a href=\"http://jekyll.com.cn/\">http://jekyll.com.cn/</a><br><a href=\"http://playingfingers.com/2016/03/26/build-a-blog/\">http://playingfingers.com/2016/03/26/build-a-blog/</a><br><a href=\"https://github.com/jekyll/jekyll/wiki/sites\">https://github.com/jekyll/jekyll/wiki/sites</a><br><a href=\"http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html\">http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html</a><br><a href=\"http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/\">http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/</a></p>\n</blockquote>"},{"layout":"post","title":"atom使用总结","date":"2016-07-15T05:50:00.000Z","_content":"\nAtom 是 Github 出的一款免费跨平台的 IDE，软件 15 年发布，至今时间较短，国内有一些文章或者帖子介绍该软件，但为数不多。笔者最初写也只是为了写文章而想在 linux 下找一款友好的 markdown 编辑器，翻阅了很多都不尽如人意，最后无意中发现了这款软件，简直爱不释手。*文章最下方的参考链接都写的比较详细，值得拿来参考阅读。*\n\n### Atom简介：\n\nAtom 是 github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持 CSS，HTML，JavaScript 等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。继承了 SublimeText 和 vim 的众多优点（除了占用资源，和开启速度慢，当然现在内存越来越不值钱，以及固态硬盘速度奇快，这些都会是问题），很大程度上不仅如此。据称，在目前IDE如此之多的情况下，开发这个软件是为了替代 vim（当然这么宣传也可能只是噱头，但 atom 确实扩展性强且容易配置），让更新更优秀的功能能够被体验，因此事实上Atom这款软件中是包含了vim模式的，当然用惯了vim的大神未必服。另外 Atom 在 web 前端相当出名，基本上可以取代老牌编辑器： SublimeText ，且功能类似vim可以无限将其配置成任何你需要的环境（如：C/C++ 开发环境，python 开发环境，markdown 写作软件等等），可见，学习这款软件无论是功能性能还是面向将来都是值得的。\n\n这边给出几个最主要的链接：[atom官网](https://atom.io/)，[atom插件中心](https://atom.io/packages)，[atom官方手册英文版](http://flight-manual.atom.io/)，[atom中文社区](https://atom-china.org/)，[atom源码](https://github.com/atom/atom)。\n\n### 快捷键的使用:\n\natom 的很多操作方式都和 chrome 等软件类似，如果习惯使用这些软件的人会觉得很得心应手，例如：ctrl+w 关闭标签页，ctrl+shift+t 重新打开之前关闭的标签等等。\n\nctrl+.  :  调用按键查看器\nctrl+\\  :  文件目录结构管理\nctrl+,  :  setting设置\nctrl-shift-M : Markdown预览\n\n<!-- more -->\n\n\n### 插件指南：\n\n有关 atom 的插件，可以使用 settings 中的自带搜索安装，也可以使用 apm install \"packages\" 安装插件，使用 apm remove \"packages\" 删除插件，所有的 package 一般都会有很详细的安装说明，注意仔细研读，一般推荐使用 apm install \"packages\" 方式安装插件，同时我们可以使用 apm update 进行插件的升级。\n\n考虑到伟大的 GFW，部分通过上面两种方法还是无法安装的小伙伴，可以访问[atom插件中心](https://atom.io/packages)，需要找到插件在git上的下载地址（如果 atom 插件中心也无法访问，则直接去 github 上搜索）。将项目下载下来，解压后，文件夹移动到 `yourpath/.atom/packages/` 下，打开到该插件文件夹目录下，在该目录下执行 `apm install` ，之后你就可以在插件管理中看到新的插件出现了。\n\n值得注意的是，各个插件虽然功能强大，但是也都会对 atom 进行一些定制，一些插件可能同事占用了某个快捷键，本身有冲突，所以在使用插件时，需要看一下里面的配置以及官方的说明，**难能可贵的是：所有插件安装后都可以点击插件名打开相关网页，上面附带有详细的帮助和使用说明，另外你也可以直接在[官方网址](https://atom.io/packages)搜索自己想要的插件。**\n\n- [Sync-setttings](https://atom.io/packages/sync-settings) (插件-备份神器),可以将你配置的atom环境备份到github上面，换电脑时，可以方便移植。自带的说明写的相当详细，注意* new personal access token 中激活 Gist -> create gists，但最好其他选项都不要打开，可能会引起插件无法读取加载。具体原因不明，如果你知道请在下面留言，或者发邮件给博主。*\n- [activate-power-mode](https://atom.io/packages/activate-power-mode) 貌似真没有什么实际作用，但的的确确是个装逼必备的神器，效果酷炫。\n- [vim-mode](https://atom.io/packages/vim-mode)，顾名思义是在 atom 下使用 vim 一些操作。由于本人不是很精通 vim，只会一些正常的按键操作，所以作为日常编辑时，感觉还行。但这个插件用的应该不是太多，毕竟是 atom 官方的插件，但却要手动安装下载。\n- autocomplete-paths:文件路径自动提示。\n- gpp-compiler:C/C++ 的编译器，可以通过快捷键直接调用这些功能，让atom成为一款真正的 C 开发环境。\n\n**注意：同样的插件可能在 windows 和 linux 下的支持是不一样的，部分插件只支持 windows ，部分插件在 linux 中可能功能会更多，具体要参见开发者写的插件说明。**\n\n### windows下的安装\n\natom 的强大就在于跨平台的使用，可以让你在不同的平台有着几乎一样的编程体验。windows 下的安装大致可以分为两个版本，一个是 .exe/.msi 安装方式，需要.net工具包才能顺利安装，另外也可以下载解压包，可以免安装直接使用。\n\n在dos 下通过cmd命令安装插件：\n- 打开 dos 窗口 window 可用快捷键 win+r  再输入cmd\n- 输入 apm install \"packages\" 如果 apm 不能识别请用 npm install \"packages\"。\n\n\n\n### FAQ\n\n#### failed to activate the package : cannot find module \"loe.random\"\n\n执行 npm install loe.random（你缺失哪一个 module，你就用那个 module 替代代码中的位置）\n\n#### 一行内容书写过多，阅读不方便，无法自动缩转到下一行。\n\n插件 language text 中的 soft wrap 等相关选项。\n\n\n\n***\nTo be continued...\n\n> 参考链接（建议查看，很多内容文章没复述）：\n> http://www.07net01.com/2015/08/893825.html\n> http://www.jianshu.com/p/dd97cbb3c22d\n> http://www.jianshu.com/p/508d540ca9c3\n> http://www.hackbase.com/article-206939-1.html\n> http://www.hackbase.com/portal.php?mod=view&aid=206939&page=1&\n> http://www.jianshu.com/p/55d6cbc175a9\n> https://www.zhihu.com/question/22867204\n> http://jingyan.baidu.com/article/375c8e19c3105a25f2a22901.html\n> http://www.cnblogs.com/20145221GQ/p/5334762.html\n","source":"_posts/2016/2016-07-15-atom使用总结.md","raw":"---\nlayout: \"post\"\ntitle: \"atom使用总结\"\ndate: \"2016-07-15 13:50\"\n---\n\nAtom 是 Github 出的一款免费跨平台的 IDE，软件 15 年发布，至今时间较短，国内有一些文章或者帖子介绍该软件，但为数不多。笔者最初写也只是为了写文章而想在 linux 下找一款友好的 markdown 编辑器，翻阅了很多都不尽如人意，最后无意中发现了这款软件，简直爱不释手。*文章最下方的参考链接都写的比较详细，值得拿来参考阅读。*\n\n### Atom简介：\n\nAtom 是 github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持 CSS，HTML，JavaScript 等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。继承了 SublimeText 和 vim 的众多优点（除了占用资源，和开启速度慢，当然现在内存越来越不值钱，以及固态硬盘速度奇快，这些都会是问题），很大程度上不仅如此。据称，在目前IDE如此之多的情况下，开发这个软件是为了替代 vim（当然这么宣传也可能只是噱头，但 atom 确实扩展性强且容易配置），让更新更优秀的功能能够被体验，因此事实上Atom这款软件中是包含了vim模式的，当然用惯了vim的大神未必服。另外 Atom 在 web 前端相当出名，基本上可以取代老牌编辑器： SublimeText ，且功能类似vim可以无限将其配置成任何你需要的环境（如：C/C++ 开发环境，python 开发环境，markdown 写作软件等等），可见，学习这款软件无论是功能性能还是面向将来都是值得的。\n\n这边给出几个最主要的链接：[atom官网](https://atom.io/)，[atom插件中心](https://atom.io/packages)，[atom官方手册英文版](http://flight-manual.atom.io/)，[atom中文社区](https://atom-china.org/)，[atom源码](https://github.com/atom/atom)。\n\n### 快捷键的使用:\n\natom 的很多操作方式都和 chrome 等软件类似，如果习惯使用这些软件的人会觉得很得心应手，例如：ctrl+w 关闭标签页，ctrl+shift+t 重新打开之前关闭的标签等等。\n\nctrl+.  :  调用按键查看器\nctrl+\\  :  文件目录结构管理\nctrl+,  :  setting设置\nctrl-shift-M : Markdown预览\n\n<!-- more -->\n\n\n### 插件指南：\n\n有关 atom 的插件，可以使用 settings 中的自带搜索安装，也可以使用 apm install \"packages\" 安装插件，使用 apm remove \"packages\" 删除插件，所有的 package 一般都会有很详细的安装说明，注意仔细研读，一般推荐使用 apm install \"packages\" 方式安装插件，同时我们可以使用 apm update 进行插件的升级。\n\n考虑到伟大的 GFW，部分通过上面两种方法还是无法安装的小伙伴，可以访问[atom插件中心](https://atom.io/packages)，需要找到插件在git上的下载地址（如果 atom 插件中心也无法访问，则直接去 github 上搜索）。将项目下载下来，解压后，文件夹移动到 `yourpath/.atom/packages/` 下，打开到该插件文件夹目录下，在该目录下执行 `apm install` ，之后你就可以在插件管理中看到新的插件出现了。\n\n值得注意的是，各个插件虽然功能强大，但是也都会对 atom 进行一些定制，一些插件可能同事占用了某个快捷键，本身有冲突，所以在使用插件时，需要看一下里面的配置以及官方的说明，**难能可贵的是：所有插件安装后都可以点击插件名打开相关网页，上面附带有详细的帮助和使用说明，另外你也可以直接在[官方网址](https://atom.io/packages)搜索自己想要的插件。**\n\n- [Sync-setttings](https://atom.io/packages/sync-settings) (插件-备份神器),可以将你配置的atom环境备份到github上面，换电脑时，可以方便移植。自带的说明写的相当详细，注意* new personal access token 中激活 Gist -> create gists，但最好其他选项都不要打开，可能会引起插件无法读取加载。具体原因不明，如果你知道请在下面留言，或者发邮件给博主。*\n- [activate-power-mode](https://atom.io/packages/activate-power-mode) 貌似真没有什么实际作用，但的的确确是个装逼必备的神器，效果酷炫。\n- [vim-mode](https://atom.io/packages/vim-mode)，顾名思义是在 atom 下使用 vim 一些操作。由于本人不是很精通 vim，只会一些正常的按键操作，所以作为日常编辑时，感觉还行。但这个插件用的应该不是太多，毕竟是 atom 官方的插件，但却要手动安装下载。\n- autocomplete-paths:文件路径自动提示。\n- gpp-compiler:C/C++ 的编译器，可以通过快捷键直接调用这些功能，让atom成为一款真正的 C 开发环境。\n\n**注意：同样的插件可能在 windows 和 linux 下的支持是不一样的，部分插件只支持 windows ，部分插件在 linux 中可能功能会更多，具体要参见开发者写的插件说明。**\n\n### windows下的安装\n\natom 的强大就在于跨平台的使用，可以让你在不同的平台有着几乎一样的编程体验。windows 下的安装大致可以分为两个版本，一个是 .exe/.msi 安装方式，需要.net工具包才能顺利安装，另外也可以下载解压包，可以免安装直接使用。\n\n在dos 下通过cmd命令安装插件：\n- 打开 dos 窗口 window 可用快捷键 win+r  再输入cmd\n- 输入 apm install \"packages\" 如果 apm 不能识别请用 npm install \"packages\"。\n\n\n\n### FAQ\n\n#### failed to activate the package : cannot find module \"loe.random\"\n\n执行 npm install loe.random（你缺失哪一个 module，你就用那个 module 替代代码中的位置）\n\n#### 一行内容书写过多，阅读不方便，无法自动缩转到下一行。\n\n插件 language text 中的 soft wrap 等相关选项。\n\n\n\n***\nTo be continued...\n\n> 参考链接（建议查看，很多内容文章没复述）：\n> http://www.07net01.com/2015/08/893825.html\n> http://www.jianshu.com/p/dd97cbb3c22d\n> http://www.jianshu.com/p/508d540ca9c3\n> http://www.hackbase.com/article-206939-1.html\n> http://www.hackbase.com/portal.php?mod=view&aid=206939&page=1&\n> http://www.jianshu.com/p/55d6cbc175a9\n> https://www.zhihu.com/question/22867204\n> http://jingyan.baidu.com/article/375c8e19c3105a25f2a22901.html\n> http://www.cnblogs.com/20145221GQ/p/5334762.html\n","slug":"2016/2016-07-15-atom使用总结","published":1,"updated":"2017-01-12T05:39:55.094Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahb001ymumu1yf7p4iu","content":"<p>Atom 是 Github 出的一款免费跨平台的 IDE，软件 15 年发布，至今时间较短，国内有一些文章或者帖子介绍该软件，但为数不多。笔者最初写也只是为了写文章而想在 linux 下找一款友好的 markdown 编辑器，翻阅了很多都不尽如人意，最后无意中发现了这款软件，简直爱不释手。<em>文章最下方的参考链接都写的比较详细，值得拿来参考阅读。</em></p>\n<h3 id=\"Atom简介：\"><a href=\"#Atom简介：\" class=\"headerlink\" title=\"Atom简介：\"></a>Atom简介：</h3><p>Atom 是 github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持 CSS，HTML，JavaScript 等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。继承了 SublimeText 和 vim 的众多优点（除了占用资源，和开启速度慢，当然现在内存越来越不值钱，以及固态硬盘速度奇快，这些都会是问题），很大程度上不仅如此。据称，在目前IDE如此之多的情况下，开发这个软件是为了替代 vim（当然这么宣传也可能只是噱头，但 atom 确实扩展性强且容易配置），让更新更优秀的功能能够被体验，因此事实上Atom这款软件中是包含了vim模式的，当然用惯了vim的大神未必服。另外 Atom 在 web 前端相当出名，基本上可以取代老牌编辑器： SublimeText ，且功能类似vim可以无限将其配置成任何你需要的环境（如：C/C++ 开发环境，python 开发环境，markdown 写作软件等等），可见，学习这款软件无论是功能性能还是面向将来都是值得的。</p>\n<p>这边给出几个最主要的链接：<a href=\"https://atom.io/\" target=\"_blank\" rel=\"external\">atom官网</a>，<a href=\"https://atom.io/packages\" target=\"_blank\" rel=\"external\">atom插件中心</a>，<a href=\"http://flight-manual.atom.io/\" target=\"_blank\" rel=\"external\">atom官方手册英文版</a>，<a href=\"https://atom-china.org/\" target=\"_blank\" rel=\"external\">atom中文社区</a>，<a href=\"https://github.com/atom/atom\" target=\"_blank\" rel=\"external\">atom源码</a>。</p>\n<h3 id=\"快捷键的使用\"><a href=\"#快捷键的使用\" class=\"headerlink\" title=\"快捷键的使用:\"></a>快捷键的使用:</h3><p>atom 的很多操作方式都和 chrome 等软件类似，如果习惯使用这些软件的人会觉得很得心应手，例如：ctrl+w 关闭标签页，ctrl+shift+t 重新打开之前关闭的标签等等。</p>\n<p>ctrl+.  :  调用按键查看器<br>ctrl+\\  :  文件目录结构管理<br>ctrl+,  :  setting设置<br>ctrl-shift-M : Markdown预览</p>\n<a id=\"more\"></a>\n<h3 id=\"插件指南：\"><a href=\"#插件指南：\" class=\"headerlink\" title=\"插件指南：\"></a>插件指南：</h3><p>有关 atom 的插件，可以使用 settings 中的自带搜索安装，也可以使用 apm install “packages” 安装插件，使用 apm remove “packages” 删除插件，所有的 package 一般都会有很详细的安装说明，注意仔细研读，一般推荐使用 apm install “packages” 方式安装插件，同时我们可以使用 apm update 进行插件的升级。</p>\n<p>考虑到伟大的 GFW，部分通过上面两种方法还是无法安装的小伙伴，可以访问<a href=\"https://atom.io/packages\" target=\"_blank\" rel=\"external\">atom插件中心</a>，需要找到插件在git上的下载地址（如果 atom 插件中心也无法访问，则直接去 github 上搜索）。将项目下载下来，解压后，文件夹移动到 <code>yourpath/.atom/packages/</code> 下，打开到该插件文件夹目录下，在该目录下执行 <code>apm install</code> ，之后你就可以在插件管理中看到新的插件出现了。</p>\n<p>值得注意的是，各个插件虽然功能强大，但是也都会对 atom 进行一些定制，一些插件可能同事占用了某个快捷键，本身有冲突，所以在使用插件时，需要看一下里面的配置以及官方的说明，<strong>难能可贵的是：所有插件安装后都可以点击插件名打开相关网页，上面附带有详细的帮助和使用说明，另外你也可以直接在<a href=\"https://atom.io/packages\" target=\"_blank\" rel=\"external\">官方网址</a>搜索自己想要的插件。</strong></p>\n<ul>\n<li><a href=\"https://atom.io/packages/sync-settings\" target=\"_blank\" rel=\"external\">Sync-setttings</a> (插件-备份神器),可以将你配置的atom环境备份到github上面，换电脑时，可以方便移植。自带的说明写的相当详细，注意<em> new personal access token 中激活 Gist -&gt; create gists，但最好其他选项都不要打开，可能会引起插件无法读取加载。具体原因不明，如果你知道请在下面留言，或者发邮件给博主。</em></li>\n<li><a href=\"https://atom.io/packages/activate-power-mode\" target=\"_blank\" rel=\"external\">activate-power-mode</a> 貌似真没有什么实际作用，但的的确确是个装逼必备的神器，效果酷炫。</li>\n<li><a href=\"https://atom.io/packages/vim-mode\" target=\"_blank\" rel=\"external\">vim-mode</a>，顾名思义是在 atom 下使用 vim 一些操作。由于本人不是很精通 vim，只会一些正常的按键操作，所以作为日常编辑时，感觉还行。但这个插件用的应该不是太多，毕竟是 atom 官方的插件，但却要手动安装下载。</li>\n<li>autocomplete-paths:文件路径自动提示。</li>\n<li>gpp-compiler:C/C++ 的编译器，可以通过快捷键直接调用这些功能，让atom成为一款真正的 C 开发环境。</li>\n</ul>\n<p><strong>注意：同样的插件可能在 windows 和 linux 下的支持是不一样的，部分插件只支持 windows ，部分插件在 linux 中可能功能会更多，具体要参见开发者写的插件说明。</strong></p>\n<h3 id=\"windows下的安装\"><a href=\"#windows下的安装\" class=\"headerlink\" title=\"windows下的安装\"></a>windows下的安装</h3><p>atom 的强大就在于跨平台的使用，可以让你在不同的平台有着几乎一样的编程体验。windows 下的安装大致可以分为两个版本，一个是 .exe/.msi 安装方式，需要.net工具包才能顺利安装，另外也可以下载解压包，可以免安装直接使用。</p>\n<p>在dos 下通过cmd命令安装插件：</p>\n<ul>\n<li>打开 dos 窗口 window 可用快捷键 win+r  再输入cmd</li>\n<li>输入 apm install “packages” 如果 apm 不能识别请用 npm install “packages”。</li>\n</ul>\n<h3 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h3><h4 id=\"failed-to-activate-the-package-cannot-find-module-“loe-random”\"><a href=\"#failed-to-activate-the-package-cannot-find-module-“loe-random”\" class=\"headerlink\" title=\"failed to activate the package : cannot find module “loe.random”\"></a>failed to activate the package : cannot find module “loe.random”</h4><p>执行 npm install loe.random（你缺失哪一个 module，你就用那个 module 替代代码中的位置）</p>\n<h4 id=\"一行内容书写过多，阅读不方便，无法自动缩转到下一行。\"><a href=\"#一行内容书写过多，阅读不方便，无法自动缩转到下一行。\" class=\"headerlink\" title=\"一行内容书写过多，阅读不方便，无法自动缩转到下一行。\"></a>一行内容书写过多，阅读不方便，无法自动缩转到下一行。</h4><p>插件 language text 中的 soft wrap 等相关选项。</p>\n<hr>\n<p>To be continued…</p>\n<blockquote>\n<p>参考链接（建议查看，很多内容文章没复述）：<br><a href=\"http://www.07net01.com/2015/08/893825.html\" target=\"_blank\" rel=\"external\">http://www.07net01.com/2015/08/893825.html</a><br><a href=\"http://www.jianshu.com/p/dd97cbb3c22d\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/dd97cbb3c22d</a><br><a href=\"http://www.jianshu.com/p/508d540ca9c3\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/508d540ca9c3</a><br><a href=\"http://www.hackbase.com/article-206939-1.html\" target=\"_blank\" rel=\"external\">http://www.hackbase.com/article-206939-1.html</a><br><a href=\"http://www.hackbase.com/portal.php?mod=view&amp;aid=206939&amp;page=1&amp;\" target=\"_blank\" rel=\"external\">http://www.hackbase.com/portal.php?mod=view&amp;aid=206939&amp;page=1&amp;</a><br><a href=\"http://www.jianshu.com/p/55d6cbc175a9\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/55d6cbc175a9</a><br><a href=\"https://www.zhihu.com/question/22867204\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/22867204</a><br><a href=\"http://jingyan.baidu.com/article/375c8e19c3105a25f2a22901.html\" target=\"_blank\" rel=\"external\">http://jingyan.baidu.com/article/375c8e19c3105a25f2a22901.html</a><br><a href=\"http://www.cnblogs.com/20145221GQ/p/5334762.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/20145221GQ/p/5334762.html</a></p>\n</blockquote>\n","excerpt":"<p>Atom 是 Github 出的一款免费跨平台的 IDE，软件 15 年发布，至今时间较短，国内有一些文章或者帖子介绍该软件，但为数不多。笔者最初写也只是为了写文章而想在 linux 下找一款友好的 markdown 编辑器，翻阅了很多都不尽如人意，最后无意中发现了这款软件，简直爱不释手。<em>文章最下方的参考链接都写的比较详细，值得拿来参考阅读。</em></p>\n<h3 id=\"Atom简介：\"><a href=\"#Atom简介：\" class=\"headerlink\" title=\"Atom简介：\"></a>Atom简介：</h3><p>Atom 是 github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持 CSS，HTML，JavaScript 等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。继承了 SublimeText 和 vim 的众多优点（除了占用资源，和开启速度慢，当然现在内存越来越不值钱，以及固态硬盘速度奇快，这些都会是问题），很大程度上不仅如此。据称，在目前IDE如此之多的情况下，开发这个软件是为了替代 vim（当然这么宣传也可能只是噱头，但 atom 确实扩展性强且容易配置），让更新更优秀的功能能够被体验，因此事实上Atom这款软件中是包含了vim模式的，当然用惯了vim的大神未必服。另外 Atom 在 web 前端相当出名，基本上可以取代老牌编辑器： SublimeText ，且功能类似vim可以无限将其配置成任何你需要的环境（如：C/C++ 开发环境，python 开发环境，markdown 写作软件等等），可见，学习这款软件无论是功能性能还是面向将来都是值得的。</p>\n<p>这边给出几个最主要的链接：<a href=\"https://atom.io/\">atom官网</a>，<a href=\"https://atom.io/packages\">atom插件中心</a>，<a href=\"http://flight-manual.atom.io/\">atom官方手册英文版</a>，<a href=\"https://atom-china.org/\">atom中文社区</a>，<a href=\"https://github.com/atom/atom\">atom源码</a>。</p>\n<h3 id=\"快捷键的使用\"><a href=\"#快捷键的使用\" class=\"headerlink\" title=\"快捷键的使用:\"></a>快捷键的使用:</h3><p>atom 的很多操作方式都和 chrome 等软件类似，如果习惯使用这些软件的人会觉得很得心应手，例如：ctrl+w 关闭标签页，ctrl+shift+t 重新打开之前关闭的标签等等。</p>\n<p>ctrl+.  :  调用按键查看器<br>ctrl+\\  :  文件目录结构管理<br>ctrl+,  :  setting设置<br>ctrl-shift-M : Markdown预览</p>","more":"<h3 id=\"插件指南：\"><a href=\"#插件指南：\" class=\"headerlink\" title=\"插件指南：\"></a>插件指南：</h3><p>有关 atom 的插件，可以使用 settings 中的自带搜索安装，也可以使用 apm install “packages” 安装插件，使用 apm remove “packages” 删除插件，所有的 package 一般都会有很详细的安装说明，注意仔细研读，一般推荐使用 apm install “packages” 方式安装插件，同时我们可以使用 apm update 进行插件的升级。</p>\n<p>考虑到伟大的 GFW，部分通过上面两种方法还是无法安装的小伙伴，可以访问<a href=\"https://atom.io/packages\">atom插件中心</a>，需要找到插件在git上的下载地址（如果 atom 插件中心也无法访问，则直接去 github 上搜索）。将项目下载下来，解压后，文件夹移动到 <code>yourpath/.atom/packages/</code> 下，打开到该插件文件夹目录下，在该目录下执行 <code>apm install</code> ，之后你就可以在插件管理中看到新的插件出现了。</p>\n<p>值得注意的是，各个插件虽然功能强大，但是也都会对 atom 进行一些定制，一些插件可能同事占用了某个快捷键，本身有冲突，所以在使用插件时，需要看一下里面的配置以及官方的说明，<strong>难能可贵的是：所有插件安装后都可以点击插件名打开相关网页，上面附带有详细的帮助和使用说明，另外你也可以直接在<a href=\"https://atom.io/packages\">官方网址</a>搜索自己想要的插件。</strong></p>\n<ul>\n<li><a href=\"https://atom.io/packages/sync-settings\">Sync-setttings</a> (插件-备份神器),可以将你配置的atom环境备份到github上面，换电脑时，可以方便移植。自带的说明写的相当详细，注意<em> new personal access token 中激活 Gist -&gt; create gists，但最好其他选项都不要打开，可能会引起插件无法读取加载。具体原因不明，如果你知道请在下面留言，或者发邮件给博主。</em></li>\n<li><a href=\"https://atom.io/packages/activate-power-mode\">activate-power-mode</a> 貌似真没有什么实际作用，但的的确确是个装逼必备的神器，效果酷炫。</li>\n<li><a href=\"https://atom.io/packages/vim-mode\">vim-mode</a>，顾名思义是在 atom 下使用 vim 一些操作。由于本人不是很精通 vim，只会一些正常的按键操作，所以作为日常编辑时，感觉还行。但这个插件用的应该不是太多，毕竟是 atom 官方的插件，但却要手动安装下载。</li>\n<li>autocomplete-paths:文件路径自动提示。</li>\n<li>gpp-compiler:C/C++ 的编译器，可以通过快捷键直接调用这些功能，让atom成为一款真正的 C 开发环境。</li>\n</ul>\n<p><strong>注意：同样的插件可能在 windows 和 linux 下的支持是不一样的，部分插件只支持 windows ，部分插件在 linux 中可能功能会更多，具体要参见开发者写的插件说明。</strong></p>\n<h3 id=\"windows下的安装\"><a href=\"#windows下的安装\" class=\"headerlink\" title=\"windows下的安装\"></a>windows下的安装</h3><p>atom 的强大就在于跨平台的使用，可以让你在不同的平台有着几乎一样的编程体验。windows 下的安装大致可以分为两个版本，一个是 .exe/.msi 安装方式，需要.net工具包才能顺利安装，另外也可以下载解压包，可以免安装直接使用。</p>\n<p>在dos 下通过cmd命令安装插件：</p>\n<ul>\n<li>打开 dos 窗口 window 可用快捷键 win+r  再输入cmd</li>\n<li>输入 apm install “packages” 如果 apm 不能识别请用 npm install “packages”。</li>\n</ul>\n<h3 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h3><h4 id=\"failed-to-activate-the-package-cannot-find-module-“loe-random”\"><a href=\"#failed-to-activate-the-package-cannot-find-module-“loe-random”\" class=\"headerlink\" title=\"failed to activate the package : cannot find module “loe.random”\"></a>failed to activate the package : cannot find module “loe.random”</h4><p>执行 npm install loe.random（你缺失哪一个 module，你就用那个 module 替代代码中的位置）</p>\n<h4 id=\"一行内容书写过多，阅读不方便，无法自动缩转到下一行。\"><a href=\"#一行内容书写过多，阅读不方便，无法自动缩转到下一行。\" class=\"headerlink\" title=\"一行内容书写过多，阅读不方便，无法自动缩转到下一行。\"></a>一行内容书写过多，阅读不方便，无法自动缩转到下一行。</h4><p>插件 language text 中的 soft wrap 等相关选项。</p>\n<hr>\n<p>To be continued…</p>\n<blockquote>\n<p>参考链接（建议查看，很多内容文章没复述）：<br><a href=\"http://www.07net01.com/2015/08/893825.html\">http://www.07net01.com/2015/08/893825.html</a><br><a href=\"http://www.jianshu.com/p/dd97cbb3c22d\">http://www.jianshu.com/p/dd97cbb3c22d</a><br><a href=\"http://www.jianshu.com/p/508d540ca9c3\">http://www.jianshu.com/p/508d540ca9c3</a><br><a href=\"http://www.hackbase.com/article-206939-1.html\">http://www.hackbase.com/article-206939-1.html</a><br><a href=\"http://www.hackbase.com/portal.php?mod=view&amp;aid=206939&amp;page=1&amp;\">http://www.hackbase.com/portal.php?mod=view&amp;aid=206939&amp;page=1&amp;</a><br><a href=\"http://www.jianshu.com/p/55d6cbc175a9\">http://www.jianshu.com/p/55d6cbc175a9</a><br><a href=\"https://www.zhihu.com/question/22867204\">https://www.zhihu.com/question/22867204</a><br><a href=\"http://jingyan.baidu.com/article/375c8e19c3105a25f2a22901.html\">http://jingyan.baidu.com/article/375c8e19c3105a25f2a22901.html</a><br><a href=\"http://www.cnblogs.com/20145221GQ/p/5334762.html\">http://www.cnblogs.com/20145221GQ/p/5334762.html</a></p>\n</blockquote>"},{"layout":"post","title":"多个发行版linux使用体验","date":"2016-07-27T03:22:00.000Z","_content":"\n*本文主要记录自己使用多个linux的发行版的一些感受体验，会包括CLI和GUI的一些体验。本文具有一定的主观性，仅供参考。*\n\n发行版包括：ubuntu，debian，centOS，openSUSE等\n窗口管理器包括：gnome，kde，awesome等\n\n<!-- more -->\n\n\n\n***\n\nTo be continued...\n","source":"_posts/2016/2016-07-27-多个发行版linux使用体验.md","raw":"---\nlayout: \"post\"\ntitle: \"多个发行版linux使用体验\"\ndate: \"2016-07-27 11:22\"\n---\n\n*本文主要记录自己使用多个linux的发行版的一些感受体验，会包括CLI和GUI的一些体验。本文具有一定的主观性，仅供参考。*\n\n发行版包括：ubuntu，debian，centOS，openSUSE等\n窗口管理器包括：gnome，kde，awesome等\n\n<!-- more -->\n\n\n\n***\n\nTo be continued...\n","slug":"2016/2016-07-27-多个发行版linux使用体验","published":1,"updated":"2017-01-12T05:20:13.774Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahc001zmumujl7l3otz","content":"<p><em>本文主要记录自己使用多个linux的发行版的一些感受体验，会包括CLI和GUI的一些体验。本文具有一定的主观性，仅供参考。</em></p>\n<p>发行版包括：ubuntu，debian，centOS，openSUSE等<br>窗口管理器包括：gnome，kde，awesome等</p>\n<a id=\"more\"></a>\n<hr>\n<p>To be continued…</p>\n","excerpt":"<p><em>本文主要记录自己使用多个linux的发行版的一些感受体验，会包括CLI和GUI的一些体验。本文具有一定的主观性，仅供参考。</em></p>\n<p>发行版包括：ubuntu，debian，centOS，openSUSE等<br>窗口管理器包括：gnome，kde，awesome等</p>","more":"<hr>\n<p>To be continued…</p>"},{"layout":"post","title":"桥接、NAT、Host-only上网方式的区别","date":"2016-07-25T05:53:00.000Z","_content":"\n*经常使用虚拟机的小伙伴们都遇到过网络链接过程中的各种问题，仔细查看设置会发现有：桥接、NAT、Host-only 等设置，vmware 等虚拟机后还会自动生成vmnet1和vmnet8，初学者可能会一头雾水，为啥只有两个？不是三种模式吗？另外每个模式代表什么？他们又有什么区别？无论是 vmware 还是 vitualbox 这些内容都大同小异，而 vmware 中看起来可能会更加直观些，这边以windows下的安装使用为例，进行深入的详解。*\n\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/0.png)\n\n**本文会尽可能详细地总结和罗列出三者的含义和区别，以及虚拟机中该如何配置他们更加合适。**\n\n\n### 桥接:\n\n简而言之桥接就是指：**就是通过一台设备（可能不止一个）把几个网络串起来形成的连接**。这边主要介绍虚拟机所采用的桥接方式，虚拟出来的操作系统就像是局域网中的一独立的主机，它可以通过路由器网线访问网内任何一台机器。不过虚拟机需要占用你同一个网段的一个 IP 地址，当且仅当虚拟机和实体机在同一个网段，两者才可以进行通信，如：*虚拟机 IP：192.168.1.101，实体机 IP：192.168.1.100*。\n\n在桥接模式下，例如在 windows 下使用 vmware 时，明显看到会生成多个虚拟网卡出来，但却没有一个网卡是属于桥接的，原因是虚拟机采用桥接方式时，是不需要虚拟网卡的，这时候*虚拟机操作系统和实体机操作系统同时使用真实网卡工作，然后真是网卡发送数据出去，而如果虚拟机发送数据给真实机，则数据流向是：**虚拟机系统->真实网卡->路由器->真实网卡->实体机系统**，不难看出同一个数据经过网卡在路由器上面绕了一圈又回到了网卡。*\n\n通过上述内容发现，桥接必须经过真实网卡和路由器，因此当你的电脑没有链接有线网或者无线网的话，你的实体机是无法和虚拟机进行交互的，即便看起来两者很近也不行。*而选用桥接还是 NAT 等方式是在虚拟机软件中选定，进入虚拟的操作系统后，所有的设置和真实电脑没有本质区别，如果路由器允许自动分配 IP 地址，则操作系统设置为自动获取 IP 即可，如果不能自动分配，也可以在操作系统中手动分配 IP 地址。另外值得注意的是*某些公司路由器绑定了电脑 mac 地址和 IP 地址，这时候虚拟机中的桥接也相当于一个真实电脑，也需要完成相关的绑定才可以访问网络。*\n\n可以看出：如果你想利用VMware在局域网内新建一个虚拟服务器，为局域网用户提供网络服务，就应该选择桥接模式。下面举个栗子：\n\n```\n例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的 wanip 就不理会了，这个 ip 是动态获取的，而一般lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的 ip 是:\n\nA: 192.168.1.100/255.255.255.0,  B: 192.168.1.101/255.255.255.0,  C: 192.168.1.102/255.255.255.0,  D: 192.168.1.103/255.255.255.0\n\n那么虚拟机的 ip 可以设置的 ip 地址是 192.168.1.2-192.168.1.99, 192.168.1.104-192.168.1.254 (网络地址 0 和 1 的除外，再除去 ABCD 四个人的 ip 地址)\n\n那么虚拟机的 ip 地址可以设置为 192.168.1.98/255.255.255.0,设置了这个 ip 地址，ABCD 这四个人就可以通过 192.168.1.98 访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是 192.168.1.1 了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个 dns 服务器，我们可以简单点，把 dns 服务器地址配置为 google 的 dns 服务器 :8.8.8.8，到此，虚拟机就可以上网了。\n```\n\n综上所述，*同一个数据经过网卡在路由器上面绕了一圈又回到了网卡。*而虚拟机的桥接也只在其他电脑需要访问你电脑的虚拟机时，或者你虚拟机需要访问其他外部设备时才有相关需求*，一般情况还是建议配置成操作方便使用简单的 NAT 方式。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/1.png)\n\n<!-- more -->\n\n\n### NAT:\n\n*NAT模式实际是虚拟了一个网卡出来，虚拟机直接使用链接这个虚拟网卡，每次访问和交互通过这个虚拟网卡交换数据。虚拟机发送数据给实体机：**虚拟机系统->虚拟网卡->实体机系统**（可以发现是不经过真实网卡的流程简单很多）；虚拟机访问外网：**虚拟机系统->虚拟网卡->实体机系统->真实网卡->路由器->外网** 。*\n\n虚拟机借助 NAT (网络地址转换)功能，通过宿主机器所在的网络来访问公网。 NAT 模式中，虚拟机的网卡和真实网卡的网络，不需要在同一个网络，虚拟机的网卡的网段可以理解：路由器所在网段之下的一个子网段。\n\n采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。如果你想利用VMWare安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议你采用NAT模式。而缺点是： NAT 模式下，虚拟机仅仅可以同路由器下网段中的一台真实机通讯，而这台真实机就是安装虚拟机的这台电脑，之所以可以通讯是因为这台电脑本身充当了虚拟机的路由器，相当于路由器的 192.168.1.1 这个地址，而你在 vmware 下的网卡管理中是可以看到这个地址的。这边再补充一点：*采用NAT模式时，虚拟机和实体机交互并不是直接进行的，首先虚拟机操作系统访问虚拟网卡 VMnet8 （地址如： 192.188.1.33），然后这个虚拟网卡会再将数据提交给真实机操作系统VMware Network Adapter VMnet8（地址： 192.188.1.1）而地址（192.188.1.33 和 192.188.1.1）实际都是由虚拟机软件 vmware 提供的，具体的交互细节不作研究。*\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/2.png)\n\n### Host-only:\n\n在 Host-Only 模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实 Host-Only 网络和 NAT 网络很相似，不同的地方就是 Host-Only 网络没有 NAT 服务，所以虚拟网络不能连接到 Internet 。主机和虚拟机之间的通信是通过 VMware Network Adepter VMnet1 虚拟网卡来实现的。\n\nHost-Only 的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为 VMnet1 网段提供路由功能，那就需要使用RRAS，而不能使用 XP 或 2000 的 ICS，因为 ICS 会把内网的 IP 地址改为 192.168.0.1，但虚拟机是不会给 VMnet1 虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/3.png)\n\n### windows下的vmware：\n\nVMware 的几个虚拟设备：\n\n- VMnet0：这是 VMware 用于虚拟桥接网络下的虚拟交换机，一般是不可见的，因为桥接一般直接使用真实网卡；\n- VMnet1：这是 VMware 用于虚拟Host-Only网络下的虚拟交换机；\n- VMnet8：这是 VMware 用于虚拟NAT网络下的虚拟交换机；\n- VMware Network Adapter VMnet1：这是 Host 用于与 Host-Only 虚拟网络进行通信的虚拟网卡；\n- VMware Network Adapter VMnet8：这是 Host 用于与 NAT 虚拟网络进行通信的虚拟网卡；\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/4.png)\n\n*事实上，根据上面对三种常见模式的详细，基本上应该已经有了清晰的认识，知道如何配置虚拟机网卡了。*\n\n### 配置建议：\n\n在普通常规虚拟机联网时，采用 NAT 的模式，一般 virtualbox 中默认就为该模式，也默认就帮设置好了网络，用户直接安装完虚拟机操作系统即可上网，如果不行通过安装相关扩展工具即可。如果不小心将如上图所示的Virtual Network Editor 中的内容或者第一张图所示中的网卡配置改乱了，则可以点击上图左下角的 Restore Default 恢复网络设置。\n\n需要特殊使用情况，虚拟机需要连接其他实体设备时，采用桥接模式，需要注意的是：如果路由器无法自动分配IP地址，桥接需要配置 IP 地址，先查看网关地址，然后找一个无法 ping 通的 IP 地址，设置成静态 IP。\n\nHost-only 模式暂时没有怎么用过，一般而言就是为了只让虚拟机和实体机链接使用，也为了屏蔽外部网络的干扰，创建一个纯净的内部实验环境，如果你需要在虚拟机中构建一台服务器，实验搭建服务环境的话，可以先设置成这种模式。\n\n\n\n***\nTo be continued...\n\n> 参考链接：\n> http://blog.csdn.net/bloghome/article/details/4487497\n> http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html\n> http://os.51cto.com/art/201003/186914.htm\n> http://www.cnblogs.com/rainman/archive/2013/05/06/3063925.html\n","source":"_posts/2016/2016-07-25-桥接、nat、host-only上网方式的区别.md","raw":"---\nlayout: \"post\"\ntitle: \"桥接、NAT、Host-only上网方式的区别\"\ndate: \"2016-07-25 13:53\"\n---\n\n*经常使用虚拟机的小伙伴们都遇到过网络链接过程中的各种问题，仔细查看设置会发现有：桥接、NAT、Host-only 等设置，vmware 等虚拟机后还会自动生成vmnet1和vmnet8，初学者可能会一头雾水，为啥只有两个？不是三种模式吗？另外每个模式代表什么？他们又有什么区别？无论是 vmware 还是 vitualbox 这些内容都大同小异，而 vmware 中看起来可能会更加直观些，这边以windows下的安装使用为例，进行深入的详解。*\n\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/0.png)\n\n**本文会尽可能详细地总结和罗列出三者的含义和区别，以及虚拟机中该如何配置他们更加合适。**\n\n\n### 桥接:\n\n简而言之桥接就是指：**就是通过一台设备（可能不止一个）把几个网络串起来形成的连接**。这边主要介绍虚拟机所采用的桥接方式，虚拟出来的操作系统就像是局域网中的一独立的主机，它可以通过路由器网线访问网内任何一台机器。不过虚拟机需要占用你同一个网段的一个 IP 地址，当且仅当虚拟机和实体机在同一个网段，两者才可以进行通信，如：*虚拟机 IP：192.168.1.101，实体机 IP：192.168.1.100*。\n\n在桥接模式下，例如在 windows 下使用 vmware 时，明显看到会生成多个虚拟网卡出来，但却没有一个网卡是属于桥接的，原因是虚拟机采用桥接方式时，是不需要虚拟网卡的，这时候*虚拟机操作系统和实体机操作系统同时使用真实网卡工作，然后真是网卡发送数据出去，而如果虚拟机发送数据给真实机，则数据流向是：**虚拟机系统->真实网卡->路由器->真实网卡->实体机系统**，不难看出同一个数据经过网卡在路由器上面绕了一圈又回到了网卡。*\n\n通过上述内容发现，桥接必须经过真实网卡和路由器，因此当你的电脑没有链接有线网或者无线网的话，你的实体机是无法和虚拟机进行交互的，即便看起来两者很近也不行。*而选用桥接还是 NAT 等方式是在虚拟机软件中选定，进入虚拟的操作系统后，所有的设置和真实电脑没有本质区别，如果路由器允许自动分配 IP 地址，则操作系统设置为自动获取 IP 即可，如果不能自动分配，也可以在操作系统中手动分配 IP 地址。另外值得注意的是*某些公司路由器绑定了电脑 mac 地址和 IP 地址，这时候虚拟机中的桥接也相当于一个真实电脑，也需要完成相关的绑定才可以访问网络。*\n\n可以看出：如果你想利用VMware在局域网内新建一个虚拟服务器，为局域网用户提供网络服务，就应该选择桥接模式。下面举个栗子：\n\n```\n例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的 wanip 就不理会了，这个 ip 是动态获取的，而一般lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的 ip 是:\n\nA: 192.168.1.100/255.255.255.0,  B: 192.168.1.101/255.255.255.0,  C: 192.168.1.102/255.255.255.0,  D: 192.168.1.103/255.255.255.0\n\n那么虚拟机的 ip 可以设置的 ip 地址是 192.168.1.2-192.168.1.99, 192.168.1.104-192.168.1.254 (网络地址 0 和 1 的除外，再除去 ABCD 四个人的 ip 地址)\n\n那么虚拟机的 ip 地址可以设置为 192.168.1.98/255.255.255.0,设置了这个 ip 地址，ABCD 这四个人就可以通过 192.168.1.98 访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是 192.168.1.1 了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个 dns 服务器，我们可以简单点，把 dns 服务器地址配置为 google 的 dns 服务器 :8.8.8.8，到此，虚拟机就可以上网了。\n```\n\n综上所述，*同一个数据经过网卡在路由器上面绕了一圈又回到了网卡。*而虚拟机的桥接也只在其他电脑需要访问你电脑的虚拟机时，或者你虚拟机需要访问其他外部设备时才有相关需求*，一般情况还是建议配置成操作方便使用简单的 NAT 方式。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/1.png)\n\n<!-- more -->\n\n\n### NAT:\n\n*NAT模式实际是虚拟了一个网卡出来，虚拟机直接使用链接这个虚拟网卡，每次访问和交互通过这个虚拟网卡交换数据。虚拟机发送数据给实体机：**虚拟机系统->虚拟网卡->实体机系统**（可以发现是不经过真实网卡的流程简单很多）；虚拟机访问外网：**虚拟机系统->虚拟网卡->实体机系统->真实网卡->路由器->外网** 。*\n\n虚拟机借助 NAT (网络地址转换)功能，通过宿主机器所在的网络来访问公网。 NAT 模式中，虚拟机的网卡和真实网卡的网络，不需要在同一个网络，虚拟机的网卡的网段可以理解：路由器所在网段之下的一个子网段。\n\n采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。如果你想利用VMWare安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议你采用NAT模式。而缺点是： NAT 模式下，虚拟机仅仅可以同路由器下网段中的一台真实机通讯，而这台真实机就是安装虚拟机的这台电脑，之所以可以通讯是因为这台电脑本身充当了虚拟机的路由器，相当于路由器的 192.168.1.1 这个地址，而你在 vmware 下的网卡管理中是可以看到这个地址的。这边再补充一点：*采用NAT模式时，虚拟机和实体机交互并不是直接进行的，首先虚拟机操作系统访问虚拟网卡 VMnet8 （地址如： 192.188.1.33），然后这个虚拟网卡会再将数据提交给真实机操作系统VMware Network Adapter VMnet8（地址： 192.188.1.1）而地址（192.188.1.33 和 192.188.1.1）实际都是由虚拟机软件 vmware 提供的，具体的交互细节不作研究。*\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/2.png)\n\n### Host-only:\n\n在 Host-Only 模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实 Host-Only 网络和 NAT 网络很相似，不同的地方就是 Host-Only 网络没有 NAT 服务，所以虚拟网络不能连接到 Internet 。主机和虚拟机之间的通信是通过 VMware Network Adepter VMnet1 虚拟网卡来实现的。\n\nHost-Only 的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为 VMnet1 网段提供路由功能，那就需要使用RRAS，而不能使用 XP 或 2000 的 ICS，因为 ICS 会把内网的 IP 地址改为 192.168.0.1，但虚拟机是不会给 VMnet1 虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/3.png)\n\n### windows下的vmware：\n\nVMware 的几个虚拟设备：\n\n- VMnet0：这是 VMware 用于虚拟桥接网络下的虚拟交换机，一般是不可见的，因为桥接一般直接使用真实网卡；\n- VMnet1：这是 VMware 用于虚拟Host-Only网络下的虚拟交换机；\n- VMnet8：这是 VMware 用于虚拟NAT网络下的虚拟交换机；\n- VMware Network Adapter VMnet1：这是 Host 用于与 Host-Only 虚拟网络进行通信的虚拟网卡；\n- VMware Network Adapter VMnet8：这是 Host 用于与 NAT 虚拟网络进行通信的虚拟网卡；\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/4.png)\n\n*事实上，根据上面对三种常见模式的详细，基本上应该已经有了清晰的认识，知道如何配置虚拟机网卡了。*\n\n### 配置建议：\n\n在普通常规虚拟机联网时，采用 NAT 的模式，一般 virtualbox 中默认就为该模式，也默认就帮设置好了网络，用户直接安装完虚拟机操作系统即可上网，如果不行通过安装相关扩展工具即可。如果不小心将如上图所示的Virtual Network Editor 中的内容或者第一张图所示中的网卡配置改乱了，则可以点击上图左下角的 Restore Default 恢复网络设置。\n\n需要特殊使用情况，虚拟机需要连接其他实体设备时，采用桥接模式，需要注意的是：如果路由器无法自动分配IP地址，桥接需要配置 IP 地址，先查看网关地址，然后找一个无法 ping 通的 IP 地址，设置成静态 IP。\n\nHost-only 模式暂时没有怎么用过，一般而言就是为了只让虚拟机和实体机链接使用，也为了屏蔽外部网络的干扰，创建一个纯净的内部实验环境，如果你需要在虚拟机中构建一台服务器，实验搭建服务环境的话，可以先设置成这种模式。\n\n\n\n***\nTo be continued...\n\n> 参考链接：\n> http://blog.csdn.net/bloghome/article/details/4487497\n> http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html\n> http://os.51cto.com/art/201003/186914.htm\n> http://www.cnblogs.com/rainman/archive/2013/05/06/3063925.html\n","slug":"2016/2016-07-25-桥接、nat、host-only上网方式的区别","published":1,"updated":"2017-01-12T05:33:07.931Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahd0020mumu3qc6w2pa","content":"<p><em>经常使用虚拟机的小伙伴们都遇到过网络链接过程中的各种问题，仔细查看设置会发现有：桥接、NAT、Host-only 等设置，vmware 等虚拟机后还会自动生成vmnet1和vmnet8，初学者可能会一头雾水，为啥只有两个？不是三种模式吗？另外每个模式代表什么？他们又有什么区别？无论是 vmware 还是 vitualbox 这些内容都大同小异，而 vmware 中看起来可能会更加直观些，这边以windows下的安装使用为例，进行深入的详解。</em></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/0.png\" alt=\"\"></p>\n<p><strong>本文会尽可能详细地总结和罗列出三者的含义和区别，以及虚拟机中该如何配置他们更加合适。</strong></p>\n<h3 id=\"桥接\"><a href=\"#桥接\" class=\"headerlink\" title=\"桥接:\"></a>桥接:</h3><p>简而言之桥接就是指：<strong>就是通过一台设备（可能不止一个）把几个网络串起来形成的连接</strong>。这边主要介绍虚拟机所采用的桥接方式，虚拟出来的操作系统就像是局域网中的一独立的主机，它可以通过路由器网线访问网内任何一台机器。不过虚拟机需要占用你同一个网段的一个 IP 地址，当且仅当虚拟机和实体机在同一个网段，两者才可以进行通信，如：<em>虚拟机 IP：192.168.1.101，实体机 IP：192.168.1.100</em>。</p>\n<p>在桥接模式下，例如在 windows 下使用 vmware 时，明显看到会生成多个虚拟网卡出来，但却没有一个网卡是属于桥接的，原因是虚拟机采用桥接方式时，是不需要虚拟网卡的，这时候<em>虚拟机操作系统和实体机操作系统同时使用真实网卡工作，然后真是网卡发送数据出去，而如果虚拟机发送数据给真实机，则数据流向是：<strong>虚拟机系统-&gt;真实网卡-&gt;路由器-&gt;真实网卡-&gt;实体机系统</strong>，不难看出同一个数据经过网卡在路由器上面绕了一圈又回到了网卡。</em></p>\n<p>通过上述内容发现，桥接必须经过真实网卡和路由器，因此当你的电脑没有链接有线网或者无线网的话，你的实体机是无法和虚拟机进行交互的，即便看起来两者很近也不行。<em>而选用桥接还是 NAT 等方式是在虚拟机软件中选定，进入虚拟的操作系统后，所有的设置和真实电脑没有本质区别，如果路由器允许自动分配 IP 地址，则操作系统设置为自动获取 IP 即可，如果不能自动分配，也可以在操作系统中手动分配 IP 地址。另外值得注意的是</em>某些公司路由器绑定了电脑 mac 地址和 IP 地址，这时候虚拟机中的桥接也相当于一个真实电脑，也需要完成相关的绑定才可以访问网络。*</p>\n<p>可以看出：如果你想利用VMware在局域网内新建一个虚拟服务器，为局域网用户提供网络服务，就应该选择桥接模式。下面举个栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的 wanip 就不理会了，这个 ip 是动态获取的，而一般lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的 ip 是:</div><div class=\"line\"></div><div class=\"line\">A: 192.168.1.100/255.255.255.0,  B: 192.168.1.101/255.255.255.0,  C: 192.168.1.102/255.255.255.0,  D: 192.168.1.103/255.255.255.0</div><div class=\"line\"></div><div class=\"line\">那么虚拟机的 ip 可以设置的 ip 地址是 192.168.1.2-192.168.1.99, 192.168.1.104-192.168.1.254 (网络地址 0 和 1 的除外，再除去 ABCD 四个人的 ip 地址)</div><div class=\"line\"></div><div class=\"line\">那么虚拟机的 ip 地址可以设置为 192.168.1.98/255.255.255.0,设置了这个 ip 地址，ABCD 这四个人就可以通过 192.168.1.98 访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是 192.168.1.1 了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个 dns 服务器，我们可以简单点，把 dns 服务器地址配置为 google 的 dns 服务器 :8.8.8.8，到此，虚拟机就可以上网了。</div></pre></td></tr></table></figure>\n<p>综上所述，<em>同一个数据经过网卡在路由器上面绕了一圈又回到了网卡。</em>而虚拟机的桥接也只在其他电脑需要访问你电脑的虚拟机时，或者你虚拟机需要访问其他外部设备时才有相关需求*，一般情况还是建议配置成操作方便使用简单的 NAT 方式。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/1.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"NAT\"><a href=\"#NAT\" class=\"headerlink\" title=\"NAT:\"></a>NAT:</h3><p><em>NAT模式实际是虚拟了一个网卡出来，虚拟机直接使用链接这个虚拟网卡，每次访问和交互通过这个虚拟网卡交换数据。虚拟机发送数据给实体机：<strong>虚拟机系统-&gt;虚拟网卡-&gt;实体机系统</strong>（可以发现是不经过真实网卡的流程简单很多）；虚拟机访问外网：<strong>虚拟机系统-&gt;虚拟网卡-&gt;实体机系统-&gt;真实网卡-&gt;路由器-&gt;外网</strong> 。</em></p>\n<p>虚拟机借助 NAT (网络地址转换)功能，通过宿主机器所在的网络来访问公网。 NAT 模式中，虚拟机的网卡和真实网卡的网络，不需要在同一个网络，虚拟机的网卡的网段可以理解：路由器所在网段之下的一个子网段。</p>\n<p>采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。如果你想利用VMWare安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议你采用NAT模式。而缺点是： NAT 模式下，虚拟机仅仅可以同路由器下网段中的一台真实机通讯，而这台真实机就是安装虚拟机的这台电脑，之所以可以通讯是因为这台电脑本身充当了虚拟机的路由器，相当于路由器的 192.168.1.1 这个地址，而你在 vmware 下的网卡管理中是可以看到这个地址的。这边再补充一点：<em>采用NAT模式时，虚拟机和实体机交互并不是直接进行的，首先虚拟机操作系统访问虚拟网卡 VMnet8 （地址如： 192.188.1.33），然后这个虚拟网卡会再将数据提交给真实机操作系统VMware Network Adapter VMnet8（地址： 192.188.1.1）而地址（192.188.1.33 和 192.188.1.1）实际都是由虚拟机软件 vmware 提供的，具体的交互细节不作研究。</em></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/2.png\" alt=\"\"></p>\n<h3 id=\"Host-only\"><a href=\"#Host-only\" class=\"headerlink\" title=\"Host-only:\"></a>Host-only:</h3><p>在 Host-Only 模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实 Host-Only 网络和 NAT 网络很相似，不同的地方就是 Host-Only 网络没有 NAT 服务，所以虚拟网络不能连接到 Internet 。主机和虚拟机之间的通信是通过 VMware Network Adepter VMnet1 虚拟网卡来实现的。</p>\n<p>Host-Only 的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为 VMnet1 网段提供路由功能，那就需要使用RRAS，而不能使用 XP 或 2000 的 ICS，因为 ICS 会把内网的 IP 地址改为 192.168.0.1，但虚拟机是不会给 VMnet1 虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/3.png\" alt=\"\"></p>\n<h3 id=\"windows下的vmware：\"><a href=\"#windows下的vmware：\" class=\"headerlink\" title=\"windows下的vmware：\"></a>windows下的vmware：</h3><p>VMware 的几个虚拟设备：</p>\n<ul>\n<li>VMnet0：这是 VMware 用于虚拟桥接网络下的虚拟交换机，一般是不可见的，因为桥接一般直接使用真实网卡；</li>\n<li>VMnet1：这是 VMware 用于虚拟Host-Only网络下的虚拟交换机；</li>\n<li>VMnet8：这是 VMware 用于虚拟NAT网络下的虚拟交换机；</li>\n<li>VMware Network Adapter VMnet1：这是 Host 用于与 Host-Only 虚拟网络进行通信的虚拟网卡；</li>\n<li>VMware Network Adapter VMnet8：这是 Host 用于与 NAT 虚拟网络进行通信的虚拟网卡；</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/4.png\" alt=\"\"></p>\n<p><em>事实上，根据上面对三种常见模式的详细，基本上应该已经有了清晰的认识，知道如何配置虚拟机网卡了。</em></p>\n<h3 id=\"配置建议：\"><a href=\"#配置建议：\" class=\"headerlink\" title=\"配置建议：\"></a>配置建议：</h3><p>在普通常规虚拟机联网时，采用 NAT 的模式，一般 virtualbox 中默认就为该模式，也默认就帮设置好了网络，用户直接安装完虚拟机操作系统即可上网，如果不行通过安装相关扩展工具即可。如果不小心将如上图所示的Virtual Network Editor 中的内容或者第一张图所示中的网卡配置改乱了，则可以点击上图左下角的 Restore Default 恢复网络设置。</p>\n<p>需要特殊使用情况，虚拟机需要连接其他实体设备时，采用桥接模式，需要注意的是：如果路由器无法自动分配IP地址，桥接需要配置 IP 地址，先查看网关地址，然后找一个无法 ping 通的 IP 地址，设置成静态 IP。</p>\n<p>Host-only 模式暂时没有怎么用过，一般而言就是为了只让虚拟机和实体机链接使用，也为了屏蔽外部网络的干扰，创建一个纯净的内部实验环境，如果你需要在虚拟机中构建一台服务器，实验搭建服务环境的话，可以先设置成这种模式。</p>\n<hr>\n<p>To be continued…</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/bloghome/article/details/4487497\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/bloghome/article/details/4487497</a><br><a href=\"http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html</a><br><a href=\"http://os.51cto.com/art/201003/186914.htm\" target=\"_blank\" rel=\"external\">http://os.51cto.com/art/201003/186914.htm</a><br><a href=\"http://www.cnblogs.com/rainman/archive/2013/05/06/3063925.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/rainman/archive/2013/05/06/3063925.html</a></p>\n</blockquote>\n","excerpt":"<p><em>经常使用虚拟机的小伙伴们都遇到过网络链接过程中的各种问题，仔细查看设置会发现有：桥接、NAT、Host-only 等设置，vmware 等虚拟机后还会自动生成vmnet1和vmnet8，初学者可能会一头雾水，为啥只有两个？不是三种模式吗？另外每个模式代表什么？他们又有什么区别？无论是 vmware 还是 vitualbox 这些内容都大同小异，而 vmware 中看起来可能会更加直观些，这边以windows下的安装使用为例，进行深入的详解。</em></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/0.png\" alt=\"\"></p>\n<p><strong>本文会尽可能详细地总结和罗列出三者的含义和区别，以及虚拟机中该如何配置他们更加合适。</strong></p>\n<h3 id=\"桥接\"><a href=\"#桥接\" class=\"headerlink\" title=\"桥接:\"></a>桥接:</h3><p>简而言之桥接就是指：<strong>就是通过一台设备（可能不止一个）把几个网络串起来形成的连接</strong>。这边主要介绍虚拟机所采用的桥接方式，虚拟出来的操作系统就像是局域网中的一独立的主机，它可以通过路由器网线访问网内任何一台机器。不过虚拟机需要占用你同一个网段的一个 IP 地址，当且仅当虚拟机和实体机在同一个网段，两者才可以进行通信，如：<em>虚拟机 IP：192.168.1.101，实体机 IP：192.168.1.100</em>。</p>\n<p>在桥接模式下，例如在 windows 下使用 vmware 时，明显看到会生成多个虚拟网卡出来，但却没有一个网卡是属于桥接的，原因是虚拟机采用桥接方式时，是不需要虚拟网卡的，这时候<em>虚拟机操作系统和实体机操作系统同时使用真实网卡工作，然后真是网卡发送数据出去，而如果虚拟机发送数据给真实机，则数据流向是：<strong>虚拟机系统-&gt;真实网卡-&gt;路由器-&gt;真实网卡-&gt;实体机系统</strong>，不难看出同一个数据经过网卡在路由器上面绕了一圈又回到了网卡。</em></p>\n<p>通过上述内容发现，桥接必须经过真实网卡和路由器，因此当你的电脑没有链接有线网或者无线网的话，你的实体机是无法和虚拟机进行交互的，即便看起来两者很近也不行。<em>而选用桥接还是 NAT 等方式是在虚拟机软件中选定，进入虚拟的操作系统后，所有的设置和真实电脑没有本质区别，如果路由器允许自动分配 IP 地址，则操作系统设置为自动获取 IP 即可，如果不能自动分配，也可以在操作系统中手动分配 IP 地址。另外值得注意的是</em>某些公司路由器绑定了电脑 mac 地址和 IP 地址，这时候虚拟机中的桥接也相当于一个真实电脑，也需要完成相关的绑定才可以访问网络。*</p>\n<p>可以看出：如果你想利用VMware在局域网内新建一个虚拟服务器，为局域网用户提供网络服务，就应该选择桥接模式。下面举个栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的 wanip 就不理会了，这个 ip 是动态获取的，而一般lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的 ip 是:</div><div class=\"line\"></div><div class=\"line\">A: 192.168.1.100/255.255.255.0,  B: 192.168.1.101/255.255.255.0,  C: 192.168.1.102/255.255.255.0,  D: 192.168.1.103/255.255.255.0</div><div class=\"line\"></div><div class=\"line\">那么虚拟机的 ip 可以设置的 ip 地址是 192.168.1.2-192.168.1.99, 192.168.1.104-192.168.1.254 (网络地址 0 和 1 的除外，再除去 ABCD 四个人的 ip 地址)</div><div class=\"line\"></div><div class=\"line\">那么虚拟机的 ip 地址可以设置为 192.168.1.98/255.255.255.0,设置了这个 ip 地址，ABCD 这四个人就可以通过 192.168.1.98 访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是 192.168.1.1 了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个 dns 服务器，我们可以简单点，把 dns 服务器地址配置为 google 的 dns 服务器 :8.8.8.8，到此，虚拟机就可以上网了。</div></pre></td></tr></table></figure>\n<p>综上所述，<em>同一个数据经过网卡在路由器上面绕了一圈又回到了网卡。</em>而虚拟机的桥接也只在其他电脑需要访问你电脑的虚拟机时，或者你虚拟机需要访问其他外部设备时才有相关需求*，一般情况还是建议配置成操作方便使用简单的 NAT 方式。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/1.png\" alt=\"\"></p>","more":"<h3 id=\"NAT\"><a href=\"#NAT\" class=\"headerlink\" title=\"NAT:\"></a>NAT:</h3><p><em>NAT模式实际是虚拟了一个网卡出来，虚拟机直接使用链接这个虚拟网卡，每次访问和交互通过这个虚拟网卡交换数据。虚拟机发送数据给实体机：<strong>虚拟机系统-&gt;虚拟网卡-&gt;实体机系统</strong>（可以发现是不经过真实网卡的流程简单很多）；虚拟机访问外网：<strong>虚拟机系统-&gt;虚拟网卡-&gt;实体机系统-&gt;真实网卡-&gt;路由器-&gt;外网</strong> 。</em></p>\n<p>虚拟机借助 NAT (网络地址转换)功能，通过宿主机器所在的网络来访问公网。 NAT 模式中，虚拟机的网卡和真实网卡的网络，不需要在同一个网络，虚拟机的网卡的网段可以理解：路由器所在网段之下的一个子网段。</p>\n<p>采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。如果你想利用VMWare安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议你采用NAT模式。而缺点是： NAT 模式下，虚拟机仅仅可以同路由器下网段中的一台真实机通讯，而这台真实机就是安装虚拟机的这台电脑，之所以可以通讯是因为这台电脑本身充当了虚拟机的路由器，相当于路由器的 192.168.1.1 这个地址，而你在 vmware 下的网卡管理中是可以看到这个地址的。这边再补充一点：<em>采用NAT模式时，虚拟机和实体机交互并不是直接进行的，首先虚拟机操作系统访问虚拟网卡 VMnet8 （地址如： 192.188.1.33），然后这个虚拟网卡会再将数据提交给真实机操作系统VMware Network Adapter VMnet8（地址： 192.188.1.1）而地址（192.188.1.33 和 192.188.1.1）实际都是由虚拟机软件 vmware 提供的，具体的交互细节不作研究。</em></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/2.png\" alt=\"\"></p>\n<h3 id=\"Host-only\"><a href=\"#Host-only\" class=\"headerlink\" title=\"Host-only:\"></a>Host-only:</h3><p>在 Host-Only 模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实 Host-Only 网络和 NAT 网络很相似，不同的地方就是 Host-Only 网络没有 NAT 服务，所以虚拟网络不能连接到 Internet 。主机和虚拟机之间的通信是通过 VMware Network Adepter VMnet1 虚拟网卡来实现的。</p>\n<p>Host-Only 的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为 VMnet1 网段提供路由功能，那就需要使用RRAS，而不能使用 XP 或 2000 的 ICS，因为 ICS 会把内网的 IP 地址改为 192.168.0.1，但虚拟机是不会给 VMnet1 虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/3.png\" alt=\"\"></p>\n<h3 id=\"windows下的vmware：\"><a href=\"#windows下的vmware：\" class=\"headerlink\" title=\"windows下的vmware：\"></a>windows下的vmware：</h3><p>VMware 的几个虚拟设备：</p>\n<ul>\n<li>VMnet0：这是 VMware 用于虚拟桥接网络下的虚拟交换机，一般是不可见的，因为桥接一般直接使用真实网卡；</li>\n<li>VMnet1：这是 VMware 用于虚拟Host-Only网络下的虚拟交换机；</li>\n<li>VMnet8：这是 VMware 用于虚拟NAT网络下的虚拟交换机；</li>\n<li>VMware Network Adapter VMnet1：这是 Host 用于与 Host-Only 虚拟网络进行通信的虚拟网卡；</li>\n<li>VMware Network Adapter VMnet8：这是 Host 用于与 NAT 虚拟网络进行通信的虚拟网卡；</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/4.png\" alt=\"\"></p>\n<p><em>事实上，根据上面对三种常见模式的详细，基本上应该已经有了清晰的认识，知道如何配置虚拟机网卡了。</em></p>\n<h3 id=\"配置建议：\"><a href=\"#配置建议：\" class=\"headerlink\" title=\"配置建议：\"></a>配置建议：</h3><p>在普通常规虚拟机联网时，采用 NAT 的模式，一般 virtualbox 中默认就为该模式，也默认就帮设置好了网络，用户直接安装完虚拟机操作系统即可上网，如果不行通过安装相关扩展工具即可。如果不小心将如上图所示的Virtual Network Editor 中的内容或者第一张图所示中的网卡配置改乱了，则可以点击上图左下角的 Restore Default 恢复网络设置。</p>\n<p>需要特殊使用情况，虚拟机需要连接其他实体设备时，采用桥接模式，需要注意的是：如果路由器无法自动分配IP地址，桥接需要配置 IP 地址，先查看网关地址，然后找一个无法 ping 通的 IP 地址，设置成静态 IP。</p>\n<p>Host-only 模式暂时没有怎么用过，一般而言就是为了只让虚拟机和实体机链接使用，也为了屏蔽外部网络的干扰，创建一个纯净的内部实验环境，如果你需要在虚拟机中构建一台服务器，实验搭建服务环境的话，可以先设置成这种模式。</p>\n<hr>\n<p>To be continued…</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/bloghome/article/details/4487497\">http://blog.csdn.net/bloghome/article/details/4487497</a><br><a href=\"http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html\">http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html</a><br><a href=\"http://os.51cto.com/art/201003/186914.htm\">http://os.51cto.com/art/201003/186914.htm</a><br><a href=\"http://www.cnblogs.com/rainman/archive/2013/05/06/3063925.html\">http://www.cnblogs.com/rainman/archive/2013/05/06/3063925.html</a></p>\n</blockquote>"},{"layout":"post","title":"架设自己的git服务","date":"2016-07-29T04:22:00.000Z","_content":"\n\n*本实验使用的是实体机 ubuntu 16.04 和虚拟机 virtualbox 搭建 ubuntu—server 16.04 系统进行连接，其中用 ubuntu-server 搭建 git，实体机 ubuntu desktop 连接 ubuntu-server，后续如果有其他环境也会逐一补充。*\n\n**这边暂时没有在实体机上面尝试，先列举出在虚拟机上面架设 git 服务器**\n\n### 使用 ssh 登陆 ubuntu-server\n\n#### ping 通两个系统：\n\n看是否可以 ping 通两个系统，首先查看 ip 地址，`ifconfig`， 例如主机是： 192.168.18.60 ，虚拟机是 192.168.18.202。则在主机中 ping 192.168.18.60 ，当然事情往往并不会一帆风顺，很多设置的时候，为了可以链接外网，虚拟机选用了 NAT 模式。*貌似该模式无法使用ssh服务，虚拟机可以 ping 通主机，但主机无法 ping 通虚拟机。*这时候可以使用几种方法：\n\n- 更改虚拟机模式为桥接模式，弃用原来的 NAT 模式。\n- 使用实体机中的虚拟机网卡与虚拟机进行交互，但貌似 ubuntu 下面并无法找到这块虚拟网卡，解决办法可以手动建立一个虚拟网卡。\n- 创建一个新的链接方式，通过这个桥接到实体机，然后通过 NAT 访问外网。*这边详细介绍这种方式*\n\n详细步骤：\n\n- 使用 virtualbox 新建一个新的 adapter，选用 bridge adapter。如下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-2011.png)\n\n- 重启虚拟机系统，或者重启网络服务 `sudo /etc/init.d/networking restart` ，ifconfig -a 查看所有网卡，可以看到虚拟机中有一个网卡 enp0s8 并没有被使用，这个就是刚刚新建的那个桥接网卡。\n- 设置该网卡，修改/etc/network/interfaces文件，如下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-4326.png)\n\n- 重启网络服务 `sudo /etc/init.d/networking restart`，ifconfig 查看网卡。如下图：\n-\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-4534.png)\n\n- 接着基本就可以尝试 ping 通两个系统了，实体机中使用 ping 192.168.18.202，虚拟机中 ping 192.168.18.60 。如果仍然不行可以尝试关闭防火墙：`sudo ufw disable`。\n\n\n<!-- more -->\n\n\n#### 尝试ssh服务：\n\n*本步骤主要是建立链接，安装 ssh 服务，然后连接实体机可以登陆 ubuntu-server。因为这边 git 采用了 ssh 与服务器进行交互，所以 ssh 在这边是必须的。*\n\n- 实体机和虚拟机，两个操作系统必须要同时安装 ssh 服务，如果只有实体机安装会出现链接失败。安装指令都是： `sudo apt-get install ssh或sudo apt-get install openssh-server`，`sudo /etc/init.d/ssh restart` 重启 ssh 服务。\n- 查看ssh服务是否启动, `ps –e | grep ssh`，响应的 sshd 和 ssh-agent 如果未打开则运行指令名字。\n- 修改实体机的 ip 配置文件 `/ect/hosts`，加入如下行： `192.168.18.202 ubuntu_server`，ubuntu_server 是你的虚拟机的主机名称，而 ubuntu_server 以后将代替 192.168.18.202 出现。如果你的虚拟机名不是 ubuntu_server ,可以修改 /etc/hostname 中的名称。\n- 通过以上设置后，你的主机基本可以通过 ssh 访问虚拟机了，你可以在虚拟机新建一个用户 adduser git，然后实体机可以使用如下命令 `ssh git@ubuntu_server 或者 ssh git@192.168.18.202` 进行登陆，输入密码就可以进行相关操作了。\n\n补充：*如果 ssh 还不能登录上，就修改 sshd 的默认配置，例如： ssh 出现 permission denied (publickey) 问题:*\n\n```\n修改 /etc/ssh/sshd-config 文件.\n将其中的 PermitRootLogin no 修改为 yes\nPubkeyAuthentication yes 修改为 no\nAuthorizedKeysFile .ssh/authorized_keys 前面加上#屏蔽掉，\nPasswordAuthentication no 修改为 yes 就可以了。*\n```\n\n### git虚拟服务器搭建：\n\n*安装 git，可以使用命令 `sudo apt-get install git-core` 或者 `sudo apt-get install git*` 。\n\n- 在实体机上，我们使用命令： ssh-keygen –t rsa 生成密钥。秘钥在当前用户目录的 .ssh 目录下。\n- 在虚拟机的 git 目录下新建一个 .ssh 目录\n- 在 .ssh 目录下，我们可以看到 id_rsa 和 id_rsa.pub 文件，id_rsa.pub 为公钥，我们 通过命令 `scp /home/git/.ssh/id_rsa.pub git@ubuntu_server:/home/git/.ssh/authorized_keys`将实体机上生成的公钥拷贝到虚拟机的git账户目录下上。如果是要添加公钥可以使用使用命令 `cat /home/git/id_rsa.pub>>/home/git/.ssh/authorized_keys`\n- 使用命令 `git –-bare init /home/git/myRep.git` ,初始化化仓库。**注意一定需要建立一个 --bare 的裸库。**\n\n#### git操作\n\n*我们可以使用 `git clone git@gitServer:/home/git/myRep.git` 直接将库克隆下来，但一般推荐，在将本地库与远程库建立链接具体步骤如下：*\n\n- 在实体机中新建一个文件夹， `mkdir test` ，进入该文件夹 `cd test`\n- 初始化这个库， `git init`。\n- 随意添加几个文件，例如： `echo \"hello world\" >> test.txt`\n- 常规git操作，加入stage并提交， `git add .  &&  git commit -m \"test\" `\n- 查看下本地库的状态： git status\n- 一切正常的话，将远程库与本地库建立关系： `git remote add test git@ubuntu_server:/home/git/myRep.git`。这边的 test 为远程库的名称，默认一般为 origin，但如果你一个项目中同时有多个库，则建议你修改 origin 名称。\n- `git remote –v`，可查看版本库的网址，以及相关的库名称\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-1126.png)\n\n- 可以通过 `git push test master` 进行推送，注意这边远程库名为test而并不是默认的origin。也可以通过`git pull test master`对虚拟机中的远程库进行拉取。*注意因为不是默认名称，所以直接使用 git  push 或者 pull 会报错。*\n\n**注意严格按照上面步骤执行，git 操作，一步错，可能就需要你删除 .git 以及 git remote remove test 等相关系列的操作，或者可以删除整个目录重新开始。值得注意的是， git 建立出来的每个库是相互独立的，除非全局设置，否则在添加远程库或者修改其他设置时，都不会对其他库有任何影响。**\n\n**建立好库，并且也 push 等操作都成功了，但查看虚拟机中远程库的源文件却发现招不到任何一个文件，事实上， git 远程裸库仅仅保存修改记录和分支，并不是用来查看的，只有当你 clone 或者 pull 之后才可以查看某条分支的完整结构。**\n\n\n\n\n> 参考链接：\n> http://developer.51cto.com/art/201507/483448.htm\n> http://blog.sina.com.cn/s/blog_6ab9984801011k81.html\n> http://stackoverflow.com/questions/20252294/ssh-could-not-resolve-hostname-hostname-nodename-nor-servname-provided-or-n\n> http://www.cnblogs.com/xdzone/archive/2011/03/09/1978327.html\n> http://blog.csdn.net/zht666/article/details/9340633\n> http://blog.sina.com.cn/s/blog_5f435c130102v6pv.html\n> http://bbs.csdn.net/topics/390158779\n> http://blog.163.com/danshiming@126/blog/static/109412748201251211140194/\n","source":"_posts/2016/2016-07-29-架设自己的git服务.md","raw":"---\nlayout: \"post\"\ntitle: \"架设自己的git服务\"\ndate: \"2016-07-29 12:22\"\n---\n\n\n*本实验使用的是实体机 ubuntu 16.04 和虚拟机 virtualbox 搭建 ubuntu—server 16.04 系统进行连接，其中用 ubuntu-server 搭建 git，实体机 ubuntu desktop 连接 ubuntu-server，后续如果有其他环境也会逐一补充。*\n\n**这边暂时没有在实体机上面尝试，先列举出在虚拟机上面架设 git 服务器**\n\n### 使用 ssh 登陆 ubuntu-server\n\n#### ping 通两个系统：\n\n看是否可以 ping 通两个系统，首先查看 ip 地址，`ifconfig`， 例如主机是： 192.168.18.60 ，虚拟机是 192.168.18.202。则在主机中 ping 192.168.18.60 ，当然事情往往并不会一帆风顺，很多设置的时候，为了可以链接外网，虚拟机选用了 NAT 模式。*貌似该模式无法使用ssh服务，虚拟机可以 ping 通主机，但主机无法 ping 通虚拟机。*这时候可以使用几种方法：\n\n- 更改虚拟机模式为桥接模式，弃用原来的 NAT 模式。\n- 使用实体机中的虚拟机网卡与虚拟机进行交互，但貌似 ubuntu 下面并无法找到这块虚拟网卡，解决办法可以手动建立一个虚拟网卡。\n- 创建一个新的链接方式，通过这个桥接到实体机，然后通过 NAT 访问外网。*这边详细介绍这种方式*\n\n详细步骤：\n\n- 使用 virtualbox 新建一个新的 adapter，选用 bridge adapter。如下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-2011.png)\n\n- 重启虚拟机系统，或者重启网络服务 `sudo /etc/init.d/networking restart` ，ifconfig -a 查看所有网卡，可以看到虚拟机中有一个网卡 enp0s8 并没有被使用，这个就是刚刚新建的那个桥接网卡。\n- 设置该网卡，修改/etc/network/interfaces文件，如下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-4326.png)\n\n- 重启网络服务 `sudo /etc/init.d/networking restart`，ifconfig 查看网卡。如下图：\n-\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-4534.png)\n\n- 接着基本就可以尝试 ping 通两个系统了，实体机中使用 ping 192.168.18.202，虚拟机中 ping 192.168.18.60 。如果仍然不行可以尝试关闭防火墙：`sudo ufw disable`。\n\n\n<!-- more -->\n\n\n#### 尝试ssh服务：\n\n*本步骤主要是建立链接，安装 ssh 服务，然后连接实体机可以登陆 ubuntu-server。因为这边 git 采用了 ssh 与服务器进行交互，所以 ssh 在这边是必须的。*\n\n- 实体机和虚拟机，两个操作系统必须要同时安装 ssh 服务，如果只有实体机安装会出现链接失败。安装指令都是： `sudo apt-get install ssh或sudo apt-get install openssh-server`，`sudo /etc/init.d/ssh restart` 重启 ssh 服务。\n- 查看ssh服务是否启动, `ps –e | grep ssh`，响应的 sshd 和 ssh-agent 如果未打开则运行指令名字。\n- 修改实体机的 ip 配置文件 `/ect/hosts`，加入如下行： `192.168.18.202 ubuntu_server`，ubuntu_server 是你的虚拟机的主机名称，而 ubuntu_server 以后将代替 192.168.18.202 出现。如果你的虚拟机名不是 ubuntu_server ,可以修改 /etc/hostname 中的名称。\n- 通过以上设置后，你的主机基本可以通过 ssh 访问虚拟机了，你可以在虚拟机新建一个用户 adduser git，然后实体机可以使用如下命令 `ssh git@ubuntu_server 或者 ssh git@192.168.18.202` 进行登陆，输入密码就可以进行相关操作了。\n\n补充：*如果 ssh 还不能登录上，就修改 sshd 的默认配置，例如： ssh 出现 permission denied (publickey) 问题:*\n\n```\n修改 /etc/ssh/sshd-config 文件.\n将其中的 PermitRootLogin no 修改为 yes\nPubkeyAuthentication yes 修改为 no\nAuthorizedKeysFile .ssh/authorized_keys 前面加上#屏蔽掉，\nPasswordAuthentication no 修改为 yes 就可以了。*\n```\n\n### git虚拟服务器搭建：\n\n*安装 git，可以使用命令 `sudo apt-get install git-core` 或者 `sudo apt-get install git*` 。\n\n- 在实体机上，我们使用命令： ssh-keygen –t rsa 生成密钥。秘钥在当前用户目录的 .ssh 目录下。\n- 在虚拟机的 git 目录下新建一个 .ssh 目录\n- 在 .ssh 目录下，我们可以看到 id_rsa 和 id_rsa.pub 文件，id_rsa.pub 为公钥，我们 通过命令 `scp /home/git/.ssh/id_rsa.pub git@ubuntu_server:/home/git/.ssh/authorized_keys`将实体机上生成的公钥拷贝到虚拟机的git账户目录下上。如果是要添加公钥可以使用使用命令 `cat /home/git/id_rsa.pub>>/home/git/.ssh/authorized_keys`\n- 使用命令 `git –-bare init /home/git/myRep.git` ,初始化化仓库。**注意一定需要建立一个 --bare 的裸库。**\n\n#### git操作\n\n*我们可以使用 `git clone git@gitServer:/home/git/myRep.git` 直接将库克隆下来，但一般推荐，在将本地库与远程库建立链接具体步骤如下：*\n\n- 在实体机中新建一个文件夹， `mkdir test` ，进入该文件夹 `cd test`\n- 初始化这个库， `git init`。\n- 随意添加几个文件，例如： `echo \"hello world\" >> test.txt`\n- 常规git操作，加入stage并提交， `git add .  &&  git commit -m \"test\" `\n- 查看下本地库的状态： git status\n- 一切正常的话，将远程库与本地库建立关系： `git remote add test git@ubuntu_server:/home/git/myRep.git`。这边的 test 为远程库的名称，默认一般为 origin，但如果你一个项目中同时有多个库，则建议你修改 origin 名称。\n- `git remote –v`，可查看版本库的网址，以及相关的库名称\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-1126.png)\n\n- 可以通过 `git push test master` 进行推送，注意这边远程库名为test而并不是默认的origin。也可以通过`git pull test master`对虚拟机中的远程库进行拉取。*注意因为不是默认名称，所以直接使用 git  push 或者 pull 会报错。*\n\n**注意严格按照上面步骤执行，git 操作，一步错，可能就需要你删除 .git 以及 git remote remove test 等相关系列的操作，或者可以删除整个目录重新开始。值得注意的是， git 建立出来的每个库是相互独立的，除非全局设置，否则在添加远程库或者修改其他设置时，都不会对其他库有任何影响。**\n\n**建立好库，并且也 push 等操作都成功了，但查看虚拟机中远程库的源文件却发现招不到任何一个文件，事实上， git 远程裸库仅仅保存修改记录和分支，并不是用来查看的，只有当你 clone 或者 pull 之后才可以查看某条分支的完整结构。**\n\n\n\n\n> 参考链接：\n> http://developer.51cto.com/art/201507/483448.htm\n> http://blog.sina.com.cn/s/blog_6ab9984801011k81.html\n> http://stackoverflow.com/questions/20252294/ssh-could-not-resolve-hostname-hostname-nodename-nor-servname-provided-or-n\n> http://www.cnblogs.com/xdzone/archive/2011/03/09/1978327.html\n> http://blog.csdn.net/zht666/article/details/9340633\n> http://blog.sina.com.cn/s/blog_5f435c130102v6pv.html\n> http://bbs.csdn.net/topics/390158779\n> http://blog.163.com/danshiming@126/blog/static/109412748201251211140194/\n","slug":"2016/2016-07-29-架设自己的git服务","published":1,"updated":"2017-01-12T05:45:49.199Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahe0021mumu1sk281u5","content":"<p><em>本实验使用的是实体机 ubuntu 16.04 和虚拟机 virtualbox 搭建 ubuntu—server 16.04 系统进行连接，其中用 ubuntu-server 搭建 git，实体机 ubuntu desktop 连接 ubuntu-server，后续如果有其他环境也会逐一补充。</em></p>\n<p><strong>这边暂时没有在实体机上面尝试，先列举出在虚拟机上面架设 git 服务器</strong></p>\n<h3 id=\"使用-ssh-登陆-ubuntu-server\"><a href=\"#使用-ssh-登陆-ubuntu-server\" class=\"headerlink\" title=\"使用 ssh 登陆 ubuntu-server\"></a>使用 ssh 登陆 ubuntu-server</h3><h4 id=\"ping-通两个系统：\"><a href=\"#ping-通两个系统：\" class=\"headerlink\" title=\"ping 通两个系统：\"></a>ping 通两个系统：</h4><p>看是否可以 ping 通两个系统，首先查看 ip 地址，<code>ifconfig</code>， 例如主机是： 192.168.18.60 ，虚拟机是 192.168.18.202。则在主机中 ping 192.168.18.60 ，当然事情往往并不会一帆风顺，很多设置的时候，为了可以链接外网，虚拟机选用了 NAT 模式。<em>貌似该模式无法使用ssh服务，虚拟机可以 ping 通主机，但主机无法 ping 通虚拟机。</em>这时候可以使用几种方法：</p>\n<ul>\n<li>更改虚拟机模式为桥接模式，弃用原来的 NAT 模式。</li>\n<li>使用实体机中的虚拟机网卡与虚拟机进行交互，但貌似 ubuntu 下面并无法找到这块虚拟网卡，解决办法可以手动建立一个虚拟网卡。</li>\n<li>创建一个新的链接方式，通过这个桥接到实体机，然后通过 NAT 访问外网。<em>这边详细介绍这种方式</em></li>\n</ul>\n<p>详细步骤：</p>\n<ul>\n<li>使用 virtualbox 新建一个新的 adapter，选用 bridge adapter。如下图：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-2011.png\" alt=\"\"></p>\n<ul>\n<li>重启虚拟机系统，或者重启网络服务 <code>sudo /etc/init.d/networking restart</code> ，ifconfig -a 查看所有网卡，可以看到虚拟机中有一个网卡 enp0s8 并没有被使用，这个就是刚刚新建的那个桥接网卡。</li>\n<li>设置该网卡，修改/etc/network/interfaces文件，如下图：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-4326.png\" alt=\"\"></p>\n<ul>\n<li><p>重启网络服务 <code>sudo /etc/init.d/networking restart</code>，ifconfig 查看网卡。如下图：<br>-<br><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-4534.png\" alt=\"\"></p>\n</li>\n<li><p>接着基本就可以尝试 ping 通两个系统了，实体机中使用 ping 192.168.18.202，虚拟机中 ping 192.168.18.60 。如果仍然不行可以尝试关闭防火墙：<code>sudo ufw disable</code>。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"尝试ssh服务：\"><a href=\"#尝试ssh服务：\" class=\"headerlink\" title=\"尝试ssh服务：\"></a>尝试ssh服务：</h4><p><em>本步骤主要是建立链接，安装 ssh 服务，然后连接实体机可以登陆 ubuntu-server。因为这边 git 采用了 ssh 与服务器进行交互，所以 ssh 在这边是必须的。</em></p>\n<ul>\n<li>实体机和虚拟机，两个操作系统必须要同时安装 ssh 服务，如果只有实体机安装会出现链接失败。安装指令都是： <code>sudo apt-get install ssh或sudo apt-get install openssh-server</code>，<code>sudo /etc/init.d/ssh restart</code> 重启 ssh 服务。</li>\n<li>查看ssh服务是否启动, <code>ps –e | grep ssh</code>，响应的 sshd 和 ssh-agent 如果未打开则运行指令名字。</li>\n<li>修改实体机的 ip 配置文件 <code>/ect/hosts</code>，加入如下行： <code>192.168.18.202 ubuntu_server</code>，ubuntu_server 是你的虚拟机的主机名称，而 ubuntu_server 以后将代替 192.168.18.202 出现。如果你的虚拟机名不是 ubuntu_server ,可以修改 /etc/hostname 中的名称。</li>\n<li>通过以上设置后，你的主机基本可以通过 ssh 访问虚拟机了，你可以在虚拟机新建一个用户 adduser git，然后实体机可以使用如下命令 <code>ssh git@ubuntu_server 或者 ssh git@192.168.18.202</code> 进行登陆，输入密码就可以进行相关操作了。</li>\n</ul>\n<p>补充：<em>如果 ssh 还不能登录上，就修改 sshd 的默认配置，例如： ssh 出现 permission denied (publickey) 问题:</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">修改 /etc/ssh/sshd-config 文件.</div><div class=\"line\">将其中的 PermitRootLogin no 修改为 yes</div><div class=\"line\">PubkeyAuthentication yes 修改为 no</div><div class=\"line\">AuthorizedKeysFile .ssh/authorized_keys 前面加上#屏蔽掉，</div><div class=\"line\">PasswordAuthentication no 修改为 yes 就可以了。*</div></pre></td></tr></table></figure>\n<h3 id=\"git虚拟服务器搭建：\"><a href=\"#git虚拟服务器搭建：\" class=\"headerlink\" title=\"git虚拟服务器搭建：\"></a>git虚拟服务器搭建：</h3><p><em>安装 git，可以使用命令 <code>sudo apt-get install git-core</code> 或者 `sudo apt-get install git</em>` 。</p>\n<ul>\n<li>在实体机上，我们使用命令： ssh-keygen –t rsa 生成密钥。秘钥在当前用户目录的 .ssh 目录下。</li>\n<li>在虚拟机的 git 目录下新建一个 .ssh 目录</li>\n<li>在 .ssh 目录下，我们可以看到 id_rsa 和 id_rsa.pub 文件，id_rsa.pub 为公钥，我们 通过命令 <code>scp /home/git/.ssh/id_rsa.pub git@ubuntu_server:/home/git/.ssh/authorized_keys</code>将实体机上生成的公钥拷贝到虚拟机的git账户目录下上。如果是要添加公钥可以使用使用命令 <code>cat /home/git/id_rsa.pub&gt;&gt;/home/git/.ssh/authorized_keys</code></li>\n<li>使用命令 <code>git –-bare init /home/git/myRep.git</code> ,初始化化仓库。<strong>注意一定需要建立一个 –bare 的裸库。</strong></li>\n</ul>\n<h4 id=\"git操作\"><a href=\"#git操作\" class=\"headerlink\" title=\"git操作\"></a>git操作</h4><p><em>我们可以使用 <code>git clone git@gitServer:/home/git/myRep.git</code> 直接将库克隆下来，但一般推荐，在将本地库与远程库建立链接具体步骤如下：</em></p>\n<ul>\n<li>在实体机中新建一个文件夹， <code>mkdir test</code> ，进入该文件夹 <code>cd test</code></li>\n<li>初始化这个库， <code>git init</code>。</li>\n<li>随意添加几个文件，例如： <code>echo &quot;hello world&quot; &gt;&gt; test.txt</code></li>\n<li>常规git操作，加入stage并提交， <code>git add .  &amp;&amp;  git commit -m &quot;test&quot;</code></li>\n<li>查看下本地库的状态： git status</li>\n<li>一切正常的话，将远程库与本地库建立关系： <code>git remote add test git@ubuntu_server:/home/git/myRep.git</code>。这边的 test 为远程库的名称，默认一般为 origin，但如果你一个项目中同时有多个库，则建议你修改 origin 名称。</li>\n<li><code>git remote –v</code>，可查看版本库的网址，以及相关的库名称</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-1126.png\" alt=\"\"></p>\n<ul>\n<li>可以通过 <code>git push test master</code> 进行推送，注意这边远程库名为test而并不是默认的origin。也可以通过<code>git pull test master</code>对虚拟机中的远程库进行拉取。<em>注意因为不是默认名称，所以直接使用 git  push 或者 pull 会报错。</em></li>\n</ul>\n<p><strong>注意严格按照上面步骤执行，git 操作，一步错，可能就需要你删除 .git 以及 git remote remove test 等相关系列的操作，或者可以删除整个目录重新开始。值得注意的是， git 建立出来的每个库是相互独立的，除非全局设置，否则在添加远程库或者修改其他设置时，都不会对其他库有任何影响。</strong></p>\n<p><strong>建立好库，并且也 push 等操作都成功了，但查看虚拟机中远程库的源文件却发现招不到任何一个文件，事实上， git 远程裸库仅仅保存修改记录和分支，并不是用来查看的，只有当你 clone 或者 pull 之后才可以查看某条分支的完整结构。</strong></p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://developer.51cto.com/art/201507/483448.htm\" target=\"_blank\" rel=\"external\">http://developer.51cto.com/art/201507/483448.htm</a><br><a href=\"http://blog.sina.com.cn/s/blog_6ab9984801011k81.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_6ab9984801011k81.html</a><br><a href=\"http://stackoverflow.com/questions/20252294/ssh-could-not-resolve-hostname-hostname-nodename-nor-servname-provided-or-n\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/20252294/ssh-could-not-resolve-hostname-hostname-nodename-nor-servname-provided-or-n</a><br><a href=\"http://www.cnblogs.com/xdzone/archive/2011/03/09/1978327.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/xdzone/archive/2011/03/09/1978327.html</a><br><a href=\"http://blog.csdn.net/zht666/article/details/9340633\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/zht666/article/details/9340633</a><br><a href=\"http://blog.sina.com.cn/s/blog_5f435c130102v6pv.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_5f435c130102v6pv.html</a><br><a href=\"http://bbs.csdn.net/topics/390158779\" target=\"_blank\" rel=\"external\">http://bbs.csdn.net/topics/390158779</a><br><a href=\"http://blog.163.com/danshiming@126/blog/static/109412748201251211140194/\" target=\"_blank\" rel=\"external\">http://blog.163.com/danshiming@126/blog/static/109412748201251211140194/</a></p>\n</blockquote>\n","excerpt":"<p><em>本实验使用的是实体机 ubuntu 16.04 和虚拟机 virtualbox 搭建 ubuntu—server 16.04 系统进行连接，其中用 ubuntu-server 搭建 git，实体机 ubuntu desktop 连接 ubuntu-server，后续如果有其他环境也会逐一补充。</em></p>\n<p><strong>这边暂时没有在实体机上面尝试，先列举出在虚拟机上面架设 git 服务器</strong></p>\n<h3 id=\"使用-ssh-登陆-ubuntu-server\"><a href=\"#使用-ssh-登陆-ubuntu-server\" class=\"headerlink\" title=\"使用 ssh 登陆 ubuntu-server\"></a>使用 ssh 登陆 ubuntu-server</h3><h4 id=\"ping-通两个系统：\"><a href=\"#ping-通两个系统：\" class=\"headerlink\" title=\"ping 通两个系统：\"></a>ping 通两个系统：</h4><p>看是否可以 ping 通两个系统，首先查看 ip 地址，<code>ifconfig</code>， 例如主机是： 192.168.18.60 ，虚拟机是 192.168.18.202。则在主机中 ping 192.168.18.60 ，当然事情往往并不会一帆风顺，很多设置的时候，为了可以链接外网，虚拟机选用了 NAT 模式。<em>貌似该模式无法使用ssh服务，虚拟机可以 ping 通主机，但主机无法 ping 通虚拟机。</em>这时候可以使用几种方法：</p>\n<ul>\n<li>更改虚拟机模式为桥接模式，弃用原来的 NAT 模式。</li>\n<li>使用实体机中的虚拟机网卡与虚拟机进行交互，但貌似 ubuntu 下面并无法找到这块虚拟网卡，解决办法可以手动建立一个虚拟网卡。</li>\n<li>创建一个新的链接方式，通过这个桥接到实体机，然后通过 NAT 访问外网。<em>这边详细介绍这种方式</em></li>\n</ul>\n<p>详细步骤：</p>\n<ul>\n<li>使用 virtualbox 新建一个新的 adapter，选用 bridge adapter。如下图：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-2011.png\" alt=\"\"></p>\n<ul>\n<li>重启虚拟机系统，或者重启网络服务 <code>sudo /etc/init.d/networking restart</code> ，ifconfig -a 查看所有网卡，可以看到虚拟机中有一个网卡 enp0s8 并没有被使用，这个就是刚刚新建的那个桥接网卡。</li>\n<li>设置该网卡，修改/etc/network/interfaces文件，如下图：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-4326.png\" alt=\"\"></p>\n<ul>\n<li><p>重启网络服务 <code>sudo /etc/init.d/networking restart</code>，ifconfig 查看网卡。如下图：<br>-<br><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-4534.png\" alt=\"\"></p>\n</li>\n<li><p>接着基本就可以尝试 ping 通两个系统了，实体机中使用 ping 192.168.18.202，虚拟机中 ping 192.168.18.60 。如果仍然不行可以尝试关闭防火墙：<code>sudo ufw disable</code>。</p>\n</li>\n</ul>","more":"<h4 id=\"尝试ssh服务：\"><a href=\"#尝试ssh服务：\" class=\"headerlink\" title=\"尝试ssh服务：\"></a>尝试ssh服务：</h4><p><em>本步骤主要是建立链接，安装 ssh 服务，然后连接实体机可以登陆 ubuntu-server。因为这边 git 采用了 ssh 与服务器进行交互，所以 ssh 在这边是必须的。</em></p>\n<ul>\n<li>实体机和虚拟机，两个操作系统必须要同时安装 ssh 服务，如果只有实体机安装会出现链接失败。安装指令都是： <code>sudo apt-get install ssh或sudo apt-get install openssh-server</code>，<code>sudo /etc/init.d/ssh restart</code> 重启 ssh 服务。</li>\n<li>查看ssh服务是否启动, <code>ps –e | grep ssh</code>，响应的 sshd 和 ssh-agent 如果未打开则运行指令名字。</li>\n<li>修改实体机的 ip 配置文件 <code>/ect/hosts</code>，加入如下行： <code>192.168.18.202 ubuntu_server</code>，ubuntu_server 是你的虚拟机的主机名称，而 ubuntu_server 以后将代替 192.168.18.202 出现。如果你的虚拟机名不是 ubuntu_server ,可以修改 /etc/hostname 中的名称。</li>\n<li>通过以上设置后，你的主机基本可以通过 ssh 访问虚拟机了，你可以在虚拟机新建一个用户 adduser git，然后实体机可以使用如下命令 <code>ssh git@ubuntu_server 或者 ssh git@192.168.18.202</code> 进行登陆，输入密码就可以进行相关操作了。</li>\n</ul>\n<p>补充：<em>如果 ssh 还不能登录上，就修改 sshd 的默认配置，例如： ssh 出现 permission denied (publickey) 问题:</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">修改 /etc/ssh/sshd-config 文件.</div><div class=\"line\">将其中的 PermitRootLogin no 修改为 yes</div><div class=\"line\">PubkeyAuthentication yes 修改为 no</div><div class=\"line\">AuthorizedKeysFile .ssh/authorized_keys 前面加上#屏蔽掉，</div><div class=\"line\">PasswordAuthentication no 修改为 yes 就可以了。*</div></pre></td></tr></table></figure>\n<h3 id=\"git虚拟服务器搭建：\"><a href=\"#git虚拟服务器搭建：\" class=\"headerlink\" title=\"git虚拟服务器搭建：\"></a>git虚拟服务器搭建：</h3><p><em>安装 git，可以使用命令 <code>sudo apt-get install git-core</code> 或者 `sudo apt-get install git</em>` 。</p>\n<ul>\n<li>在实体机上，我们使用命令： ssh-keygen –t rsa 生成密钥。秘钥在当前用户目录的 .ssh 目录下。</li>\n<li>在虚拟机的 git 目录下新建一个 .ssh 目录</li>\n<li>在 .ssh 目录下，我们可以看到 id_rsa 和 id_rsa.pub 文件，id_rsa.pub 为公钥，我们 通过命令 <code>scp /home/git/.ssh/id_rsa.pub git@ubuntu_server:/home/git/.ssh/authorized_keys</code>将实体机上生成的公钥拷贝到虚拟机的git账户目录下上。如果是要添加公钥可以使用使用命令 <code>cat /home/git/id_rsa.pub&gt;&gt;/home/git/.ssh/authorized_keys</code></li>\n<li>使用命令 <code>git –-bare init /home/git/myRep.git</code> ,初始化化仓库。<strong>注意一定需要建立一个 –bare 的裸库。</strong></li>\n</ul>\n<h4 id=\"git操作\"><a href=\"#git操作\" class=\"headerlink\" title=\"git操作\"></a>git操作</h4><p><em>我们可以使用 <code>git clone git@gitServer:/home/git/myRep.git</code> 直接将库克隆下来，但一般推荐，在将本地库与远程库建立链接具体步骤如下：</em></p>\n<ul>\n<li>在实体机中新建一个文件夹， <code>mkdir test</code> ，进入该文件夹 <code>cd test</code></li>\n<li>初始化这个库， <code>git init</code>。</li>\n<li>随意添加几个文件，例如： <code>echo &quot;hello world&quot; &gt;&gt; test.txt</code></li>\n<li>常规git操作，加入stage并提交， <code>git add .  &amp;&amp;  git commit -m &quot;test&quot;</code></li>\n<li>查看下本地库的状态： git status</li>\n<li>一切正常的话，将远程库与本地库建立关系： <code>git remote add test git@ubuntu_server:/home/git/myRep.git</code>。这边的 test 为远程库的名称，默认一般为 origin，但如果你一个项目中同时有多个库，则建议你修改 origin 名称。</li>\n<li><code>git remote –v</code>，可查看版本库的网址，以及相关的库名称</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-1126.png\" alt=\"\"></p>\n<ul>\n<li>可以通过 <code>git push test master</code> 进行推送，注意这边远程库名为test而并不是默认的origin。也可以通过<code>git pull test master</code>对虚拟机中的远程库进行拉取。<em>注意因为不是默认名称，所以直接使用 git  push 或者 pull 会报错。</em></li>\n</ul>\n<p><strong>注意严格按照上面步骤执行，git 操作，一步错，可能就需要你删除 .git 以及 git remote remove test 等相关系列的操作，或者可以删除整个目录重新开始。值得注意的是， git 建立出来的每个库是相互独立的，除非全局设置，否则在添加远程库或者修改其他设置时，都不会对其他库有任何影响。</strong></p>\n<p><strong>建立好库，并且也 push 等操作都成功了，但查看虚拟机中远程库的源文件却发现招不到任何一个文件，事实上， git 远程裸库仅仅保存修改记录和分支，并不是用来查看的，只有当你 clone 或者 pull 之后才可以查看某条分支的完整结构。</strong></p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://developer.51cto.com/art/201507/483448.htm\">http://developer.51cto.com/art/201507/483448.htm</a><br><a href=\"http://blog.sina.com.cn/s/blog_6ab9984801011k81.html\">http://blog.sina.com.cn/s/blog_6ab9984801011k81.html</a><br><a href=\"http://stackoverflow.com/questions/20252294/ssh-could-not-resolve-hostname-hostname-nodename-nor-servname-provided-or-n\">http://stackoverflow.com/questions/20252294/ssh-could-not-resolve-hostname-hostname-nodename-nor-servname-provided-or-n</a><br><a href=\"http://www.cnblogs.com/xdzone/archive/2011/03/09/1978327.html\">http://www.cnblogs.com/xdzone/archive/2011/03/09/1978327.html</a><br><a href=\"http://blog.csdn.net/zht666/article/details/9340633\">http://blog.csdn.net/zht666/article/details/9340633</a><br><a href=\"http://blog.sina.com.cn/s/blog_5f435c130102v6pv.html\">http://blog.sina.com.cn/s/blog_5f435c130102v6pv.html</a><br><a href=\"http://bbs.csdn.net/topics/390158779\">http://bbs.csdn.net/topics/390158779</a><br><a href=\"http://blog.163.com/danshiming@126/blog/static/109412748201251211140194/\">http://blog.163.com/danshiming@126/blog/static/109412748201251211140194/</a></p>\n</blockquote>"},{"layout":"post","title":"GPIO口详解","date":"2016-08-03T03:49:00.000Z","_content":"\n*在做 MCU 编程开发的时候，GPIO 可以说是最基础也是最重要的部分，MCU 的学习研究无非就是三点：高低电频，输入输出，通讯协议。而GPIO可以说贯穿始终，在模拟一些通讯协议时，GPIO 所采用的模式，往往会引起各种意想不到的问题。*\n\n### GPIO 模式：\n\n#### 通用推挽输出（push-pull）：\n在功率放大器电路中大量采用推挽放大器电路，这种电路中用两只三极管构成一级放大器电路，两只三极管分别放大输入信号的正半周和负半周，即用一只三极管放大信号的正半周，用另一只三极管放大信号的负半周，两只三极管输出的半周信号在放大器负载上合并后得到一个完整周期的输出信号。原理图如下：\n\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-08-03-gpio%E5%8F%A3%E8%AF%A6%E8%A7%A3/8b82b9014a90f6037a3d50aa3a12b31bb151ed4a.jpg)\n\n推挽放大器电路中，一只三极管工作在导通、放大状态时，另一只三极管处于截止状态，当输入信号变化到另一个半周后，原先导通、放大的三极管进入截止，而原先截止的三极管进入导通、放大状态，两只三极管在不断地交替导通放大和截止变化，所以称为**推挽放大器**。\n\n*这种电路主要用于低功耗情况下能输出较大功率的交流信号，通常用于低频放大电路设计中。可增强输出的负载能力。这种输出结构带负载能力较强，你驱动个LED灯什么的操作IO口可以用推挽输出。*\n\n\n<!-- more -->\n\n\n#### 开漏输出（open drain）:\n\n输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行。原理图如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-08-03-gpio%E5%8F%A3%E8%AF%A6%E8%A7%A3/DeepinScrot-2019.png)\n\n开漏输出只有外部有上拉电阻时，才有可能输出高电平。当外部无上拉电阻时，该口不能输出高电平，处于悬空状态，或只可以输出低电平。开漏的主要用处：\n- 芯片的 Open drain 输出是设计用于\"线或\" (wire AND) 逻辑的，就是说当多个漏极开路器件的输出连在一起的时候，只要是其中一个导通，输出就为‘0’。这个特性被广泛用于串行总线电路。\n- 可以用于如继电器之类只吸入电流的负载, 或驱动比你的芯片电源电压高的负载，吸电流能力较强，但是输出能力不如推挽输出较弱，（一般如果单一驱动的话，大都选用推挽输出。）\n- 对于一些需要防止干扰的操作，如：不希望单片机的上拉电阻对外部电路（如ADC）产生任何影响。\n\n\n#### 开集输出（open collector）：\n\n\n\n\n\n#### 开漏输出\n\n\n### 通信协议：\n\n\n\n> 参考链接：\n> http://www.openedv.com/forum.php?mod=viewthread&tid=2288&highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9\n> http://www.openedv.com/forum.php?mod=viewthread&tid=67623&highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9  \n> http://jingyan.baidu.com/article/5225f26b047a5ee6fa0908f6.html\n> http://zhidao.baidu.com/link?url=ZnvwHHE10-0UZ8hPRvLczpw7-qZolpNolBuT0TsGZHEjDMxmZeYz5QsOYUybxc7OBMSiPOfZx_401s5KlEIQKcrUZPqSaOTMX4yrEgfsbX3\n> http://blog.chinaunix.net/uid-23065002-id-3885199.html\n> http://wenku.baidu.com/link?url=9BSyigTdzjcZ73LWkfGOhzfxyD1oDhVHMS0ykLUG1sMp9lUbY9yGhL2hsqIKPaX47fdcfDwRxLnfu46m_Z4y0_HGE6XPk_8VSpE38ztCFIe\n> http://www.9mcu.com/9mcubbs/forum.php?mod=viewthread&tid=951093\n","source":"_posts/2016/2016-08-03-gpio口详解.md","raw":"---\nlayout: \"post\"\ntitle: \"GPIO口详解\"\ndate: \"2016-08-03 11:49\"\n---\n\n*在做 MCU 编程开发的时候，GPIO 可以说是最基础也是最重要的部分，MCU 的学习研究无非就是三点：高低电频，输入输出，通讯协议。而GPIO可以说贯穿始终，在模拟一些通讯协议时，GPIO 所采用的模式，往往会引起各种意想不到的问题。*\n\n### GPIO 模式：\n\n#### 通用推挽输出（push-pull）：\n在功率放大器电路中大量采用推挽放大器电路，这种电路中用两只三极管构成一级放大器电路，两只三极管分别放大输入信号的正半周和负半周，即用一只三极管放大信号的正半周，用另一只三极管放大信号的负半周，两只三极管输出的半周信号在放大器负载上合并后得到一个完整周期的输出信号。原理图如下：\n\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-08-03-gpio%E5%8F%A3%E8%AF%A6%E8%A7%A3/8b82b9014a90f6037a3d50aa3a12b31bb151ed4a.jpg)\n\n推挽放大器电路中，一只三极管工作在导通、放大状态时，另一只三极管处于截止状态，当输入信号变化到另一个半周后，原先导通、放大的三极管进入截止，而原先截止的三极管进入导通、放大状态，两只三极管在不断地交替导通放大和截止变化，所以称为**推挽放大器**。\n\n*这种电路主要用于低功耗情况下能输出较大功率的交流信号，通常用于低频放大电路设计中。可增强输出的负载能力。这种输出结构带负载能力较强，你驱动个LED灯什么的操作IO口可以用推挽输出。*\n\n\n<!-- more -->\n\n\n#### 开漏输出（open drain）:\n\n输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行。原理图如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-08-03-gpio%E5%8F%A3%E8%AF%A6%E8%A7%A3/DeepinScrot-2019.png)\n\n开漏输出只有外部有上拉电阻时，才有可能输出高电平。当外部无上拉电阻时，该口不能输出高电平，处于悬空状态，或只可以输出低电平。开漏的主要用处：\n- 芯片的 Open drain 输出是设计用于\"线或\" (wire AND) 逻辑的，就是说当多个漏极开路器件的输出连在一起的时候，只要是其中一个导通，输出就为‘0’。这个特性被广泛用于串行总线电路。\n- 可以用于如继电器之类只吸入电流的负载, 或驱动比你的芯片电源电压高的负载，吸电流能力较强，但是输出能力不如推挽输出较弱，（一般如果单一驱动的话，大都选用推挽输出。）\n- 对于一些需要防止干扰的操作，如：不希望单片机的上拉电阻对外部电路（如ADC）产生任何影响。\n\n\n#### 开集输出（open collector）：\n\n\n\n\n\n#### 开漏输出\n\n\n### 通信协议：\n\n\n\n> 参考链接：\n> http://www.openedv.com/forum.php?mod=viewthread&tid=2288&highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9\n> http://www.openedv.com/forum.php?mod=viewthread&tid=67623&highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9  \n> http://jingyan.baidu.com/article/5225f26b047a5ee6fa0908f6.html\n> http://zhidao.baidu.com/link?url=ZnvwHHE10-0UZ8hPRvLczpw7-qZolpNolBuT0TsGZHEjDMxmZeYz5QsOYUybxc7OBMSiPOfZx_401s5KlEIQKcrUZPqSaOTMX4yrEgfsbX3\n> http://blog.chinaunix.net/uid-23065002-id-3885199.html\n> http://wenku.baidu.com/link?url=9BSyigTdzjcZ73LWkfGOhzfxyD1oDhVHMS0ykLUG1sMp9lUbY9yGhL2hsqIKPaX47fdcfDwRxLnfu46m_Z4y0_HGE6XPk_8VSpE38ztCFIe\n> http://www.9mcu.com/9mcubbs/forum.php?mod=viewthread&tid=951093\n","slug":"2016/2016-08-03-gpio口详解","published":1,"updated":"2017-01-12T05:46:34.141Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahg0022mumu42v12m7m","content":"<p><em>在做 MCU 编程开发的时候，GPIO 可以说是最基础也是最重要的部分，MCU 的学习研究无非就是三点：高低电频，输入输出，通讯协议。而GPIO可以说贯穿始终，在模拟一些通讯协议时，GPIO 所采用的模式，往往会引起各种意想不到的问题。</em></p>\n<h3 id=\"GPIO-模式：\"><a href=\"#GPIO-模式：\" class=\"headerlink\" title=\"GPIO 模式：\"></a>GPIO 模式：</h3><h4 id=\"通用推挽输出（push-pull）：\"><a href=\"#通用推挽输出（push-pull）：\" class=\"headerlink\" title=\"通用推挽输出（push-pull）：\"></a>通用推挽输出（push-pull）：</h4><p>在功率放大器电路中大量采用推挽放大器电路，这种电路中用两只三极管构成一级放大器电路，两只三极管分别放大输入信号的正半周和负半周，即用一只三极管放大信号的正半周，用另一只三极管放大信号的负半周，两只三极管输出的半周信号在放大器负载上合并后得到一个完整周期的输出信号。原理图如下：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-08-03-gpio%E5%8F%A3%E8%AF%A6%E8%A7%A3/8b82b9014a90f6037a3d50aa3a12b31bb151ed4a.jpg\" alt=\"\"></p>\n<p>推挽放大器电路中，一只三极管工作在导通、放大状态时，另一只三极管处于截止状态，当输入信号变化到另一个半周后，原先导通、放大的三极管进入截止，而原先截止的三极管进入导通、放大状态，两只三极管在不断地交替导通放大和截止变化，所以称为<strong>推挽放大器</strong>。</p>\n<p><em>这种电路主要用于低功耗情况下能输出较大功率的交流信号，通常用于低频放大电路设计中。可增强输出的负载能力。这种输出结构带负载能力较强，你驱动个LED灯什么的操作IO口可以用推挽输出。</em></p>\n<a id=\"more\"></a>\n<h4 id=\"开漏输出（open-drain）\"><a href=\"#开漏输出（open-drain）\" class=\"headerlink\" title=\"开漏输出（open drain）:\"></a>开漏输出（open drain）:</h4><p>输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行。原理图如下：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-08-03-gpio%E5%8F%A3%E8%AF%A6%E8%A7%A3/DeepinScrot-2019.png\" alt=\"\"></p>\n<p>开漏输出只有外部有上拉电阻时，才有可能输出高电平。当外部无上拉电阻时，该口不能输出高电平，处于悬空状态，或只可以输出低电平。开漏的主要用处：</p>\n<ul>\n<li>芯片的 Open drain 输出是设计用于”线或” (wire AND) 逻辑的，就是说当多个漏极开路器件的输出连在一起的时候，只要是其中一个导通，输出就为‘0’。这个特性被广泛用于串行总线电路。</li>\n<li>可以用于如继电器之类只吸入电流的负载, 或驱动比你的芯片电源电压高的负载，吸电流能力较强，但是输出能力不如推挽输出较弱，（一般如果单一驱动的话，大都选用推挽输出。）</li>\n<li>对于一些需要防止干扰的操作，如：不希望单片机的上拉电阻对外部电路（如ADC）产生任何影响。</li>\n</ul>\n<h4 id=\"开集输出（open-collector）：\"><a href=\"#开集输出（open-collector）：\" class=\"headerlink\" title=\"开集输出（open collector）：\"></a>开集输出（open collector）：</h4><h4 id=\"开漏输出\"><a href=\"#开漏输出\" class=\"headerlink\" title=\"开漏输出\"></a>开漏输出</h4><h3 id=\"通信协议：\"><a href=\"#通信协议：\" class=\"headerlink\" title=\"通信协议：\"></a>通信协议：</h3><blockquote>\n<p>参考链接：<br><a href=\"http://www.openedv.com/forum.php?mod=viewthread&amp;tid=2288&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9\" target=\"_blank\" rel=\"external\">http://www.openedv.com/forum.php?mod=viewthread&amp;tid=2288&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9</a><br><a href=\"http://www.openedv.com/forum.php?mod=viewthread&amp;tid=67623&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9\" target=\"_blank\" rel=\"external\">http://www.openedv.com/forum.php?mod=viewthread&amp;tid=67623&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9</a><br><a href=\"http://jingyan.baidu.com/article/5225f26b047a5ee6fa0908f6.html\" target=\"_blank\" rel=\"external\">http://jingyan.baidu.com/article/5225f26b047a5ee6fa0908f6.html</a><br><a href=\"http://zhidao.baidu.com/link?url=ZnvwHHE10-0UZ8hPRvLczpw7-qZolpNolBuT0TsGZHEjDMxmZeYz5QsOYUybxc7OBMSiPOfZx_401s5KlEIQKcrUZPqSaOTMX4yrEgfsbX3\" target=\"_blank\" rel=\"external\">http://zhidao.baidu.com/link?url=ZnvwHHE10-0UZ8hPRvLczpw7-qZolpNolBuT0TsGZHEjDMxmZeYz5QsOYUybxc7OBMSiPOfZx_401s5KlEIQKcrUZPqSaOTMX4yrEgfsbX3</a><br><a href=\"http://blog.chinaunix.net/uid-23065002-id-3885199.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-23065002-id-3885199.html</a><br><a href=\"http://wenku.baidu.com/link?url=9BSyigTdzjcZ73LWkfGOhzfxyD1oDhVHMS0ykLUG1sMp9lUbY9yGhL2hsqIKPaX47fdcfDwRxLnfu46m_Z4y0_HGE6XPk_8VSpE38ztCFIe\" target=\"_blank\" rel=\"external\">http://wenku.baidu.com/link?url=9BSyigTdzjcZ73LWkfGOhzfxyD1oDhVHMS0ykLUG1sMp9lUbY9yGhL2hsqIKPaX47fdcfDwRxLnfu46m_Z4y0_HGE6XPk_8VSpE38ztCFIe</a><br><a href=\"http://www.9mcu.com/9mcubbs/forum.php?mod=viewthread&amp;tid=951093\" target=\"_blank\" rel=\"external\">http://www.9mcu.com/9mcubbs/forum.php?mod=viewthread&amp;tid=951093</a></p>\n</blockquote>\n","excerpt":"<p><em>在做 MCU 编程开发的时候，GPIO 可以说是最基础也是最重要的部分，MCU 的学习研究无非就是三点：高低电频，输入输出，通讯协议。而GPIO可以说贯穿始终，在模拟一些通讯协议时，GPIO 所采用的模式，往往会引起各种意想不到的问题。</em></p>\n<h3 id=\"GPIO-模式：\"><a href=\"#GPIO-模式：\" class=\"headerlink\" title=\"GPIO 模式：\"></a>GPIO 模式：</h3><h4 id=\"通用推挽输出（push-pull）：\"><a href=\"#通用推挽输出（push-pull）：\" class=\"headerlink\" title=\"通用推挽输出（push-pull）：\"></a>通用推挽输出（push-pull）：</h4><p>在功率放大器电路中大量采用推挽放大器电路，这种电路中用两只三极管构成一级放大器电路，两只三极管分别放大输入信号的正半周和负半周，即用一只三极管放大信号的正半周，用另一只三极管放大信号的负半周，两只三极管输出的半周信号在放大器负载上合并后得到一个完整周期的输出信号。原理图如下：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-08-03-gpio%E5%8F%A3%E8%AF%A6%E8%A7%A3/8b82b9014a90f6037a3d50aa3a12b31bb151ed4a.jpg\" alt=\"\"></p>\n<p>推挽放大器电路中，一只三极管工作在导通、放大状态时，另一只三极管处于截止状态，当输入信号变化到另一个半周后，原先导通、放大的三极管进入截止，而原先截止的三极管进入导通、放大状态，两只三极管在不断地交替导通放大和截止变化，所以称为<strong>推挽放大器</strong>。</p>\n<p><em>这种电路主要用于低功耗情况下能输出较大功率的交流信号，通常用于低频放大电路设计中。可增强输出的负载能力。这种输出结构带负载能力较强，你驱动个LED灯什么的操作IO口可以用推挽输出。</em></p>","more":"<h4 id=\"开漏输出（open-drain）\"><a href=\"#开漏输出（open-drain）\" class=\"headerlink\" title=\"开漏输出（open drain）:\"></a>开漏输出（open drain）:</h4><p>输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行。原理图如下：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-08-03-gpio%E5%8F%A3%E8%AF%A6%E8%A7%A3/DeepinScrot-2019.png\" alt=\"\"></p>\n<p>开漏输出只有外部有上拉电阻时，才有可能输出高电平。当外部无上拉电阻时，该口不能输出高电平，处于悬空状态，或只可以输出低电平。开漏的主要用处：</p>\n<ul>\n<li>芯片的 Open drain 输出是设计用于”线或” (wire AND) 逻辑的，就是说当多个漏极开路器件的输出连在一起的时候，只要是其中一个导通，输出就为‘0’。这个特性被广泛用于串行总线电路。</li>\n<li>可以用于如继电器之类只吸入电流的负载, 或驱动比你的芯片电源电压高的负载，吸电流能力较强，但是输出能力不如推挽输出较弱，（一般如果单一驱动的话，大都选用推挽输出。）</li>\n<li>对于一些需要防止干扰的操作，如：不希望单片机的上拉电阻对外部电路（如ADC）产生任何影响。</li>\n</ul>\n<h4 id=\"开集输出（open-collector）：\"><a href=\"#开集输出（open-collector）：\" class=\"headerlink\" title=\"开集输出（open collector）：\"></a>开集输出（open collector）：</h4><h4 id=\"开漏输出\"><a href=\"#开漏输出\" class=\"headerlink\" title=\"开漏输出\"></a>开漏输出</h4><h3 id=\"通信协议：\"><a href=\"#通信协议：\" class=\"headerlink\" title=\"通信协议：\"></a>通信协议：</h3><blockquote>\n<p>参考链接：<br><a href=\"http://www.openedv.com/forum.php?mod=viewthread&amp;tid=2288&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9\">http://www.openedv.com/forum.php?mod=viewthread&amp;tid=2288&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9</a><br><a href=\"http://www.openedv.com/forum.php?mod=viewthread&amp;tid=67623&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9\">http://www.openedv.com/forum.php?mod=viewthread&amp;tid=67623&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9</a><br><a href=\"http://jingyan.baidu.com/article/5225f26b047a5ee6fa0908f6.html\">http://jingyan.baidu.com/article/5225f26b047a5ee6fa0908f6.html</a><br><a href=\"http://zhidao.baidu.com/link?url=ZnvwHHE10-0UZ8hPRvLczpw7-qZolpNolBuT0TsGZHEjDMxmZeYz5QsOYUybxc7OBMSiPOfZx_401s5KlEIQKcrUZPqSaOTMX4yrEgfsbX3\">http://zhidao.baidu.com/link?url=ZnvwHHE10-0UZ8hPRvLczpw7-qZolpNolBuT0TsGZHEjDMxmZeYz5QsOYUybxc7OBMSiPOfZx_401s5KlEIQKcrUZPqSaOTMX4yrEgfsbX3</a><br><a href=\"http://blog.chinaunix.net/uid-23065002-id-3885199.html\">http://blog.chinaunix.net/uid-23065002-id-3885199.html</a><br><a href=\"http://wenku.baidu.com/link?url=9BSyigTdzjcZ73LWkfGOhzfxyD1oDhVHMS0ykLUG1sMp9lUbY9yGhL2hsqIKPaX47fdcfDwRxLnfu46m_Z4y0_HGE6XPk_8VSpE38ztCFIe\">http://wenku.baidu.com/link?url=9BSyigTdzjcZ73LWkfGOhzfxyD1oDhVHMS0ykLUG1sMp9lUbY9yGhL2hsqIKPaX47fdcfDwRxLnfu46m_Z4y0_HGE6XPk_8VSpE38ztCFIe</a><br><a href=\"http://www.9mcu.com/9mcubbs/forum.php?mod=viewthread&amp;tid=951093\">http://www.9mcu.com/9mcubbs/forum.php?mod=viewthread&amp;tid=951093</a></p>\n</blockquote>"},{"layout":"post","title":"常规的通讯校验","date":"2016-08-06T00:31:00.000Z","_content":"\n\n\n<!-- more -->\n\n\n\n> 参考链接：\n> http://blog.csdn.net/liyuanbhu/article/details/7882789\n","source":"_posts/2016/2016-08-06-常规的通讯校验.md","raw":"---\nlayout: \"post\"\ntitle: \"常规的通讯校验\"\ndate: \"2016-08-06 08:31\"\n---\n\n\n\n<!-- more -->\n\n\n\n> 参考链接：\n> http://blog.csdn.net/liyuanbhu/article/details/7882789\n","slug":"2016/2016-08-06-常规的通讯校验","published":1,"updated":"2016-12-16T01:43:42.275Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahi0023mumuom0d1goz","content":"<a id=\"more\"></a>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/liyuanbhu/article/details/7882789\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/liyuanbhu/article/details/7882789</a></p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/liyuanbhu/article/details/7882789\">http://blog.csdn.net/liyuanbhu/article/details/7882789</a></p>\n</blockquote>"},{"layout":"post","title":"模拟IIC通信时IO选用模式","date":"2016-08-10T03:36:00.000Z","_content":"\n*现如今很多芯片都已经包含有 IIC 通信功能，为何仍然选择模拟 IIC 呢？* **首先 IIC 通讯的版权掌握在飞利浦手中，部分厂家如：st 等，实现 IIC 通信较为繁琐，据说不是特别合理稳定；此外，芯片级的 IIC 不同的芯片就需要重新研究书写一次，而模拟 IIC 天生具有较好的移植性，可以做到一次书写，终身可移植。**\n\n### IIC 通信原理\n\n\n\n\n### IIC 选用 IO 模式\n\n通过上面可以知道，IIC 在通信过程中，主设备SCL始终是保持发送状态，因此这边我们可以将 SCL 设置为推挽或者开漏输出。推挽的输出能力较强，开漏输出则需要加上拉电阻，而一般 IIC 的推荐电路就是需要人为增加了上拉电阻的，因此在考虑功耗等一些情况下，可能开漏输出更好。\n\n**而问题的关键是 SDA 到底设置为什么模式？**\n\n网上参考资料众说纷纭，这边以我自己做实验的亲身感受为例，我推荐在作为输出时将这个脚配置为开漏输出模式；在 MCU 需要接收信号的时候，如果 MCU 本身没有限制，或者不需要精简代码的话，则将其设置为输入模式。详解：\n\n\n<!-- more -->\n\n\n#### 将 SDA 直接设置为开漏模式：\n\n这种方法一般用于之前程序的很多单片机中，开漏因为需要接上拉电阻才能改变电平，且具有线与的特性，通过读 IO 口的状态，即便是设置成了开漏输出，但仍然可以读取IO的数据状态，可以说一劳永逸，一种模式两种用途，虽然目前试过大多数MCU通过这种方式也都可以读取，但毕竟是输出模式，万一以后的设计更改了，无法读取了，则有潜在性的问题。\n\n#### 将 SDA 设置位推挽输出模式进行输出，需要读取数据时转换成输入模式：\n\n最近在不少地方看到用这种方式来对 IIC 器件进行读取，感觉较为灵活，之前也将开漏转换成了这种模式。但最近实验过程中发现了不少问题，在 SDA 发送数据结束后，等待应答的这个过程中，使用推挽模式，有明显的短路风险。这段时间虽然时间很短，且接下来会立即将推挽切换为输入模式，但在单步执行测试的过程中,实际会出现很高的电流，疑似推挽的高电平输出引起了断路，用这种模式必须较为谨慎，注意各种延时时间，千万不能让器件断路烧坏。*在使用一个 IIC 通信的 AD 芯片过程中，一段时间后出现测量值不准，疑似可能是这种原因引起的。*\n\n#### SCL 使用开漏输出模式，SDA 使用开漏输出+输入模式：\n\n通过上面的讨论，最终个人认为 IIC 通信过程中：SCL 使用开漏输出模式，SDA 使用开漏输出发送数据，使用输入模式读取数据，这种方法较为合理。值得注意：SDA 需要模式切换，IIC 的延迟时间无需过长，否则影响效率，这些根据手册中的标准执行。\n","source":"_posts/2016/2016-08-10-模拟IIC通信时IO选用模式.md","raw":"---\nlayout: \"post\"\ntitle: \"模拟IIC通信时IO选用模式\"\ndate: \"2016-08-10 11:36\"\n---\n\n*现如今很多芯片都已经包含有 IIC 通信功能，为何仍然选择模拟 IIC 呢？* **首先 IIC 通讯的版权掌握在飞利浦手中，部分厂家如：st 等，实现 IIC 通信较为繁琐，据说不是特别合理稳定；此外，芯片级的 IIC 不同的芯片就需要重新研究书写一次，而模拟 IIC 天生具有较好的移植性，可以做到一次书写，终身可移植。**\n\n### IIC 通信原理\n\n\n\n\n### IIC 选用 IO 模式\n\n通过上面可以知道，IIC 在通信过程中，主设备SCL始终是保持发送状态，因此这边我们可以将 SCL 设置为推挽或者开漏输出。推挽的输出能力较强，开漏输出则需要加上拉电阻，而一般 IIC 的推荐电路就是需要人为增加了上拉电阻的，因此在考虑功耗等一些情况下，可能开漏输出更好。\n\n**而问题的关键是 SDA 到底设置为什么模式？**\n\n网上参考资料众说纷纭，这边以我自己做实验的亲身感受为例，我推荐在作为输出时将这个脚配置为开漏输出模式；在 MCU 需要接收信号的时候，如果 MCU 本身没有限制，或者不需要精简代码的话，则将其设置为输入模式。详解：\n\n\n<!-- more -->\n\n\n#### 将 SDA 直接设置为开漏模式：\n\n这种方法一般用于之前程序的很多单片机中，开漏因为需要接上拉电阻才能改变电平，且具有线与的特性，通过读 IO 口的状态，即便是设置成了开漏输出，但仍然可以读取IO的数据状态，可以说一劳永逸，一种模式两种用途，虽然目前试过大多数MCU通过这种方式也都可以读取，但毕竟是输出模式，万一以后的设计更改了，无法读取了，则有潜在性的问题。\n\n#### 将 SDA 设置位推挽输出模式进行输出，需要读取数据时转换成输入模式：\n\n最近在不少地方看到用这种方式来对 IIC 器件进行读取，感觉较为灵活，之前也将开漏转换成了这种模式。但最近实验过程中发现了不少问题，在 SDA 发送数据结束后，等待应答的这个过程中，使用推挽模式，有明显的短路风险。这段时间虽然时间很短，且接下来会立即将推挽切换为输入模式，但在单步执行测试的过程中,实际会出现很高的电流，疑似推挽的高电平输出引起了断路，用这种模式必须较为谨慎，注意各种延时时间，千万不能让器件断路烧坏。*在使用一个 IIC 通信的 AD 芯片过程中，一段时间后出现测量值不准，疑似可能是这种原因引起的。*\n\n#### SCL 使用开漏输出模式，SDA 使用开漏输出+输入模式：\n\n通过上面的讨论，最终个人认为 IIC 通信过程中：SCL 使用开漏输出模式，SDA 使用开漏输出发送数据，使用输入模式读取数据，这种方法较为合理。值得注意：SDA 需要模式切换，IIC 的延迟时间无需过长，否则影响效率，这些根据手册中的标准执行。\n","slug":"2016/2016-08-10-模拟IIC通信时IO选用模式","published":1,"updated":"2017-01-12T05:48:11.981Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahj0024mumu3hqp759w","content":"<p><em>现如今很多芯片都已经包含有 IIC 通信功能，为何仍然选择模拟 IIC 呢？</em> <strong>首先 IIC 通讯的版权掌握在飞利浦手中，部分厂家如：st 等，实现 IIC 通信较为繁琐，据说不是特别合理稳定；此外，芯片级的 IIC 不同的芯片就需要重新研究书写一次，而模拟 IIC 天生具有较好的移植性，可以做到一次书写，终身可移植。</strong></p>\n<h3 id=\"IIC-通信原理\"><a href=\"#IIC-通信原理\" class=\"headerlink\" title=\"IIC 通信原理\"></a>IIC 通信原理</h3><h3 id=\"IIC-选用-IO-模式\"><a href=\"#IIC-选用-IO-模式\" class=\"headerlink\" title=\"IIC 选用 IO 模式\"></a>IIC 选用 IO 模式</h3><p>通过上面可以知道，IIC 在通信过程中，主设备SCL始终是保持发送状态，因此这边我们可以将 SCL 设置为推挽或者开漏输出。推挽的输出能力较强，开漏输出则需要加上拉电阻，而一般 IIC 的推荐电路就是需要人为增加了上拉电阻的，因此在考虑功耗等一些情况下，可能开漏输出更好。</p>\n<p><strong>而问题的关键是 SDA 到底设置为什么模式？</strong></p>\n<p>网上参考资料众说纷纭，这边以我自己做实验的亲身感受为例，我推荐在作为输出时将这个脚配置为开漏输出模式；在 MCU 需要接收信号的时候，如果 MCU 本身没有限制，或者不需要精简代码的话，则将其设置为输入模式。详解：</p>\n<a id=\"more\"></a>\n<h4 id=\"将-SDA-直接设置为开漏模式：\"><a href=\"#将-SDA-直接设置为开漏模式：\" class=\"headerlink\" title=\"将 SDA 直接设置为开漏模式：\"></a>将 SDA 直接设置为开漏模式：</h4><p>这种方法一般用于之前程序的很多单片机中，开漏因为需要接上拉电阻才能改变电平，且具有线与的特性，通过读 IO 口的状态，即便是设置成了开漏输出，但仍然可以读取IO的数据状态，可以说一劳永逸，一种模式两种用途，虽然目前试过大多数MCU通过这种方式也都可以读取，但毕竟是输出模式，万一以后的设计更改了，无法读取了，则有潜在性的问题。</p>\n<h4 id=\"将-SDA-设置位推挽输出模式进行输出，需要读取数据时转换成输入模式：\"><a href=\"#将-SDA-设置位推挽输出模式进行输出，需要读取数据时转换成输入模式：\" class=\"headerlink\" title=\"将 SDA 设置位推挽输出模式进行输出，需要读取数据时转换成输入模式：\"></a>将 SDA 设置位推挽输出模式进行输出，需要读取数据时转换成输入模式：</h4><p>最近在不少地方看到用这种方式来对 IIC 器件进行读取，感觉较为灵活，之前也将开漏转换成了这种模式。但最近实验过程中发现了不少问题，在 SDA 发送数据结束后，等待应答的这个过程中，使用推挽模式，有明显的短路风险。这段时间虽然时间很短，且接下来会立即将推挽切换为输入模式，但在单步执行测试的过程中,实际会出现很高的电流，疑似推挽的高电平输出引起了断路，用这种模式必须较为谨慎，注意各种延时时间，千万不能让器件断路烧坏。<em>在使用一个 IIC 通信的 AD 芯片过程中，一段时间后出现测量值不准，疑似可能是这种原因引起的。</em></p>\n<h4 id=\"SCL-使用开漏输出模式，SDA-使用开漏输出-输入模式：\"><a href=\"#SCL-使用开漏输出模式，SDA-使用开漏输出-输入模式：\" class=\"headerlink\" title=\"SCL 使用开漏输出模式，SDA 使用开漏输出+输入模式：\"></a>SCL 使用开漏输出模式，SDA 使用开漏输出+输入模式：</h4><p>通过上面的讨论，最终个人认为 IIC 通信过程中：SCL 使用开漏输出模式，SDA 使用开漏输出发送数据，使用输入模式读取数据，这种方法较为合理。值得注意：SDA 需要模式切换，IIC 的延迟时间无需过长，否则影响效率，这些根据手册中的标准执行。</p>\n","excerpt":"<p><em>现如今很多芯片都已经包含有 IIC 通信功能，为何仍然选择模拟 IIC 呢？</em> <strong>首先 IIC 通讯的版权掌握在飞利浦手中，部分厂家如：st 等，实现 IIC 通信较为繁琐，据说不是特别合理稳定；此外，芯片级的 IIC 不同的芯片就需要重新研究书写一次，而模拟 IIC 天生具有较好的移植性，可以做到一次书写，终身可移植。</strong></p>\n<h3 id=\"IIC-通信原理\"><a href=\"#IIC-通信原理\" class=\"headerlink\" title=\"IIC 通信原理\"></a>IIC 通信原理</h3><h3 id=\"IIC-选用-IO-模式\"><a href=\"#IIC-选用-IO-模式\" class=\"headerlink\" title=\"IIC 选用 IO 模式\"></a>IIC 选用 IO 模式</h3><p>通过上面可以知道，IIC 在通信过程中，主设备SCL始终是保持发送状态，因此这边我们可以将 SCL 设置为推挽或者开漏输出。推挽的输出能力较强，开漏输出则需要加上拉电阻，而一般 IIC 的推荐电路就是需要人为增加了上拉电阻的，因此在考虑功耗等一些情况下，可能开漏输出更好。</p>\n<p><strong>而问题的关键是 SDA 到底设置为什么模式？</strong></p>\n<p>网上参考资料众说纷纭，这边以我自己做实验的亲身感受为例，我推荐在作为输出时将这个脚配置为开漏输出模式；在 MCU 需要接收信号的时候，如果 MCU 本身没有限制，或者不需要精简代码的话，则将其设置为输入模式。详解：</p>","more":"<h4 id=\"将-SDA-直接设置为开漏模式：\"><a href=\"#将-SDA-直接设置为开漏模式：\" class=\"headerlink\" title=\"将 SDA 直接设置为开漏模式：\"></a>将 SDA 直接设置为开漏模式：</h4><p>这种方法一般用于之前程序的很多单片机中，开漏因为需要接上拉电阻才能改变电平，且具有线与的特性，通过读 IO 口的状态，即便是设置成了开漏输出，但仍然可以读取IO的数据状态，可以说一劳永逸，一种模式两种用途，虽然目前试过大多数MCU通过这种方式也都可以读取，但毕竟是输出模式，万一以后的设计更改了，无法读取了，则有潜在性的问题。</p>\n<h4 id=\"将-SDA-设置位推挽输出模式进行输出，需要读取数据时转换成输入模式：\"><a href=\"#将-SDA-设置位推挽输出模式进行输出，需要读取数据时转换成输入模式：\" class=\"headerlink\" title=\"将 SDA 设置位推挽输出模式进行输出，需要读取数据时转换成输入模式：\"></a>将 SDA 设置位推挽输出模式进行输出，需要读取数据时转换成输入模式：</h4><p>最近在不少地方看到用这种方式来对 IIC 器件进行读取，感觉较为灵活，之前也将开漏转换成了这种模式。但最近实验过程中发现了不少问题，在 SDA 发送数据结束后，等待应答的这个过程中，使用推挽模式，有明显的短路风险。这段时间虽然时间很短，且接下来会立即将推挽切换为输入模式，但在单步执行测试的过程中,实际会出现很高的电流，疑似推挽的高电平输出引起了断路，用这种模式必须较为谨慎，注意各种延时时间，千万不能让器件断路烧坏。<em>在使用一个 IIC 通信的 AD 芯片过程中，一段时间后出现测量值不准，疑似可能是这种原因引起的。</em></p>\n<h4 id=\"SCL-使用开漏输出模式，SDA-使用开漏输出-输入模式：\"><a href=\"#SCL-使用开漏输出模式，SDA-使用开漏输出-输入模式：\" class=\"headerlink\" title=\"SCL 使用开漏输出模式，SDA 使用开漏输出+输入模式：\"></a>SCL 使用开漏输出模式，SDA 使用开漏输出+输入模式：</h4><p>通过上面的讨论，最终个人认为 IIC 通信过程中：SCL 使用开漏输出模式，SDA 使用开漏输出发送数据，使用输入模式读取数据，这种方法较为合理。值得注意：SDA 需要模式切换，IIC 的延迟时间无需过长，否则影响效率，这些根据手册中的标准执行。</p>"},{"layout":"post","title":"C语言中宏定义存在位置","date":"2016-08-24T10:34:00.000Z","_content":"\n\n*宏定义作为C语言的一个传统内容，如果使用新标准的话，一般也只用宏定义来结局编译的一些问题如：#ifndef，#if undefined()等。*\n\n宏定义究竟放在什么地方，在使用 C 语言老款编辑器情况下，一些程序大量使用宏定义，且很多程序都是将宏定义作为申明一样全部放在头文件中的，这个没有一个统一的说法，其中各有利弊，每个人风格不尽相同。\n\n首先，宏定义的常量在编译的时候是作为内容直接替换的，因此这部分并不会因此占用你堆、栈等存储空间。所以这就导致无论你将宏定义放在头文件还是放在源文件中，资源消耗上面没有太大差别。差别就是在头文件和源文件中可以使用的作用域不同。\n\n### 1. 放在头文件中：\n\n- 作用域更广，不仅仅对应源文件可以使用，且其他所有的源文件包含这个都可以使用，即便一些常量现在不会被使用，将来也可能会使用。\n- 作用域太宽，可能会与其他文件中的某个宏定义命名冲突，需要定义较长的名字。\n- 方便集中在一起进行管理，看起来代码更加显得整洁。\n\n<!-- more -->\n\n\n\n### 2. 放在头文件中：\n\n- 没有统一管理，分部零散，查找较麻烦，将来一些需要引用的话，重新修改程序。\n- 只作用需要使用到的范围，减少与其他文件的关联性，出错几率更低。\n- 宏定义名称无所谓起多长，作用域有限，不会与其他文件冲突。\n- 只将需要在其他文件中使用的宏定义放在头文件中，按需进行分配。\n\n个人建议：\n**采用方法 2，将宏定义绝大多数放在 .c 文件中，只将极个别需要其他源文件引用的宏定义放在 .h 中，这可以有效控制一些源文件没必要的相关性，虽然较长的定义名也避免了出错，但为了减少耦合性，按照需求来进行分配算是一个良好的编程习惯，否则工程一旦复杂性增加难免会出现一些意想不到的问题。**\n","source":"_posts/2016/2016-08-24-c语言中宏定义存在位置.md","raw":"---\nlayout: \"post\"\ntitle: \"C语言中宏定义存在位置\"\ndate: \"2016-08-24 18:34\"\n---\n\n\n*宏定义作为C语言的一个传统内容，如果使用新标准的话，一般也只用宏定义来结局编译的一些问题如：#ifndef，#if undefined()等。*\n\n宏定义究竟放在什么地方，在使用 C 语言老款编辑器情况下，一些程序大量使用宏定义，且很多程序都是将宏定义作为申明一样全部放在头文件中的，这个没有一个统一的说法，其中各有利弊，每个人风格不尽相同。\n\n首先，宏定义的常量在编译的时候是作为内容直接替换的，因此这部分并不会因此占用你堆、栈等存储空间。所以这就导致无论你将宏定义放在头文件还是放在源文件中，资源消耗上面没有太大差别。差别就是在头文件和源文件中可以使用的作用域不同。\n\n### 1. 放在头文件中：\n\n- 作用域更广，不仅仅对应源文件可以使用，且其他所有的源文件包含这个都可以使用，即便一些常量现在不会被使用，将来也可能会使用。\n- 作用域太宽，可能会与其他文件中的某个宏定义命名冲突，需要定义较长的名字。\n- 方便集中在一起进行管理，看起来代码更加显得整洁。\n\n<!-- more -->\n\n\n\n### 2. 放在头文件中：\n\n- 没有统一管理，分部零散，查找较麻烦，将来一些需要引用的话，重新修改程序。\n- 只作用需要使用到的范围，减少与其他文件的关联性，出错几率更低。\n- 宏定义名称无所谓起多长，作用域有限，不会与其他文件冲突。\n- 只将需要在其他文件中使用的宏定义放在头文件中，按需进行分配。\n\n个人建议：\n**采用方法 2，将宏定义绝大多数放在 .c 文件中，只将极个别需要其他源文件引用的宏定义放在 .h 中，这可以有效控制一些源文件没必要的相关性，虽然较长的定义名也避免了出错，但为了减少耦合性，按照需求来进行分配算是一个良好的编程习惯，否则工程一旦复杂性增加难免会出现一些意想不到的问题。**\n","slug":"2016/2016-08-24-c语言中宏定义存在位置","published":1,"updated":"2017-01-12T05:27:40.006Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahl0025mumu0dcwra8k","content":"<p><em>宏定义作为C语言的一个传统内容，如果使用新标准的话，一般也只用宏定义来结局编译的一些问题如：#ifndef，#if undefined()等。</em></p>\n<p>宏定义究竟放在什么地方，在使用 C 语言老款编辑器情况下，一些程序大量使用宏定义，且很多程序都是将宏定义作为申明一样全部放在头文件中的，这个没有一个统一的说法，其中各有利弊，每个人风格不尽相同。</p>\n<p>首先，宏定义的常量在编译的时候是作为内容直接替换的，因此这部分并不会因此占用你堆、栈等存储空间。所以这就导致无论你将宏定义放在头文件还是放在源文件中，资源消耗上面没有太大差别。差别就是在头文件和源文件中可以使用的作用域不同。</p>\n<h3 id=\"1-放在头文件中：\"><a href=\"#1-放在头文件中：\" class=\"headerlink\" title=\"1. 放在头文件中：\"></a>1. 放在头文件中：</h3><ul>\n<li>作用域更广，不仅仅对应源文件可以使用，且其他所有的源文件包含这个都可以使用，即便一些常量现在不会被使用，将来也可能会使用。</li>\n<li>作用域太宽，可能会与其他文件中的某个宏定义命名冲突，需要定义较长的名字。</li>\n<li>方便集中在一起进行管理，看起来代码更加显得整洁。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"2-放在头文件中：\"><a href=\"#2-放在头文件中：\" class=\"headerlink\" title=\"2. 放在头文件中：\"></a>2. 放在头文件中：</h3><ul>\n<li>没有统一管理，分部零散，查找较麻烦，将来一些需要引用的话，重新修改程序。</li>\n<li>只作用需要使用到的范围，减少与其他文件的关联性，出错几率更低。</li>\n<li>宏定义名称无所谓起多长，作用域有限，不会与其他文件冲突。</li>\n<li>只将需要在其他文件中使用的宏定义放在头文件中，按需进行分配。</li>\n</ul>\n<p>个人建议：<br><strong>采用方法 2，将宏定义绝大多数放在 .c 文件中，只将极个别需要其他源文件引用的宏定义放在 .h 中，这可以有效控制一些源文件没必要的相关性，虽然较长的定义名也避免了出错，但为了减少耦合性，按照需求来进行分配算是一个良好的编程习惯，否则工程一旦复杂性增加难免会出现一些意想不到的问题。</strong></p>\n","excerpt":"<p><em>宏定义作为C语言的一个传统内容，如果使用新标准的话，一般也只用宏定义来结局编译的一些问题如：#ifndef，#if undefined()等。</em></p>\n<p>宏定义究竟放在什么地方，在使用 C 语言老款编辑器情况下，一些程序大量使用宏定义，且很多程序都是将宏定义作为申明一样全部放在头文件中的，这个没有一个统一的说法，其中各有利弊，每个人风格不尽相同。</p>\n<p>首先，宏定义的常量在编译的时候是作为内容直接替换的，因此这部分并不会因此占用你堆、栈等存储空间。所以这就导致无论你将宏定义放在头文件还是放在源文件中，资源消耗上面没有太大差别。差别就是在头文件和源文件中可以使用的作用域不同。</p>\n<h3 id=\"1-放在头文件中：\"><a href=\"#1-放在头文件中：\" class=\"headerlink\" title=\"1. 放在头文件中：\"></a>1. 放在头文件中：</h3><ul>\n<li>作用域更广，不仅仅对应源文件可以使用，且其他所有的源文件包含这个都可以使用，即便一些常量现在不会被使用，将来也可能会使用。</li>\n<li>作用域太宽，可能会与其他文件中的某个宏定义命名冲突，需要定义较长的名字。</li>\n<li>方便集中在一起进行管理，看起来代码更加显得整洁。</li>\n</ul>","more":"<h3 id=\"2-放在头文件中：\"><a href=\"#2-放在头文件中：\" class=\"headerlink\" title=\"2. 放在头文件中：\"></a>2. 放在头文件中：</h3><ul>\n<li>没有统一管理，分部零散，查找较麻烦，将来一些需要引用的话，重新修改程序。</li>\n<li>只作用需要使用到的范围，减少与其他文件的关联性，出错几率更低。</li>\n<li>宏定义名称无所谓起多长，作用域有限，不会与其他文件冲突。</li>\n<li>只将需要在其他文件中使用的宏定义放在头文件中，按需进行分配。</li>\n</ul>\n<p>个人建议：<br><strong>采用方法 2，将宏定义绝大多数放在 .c 文件中，只将极个别需要其他源文件引用的宏定义放在 .h 中，这可以有效控制一些源文件没必要的相关性，虽然较长的定义名也避免了出错，但为了减少耦合性，按照需求来进行分配算是一个良好的编程习惯，否则工程一旦复杂性增加难免会出现一些意想不到的问题。</strong></p>"},{"layout":"post","title":"头文件交叉引用","date":"2016-08-24T10:32:00.000Z","_content":"\n**尽可能将所需要包含的头文件文件在.c文件中包含定义如：#inlcude \"x.h\"，除非头文件必须的部分申明出现在其他头文件中定义过的结构体或者宏定义类型，这时候没办法，只能在.h中包含.h。**\n\n具体分析这样定义的原因：\n\n#### 1. 减少编译展开所需时间\n\n虽然头文件中都加入了\n```\n#ifndef __KEY_H\n#define __KEY_H\n...\n#endif\n```\n一般编译不会再出现重定等错误，但是每次遇到#include的时候，都会将这段代码复制一边进行排查，而头文件多次被展开，会严重影响编译效率，且也没有什么好处。\n\n<!-- more -->\n\n\n\n#### 2. 头文件的嵌套调用难免造成问题\n\n两个.c文件相互调用彼此的内容是常有的事情，这时候如果处理不善则往往会遇到未声明之类的报错，这种情况需要你小心的调整#include\"x.h\"文件在编译过程中第一次出现的顺序。\n```\n举例：\na.h中存在#inlcude \"b.h\"\nb.h中存在#inlcude \"a.h\"\n而这时候a.h依赖于 b.h,但b.h直接被先包含在了main.c文件中，这时候往往会提示编译错误，原因是a.h中的一些内容未被申明定义。\n\n具体解析：\n编译器在编译的过程中，如果先从main.c文件开始执行，main.c中包含有b.h，而b.h中包含有a.h则展开为：\n\nb.h(上部分极少数定义包含内容)\na.h(全部内容，因为#ifndef，所以b.h不会在a.h中再出现)\nb.h(绝大多数内容)\n因此，通过上述代码，在执行编译过程中，在编译a.h时则无法找到依赖b.h的一些相关定义。\n```\n\n**直接将头文件文件相互写入到对方的头文件文件下这时候最容易出错。解决的办法一般是：1.将所有不需要写在头文件中的#inlcude写在#inlcude \".h\"中。2.小心调整#inlcude \".h\"的顺序，将需要依赖其他的那个调用放在后面，对于多次嵌套调用等情况，调整顺序时尤其需要注意顺序。**\n","source":"_posts/2016/2016-08-24-头文件交叉引用.md","raw":"---\nlayout: \"post\"\ntitle: \"头文件交叉引用\"\ndate: \"2016-08-24 18:32\"\n---\n\n**尽可能将所需要包含的头文件文件在.c文件中包含定义如：#inlcude \"x.h\"，除非头文件必须的部分申明出现在其他头文件中定义过的结构体或者宏定义类型，这时候没办法，只能在.h中包含.h。**\n\n具体分析这样定义的原因：\n\n#### 1. 减少编译展开所需时间\n\n虽然头文件中都加入了\n```\n#ifndef __KEY_H\n#define __KEY_H\n...\n#endif\n```\n一般编译不会再出现重定等错误，但是每次遇到#include的时候，都会将这段代码复制一边进行排查，而头文件多次被展开，会严重影响编译效率，且也没有什么好处。\n\n<!-- more -->\n\n\n\n#### 2. 头文件的嵌套调用难免造成问题\n\n两个.c文件相互调用彼此的内容是常有的事情，这时候如果处理不善则往往会遇到未声明之类的报错，这种情况需要你小心的调整#include\"x.h\"文件在编译过程中第一次出现的顺序。\n```\n举例：\na.h中存在#inlcude \"b.h\"\nb.h中存在#inlcude \"a.h\"\n而这时候a.h依赖于 b.h,但b.h直接被先包含在了main.c文件中，这时候往往会提示编译错误，原因是a.h中的一些内容未被申明定义。\n\n具体解析：\n编译器在编译的过程中，如果先从main.c文件开始执行，main.c中包含有b.h，而b.h中包含有a.h则展开为：\n\nb.h(上部分极少数定义包含内容)\na.h(全部内容，因为#ifndef，所以b.h不会在a.h中再出现)\nb.h(绝大多数内容)\n因此，通过上述代码，在执行编译过程中，在编译a.h时则无法找到依赖b.h的一些相关定义。\n```\n\n**直接将头文件文件相互写入到对方的头文件文件下这时候最容易出错。解决的办法一般是：1.将所有不需要写在头文件中的#inlcude写在#inlcude \".h\"中。2.小心调整#inlcude \".h\"的顺序，将需要依赖其他的那个调用放在后面，对于多次嵌套调用等情况，调整顺序时尤其需要注意顺序。**\n","slug":"2016/2016-08-24-头文件交叉引用","published":1,"updated":"2016-12-16T01:45:38.916Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahl0026mumuqk5tc9fn","content":"<p><strong>尽可能将所需要包含的头文件文件在.c文件中包含定义如：#inlcude “x.h”，除非头文件必须的部分申明出现在其他头文件中定义过的结构体或者宏定义类型，这时候没办法，只能在.h中包含.h。</strong></p>\n<p>具体分析这样定义的原因：</p>\n<h4 id=\"1-减少编译展开所需时间\"><a href=\"#1-减少编译展开所需时间\" class=\"headerlink\" title=\"1. 减少编译展开所需时间\"></a>1. 减少编译展开所需时间</h4><p>虽然头文件中都加入了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">#ifndef __KEY_H</div><div class=\"line\">#define __KEY_H</div><div class=\"line\">...</div><div class=\"line\">#endif</div></pre></td></tr></table></figure></p>\n<p>一般编译不会再出现重定等错误，但是每次遇到#include的时候，都会将这段代码复制一边进行排查，而头文件多次被展开，会严重影响编译效率，且也没有什么好处。</p>\n<a id=\"more\"></a>\n<h4 id=\"2-头文件的嵌套调用难免造成问题\"><a href=\"#2-头文件的嵌套调用难免造成问题\" class=\"headerlink\" title=\"2. 头文件的嵌套调用难免造成问题\"></a>2. 头文件的嵌套调用难免造成问题</h4><p>两个.c文件相互调用彼此的内容是常有的事情，这时候如果处理不善则往往会遇到未声明之类的报错，这种情况需要你小心的调整#include”x.h”文件在编译过程中第一次出现的顺序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">举例：</div><div class=\"line\">a.h中存在#inlcude &quot;b.h&quot;</div><div class=\"line\">b.h中存在#inlcude &quot;a.h&quot;</div><div class=\"line\">而这时候a.h依赖于 b.h,但b.h直接被先包含在了main.c文件中，这时候往往会提示编译错误，原因是a.h中的一些内容未被申明定义。</div><div class=\"line\"></div><div class=\"line\">具体解析：</div><div class=\"line\">编译器在编译的过程中，如果先从main.c文件开始执行，main.c中包含有b.h，而b.h中包含有a.h则展开为：</div><div class=\"line\"></div><div class=\"line\">b.h(上部分极少数定义包含内容)</div><div class=\"line\">a.h(全部内容，因为#ifndef，所以b.h不会在a.h中再出现)</div><div class=\"line\">b.h(绝大多数内容)</div><div class=\"line\">因此，通过上述代码，在执行编译过程中，在编译a.h时则无法找到依赖b.h的一些相关定义。</div></pre></td></tr></table></figure></p>\n<p><strong>直接将头文件文件相互写入到对方的头文件文件下这时候最容易出错。解决的办法一般是：1.将所有不需要写在头文件中的#inlcude写在#inlcude “.h”中。2.小心调整#inlcude “.h”的顺序，将需要依赖其他的那个调用放在后面，对于多次嵌套调用等情况，调整顺序时尤其需要注意顺序。</strong></p>\n","excerpt":"<p><strong>尽可能将所需要包含的头文件文件在.c文件中包含定义如：#inlcude “x.h”，除非头文件必须的部分申明出现在其他头文件中定义过的结构体或者宏定义类型，这时候没办法，只能在.h中包含.h。</strong></p>\n<p>具体分析这样定义的原因：</p>\n<h4 id=\"1-减少编译展开所需时间\"><a href=\"#1-减少编译展开所需时间\" class=\"headerlink\" title=\"1. 减少编译展开所需时间\"></a>1. 减少编译展开所需时间</h4><p>虽然头文件中都加入了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">#ifndef __KEY_H</div><div class=\"line\">#define __KEY_H</div><div class=\"line\">...</div><div class=\"line\">#endif</div></pre></td></tr></table></figure></p>\n<p>一般编译不会再出现重定等错误，但是每次遇到#include的时候，都会将这段代码复制一边进行排查，而头文件多次被展开，会严重影响编译效率，且也没有什么好处。</p>","more":"<h4 id=\"2-头文件的嵌套调用难免造成问题\"><a href=\"#2-头文件的嵌套调用难免造成问题\" class=\"headerlink\" title=\"2. 头文件的嵌套调用难免造成问题\"></a>2. 头文件的嵌套调用难免造成问题</h4><p>两个.c文件相互调用彼此的内容是常有的事情，这时候如果处理不善则往往会遇到未声明之类的报错，这种情况需要你小心的调整#include”x.h”文件在编译过程中第一次出现的顺序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">举例：</div><div class=\"line\">a.h中存在#inlcude &quot;b.h&quot;</div><div class=\"line\">b.h中存在#inlcude &quot;a.h&quot;</div><div class=\"line\">而这时候a.h依赖于 b.h,但b.h直接被先包含在了main.c文件中，这时候往往会提示编译错误，原因是a.h中的一些内容未被申明定义。</div><div class=\"line\"></div><div class=\"line\">具体解析：</div><div class=\"line\">编译器在编译的过程中，如果先从main.c文件开始执行，main.c中包含有b.h，而b.h中包含有a.h则展开为：</div><div class=\"line\"></div><div class=\"line\">b.h(上部分极少数定义包含内容)</div><div class=\"line\">a.h(全部内容，因为#ifndef，所以b.h不会在a.h中再出现)</div><div class=\"line\">b.h(绝大多数内容)</div><div class=\"line\">因此，通过上述代码，在执行编译过程中，在编译a.h时则无法找到依赖b.h的一些相关定义。</div></pre></td></tr></table></figure></p>\n<p><strong>直接将头文件文件相互写入到对方的头文件文件下这时候最容易出错。解决的办法一般是：1.将所有不需要写在头文件中的#inlcude写在#inlcude “.h”中。2.小心调整#inlcude “.h”的顺序，将需要依赖其他的那个调用放在后面，对于多次嵌套调用等情况，调整顺序时尤其需要注意顺序。</strong></p>"},{"layout":"post","title":"ubuntu的基本使用","date":"2016-08-15T06:25:00.000Z","_content":"\n*本文专门针对ubuntu这个linux发行版而写的，对ubuntu特有一些操作进行介绍和总结。*\n\n### apt-get\n\n*用过ubuntu的人都知道apt-get的方便*\n\n#### 远程安装软件：\n\n- sudo apt-get install xxx 远程库一般会提供不少常见的软件，当然也可以手动添加源。\n- sudo apt-get install -f 常用于手动安装软件后，出现错误，一般该指令可以解决大多数的依赖关系。\n\n#### 删除软件：\n\n- sudo apt-get remove xxx 删除一个软件包\n\n<!-- more -->\n\n#### 清理命令：\n\n- sudo apt-get autoclean                清理旧版本的软件缓存\n- sudo apt-get clean                    清理所有软件缓存\n- sudo apt-get autoremove             删除系统不再使用的孤立软件\n\n*这三个命令主要清理升级缓存以及无用包的。*\n\n### 启动项\n\n在/etc/rc.local中可以加入ubuntu的开机自启内容。\n\n\n***\n\nTo be continued...\n\n\n\n> 参考网址：\n> http://my.oschina.net/zhangqingcai/blog/23994\n","source":"_posts/2016/2016-08-15-ubuntu的基本使用.md","raw":"---\nlayout: \"post\"\ntitle: \"ubuntu的基本使用\"\ndate: \"2016-08-15 14:25\"\n---\n\n*本文专门针对ubuntu这个linux发行版而写的，对ubuntu特有一些操作进行介绍和总结。*\n\n### apt-get\n\n*用过ubuntu的人都知道apt-get的方便*\n\n#### 远程安装软件：\n\n- sudo apt-get install xxx 远程库一般会提供不少常见的软件，当然也可以手动添加源。\n- sudo apt-get install -f 常用于手动安装软件后，出现错误，一般该指令可以解决大多数的依赖关系。\n\n#### 删除软件：\n\n- sudo apt-get remove xxx 删除一个软件包\n\n<!-- more -->\n\n#### 清理命令：\n\n- sudo apt-get autoclean                清理旧版本的软件缓存\n- sudo apt-get clean                    清理所有软件缓存\n- sudo apt-get autoremove             删除系统不再使用的孤立软件\n\n*这三个命令主要清理升级缓存以及无用包的。*\n\n### 启动项\n\n在/etc/rc.local中可以加入ubuntu的开机自启内容。\n\n\n***\n\nTo be continued...\n\n\n\n> 参考网址：\n> http://my.oschina.net/zhangqingcai/blog/23994\n","slug":"2016/2016-08-15-ubuntu的基本使用","published":1,"updated":"2016-12-16T01:45:17.536Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahn0027mumucapeu8bf","content":"<p><em>本文专门针对ubuntu这个linux发行版而写的，对ubuntu特有一些操作进行介绍和总结。</em></p>\n<h3 id=\"apt-get\"><a href=\"#apt-get\" class=\"headerlink\" title=\"apt-get\"></a>apt-get</h3><p><em>用过ubuntu的人都知道apt-get的方便</em></p>\n<h4 id=\"远程安装软件：\"><a href=\"#远程安装软件：\" class=\"headerlink\" title=\"远程安装软件：\"></a>远程安装软件：</h4><ul>\n<li>sudo apt-get install xxx 远程库一般会提供不少常见的软件，当然也可以手动添加源。</li>\n<li>sudo apt-get install -f 常用于手动安装软件后，出现错误，一般该指令可以解决大多数的依赖关系。</li>\n</ul>\n<h4 id=\"删除软件：\"><a href=\"#删除软件：\" class=\"headerlink\" title=\"删除软件：\"></a>删除软件：</h4><ul>\n<li>sudo apt-get remove xxx 删除一个软件包</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"清理命令：\"><a href=\"#清理命令：\" class=\"headerlink\" title=\"清理命令：\"></a>清理命令：</h4><ul>\n<li>sudo apt-get autoclean                清理旧版本的软件缓存</li>\n<li>sudo apt-get clean                    清理所有软件缓存</li>\n<li>sudo apt-get autoremove             删除系统不再使用的孤立软件</li>\n</ul>\n<p><em>这三个命令主要清理升级缓存以及无用包的。</em></p>\n<h3 id=\"启动项\"><a href=\"#启动项\" class=\"headerlink\" title=\"启动项\"></a>启动项</h3><p>在/etc/rc.local中可以加入ubuntu的开机自启内容。</p>\n<hr>\n<p>To be continued…</p>\n<blockquote>\n<p>参考网址：<br><a href=\"http://my.oschina.net/zhangqingcai/blog/23994\" target=\"_blank\" rel=\"external\">http://my.oschina.net/zhangqingcai/blog/23994</a></p>\n</blockquote>\n","excerpt":"<p><em>本文专门针对ubuntu这个linux发行版而写的，对ubuntu特有一些操作进行介绍和总结。</em></p>\n<h3 id=\"apt-get\"><a href=\"#apt-get\" class=\"headerlink\" title=\"apt-get\"></a>apt-get</h3><p><em>用过ubuntu的人都知道apt-get的方便</em></p>\n<h4 id=\"远程安装软件：\"><a href=\"#远程安装软件：\" class=\"headerlink\" title=\"远程安装软件：\"></a>远程安装软件：</h4><ul>\n<li>sudo apt-get install xxx 远程库一般会提供不少常见的软件，当然也可以手动添加源。</li>\n<li>sudo apt-get install -f 常用于手动安装软件后，出现错误，一般该指令可以解决大多数的依赖关系。</li>\n</ul>\n<h4 id=\"删除软件：\"><a href=\"#删除软件：\" class=\"headerlink\" title=\"删除软件：\"></a>删除软件：</h4><ul>\n<li>sudo apt-get remove xxx 删除一个软件包</li>\n</ul>","more":"<h4 id=\"清理命令：\"><a href=\"#清理命令：\" class=\"headerlink\" title=\"清理命令：\"></a>清理命令：</h4><ul>\n<li>sudo apt-get autoclean                清理旧版本的软件缓存</li>\n<li>sudo apt-get clean                    清理所有软件缓存</li>\n<li>sudo apt-get autoremove             删除系统不再使用的孤立软件</li>\n</ul>\n<p><em>这三个命令主要清理升级缓存以及无用包的。</em></p>\n<h3 id=\"启动项\"><a href=\"#启动项\" class=\"headerlink\" title=\"启动项\"></a>启动项</h3><p>在/etc/rc.local中可以加入ubuntu的开机自启内容。</p>\n<hr>\n<p>To be continued…</p>\n<blockquote>\n<p>参考网址：<br><a href=\"http://my.oschina.net/zhangqingcai/blog/23994\">http://my.oschina.net/zhangqingcai/blog/23994</a></p>\n</blockquote>"},{"layout":"post","title":"linux下的shell和终端使用","date":"2016-08-26T08:11:00.000Z","_content":"\n\n### ZSH使用\n*bash为linux和OS X传统的默认shell，但使用起来比较麻烦，缺少一些人性化的特性，而现在流行的ZSH补足了bash的这些问题，且通过[oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)可以很方便的配置，因此已经广泛的被很多人使用。下面将会对网上的资料和自我使用经验做一个详细的总结。*\n\n\n\n### Tmux使用\n\n<!-- more -->\n\n\n\n> 参考网址：\n> http://blog.jobbole.com/87584/\n> http://xiaozhou.net/build-your-go-ide-2015-07-18.html\n","source":"_posts/2016/2016-08-26-linux下的shell和终端使用.md","raw":"---\nlayout: \"post\"\ntitle: \"linux下的shell和终端使用\"\ndate: \"2016-08-26 16:11\"\n---\n\n\n### ZSH使用\n*bash为linux和OS X传统的默认shell，但使用起来比较麻烦，缺少一些人性化的特性，而现在流行的ZSH补足了bash的这些问题，且通过[oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)可以很方便的配置，因此已经广泛的被很多人使用。下面将会对网上的资料和自我使用经验做一个详细的总结。*\n\n\n\n### Tmux使用\n\n<!-- more -->\n\n\n\n> 参考网址：\n> http://blog.jobbole.com/87584/\n> http://xiaozhou.net/build-your-go-ide-2015-07-18.html\n","slug":"2016/2016-08-26-linux下的shell和终端使用","published":1,"updated":"2016-12-16T01:46:57.261Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahn0028mumuju2549dv","content":"<h3 id=\"ZSH使用\"><a href=\"#ZSH使用\" class=\"headerlink\" title=\"ZSH使用\"></a>ZSH使用</h3><p><em>bash为linux和OS X传统的默认shell，但使用起来比较麻烦，缺少一些人性化的特性，而现在流行的ZSH补足了bash的这些问题，且通过<a href=\"https://github.com/robbyrussell/oh-my-zsh\" target=\"_blank\" rel=\"external\">oh-my-zsh</a>可以很方便的配置，因此已经广泛的被很多人使用。下面将会对网上的资料和自我使用经验做一个详细的总结。</em></p>\n<h3 id=\"Tmux使用\"><a href=\"#Tmux使用\" class=\"headerlink\" title=\"Tmux使用\"></a>Tmux使用</h3><a id=\"more\"></a>\n<blockquote>\n<p>参考网址：<br><a href=\"http://blog.jobbole.com/87584/\" target=\"_blank\" rel=\"external\">http://blog.jobbole.com/87584/</a><br><a href=\"http://xiaozhou.net/build-your-go-ide-2015-07-18.html\" target=\"_blank\" rel=\"external\">http://xiaozhou.net/build-your-go-ide-2015-07-18.html</a></p>\n</blockquote>\n","excerpt":"<h3 id=\"ZSH使用\"><a href=\"#ZSH使用\" class=\"headerlink\" title=\"ZSH使用\"></a>ZSH使用</h3><p><em>bash为linux和OS X传统的默认shell，但使用起来比较麻烦，缺少一些人性化的特性，而现在流行的ZSH补足了bash的这些问题，且通过<a href=\"https://github.com/robbyrussell/oh-my-zsh\">oh-my-zsh</a>可以很方便的配置，因此已经广泛的被很多人使用。下面将会对网上的资料和自我使用经验做一个详细的总结。</em></p>\n<h3 id=\"Tmux使用\"><a href=\"#Tmux使用\" class=\"headerlink\" title=\"Tmux使用\"></a>Tmux使用</h3>","more":"<blockquote>\n<p>参考网址：<br><a href=\"http://blog.jobbole.com/87584/\">http://blog.jobbole.com/87584/</a><br><a href=\"http://xiaozhou.net/build-your-go-ide-2015-07-18.html\">http://xiaozhou.net/build-your-go-ide-2015-07-18.html</a></p>\n</blockquote>"},{"layout":"post","title":"C/C++编程规范","date":"2016-08-10T16:00:00.000Z","_content":"\n*文章阐述个人使用 C/C++ 的一些命名规范总结，当然现在很多编辑器强大，很多人不再注意这些规范，但由于本人记性较差，加上打字速度较快，所以这套规范虽然繁琐，但还是比较适合我自己的。*\n\n### 1. 命名规范    \n\n#### 1.1 宏定义的命名全部采用大写，中间间隔用_隔开，要求常量名用大写，常量名用英文表达其意思。 当需要由多个单词表示时，单词与单词之间必须采用连字符\"_\"连接。 \n\n```\n如：\n#define CM_FILE_NOT_FOUND  CMMAKEHR(0X20B) 其中CM表示类别。 \n```\n\n#### 1.2 变量的命名规则要求用“匈牙利命名法”。 (即便很冗余且很多时候并没有实际作用，但方便查看，记性差防止跳过去查了就忘的情况)\n\n*这种命名法的出发点是把变量名按：属性+类型+对象描述的顺序组合起来：*\n\n<!-- more -->\n\n\n- 属性部分：   \n\n```\ng_ 全局变量\t：如一个全局的长型变量定义为g_lFailCount。  \nm_ 　类，结构体成员变量\ns_ 　静态变量：如一个静态的指针变量定义为s_plPerv_Inst\nc_ 　常量： const 的变量 示例：const char* c_szFileName; \n```\n\n- 类型部分：\n\n```\nbool 用b开头 b标志寄存器 \nint 用i  32位开头 iCount \nshort  int  16位用n开头 nStepCount \nlong  int 用l开头 lSum \nchar  用c开头 cCount \nfloat 用f开头 fAvg \ndouble 用d开头 dDeta \nunsigned  char / byte(字节) 用by开头 \nunsigned  int(WORD) 用w开头 wCount \nunsigned  long  int(DWORD) 用dw开头 dwBroad \n字符串 用s开头 sFileName \n用0结尾的字符串 用sz开头 szFileName \n指针数组跟着上面类型之前：\n数组 a：如一个short int型数组应该表示为anStat。\n指针 p：\n对一重指针变量的基本原则为：“p”+变量类型前缀+命名，如一个float*型应该表示为pfStat。对二重指针变量的基本规则为：“pp”+变量类型前缀+命名。对三重指针变量的基本规则为：“ppp”+变量类型前缀+命名。 \n```\n\n- 描述部分：\n\n```\n最大　Max\t\t最小　Min\t\t初始化　Init\t\t临时变量　T（或Temp）\n源对象　Src\t\t目的对象　Dest\n```\n\n#### 1.3 枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用 EM_+ 大写字母类似宏定义的形式，申明为枚举型的变量使用以 em 为头的驼峰式命名(枚举变量本身就类似于常量)。\n\n```\n如： \nenum EMDays \n{ \n\tEM_DAYS_MONDAY; \n\tEM_DAYS_TUESDAY; \n\t…… \n}; \nEMDays  emToday;\n```\n\n#### 1.4 结构体、类、共用体的命名规则统一采用大驼峰式（帕斯克命名法），结构体类型定义时在前面需要加上 stru 前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量统一加 m_ 不允许使用任何下划线。（函数与结构体变量方便区分，固都采用大驼峰式）\n\n```\n如：\ntypedef struct\n{ \n\tchar *m_pcNodeNext;\nchar *m_pcNodePreview;\n}struStudentNode; \nstruStudentNode  StudentNode;\n```\n\n#### 1.5 函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如`NVIC_Configuration，init_I2C，delay_us 硬件设备相关的使用下划线`，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）\n\n**函数参数命名规范 :**\n\n- 参数名称的命名参照变量命名规范。\n- 为了提高程序的运行效率，减少参数占用的堆栈，传递大结构的参数，一律采用指针或引用方式传递。\n- 为了便于其他程序员识别某个指针参数是入口参数还是出口参数，同时便于编译器检查错误，应该在入口参数前加入const标志。 \n\n```\n如：\nint CmCopyString(const char * c_pcSource, char* pcDest) \n{\n...\n}\n```\n\n- 普通函数与中断调用函数区别命名，普通函数如果需要设定控制终中断函数则命名以Set开头通过修改中断函数中的全局变量判定条件来控制中断执行，而中断功能函数只能被中断调用，不可直接被普通函数调用(包括主函数)，命名以 Run 开头。\n\n#### 1.6 硬件设备名称函数命名参考 stm32 固件库命名法则：外设名称在前面全部大写\n\n```\n如：\nvoid NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)\n{\n\t/* Check the parameters */\n\tassert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));\n\n\t/* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */\n\tSCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;\n}\n```\n\n#### 1.7 文件名(包括动态库、组件、控件、工程文件等)的命名规范,文件名的命名要求表达出文件的内容:要求文件名的长度不得少于5个字母，严禁使用象 file1,myfile 之类的文件名，多个具体含义的单词中用_隔开，一般都采用小写。 \n\n#### 1.8 除了编译开关/头文件等特殊应用，应避免使用 _EXAMPLE_TEST_ 之类以下划线开始和结尾的定义。\n\n### 2 注释规范\n\n#### 2.1 文件注释：(使用/*...*/整体注释，不得采用//行注释)\n\n*格式：*\n\n```\n/********************* Copyright(C)  20xx  company********************\n\tFile name: \t// 文件名\n\tAuthor: \t\t// 作者、\n\tVersion:\t\t// 版本\n\tDate: \t\t// 完成日期\n\tDescription: \t// 用于详细说明此程序文件完成的主要功能，与其他模块\n\t\t\t\t// 或函数的接口，输出值、取值范围、含义及参数间的控\n\t\t\t\t// 制、顺序、独立或依赖等关系\n\tOthers: \t\t// 其它内容的说明\n\tFunction List: // 主要函数列表，每条记录应包括函数名及功能简要说明\n\t\t\t\t\t1. ....\n\tHistory: \t// 修改历史记录列表，每条修改记录应包括修改日期、修改\n\t\t\t\t// 者及修改内容简述\n\t<author> \t\t<time>\t \t<version > \t\t<desc>\n\tName1\t\t\t20xx.x.x\t\tVx.x\t\t//修改的内容\n\n*************************************************/\n```\n\n*例：*\n\n```\n/************************************ Copyright (C)  2015  HS ***********************************\n\tFile name：    \tchannel.c\n\tAuthor: \t\tname\n\tversion:\t\t\tV1.0\n\tDescription:\t\t实现多个通道的脉冲发送\n\tOthers:\n\tFunction List:\n\t\t\t\t\tvoid GetChanCtrl(void);\n\t\t\t\t\tvoid SetNormalMode(void);\n\t\t\t\t\tvoid SetImMode(void);\n\t\t\t\t\tvoid CtrlPulse(u8 g_byComRev);\n\t\t\t\t\tvoid SetTimeMode(void);\n\t\t\t\t\tu16 ScanfValue(void);\n\t\t\t\t\tu32 ScanfTime(void);\n\t\t\t\t\tvoid CtrlChannel(void);\n\t\t\t\t\tvoid InitChannel(void);\n\t\t\t\t\tvoid RunNormal(void);\n\t\t\t\t\tvoid RunPulse(void);\n\t\t\t\t\tvoid RunMode(void);\n\tHistory:\n\t<author> \t\t<time>\t \t<version > \t\t<desc>\nName1\t\t\t2015.6.1\t\tV1.1\t\t修复xx问题\n**************************************************************************************************/\n```\n\n#### 2.2 函数注释：(使用/*...*/整体注释，不得采用//行注释)\n\n*格式：*\n\n```\n/**************************************************************************\n\tFunction: \t\t// 函数名称\n\tDescription: \t\t// 函数功能、性能等的描述\n\tCalls: \t\t\t// 被本函数调用的函数清单\n\tCalled By:\t\t \t// 调用本函数的函数清单\n\tTable Accessed: \t// 被访问的表（此项仅对于牵扯到数据库操作的程序）\n\tTable Updated: \t// 被修改的表（此项仅对于牵扯到数据库操作的程序）\n\tInput: \t\t\t// 输入参数说明，包括每个参数的作\n\t\t\t\t\t// 用、取值说明及参数间关系。\n\tOutput: \t\t\t// 对输出参数的说明。\n\tReturn: \t\t\t// 函数返回值的说明\n\tOthers: \t\t\t// 其它说明\n**************************************************************************/\n```\n\n*例：*\n\n```\n/**************************************************************************\n\tFunction: \t\tInitChannel\n\tDescription: \t\t启动初始化所有通道\n\tCalls: \t\t\tTIM_DeInit\n\t\t\t\t\tTIM3_Int_Init\n\tCalled By:\t\t\tmain()\n\tInput: \t\t\t无\n\tOutput: \t\t\t让所有通道输出低电平\n\tReturn: \t\t\t无\n************************************************************************/\n```\n\n#### 2.3 程序块注释：\n\n*一般的程序块注释如 for，while 之类的注释在前面，程序排版整齐，并方便注释的阅读与理解，将注释与其上面的代码用空一行隔开，且该程序块与下面的代码也应该用空一行(使用/\\*...\\*/整体注释，不得采用//行注释)*\n\n```\n例：\nvoid example_fun( void )\n{\n\t/* code one comments */\n\tCodeBlock One\n\n\t/* code two comments */\n\tCodeBlock Two\n\n\t/* code three comments */\n\tCodeBlock Three\n}\n```\n\n#### 2.4 边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则(详见命名规范),在需要注释的变量以及函数调用后加注释使用//，无需空行。\n","source":"_posts/2016/2016-08-11-C编程规范.md","raw":"---\nlayout: \"post\"\ntitle: \"C/C++编程规范\"\ndate: \"2016-08-11 00:00\"\n---\n\n*文章阐述个人使用 C/C++ 的一些命名规范总结，当然现在很多编辑器强大，很多人不再注意这些规范，但由于本人记性较差，加上打字速度较快，所以这套规范虽然繁琐，但还是比较适合我自己的。*\n\n### 1. 命名规范    \n\n#### 1.1 宏定义的命名全部采用大写，中间间隔用_隔开，要求常量名用大写，常量名用英文表达其意思。 当需要由多个单词表示时，单词与单词之间必须采用连字符\"_\"连接。 \n\n```\n如：\n#define CM_FILE_NOT_FOUND  CMMAKEHR(0X20B) 其中CM表示类别。 \n```\n\n#### 1.2 变量的命名规则要求用“匈牙利命名法”。 (即便很冗余且很多时候并没有实际作用，但方便查看，记性差防止跳过去查了就忘的情况)\n\n*这种命名法的出发点是把变量名按：属性+类型+对象描述的顺序组合起来：*\n\n<!-- more -->\n\n\n- 属性部分：   \n\n```\ng_ 全局变量\t：如一个全局的长型变量定义为g_lFailCount。  \nm_ 　类，结构体成员变量\ns_ 　静态变量：如一个静态的指针变量定义为s_plPerv_Inst\nc_ 　常量： const 的变量 示例：const char* c_szFileName; \n```\n\n- 类型部分：\n\n```\nbool 用b开头 b标志寄存器 \nint 用i  32位开头 iCount \nshort  int  16位用n开头 nStepCount \nlong  int 用l开头 lSum \nchar  用c开头 cCount \nfloat 用f开头 fAvg \ndouble 用d开头 dDeta \nunsigned  char / byte(字节) 用by开头 \nunsigned  int(WORD) 用w开头 wCount \nunsigned  long  int(DWORD) 用dw开头 dwBroad \n字符串 用s开头 sFileName \n用0结尾的字符串 用sz开头 szFileName \n指针数组跟着上面类型之前：\n数组 a：如一个short int型数组应该表示为anStat。\n指针 p：\n对一重指针变量的基本原则为：“p”+变量类型前缀+命名，如一个float*型应该表示为pfStat。对二重指针变量的基本规则为：“pp”+变量类型前缀+命名。对三重指针变量的基本规则为：“ppp”+变量类型前缀+命名。 \n```\n\n- 描述部分：\n\n```\n最大　Max\t\t最小　Min\t\t初始化　Init\t\t临时变量　T（或Temp）\n源对象　Src\t\t目的对象　Dest\n```\n\n#### 1.3 枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用 EM_+ 大写字母类似宏定义的形式，申明为枚举型的变量使用以 em 为头的驼峰式命名(枚举变量本身就类似于常量)。\n\n```\n如： \nenum EMDays \n{ \n\tEM_DAYS_MONDAY; \n\tEM_DAYS_TUESDAY; \n\t…… \n}; \nEMDays  emToday;\n```\n\n#### 1.4 结构体、类、共用体的命名规则统一采用大驼峰式（帕斯克命名法），结构体类型定义时在前面需要加上 stru 前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量统一加 m_ 不允许使用任何下划线。（函数与结构体变量方便区分，固都采用大驼峰式）\n\n```\n如：\ntypedef struct\n{ \n\tchar *m_pcNodeNext;\nchar *m_pcNodePreview;\n}struStudentNode; \nstruStudentNode  StudentNode;\n```\n\n#### 1.5 函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如`NVIC_Configuration，init_I2C，delay_us 硬件设备相关的使用下划线`，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）\n\n**函数参数命名规范 :**\n\n- 参数名称的命名参照变量命名规范。\n- 为了提高程序的运行效率，减少参数占用的堆栈，传递大结构的参数，一律采用指针或引用方式传递。\n- 为了便于其他程序员识别某个指针参数是入口参数还是出口参数，同时便于编译器检查错误，应该在入口参数前加入const标志。 \n\n```\n如：\nint CmCopyString(const char * c_pcSource, char* pcDest) \n{\n...\n}\n```\n\n- 普通函数与中断调用函数区别命名，普通函数如果需要设定控制终中断函数则命名以Set开头通过修改中断函数中的全局变量判定条件来控制中断执行，而中断功能函数只能被中断调用，不可直接被普通函数调用(包括主函数)，命名以 Run 开头。\n\n#### 1.6 硬件设备名称函数命名参考 stm32 固件库命名法则：外设名称在前面全部大写\n\n```\n如：\nvoid NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)\n{\n\t/* Check the parameters */\n\tassert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));\n\n\t/* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */\n\tSCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;\n}\n```\n\n#### 1.7 文件名(包括动态库、组件、控件、工程文件等)的命名规范,文件名的命名要求表达出文件的内容:要求文件名的长度不得少于5个字母，严禁使用象 file1,myfile 之类的文件名，多个具体含义的单词中用_隔开，一般都采用小写。 \n\n#### 1.8 除了编译开关/头文件等特殊应用，应避免使用 _EXAMPLE_TEST_ 之类以下划线开始和结尾的定义。\n\n### 2 注释规范\n\n#### 2.1 文件注释：(使用/*...*/整体注释，不得采用//行注释)\n\n*格式：*\n\n```\n/********************* Copyright(C)  20xx  company********************\n\tFile name: \t// 文件名\n\tAuthor: \t\t// 作者、\n\tVersion:\t\t// 版本\n\tDate: \t\t// 完成日期\n\tDescription: \t// 用于详细说明此程序文件完成的主要功能，与其他模块\n\t\t\t\t// 或函数的接口，输出值、取值范围、含义及参数间的控\n\t\t\t\t// 制、顺序、独立或依赖等关系\n\tOthers: \t\t// 其它内容的说明\n\tFunction List: // 主要函数列表，每条记录应包括函数名及功能简要说明\n\t\t\t\t\t1. ....\n\tHistory: \t// 修改历史记录列表，每条修改记录应包括修改日期、修改\n\t\t\t\t// 者及修改内容简述\n\t<author> \t\t<time>\t \t<version > \t\t<desc>\n\tName1\t\t\t20xx.x.x\t\tVx.x\t\t//修改的内容\n\n*************************************************/\n```\n\n*例：*\n\n```\n/************************************ Copyright (C)  2015  HS ***********************************\n\tFile name：    \tchannel.c\n\tAuthor: \t\tname\n\tversion:\t\t\tV1.0\n\tDescription:\t\t实现多个通道的脉冲发送\n\tOthers:\n\tFunction List:\n\t\t\t\t\tvoid GetChanCtrl(void);\n\t\t\t\t\tvoid SetNormalMode(void);\n\t\t\t\t\tvoid SetImMode(void);\n\t\t\t\t\tvoid CtrlPulse(u8 g_byComRev);\n\t\t\t\t\tvoid SetTimeMode(void);\n\t\t\t\t\tu16 ScanfValue(void);\n\t\t\t\t\tu32 ScanfTime(void);\n\t\t\t\t\tvoid CtrlChannel(void);\n\t\t\t\t\tvoid InitChannel(void);\n\t\t\t\t\tvoid RunNormal(void);\n\t\t\t\t\tvoid RunPulse(void);\n\t\t\t\t\tvoid RunMode(void);\n\tHistory:\n\t<author> \t\t<time>\t \t<version > \t\t<desc>\nName1\t\t\t2015.6.1\t\tV1.1\t\t修复xx问题\n**************************************************************************************************/\n```\n\n#### 2.2 函数注释：(使用/*...*/整体注释，不得采用//行注释)\n\n*格式：*\n\n```\n/**************************************************************************\n\tFunction: \t\t// 函数名称\n\tDescription: \t\t// 函数功能、性能等的描述\n\tCalls: \t\t\t// 被本函数调用的函数清单\n\tCalled By:\t\t \t// 调用本函数的函数清单\n\tTable Accessed: \t// 被访问的表（此项仅对于牵扯到数据库操作的程序）\n\tTable Updated: \t// 被修改的表（此项仅对于牵扯到数据库操作的程序）\n\tInput: \t\t\t// 输入参数说明，包括每个参数的作\n\t\t\t\t\t// 用、取值说明及参数间关系。\n\tOutput: \t\t\t// 对输出参数的说明。\n\tReturn: \t\t\t// 函数返回值的说明\n\tOthers: \t\t\t// 其它说明\n**************************************************************************/\n```\n\n*例：*\n\n```\n/**************************************************************************\n\tFunction: \t\tInitChannel\n\tDescription: \t\t启动初始化所有通道\n\tCalls: \t\t\tTIM_DeInit\n\t\t\t\t\tTIM3_Int_Init\n\tCalled By:\t\t\tmain()\n\tInput: \t\t\t无\n\tOutput: \t\t\t让所有通道输出低电平\n\tReturn: \t\t\t无\n************************************************************************/\n```\n\n#### 2.3 程序块注释：\n\n*一般的程序块注释如 for，while 之类的注释在前面，程序排版整齐，并方便注释的阅读与理解，将注释与其上面的代码用空一行隔开，且该程序块与下面的代码也应该用空一行(使用/\\*...\\*/整体注释，不得采用//行注释)*\n\n```\n例：\nvoid example_fun( void )\n{\n\t/* code one comments */\n\tCodeBlock One\n\n\t/* code two comments */\n\tCodeBlock Two\n\n\t/* code three comments */\n\tCodeBlock Three\n}\n```\n\n#### 2.4 边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则(详见命名规范),在需要注释的变量以及函数调用后加注释使用//，无需空行。\n","slug":"2016/2016-08-11-C编程规范","published":1,"updated":"2017-01-12T05:49:15.219Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aho0029mumuy8jcwrqr","content":"<p><em>文章阐述个人使用 C/C++ 的一些命名规范总结，当然现在很多编辑器强大，很多人不再注意这些规范，但由于本人记性较差，加上打字速度较快，所以这套规范虽然繁琐，但还是比较适合我自己的。</em></p>\n<h3 id=\"1-命名规范\"><a href=\"#1-命名规范\" class=\"headerlink\" title=\"1. 命名规范\"></a>1. 命名规范</h3><h4 id=\"1-1-宏定义的命名全部采用大写，中间间隔用隔开，要求常量名用大写，常量名用英文表达其意思。-当需要由多个单词表示时，单词与单词之间必须采用连字符”“连接。\"><a href=\"#1-1-宏定义的命名全部采用大写，中间间隔用隔开，要求常量名用大写，常量名用英文表达其意思。-当需要由多个单词表示时，单词与单词之间必须采用连字符”“连接。\" class=\"headerlink\" title=\"1.1 宏定义的命名全部采用大写，中间间隔用隔开，要求常量名用大写，常量名用英文表达其意思。 当需要由多个单词表示时，单词与单词之间必须采用连字符”“连接。\"></a>1.1 宏定义的命名全部采用大写，中间间隔用<em>隔开，要求常量名用大写，常量名用英文表达其意思。 当需要由多个单词表示时，单词与单词之间必须采用连字符”</em>“连接。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">如：</div><div class=\"line\">#define CM_FILE_NOT_FOUND  CMMAKEHR(0X20B) 其中CM表示类别。</div></pre></td></tr></table></figure>\n<h4 id=\"1-2-变量的命名规则要求用“匈牙利命名法”。-即便很冗余且很多时候并没有实际作用，但方便查看，记性差防止跳过去查了就忘的情况\"><a href=\"#1-2-变量的命名规则要求用“匈牙利命名法”。-即便很冗余且很多时候并没有实际作用，但方便查看，记性差防止跳过去查了就忘的情况\" class=\"headerlink\" title=\"1.2 变量的命名规则要求用“匈牙利命名法”。 (即便很冗余且很多时候并没有实际作用，但方便查看，记性差防止跳过去查了就忘的情况)\"></a>1.2 变量的命名规则要求用“匈牙利命名法”。 (即便很冗余且很多时候并没有实际作用，但方便查看，记性差防止跳过去查了就忘的情况)</h4><p><em>这种命名法的出发点是把变量名按：属性+类型+对象描述的顺序组合起来：</em></p>\n<a id=\"more\"></a>\n<ul>\n<li>属性部分：   </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">g_ 全局变量\t：如一个全局的长型变量定义为g_lFailCount。  </div><div class=\"line\">m_ 　类，结构体成员变量</div><div class=\"line\">s_ 　静态变量：如一个静态的指针变量定义为s_plPerv_Inst</div><div class=\"line\">c_ 　常量： const 的变量 示例：const char* c_szFileName;</div></pre></td></tr></table></figure>\n<ul>\n<li>类型部分：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool 用b开头 b标志寄存器 </div><div class=\"line\">int 用i  32位开头 iCount </div><div class=\"line\">short  int  16位用n开头 nStepCount </div><div class=\"line\">long  int 用l开头 lSum </div><div class=\"line\">char  用c开头 cCount </div><div class=\"line\">float 用f开头 fAvg </div><div class=\"line\">double 用d开头 dDeta </div><div class=\"line\">unsigned  char / byte(字节) 用by开头 </div><div class=\"line\">unsigned  int(WORD) 用w开头 wCount </div><div class=\"line\">unsigned  long  int(DWORD) 用dw开头 dwBroad </div><div class=\"line\">字符串 用s开头 sFileName </div><div class=\"line\">用0结尾的字符串 用sz开头 szFileName </div><div class=\"line\">指针数组跟着上面类型之前：</div><div class=\"line\">数组 a：如一个short int型数组应该表示为anStat。</div><div class=\"line\">指针 p：</div><div class=\"line\">对一重指针变量的基本原则为：“p”+变量类型前缀+命名，如一个float*型应该表示为pfStat。对二重指针变量的基本规则为：“pp”+变量类型前缀+命名。对三重指针变量的基本规则为：“ppp”+变量类型前缀+命名。</div></pre></td></tr></table></figure>\n<ul>\n<li>描述部分：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">最大　Max\t\t最小　Min\t\t初始化　Init\t\t临时变量　T（或Temp）</div><div class=\"line\">源对象　Src\t\t目的对象　Dest</div></pre></td></tr></table></figure>\n<h4 id=\"1-3-枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用-EM-大写字母类似宏定义的形式，申明为枚举型的变量使用以-em-为头的驼峰式命名-枚举变量本身就类似于常量-。\"><a href=\"#1-3-枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用-EM-大写字母类似宏定义的形式，申明为枚举型的变量使用以-em-为头的驼峰式命名-枚举变量本身就类似于常量-。\" class=\"headerlink\" title=\"1.3 枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用 EM_+ 大写字母类似宏定义的形式，申明为枚举型的变量使用以 em 为头的驼峰式命名(枚举变量本身就类似于常量)。\"></a>1.3 枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用 EM_+ 大写字母类似宏定义的形式，申明为枚举型的变量使用以 em 为头的驼峰式命名(枚举变量本身就类似于常量)。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">如： </div><div class=\"line\">enum EMDays </div><div class=\"line\">&#123; </div><div class=\"line\">\tEM_DAYS_MONDAY; </div><div class=\"line\">\tEM_DAYS_TUESDAY; </div><div class=\"line\">\t…… </div><div class=\"line\">&#125;; </div><div class=\"line\">EMDays  emToday;</div></pre></td></tr></table></figure>\n<h4 id=\"1-4-结构体、类、共用体的命名规则统一采用大驼峰式（帕斯克命名法），结构体类型定义时在前面需要加上-stru-前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量统一加-m-不允许使用任何下划线。（函数与结构体变量方便区分，固都采用大驼峰式）\"><a href=\"#1-4-结构体、类、共用体的命名规则统一采用大驼峰式（帕斯克命名法），结构体类型定义时在前面需要加上-stru-前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量统一加-m-不允许使用任何下划线。（函数与结构体变量方便区分，固都采用大驼峰式）\" class=\"headerlink\" title=\"1.4 结构体、类、共用体的命名规则统一采用大驼峰式（帕斯克命名法），结构体类型定义时在前面需要加上 stru 前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量统一加 m_ 不允许使用任何下划线。（函数与结构体变量方便区分，固都采用大驼峰式）\"></a>1.4 结构体、类、共用体的命名规则统一采用大驼峰式（帕斯克命名法），结构体类型定义时在前面需要加上 stru 前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量统一加 m_ 不允许使用任何下划线。（函数与结构体变量方便区分，固都采用大驼峰式）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">如：</div><div class=\"line\">typedef struct</div><div class=\"line\">&#123; </div><div class=\"line\">\tchar *m_pcNodeNext;</div><div class=\"line\">char *m_pcNodePreview;</div><div class=\"line\">&#125;struStudentNode; </div><div class=\"line\">struStudentNode  StudentNode;</div></pre></td></tr></table></figure>\n<h4 id=\"1-5-函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如NVIC-Configuration，init-I2C，delay-us-硬件设备相关的使用下划线，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）\"><a href=\"#1-5-函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如NVIC-Configuration，init-I2C，delay-us-硬件设备相关的使用下划线，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）\" class=\"headerlink\" title=\"1.5 函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如NVIC_Configuration，init_I2C，delay_us 硬件设备相关的使用下划线，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）\"></a>1.5 函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如<code>NVIC_Configuration，init_I2C，delay_us 硬件设备相关的使用下划线</code>，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）</h4><p><strong>函数参数命名规范 :</strong></p>\n<ul>\n<li>参数名称的命名参照变量命名规范。</li>\n<li>为了提高程序的运行效率，减少参数占用的堆栈，传递大结构的参数，一律采用指针或引用方式传递。</li>\n<li>为了便于其他程序员识别某个指针参数是入口参数还是出口参数，同时便于编译器检查错误，应该在入口参数前加入const标志。 </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">如：</div><div class=\"line\">int CmCopyString(const char * c_pcSource, char* pcDest) </div><div class=\"line\">&#123;</div><div class=\"line\">...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>普通函数与中断调用函数区别命名，普通函数如果需要设定控制终中断函数则命名以Set开头通过修改中断函数中的全局变量判定条件来控制中断执行，而中断功能函数只能被中断调用，不可直接被普通函数调用(包括主函数)，命名以 Run 开头。</li>\n</ul>\n<h4 id=\"1-6-硬件设备名称函数命名参考-stm32-固件库命名法则：外设名称在前面全部大写\"><a href=\"#1-6-硬件设备名称函数命名参考-stm32-固件库命名法则：外设名称在前面全部大写\" class=\"headerlink\" title=\"1.6 硬件设备名称函数命名参考 stm32 固件库命名法则：外设名称在前面全部大写\"></a>1.6 硬件设备名称函数命名参考 stm32 固件库命名法则：外设名称在前面全部大写</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">如：</div><div class=\"line\">void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)</div><div class=\"line\">&#123;</div><div class=\"line\">\t/* Check the parameters */</div><div class=\"line\">\tassert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));</div><div class=\"line\"></div><div class=\"line\">\t/* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */</div><div class=\"line\">\tSCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"1-7-文件名-包括动态库、组件、控件、工程文件等-的命名规范-文件名的命名要求表达出文件的内容-要求文件名的长度不得少于5个字母，严禁使用象-file1-myfile-之类的文件名，多个具体含义的单词中用-隔开，一般都采用小写。\"><a href=\"#1-7-文件名-包括动态库、组件、控件、工程文件等-的命名规范-文件名的命名要求表达出文件的内容-要求文件名的长度不得少于5个字母，严禁使用象-file1-myfile-之类的文件名，多个具体含义的单词中用-隔开，一般都采用小写。\" class=\"headerlink\" title=\"1.7 文件名(包括动态库、组件、控件、工程文件等)的命名规范,文件名的命名要求表达出文件的内容:要求文件名的长度不得少于5个字母，严禁使用象 file1,myfile 之类的文件名，多个具体含义的单词中用_隔开，一般都采用小写。\"></a>1.7 文件名(包括动态库、组件、控件、工程文件等)的命名规范,文件名的命名要求表达出文件的内容:要求文件名的长度不得少于5个字母，严禁使用象 file1,myfile 之类的文件名，多个具体含义的单词中用_隔开，一般都采用小写。</h4><h4 id=\"1-8-除了编译开关-头文件等特殊应用，应避免使用-EXAMPLETEST-之类以下划线开始和结尾的定义。\"><a href=\"#1-8-除了编译开关-头文件等特殊应用，应避免使用-EXAMPLETEST-之类以下划线开始和结尾的定义。\" class=\"headerlink\" title=\"1.8 除了编译开关/头文件等特殊应用，应避免使用 _EXAMPLETEST 之类以下划线开始和结尾的定义。\"></a>1.8 除了编译开关/头文件等特殊应用，应避免使用 _EXAMPLE<em>TEST</em> 之类以下划线开始和结尾的定义。</h4><h3 id=\"2-注释规范\"><a href=\"#2-注释规范\" class=\"headerlink\" title=\"2 注释规范\"></a>2 注释规范</h3><h4 id=\"2-1-文件注释：-使用-…-整体注释，不得采用-行注释\"><a href=\"#2-1-文件注释：-使用-…-整体注释，不得采用-行注释\" class=\"headerlink\" title=\"2.1 文件注释：(使用/…/整体注释，不得采用//行注释)\"></a>2.1 文件注释：(使用/<em>…</em>/整体注释，不得采用//行注释)</h4><p><em>格式：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">/********************* Copyright(C)  20xx  company********************</div><div class=\"line\">\tFile name: \t// 文件名</div><div class=\"line\">\tAuthor: \t\t// 作者、</div><div class=\"line\">\tVersion:\t\t// 版本</div><div class=\"line\">\tDate: \t\t// 完成日期</div><div class=\"line\">\tDescription: \t// 用于详细说明此程序文件完成的主要功能，与其他模块</div><div class=\"line\">\t\t\t\t// 或函数的接口，输出值、取值范围、含义及参数间的控</div><div class=\"line\">\t\t\t\t// 制、顺序、独立或依赖等关系</div><div class=\"line\">\tOthers: \t\t// 其它内容的说明</div><div class=\"line\">\tFunction List: // 主要函数列表，每条记录应包括函数名及功能简要说明</div><div class=\"line\">\t\t\t\t\t1. ....</div><div class=\"line\">\tHistory: \t// 修改历史记录列表，每条修改记录应包括修改日期、修改</div><div class=\"line\">\t\t\t\t// 者及修改内容简述</div><div class=\"line\">\t&lt;author&gt; \t\t&lt;time&gt;\t \t&lt;version &gt; \t\t&lt;desc&gt;</div><div class=\"line\">\tName1\t\t\t20xx.x.x\t\tVx.x\t\t//修改的内容</div><div class=\"line\"></div><div class=\"line\">*************************************************/</div></pre></td></tr></table></figure>\n<p><em>例：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">/************************************ Copyright (C)  2015  HS ***********************************</div><div class=\"line\">\tFile name：    \tchannel.c</div><div class=\"line\">\tAuthor: \t\tname</div><div class=\"line\">\tversion:\t\t\tV1.0</div><div class=\"line\">\tDescription:\t\t实现多个通道的脉冲发送</div><div class=\"line\">\tOthers:</div><div class=\"line\">\tFunction List:</div><div class=\"line\">\t\t\t\t\tvoid GetChanCtrl(void);</div><div class=\"line\">\t\t\t\t\tvoid SetNormalMode(void);</div><div class=\"line\">\t\t\t\t\tvoid SetImMode(void);</div><div class=\"line\">\t\t\t\t\tvoid CtrlPulse(u8 g_byComRev);</div><div class=\"line\">\t\t\t\t\tvoid SetTimeMode(void);</div><div class=\"line\">\t\t\t\t\tu16 ScanfValue(void);</div><div class=\"line\">\t\t\t\t\tu32 ScanfTime(void);</div><div class=\"line\">\t\t\t\t\tvoid CtrlChannel(void);</div><div class=\"line\">\t\t\t\t\tvoid InitChannel(void);</div><div class=\"line\">\t\t\t\t\tvoid RunNormal(void);</div><div class=\"line\">\t\t\t\t\tvoid RunPulse(void);</div><div class=\"line\">\t\t\t\t\tvoid RunMode(void);</div><div class=\"line\">\tHistory:</div><div class=\"line\">\t&lt;author&gt; \t\t&lt;time&gt;\t \t&lt;version &gt; \t\t&lt;desc&gt;</div><div class=\"line\">Name1\t\t\t2015.6.1\t\tV1.1\t\t修复xx问题</div><div class=\"line\">**************************************************************************************************/</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-函数注释：-使用-…-整体注释，不得采用-行注释\"><a href=\"#2-2-函数注释：-使用-…-整体注释，不得采用-行注释\" class=\"headerlink\" title=\"2.2 函数注释：(使用/…/整体注释，不得采用//行注释)\"></a>2.2 函数注释：(使用/<em>…</em>/整体注释，不得采用//行注释)</h4><p><em>格式：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**************************************************************************</div><div class=\"line\">\tFunction: \t\t// 函数名称</div><div class=\"line\">\tDescription: \t\t// 函数功能、性能等的描述</div><div class=\"line\">\tCalls: \t\t\t// 被本函数调用的函数清单</div><div class=\"line\">\tCalled By:\t\t \t// 调用本函数的函数清单</div><div class=\"line\">\tTable Accessed: \t// 被访问的表（此项仅对于牵扯到数据库操作的程序）</div><div class=\"line\">\tTable Updated: \t// 被修改的表（此项仅对于牵扯到数据库操作的程序）</div><div class=\"line\">\tInput: \t\t\t// 输入参数说明，包括每个参数的作</div><div class=\"line\">\t\t\t\t\t// 用、取值说明及参数间关系。</div><div class=\"line\">\tOutput: \t\t\t// 对输出参数的说明。</div><div class=\"line\">\tReturn: \t\t\t// 函数返回值的说明</div><div class=\"line\">\tOthers: \t\t\t// 其它说明</div><div class=\"line\">**************************************************************************/</div></pre></td></tr></table></figure>\n<p><em>例：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**************************************************************************</div><div class=\"line\">\tFunction: \t\tInitChannel</div><div class=\"line\">\tDescription: \t\t启动初始化所有通道</div><div class=\"line\">\tCalls: \t\t\tTIM_DeInit</div><div class=\"line\">\t\t\t\t\tTIM3_Int_Init</div><div class=\"line\">\tCalled By:\t\t\tmain()</div><div class=\"line\">\tInput: \t\t\t无</div><div class=\"line\">\tOutput: \t\t\t让所有通道输出低电平</div><div class=\"line\">\tReturn: \t\t\t无</div><div class=\"line\">************************************************************************/</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-程序块注释：\"><a href=\"#2-3-程序块注释：\" class=\"headerlink\" title=\"2.3 程序块注释：\"></a>2.3 程序块注释：</h4><p><em>一般的程序块注释如 for，while 之类的注释在前面，程序排版整齐，并方便注释的阅读与理解，将注释与其上面的代码用空一行隔开，且该程序块与下面的代码也应该用空一行(使用/\\</em>…*/整体注释，不得采用//行注释)*</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">例：</div><div class=\"line\">void example_fun( void )</div><div class=\"line\">&#123;</div><div class=\"line\">\t/* code one comments */</div><div class=\"line\">\tCodeBlock One</div><div class=\"line\"></div><div class=\"line\">\t/* code two comments */</div><div class=\"line\">\tCodeBlock Two</div><div class=\"line\"></div><div class=\"line\">\t/* code three comments */</div><div class=\"line\">\tCodeBlock Three</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-4-边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则-详见命名规范-在需要注释的变量以及函数调用后加注释使用-，无需空行。\"><a href=\"#2-4-边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则-详见命名规范-在需要注释的变量以及函数调用后加注释使用-，无需空行。\" class=\"headerlink\" title=\"2.4 边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则(详见命名规范),在需要注释的变量以及函数调用后加注释使用//，无需空行。\"></a>2.4 边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则(详见命名规范),在需要注释的变量以及函数调用后加注释使用//，无需空行。</h4>","excerpt":"<p><em>文章阐述个人使用 C/C++ 的一些命名规范总结，当然现在很多编辑器强大，很多人不再注意这些规范，但由于本人记性较差，加上打字速度较快，所以这套规范虽然繁琐，但还是比较适合我自己的。</em></p>\n<h3 id=\"1-命名规范\"><a href=\"#1-命名规范\" class=\"headerlink\" title=\"1. 命名规范\"></a>1. 命名规范</h3><h4 id=\"1-1-宏定义的命名全部采用大写，中间间隔用隔开，要求常量名用大写，常量名用英文表达其意思。-当需要由多个单词表示时，单词与单词之间必须采用连字符”“连接。\"><a href=\"#1-1-宏定义的命名全部采用大写，中间间隔用隔开，要求常量名用大写，常量名用英文表达其意思。-当需要由多个单词表示时，单词与单词之间必须采用连字符”“连接。\" class=\"headerlink\" title=\"1.1 宏定义的命名全部采用大写，中间间隔用隔开，要求常量名用大写，常量名用英文表达其意思。 当需要由多个单词表示时，单词与单词之间必须采用连字符”“连接。\"></a>1.1 宏定义的命名全部采用大写，中间间隔用<em>隔开，要求常量名用大写，常量名用英文表达其意思。 当需要由多个单词表示时，单词与单词之间必须采用连字符”</em>“连接。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">如：</div><div class=\"line\">#define CM_FILE_NOT_FOUND  CMMAKEHR(0X20B) 其中CM表示类别。</div></pre></td></tr></table></figure>\n<h4 id=\"1-2-变量的命名规则要求用“匈牙利命名法”。-即便很冗余且很多时候并没有实际作用，但方便查看，记性差防止跳过去查了就忘的情况\"><a href=\"#1-2-变量的命名规则要求用“匈牙利命名法”。-即便很冗余且很多时候并没有实际作用，但方便查看，记性差防止跳过去查了就忘的情况\" class=\"headerlink\" title=\"1.2 变量的命名规则要求用“匈牙利命名法”。 (即便很冗余且很多时候并没有实际作用，但方便查看，记性差防止跳过去查了就忘的情况)\"></a>1.2 变量的命名规则要求用“匈牙利命名法”。 (即便很冗余且很多时候并没有实际作用，但方便查看，记性差防止跳过去查了就忘的情况)</h4><p><em>这种命名法的出发点是把变量名按：属性+类型+对象描述的顺序组合起来：</em></p>","more":"<ul>\n<li>属性部分：   </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">g_ 全局变量\t：如一个全局的长型变量定义为g_lFailCount。  </div><div class=\"line\">m_ 　类，结构体成员变量</div><div class=\"line\">s_ 　静态变量：如一个静态的指针变量定义为s_plPerv_Inst</div><div class=\"line\">c_ 　常量： const 的变量 示例：const char* c_szFileName;</div></pre></td></tr></table></figure>\n<ul>\n<li>类型部分：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool 用b开头 b标志寄存器 </div><div class=\"line\">int 用i  32位开头 iCount </div><div class=\"line\">short  int  16位用n开头 nStepCount </div><div class=\"line\">long  int 用l开头 lSum </div><div class=\"line\">char  用c开头 cCount </div><div class=\"line\">float 用f开头 fAvg </div><div class=\"line\">double 用d开头 dDeta </div><div class=\"line\">unsigned  char / byte(字节) 用by开头 </div><div class=\"line\">unsigned  int(WORD) 用w开头 wCount </div><div class=\"line\">unsigned  long  int(DWORD) 用dw开头 dwBroad </div><div class=\"line\">字符串 用s开头 sFileName </div><div class=\"line\">用0结尾的字符串 用sz开头 szFileName </div><div class=\"line\">指针数组跟着上面类型之前：</div><div class=\"line\">数组 a：如一个short int型数组应该表示为anStat。</div><div class=\"line\">指针 p：</div><div class=\"line\">对一重指针变量的基本原则为：“p”+变量类型前缀+命名，如一个float*型应该表示为pfStat。对二重指针变量的基本规则为：“pp”+变量类型前缀+命名。对三重指针变量的基本规则为：“ppp”+变量类型前缀+命名。</div></pre></td></tr></table></figure>\n<ul>\n<li>描述部分：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">最大　Max\t\t最小　Min\t\t初始化　Init\t\t临时变量　T（或Temp）</div><div class=\"line\">源对象　Src\t\t目的对象　Dest</div></pre></td></tr></table></figure>\n<h4 id=\"1-3-枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用-EM-大写字母类似宏定义的形式，申明为枚举型的变量使用以-em-为头的驼峰式命名-枚举变量本身就类似于常量-。\"><a href=\"#1-3-枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用-EM-大写字母类似宏定义的形式，申明为枚举型的变量使用以-em-为头的驼峰式命名-枚举变量本身就类似于常量-。\" class=\"headerlink\" title=\"1.3 枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用 EM_+ 大写字母类似宏定义的形式，申明为枚举型的变量使用以 em 为头的驼峰式命名(枚举变量本身就类似于常量)。\"></a>1.3 枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用 EM_+ 大写字母类似宏定义的形式，申明为枚举型的变量使用以 em 为头的驼峰式命名(枚举变量本身就类似于常量)。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">如： </div><div class=\"line\">enum EMDays </div><div class=\"line\">&#123; </div><div class=\"line\">\tEM_DAYS_MONDAY; </div><div class=\"line\">\tEM_DAYS_TUESDAY; </div><div class=\"line\">\t…… </div><div class=\"line\">&#125;; </div><div class=\"line\">EMDays  emToday;</div></pre></td></tr></table></figure>\n<h4 id=\"1-4-结构体、类、共用体的命名规则统一采用大驼峰式（帕斯克命名法），结构体类型定义时在前面需要加上-stru-前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量统一加-m-不允许使用任何下划线。（函数与结构体变量方便区分，固都采用大驼峰式）\"><a href=\"#1-4-结构体、类、共用体的命名规则统一采用大驼峰式（帕斯克命名法），结构体类型定义时在前面需要加上-stru-前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量统一加-m-不允许使用任何下划线。（函数与结构体变量方便区分，固都采用大驼峰式）\" class=\"headerlink\" title=\"1.4 结构体、类、共用体的命名规则统一采用大驼峰式（帕斯克命名法），结构体类型定义时在前面需要加上 stru 前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量统一加 m_ 不允许使用任何下划线。（函数与结构体变量方便区分，固都采用大驼峰式）\"></a>1.4 结构体、类、共用体的命名规则统一采用大驼峰式（帕斯克命名法），结构体类型定义时在前面需要加上 stru 前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量统一加 m_ 不允许使用任何下划线。（函数与结构体变量方便区分，固都采用大驼峰式）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">如：</div><div class=\"line\">typedef struct</div><div class=\"line\">&#123; </div><div class=\"line\">\tchar *m_pcNodeNext;</div><div class=\"line\">char *m_pcNodePreview;</div><div class=\"line\">&#125;struStudentNode; </div><div class=\"line\">struStudentNode  StudentNode;</div></pre></td></tr></table></figure>\n<h4 id=\"1-5-函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如NVIC-Configuration，init-I2C，delay-us-硬件设备相关的使用下划线，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）\"><a href=\"#1-5-函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如NVIC-Configuration，init-I2C，delay-us-硬件设备相关的使用下划线，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）\" class=\"headerlink\" title=\"1.5 函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如NVIC_Configuration，init_I2C，delay_us 硬件设备相关的使用下划线，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）\"></a>1.5 函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如<code>NVIC_Configuration，init_I2C，delay_us 硬件设备相关的使用下划线</code>，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）</h4><p><strong>函数参数命名规范 :</strong></p>\n<ul>\n<li>参数名称的命名参照变量命名规范。</li>\n<li>为了提高程序的运行效率，减少参数占用的堆栈，传递大结构的参数，一律采用指针或引用方式传递。</li>\n<li>为了便于其他程序员识别某个指针参数是入口参数还是出口参数，同时便于编译器检查错误，应该在入口参数前加入const标志。 </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">如：</div><div class=\"line\">int CmCopyString(const char * c_pcSource, char* pcDest) </div><div class=\"line\">&#123;</div><div class=\"line\">...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>普通函数与中断调用函数区别命名，普通函数如果需要设定控制终中断函数则命名以Set开头通过修改中断函数中的全局变量判定条件来控制中断执行，而中断功能函数只能被中断调用，不可直接被普通函数调用(包括主函数)，命名以 Run 开头。</li>\n</ul>\n<h4 id=\"1-6-硬件设备名称函数命名参考-stm32-固件库命名法则：外设名称在前面全部大写\"><a href=\"#1-6-硬件设备名称函数命名参考-stm32-固件库命名法则：外设名称在前面全部大写\" class=\"headerlink\" title=\"1.6 硬件设备名称函数命名参考 stm32 固件库命名法则：外设名称在前面全部大写\"></a>1.6 硬件设备名称函数命名参考 stm32 固件库命名法则：外设名称在前面全部大写</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">如：</div><div class=\"line\">void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)</div><div class=\"line\">&#123;</div><div class=\"line\">\t/* Check the parameters */</div><div class=\"line\">\tassert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));</div><div class=\"line\"></div><div class=\"line\">\t/* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */</div><div class=\"line\">\tSCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"1-7-文件名-包括动态库、组件、控件、工程文件等-的命名规范-文件名的命名要求表达出文件的内容-要求文件名的长度不得少于5个字母，严禁使用象-file1-myfile-之类的文件名，多个具体含义的单词中用-隔开，一般都采用小写。\"><a href=\"#1-7-文件名-包括动态库、组件、控件、工程文件等-的命名规范-文件名的命名要求表达出文件的内容-要求文件名的长度不得少于5个字母，严禁使用象-file1-myfile-之类的文件名，多个具体含义的单词中用-隔开，一般都采用小写。\" class=\"headerlink\" title=\"1.7 文件名(包括动态库、组件、控件、工程文件等)的命名规范,文件名的命名要求表达出文件的内容:要求文件名的长度不得少于5个字母，严禁使用象 file1,myfile 之类的文件名，多个具体含义的单词中用_隔开，一般都采用小写。\"></a>1.7 文件名(包括动态库、组件、控件、工程文件等)的命名规范,文件名的命名要求表达出文件的内容:要求文件名的长度不得少于5个字母，严禁使用象 file1,myfile 之类的文件名，多个具体含义的单词中用_隔开，一般都采用小写。</h4><h4 id=\"1-8-除了编译开关-头文件等特殊应用，应避免使用-EXAMPLETEST-之类以下划线开始和结尾的定义。\"><a href=\"#1-8-除了编译开关-头文件等特殊应用，应避免使用-EXAMPLETEST-之类以下划线开始和结尾的定义。\" class=\"headerlink\" title=\"1.8 除了编译开关/头文件等特殊应用，应避免使用 _EXAMPLETEST 之类以下划线开始和结尾的定义。\"></a>1.8 除了编译开关/头文件等特殊应用，应避免使用 _EXAMPLE<em>TEST</em> 之类以下划线开始和结尾的定义。</h4><h3 id=\"2-注释规范\"><a href=\"#2-注释规范\" class=\"headerlink\" title=\"2 注释规范\"></a>2 注释规范</h3><h4 id=\"2-1-文件注释：-使用-…-整体注释，不得采用-行注释\"><a href=\"#2-1-文件注释：-使用-…-整体注释，不得采用-行注释\" class=\"headerlink\" title=\"2.1 文件注释：(使用/…/整体注释，不得采用//行注释)\"></a>2.1 文件注释：(使用/<em>…</em>/整体注释，不得采用//行注释)</h4><p><em>格式：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">/********************* Copyright(C)  20xx  company********************</div><div class=\"line\">\tFile name: \t// 文件名</div><div class=\"line\">\tAuthor: \t\t// 作者、</div><div class=\"line\">\tVersion:\t\t// 版本</div><div class=\"line\">\tDate: \t\t// 完成日期</div><div class=\"line\">\tDescription: \t// 用于详细说明此程序文件完成的主要功能，与其他模块</div><div class=\"line\">\t\t\t\t// 或函数的接口，输出值、取值范围、含义及参数间的控</div><div class=\"line\">\t\t\t\t// 制、顺序、独立或依赖等关系</div><div class=\"line\">\tOthers: \t\t// 其它内容的说明</div><div class=\"line\">\tFunction List: // 主要函数列表，每条记录应包括函数名及功能简要说明</div><div class=\"line\">\t\t\t\t\t1. ....</div><div class=\"line\">\tHistory: \t// 修改历史记录列表，每条修改记录应包括修改日期、修改</div><div class=\"line\">\t\t\t\t// 者及修改内容简述</div><div class=\"line\">\t&lt;author&gt; \t\t&lt;time&gt;\t \t&lt;version &gt; \t\t&lt;desc&gt;</div><div class=\"line\">\tName1\t\t\t20xx.x.x\t\tVx.x\t\t//修改的内容</div><div class=\"line\"></div><div class=\"line\">*************************************************/</div></pre></td></tr></table></figure>\n<p><em>例：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">/************************************ Copyright (C)  2015  HS ***********************************</div><div class=\"line\">\tFile name：    \tchannel.c</div><div class=\"line\">\tAuthor: \t\tname</div><div class=\"line\">\tversion:\t\t\tV1.0</div><div class=\"line\">\tDescription:\t\t实现多个通道的脉冲发送</div><div class=\"line\">\tOthers:</div><div class=\"line\">\tFunction List:</div><div class=\"line\">\t\t\t\t\tvoid GetChanCtrl(void);</div><div class=\"line\">\t\t\t\t\tvoid SetNormalMode(void);</div><div class=\"line\">\t\t\t\t\tvoid SetImMode(void);</div><div class=\"line\">\t\t\t\t\tvoid CtrlPulse(u8 g_byComRev);</div><div class=\"line\">\t\t\t\t\tvoid SetTimeMode(void);</div><div class=\"line\">\t\t\t\t\tu16 ScanfValue(void);</div><div class=\"line\">\t\t\t\t\tu32 ScanfTime(void);</div><div class=\"line\">\t\t\t\t\tvoid CtrlChannel(void);</div><div class=\"line\">\t\t\t\t\tvoid InitChannel(void);</div><div class=\"line\">\t\t\t\t\tvoid RunNormal(void);</div><div class=\"line\">\t\t\t\t\tvoid RunPulse(void);</div><div class=\"line\">\t\t\t\t\tvoid RunMode(void);</div><div class=\"line\">\tHistory:</div><div class=\"line\">\t&lt;author&gt; \t\t&lt;time&gt;\t \t&lt;version &gt; \t\t&lt;desc&gt;</div><div class=\"line\">Name1\t\t\t2015.6.1\t\tV1.1\t\t修复xx问题</div><div class=\"line\">**************************************************************************************************/</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-函数注释：-使用-…-整体注释，不得采用-行注释\"><a href=\"#2-2-函数注释：-使用-…-整体注释，不得采用-行注释\" class=\"headerlink\" title=\"2.2 函数注释：(使用/…/整体注释，不得采用//行注释)\"></a>2.2 函数注释：(使用/<em>…</em>/整体注释，不得采用//行注释)</h4><p><em>格式：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**************************************************************************</div><div class=\"line\">\tFunction: \t\t// 函数名称</div><div class=\"line\">\tDescription: \t\t// 函数功能、性能等的描述</div><div class=\"line\">\tCalls: \t\t\t// 被本函数调用的函数清单</div><div class=\"line\">\tCalled By:\t\t \t// 调用本函数的函数清单</div><div class=\"line\">\tTable Accessed: \t// 被访问的表（此项仅对于牵扯到数据库操作的程序）</div><div class=\"line\">\tTable Updated: \t// 被修改的表（此项仅对于牵扯到数据库操作的程序）</div><div class=\"line\">\tInput: \t\t\t// 输入参数说明，包括每个参数的作</div><div class=\"line\">\t\t\t\t\t// 用、取值说明及参数间关系。</div><div class=\"line\">\tOutput: \t\t\t// 对输出参数的说明。</div><div class=\"line\">\tReturn: \t\t\t// 函数返回值的说明</div><div class=\"line\">\tOthers: \t\t\t// 其它说明</div><div class=\"line\">**************************************************************************/</div></pre></td></tr></table></figure>\n<p><em>例：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**************************************************************************</div><div class=\"line\">\tFunction: \t\tInitChannel</div><div class=\"line\">\tDescription: \t\t启动初始化所有通道</div><div class=\"line\">\tCalls: \t\t\tTIM_DeInit</div><div class=\"line\">\t\t\t\t\tTIM3_Int_Init</div><div class=\"line\">\tCalled By:\t\t\tmain()</div><div class=\"line\">\tInput: \t\t\t无</div><div class=\"line\">\tOutput: \t\t\t让所有通道输出低电平</div><div class=\"line\">\tReturn: \t\t\t无</div><div class=\"line\">************************************************************************/</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-程序块注释：\"><a href=\"#2-3-程序块注释：\" class=\"headerlink\" title=\"2.3 程序块注释：\"></a>2.3 程序块注释：</h4><p><em>一般的程序块注释如 for，while 之类的注释在前面，程序排版整齐，并方便注释的阅读与理解，将注释与其上面的代码用空一行隔开，且该程序块与下面的代码也应该用空一行(使用/\\</em>…*/整体注释，不得采用//行注释)*</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">例：</div><div class=\"line\">void example_fun( void )</div><div class=\"line\">&#123;</div><div class=\"line\">\t/* code one comments */</div><div class=\"line\">\tCodeBlock One</div><div class=\"line\"></div><div class=\"line\">\t/* code two comments */</div><div class=\"line\">\tCodeBlock Two</div><div class=\"line\"></div><div class=\"line\">\t/* code three comments */</div><div class=\"line\">\tCodeBlock Three</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-4-边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则-详见命名规范-在需要注释的变量以及函数调用后加注释使用-，无需空行。\"><a href=\"#2-4-边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则-详见命名规范-在需要注释的变量以及函数调用后加注释使用-，无需空行。\" class=\"headerlink\" title=\"2.4 边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则(详见命名规范),在需要注释的变量以及函数调用后加注释使用//，无需空行。\"></a>2.4 边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则(详见命名规范),在需要注释的变量以及函数调用后加注释使用//，无需空行。</h4>"},{"layout":"post","title":"linux下的bash","date":"2016-09-06T03:19:00.000Z","_content":"\n*本文主要学习总结，linux下的CLI的使用技巧，不以任何发行版为例，仅仅介绍最通用的bash下的快捷操作和相关技巧，当然bash本身也可以跨平台，在诸如OS X上面默认也使用bash，同样可以参考本文。*\n\n\n<!-- more -->\n","source":"_posts/2016/2016-09-06-linux下的bash.md","raw":"---\nlayout: \"post\"\ntitle: \"linux下的bash\"\ndate: \"2016-09-06 11:19\"\n---\n\n*本文主要学习总结，linux下的CLI的使用技巧，不以任何发行版为例，仅仅介绍最通用的bash下的快捷操作和相关技巧，当然bash本身也可以跨平台，在诸如OS X上面默认也使用bash，同样可以参考本文。*\n\n\n<!-- more -->\n","slug":"2016/2016-09-06-linux下的bash","published":1,"updated":"2016-12-16T01:47:16.941Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahq002amumuurwjci6d","content":"<p><em>本文主要学习总结，linux下的CLI的使用技巧，不以任何发行版为例，仅仅介绍最通用的bash下的快捷操作和相关技巧，当然bash本身也可以跨平台，在诸如OS X上面默认也使用bash，同样可以参考本文。</em></p>\n<a id=\"more\"></a>\n","excerpt":"<p><em>本文主要学习总结，linux下的CLI的使用技巧，不以任何发行版为例，仅仅介绍最通用的bash下的快捷操作和相关技巧，当然bash本身也可以跨平台，在诸如OS X上面默认也使用bash，同样可以参考本文。</em></p>","more":""},{"layout":"post","title":"linux-CLI下的常用命令","date":"2016-09-06T08:56:00.000Z","_content":"\n*本文主要学习总结，linux下的CLI的使用技巧，不以任何发行版为例，仅仅介绍最常用的一些软件命令功能，当然部分软件也都是可以跨平台操作的。*\n\n### 环境变量\n\nLinux中set,env和export这三个命令的区别\n \nset命令显示当前shell的变量，包括当前用户的变量;\n \nenv命令显示当前用户的变量;\n \nexport命令显示当前导出成用户变量的shell变量。\n \n    每个shell有自己特有的变量（set）显示的变量，这个和用户变量是不同的，当前用户变量和你用什么shell无关，不管你用什么shell都在，比如HOME,SHELL等这些变量，\n \n但shell自己的变量不同shell是不同的，比如BASH_ARGC， BASH等，这些变量只有set才会显示，是bash特有的，export不加参数的时候，显示哪些变量被导出成了用户变量，因为一个shell自己的变量可以通过export “导出”变成一个用户变量。\n\n<!-- more -->\n\n### 系统信息查看：\n\n*注意：以下命令如果在ubuntu下可能都需要root权限才可以执行。*\n\n#### CPU\n\n- lscpu : 查看的是cpu的统计信息.\n- cat /proc/cpuinfo : 可以知道每个cpu信息，如每个CPU的型号，主频等。\n\n\n#### 内存\n\n- cat /proc/meminfo : 查看内存详细使用\n- free -m : 概要查看内存情况\n- grep MemTotal /proc/meminfo ： 查看内存总量 \n- grep MemFree /proc/meminfo ：  查看空闲内存量 \n\n#### 硬盘\n\n- lsblk ： 查看硬盘和分区分布\n- fdisk -l ： 如果要看硬盘和分区的详细信息\n- df -h ： 查看各分区使用情况 \n- cat /proc/loadavg ： 查看系统负载磁盘和分区 \n\n#### 网卡\n\n- lspci | grep -i 'eth' ： 查看网卡硬件信息\n- ifconfig -a ： 查看系统的所有网络接口\n- route -n : 查看路由表 \n\n#### 其他硬件信息\n\n- lspci ： 查看pci信息，即主板所有硬件槽信息。\n- dmidecode -t bios ： 查看bios信息\n- dmidecode -q : dmidecode以一种可读的方式dump出机器的DMI(Desktop Management Interface)信息。这些信息包括了硬件以及BIOS，既可以得到当前的配置，也可以得到系统支持的最大配置，比如说支持的最大内存数等。\n- dmesg | grep IDE ： 查看启动时IDE设备检测状况网络 \n\n#### 操作系统\n\n- uname -a 或 cat /proc/version ： 查看内核/操作系统/CPU信息 \n- lsb_release -a 或 cat /etc/issue（此命令也适用于所有的Linux发行版)： 查看Linux系统版本\n- head -n 1 /etc/issue ： 查看操作系统版本 \n- lsmod ： 列出加载的内核模块 \n- hostname ： 查看计算机名 \n- free -m ： 查看内存使用量和交换区使用量 \n- uptime ： 查看系统运行时间、用户数、负载 \n- ps -ef ： 查看所有进程 \n- top ： 实时显示进程状态用户 \n- w ： 查看活动用户 \n- id <用户名> : 查看指定用户信息 \n- last : 查看用户登录日志 \n- cut -d: -f1 /etc/passwd : 查看系统所有用户 \n- cut -d: -f1 /etc/group : 查看系统所有组 \n- crontab -l : 查看当前用户的计划任务服务 \n- chkconfig –list : 列出所有系统服务 \n- chkconfig –list | grep on : 列出所有启动的系统服务程序 \n\n\n\n\n\n### 分屏功能\n\nxrandr 命令，用于分屏驱动多个显示器，一般是底层控制的，虽然是显示功能，但分屏并非GUI的独享，图形界面的分屏控制大都是调用 xrandr 这个软件。\n\n\n### 管理类\n\n\n### du\n\n### df\n\n\n### top\n\n\n\n### 网络类\n\n\n### ping\n\n### nslookup\n\n### ip\n\n### route\n\n\n\n\n\n\n\n\n******\n\n\n\nTo be continued...\n\n> 参考链接：\n> http://www.2cto.com/os/201306/223758.html\n> http://www.ha97.com/2987.html\n> http://blog.csdn.net/lhf_tiger/article/details/7102753\n> http://www.cnblogs.com/ggjucheng/archive/2013/01/14/2859613.html\n","source":"_posts/2016/2016-09-06-linux-CLI下的常用命令.md","raw":"---\nlayout: \"post\"\ntitle: \"linux-CLI下的常用命令\"\ndate: \"2016-09-06 16:56\"\n---\n\n*本文主要学习总结，linux下的CLI的使用技巧，不以任何发行版为例，仅仅介绍最常用的一些软件命令功能，当然部分软件也都是可以跨平台操作的。*\n\n### 环境变量\n\nLinux中set,env和export这三个命令的区别\n \nset命令显示当前shell的变量，包括当前用户的变量;\n \nenv命令显示当前用户的变量;\n \nexport命令显示当前导出成用户变量的shell变量。\n \n    每个shell有自己特有的变量（set）显示的变量，这个和用户变量是不同的，当前用户变量和你用什么shell无关，不管你用什么shell都在，比如HOME,SHELL等这些变量，\n \n但shell自己的变量不同shell是不同的，比如BASH_ARGC， BASH等，这些变量只有set才会显示，是bash特有的，export不加参数的时候，显示哪些变量被导出成了用户变量，因为一个shell自己的变量可以通过export “导出”变成一个用户变量。\n\n<!-- more -->\n\n### 系统信息查看：\n\n*注意：以下命令如果在ubuntu下可能都需要root权限才可以执行。*\n\n#### CPU\n\n- lscpu : 查看的是cpu的统计信息.\n- cat /proc/cpuinfo : 可以知道每个cpu信息，如每个CPU的型号，主频等。\n\n\n#### 内存\n\n- cat /proc/meminfo : 查看内存详细使用\n- free -m : 概要查看内存情况\n- grep MemTotal /proc/meminfo ： 查看内存总量 \n- grep MemFree /proc/meminfo ：  查看空闲内存量 \n\n#### 硬盘\n\n- lsblk ： 查看硬盘和分区分布\n- fdisk -l ： 如果要看硬盘和分区的详细信息\n- df -h ： 查看各分区使用情况 \n- cat /proc/loadavg ： 查看系统负载磁盘和分区 \n\n#### 网卡\n\n- lspci | grep -i 'eth' ： 查看网卡硬件信息\n- ifconfig -a ： 查看系统的所有网络接口\n- route -n : 查看路由表 \n\n#### 其他硬件信息\n\n- lspci ： 查看pci信息，即主板所有硬件槽信息。\n- dmidecode -t bios ： 查看bios信息\n- dmidecode -q : dmidecode以一种可读的方式dump出机器的DMI(Desktop Management Interface)信息。这些信息包括了硬件以及BIOS，既可以得到当前的配置，也可以得到系统支持的最大配置，比如说支持的最大内存数等。\n- dmesg | grep IDE ： 查看启动时IDE设备检测状况网络 \n\n#### 操作系统\n\n- uname -a 或 cat /proc/version ： 查看内核/操作系统/CPU信息 \n- lsb_release -a 或 cat /etc/issue（此命令也适用于所有的Linux发行版)： 查看Linux系统版本\n- head -n 1 /etc/issue ： 查看操作系统版本 \n- lsmod ： 列出加载的内核模块 \n- hostname ： 查看计算机名 \n- free -m ： 查看内存使用量和交换区使用量 \n- uptime ： 查看系统运行时间、用户数、负载 \n- ps -ef ： 查看所有进程 \n- top ： 实时显示进程状态用户 \n- w ： 查看活动用户 \n- id <用户名> : 查看指定用户信息 \n- last : 查看用户登录日志 \n- cut -d: -f1 /etc/passwd : 查看系统所有用户 \n- cut -d: -f1 /etc/group : 查看系统所有组 \n- crontab -l : 查看当前用户的计划任务服务 \n- chkconfig –list : 列出所有系统服务 \n- chkconfig –list | grep on : 列出所有启动的系统服务程序 \n\n\n\n\n\n### 分屏功能\n\nxrandr 命令，用于分屏驱动多个显示器，一般是底层控制的，虽然是显示功能，但分屏并非GUI的独享，图形界面的分屏控制大都是调用 xrandr 这个软件。\n\n\n### 管理类\n\n\n### du\n\n### df\n\n\n### top\n\n\n\n### 网络类\n\n\n### ping\n\n### nslookup\n\n### ip\n\n### route\n\n\n\n\n\n\n\n\n******\n\n\n\nTo be continued...\n\n> 参考链接：\n> http://www.2cto.com/os/201306/223758.html\n> http://www.ha97.com/2987.html\n> http://blog.csdn.net/lhf_tiger/article/details/7102753\n> http://www.cnblogs.com/ggjucheng/archive/2013/01/14/2859613.html\n","slug":"2016/2016-09-06-linux-CLI下的常用命令","published":1,"updated":"2016-12-16T01:47:07.217Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahs002bmumuz3ona43w","content":"<p><em>本文主要学习总结，linux下的CLI的使用技巧，不以任何发行版为例，仅仅介绍最常用的一些软件命令功能，当然部分软件也都是可以跨平台操作的。</em></p>\n<h3 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h3><p>Linux中set,env和export这三个命令的区别</p>\n<p>set命令显示当前shell的变量，包括当前用户的变量;</p>\n<p>env命令显示当前用户的变量;</p>\n<p>export命令显示当前导出成用户变量的shell变量。</p>\n<pre><code>每个shell有自己特有的变量（set）显示的变量，这个和用户变量是不同的，当前用户变量和你用什么shell无关，不管你用什么shell都在，比如HOME,SHELL等这些变量，\n</code></pre><p>但shell自己的变量不同shell是不同的，比如BASH_ARGC， BASH等，这些变量只有set才会显示，是bash特有的，export不加参数的时候，显示哪些变量被导出成了用户变量，因为一个shell自己的变量可以通过export “导出”变成一个用户变量。</p>\n<a id=\"more\"></a>\n<h3 id=\"系统信息查看：\"><a href=\"#系统信息查看：\" class=\"headerlink\" title=\"系统信息查看：\"></a>系统信息查看：</h3><p><em>注意：以下命令如果在ubuntu下可能都需要root权限才可以执行。</em></p>\n<h4 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h4><ul>\n<li>lscpu : 查看的是cpu的统计信息.</li>\n<li>cat /proc/cpuinfo : 可以知道每个cpu信息，如每个CPU的型号，主频等。</li>\n</ul>\n<h4 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h4><ul>\n<li>cat /proc/meminfo : 查看内存详细使用</li>\n<li>free -m : 概要查看内存情况</li>\n<li>grep MemTotal /proc/meminfo ： 查看内存总量 </li>\n<li>grep MemFree /proc/meminfo ：  查看空闲内存量 </li>\n</ul>\n<h4 id=\"硬盘\"><a href=\"#硬盘\" class=\"headerlink\" title=\"硬盘\"></a>硬盘</h4><ul>\n<li>lsblk ： 查看硬盘和分区分布</li>\n<li>fdisk -l ： 如果要看硬盘和分区的详细信息</li>\n<li>df -h ： 查看各分区使用情况 </li>\n<li>cat /proc/loadavg ： 查看系统负载磁盘和分区 </li>\n</ul>\n<h4 id=\"网卡\"><a href=\"#网卡\" class=\"headerlink\" title=\"网卡\"></a>网卡</h4><ul>\n<li>lspci | grep -i ‘eth’ ： 查看网卡硬件信息</li>\n<li>ifconfig -a ： 查看系统的所有网络接口</li>\n<li>route -n : 查看路由表 </li>\n</ul>\n<h4 id=\"其他硬件信息\"><a href=\"#其他硬件信息\" class=\"headerlink\" title=\"其他硬件信息\"></a>其他硬件信息</h4><ul>\n<li>lspci ： 查看pci信息，即主板所有硬件槽信息。</li>\n<li>dmidecode -t bios ： 查看bios信息</li>\n<li>dmidecode -q : dmidecode以一种可读的方式dump出机器的DMI(Desktop Management Interface)信息。这些信息包括了硬件以及BIOS，既可以得到当前的配置，也可以得到系统支持的最大配置，比如说支持的最大内存数等。</li>\n<li>dmesg | grep IDE ： 查看启动时IDE设备检测状况网络 </li>\n</ul>\n<h4 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h4><ul>\n<li>uname -a 或 cat /proc/version ： 查看内核/操作系统/CPU信息 </li>\n<li>lsb_release -a 或 cat /etc/issue（此命令也适用于所有的Linux发行版)： 查看Linux系统版本</li>\n<li>head -n 1 /etc/issue ： 查看操作系统版本 </li>\n<li>lsmod ： 列出加载的内核模块 </li>\n<li>hostname ： 查看计算机名 </li>\n<li>free -m ： 查看内存使用量和交换区使用量 </li>\n<li>uptime ： 查看系统运行时间、用户数、负载 </li>\n<li>ps -ef ： 查看所有进程 </li>\n<li>top ： 实时显示进程状态用户 </li>\n<li>w ： 查看活动用户 </li>\n<li>id &lt;用户名&gt; : 查看指定用户信息 </li>\n<li>last : 查看用户登录日志 </li>\n<li>cut -d: -f1 /etc/passwd : 查看系统所有用户 </li>\n<li>cut -d: -f1 /etc/group : 查看系统所有组 </li>\n<li>crontab -l : 查看当前用户的计划任务服务 </li>\n<li>chkconfig –list : 列出所有系统服务 </li>\n<li>chkconfig –list | grep on : 列出所有启动的系统服务程序 </li>\n</ul>\n<h3 id=\"分屏功能\"><a href=\"#分屏功能\" class=\"headerlink\" title=\"分屏功能\"></a>分屏功能</h3><p>xrandr 命令，用于分屏驱动多个显示器，一般是底层控制的，虽然是显示功能，但分屏并非GUI的独享，图形界面的分屏控制大都是调用 xrandr 这个软件。</p>\n<h3 id=\"管理类\"><a href=\"#管理类\" class=\"headerlink\" title=\"管理类\"></a>管理类</h3><h3 id=\"du\"><a href=\"#du\" class=\"headerlink\" title=\"du\"></a>du</h3><h3 id=\"df\"><a href=\"#df\" class=\"headerlink\" title=\"df\"></a>df</h3><h3 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a>top</h3><h3 id=\"网络类\"><a href=\"#网络类\" class=\"headerlink\" title=\"网络类\"></a>网络类</h3><h3 id=\"ping\"><a href=\"#ping\" class=\"headerlink\" title=\"ping\"></a>ping</h3><h3 id=\"nslookup\"><a href=\"#nslookup\" class=\"headerlink\" title=\"nslookup\"></a>nslookup</h3><h3 id=\"ip\"><a href=\"#ip\" class=\"headerlink\" title=\"ip\"></a>ip</h3><h3 id=\"route\"><a href=\"#route\" class=\"headerlink\" title=\"route\"></a>route</h3><hr>\n<p>To be continued…</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.2cto.com/os/201306/223758.html\" target=\"_blank\" rel=\"external\">http://www.2cto.com/os/201306/223758.html</a><br><a href=\"http://www.ha97.com/2987.html\" target=\"_blank\" rel=\"external\">http://www.ha97.com/2987.html</a><br><a href=\"http://blog.csdn.net/lhf_tiger/article/details/7102753\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lhf_tiger/article/details/7102753</a><br><a href=\"http://www.cnblogs.com/ggjucheng/archive/2013/01/14/2859613.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/ggjucheng/archive/2013/01/14/2859613.html</a></p>\n</blockquote>\n","excerpt":"<p><em>本文主要学习总结，linux下的CLI的使用技巧，不以任何发行版为例，仅仅介绍最常用的一些软件命令功能，当然部分软件也都是可以跨平台操作的。</em></p>\n<h3 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h3><p>Linux中set,env和export这三个命令的区别</p>\n<p>set命令显示当前shell的变量，包括当前用户的变量;</p>\n<p>env命令显示当前用户的变量;</p>\n<p>export命令显示当前导出成用户变量的shell变量。</p>\n<pre><code>每个shell有自己特有的变量（set）显示的变量，这个和用户变量是不同的，当前用户变量和你用什么shell无关，不管你用什么shell都在，比如HOME,SHELL等这些变量，\n</code></pre><p>但shell自己的变量不同shell是不同的，比如BASH_ARGC， BASH等，这些变量只有set才会显示，是bash特有的，export不加参数的时候，显示哪些变量被导出成了用户变量，因为一个shell自己的变量可以通过export “导出”变成一个用户变量。</p>","more":"<h3 id=\"系统信息查看：\"><a href=\"#系统信息查看：\" class=\"headerlink\" title=\"系统信息查看：\"></a>系统信息查看：</h3><p><em>注意：以下命令如果在ubuntu下可能都需要root权限才可以执行。</em></p>\n<h4 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h4><ul>\n<li>lscpu : 查看的是cpu的统计信息.</li>\n<li>cat /proc/cpuinfo : 可以知道每个cpu信息，如每个CPU的型号，主频等。</li>\n</ul>\n<h4 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h4><ul>\n<li>cat /proc/meminfo : 查看内存详细使用</li>\n<li>free -m : 概要查看内存情况</li>\n<li>grep MemTotal /proc/meminfo ： 查看内存总量 </li>\n<li>grep MemFree /proc/meminfo ：  查看空闲内存量 </li>\n</ul>\n<h4 id=\"硬盘\"><a href=\"#硬盘\" class=\"headerlink\" title=\"硬盘\"></a>硬盘</h4><ul>\n<li>lsblk ： 查看硬盘和分区分布</li>\n<li>fdisk -l ： 如果要看硬盘和分区的详细信息</li>\n<li>df -h ： 查看各分区使用情况 </li>\n<li>cat /proc/loadavg ： 查看系统负载磁盘和分区 </li>\n</ul>\n<h4 id=\"网卡\"><a href=\"#网卡\" class=\"headerlink\" title=\"网卡\"></a>网卡</h4><ul>\n<li>lspci | grep -i ‘eth’ ： 查看网卡硬件信息</li>\n<li>ifconfig -a ： 查看系统的所有网络接口</li>\n<li>route -n : 查看路由表 </li>\n</ul>\n<h4 id=\"其他硬件信息\"><a href=\"#其他硬件信息\" class=\"headerlink\" title=\"其他硬件信息\"></a>其他硬件信息</h4><ul>\n<li>lspci ： 查看pci信息，即主板所有硬件槽信息。</li>\n<li>dmidecode -t bios ： 查看bios信息</li>\n<li>dmidecode -q : dmidecode以一种可读的方式dump出机器的DMI(Desktop Management Interface)信息。这些信息包括了硬件以及BIOS，既可以得到当前的配置，也可以得到系统支持的最大配置，比如说支持的最大内存数等。</li>\n<li>dmesg | grep IDE ： 查看启动时IDE设备检测状况网络 </li>\n</ul>\n<h4 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h4><ul>\n<li>uname -a 或 cat /proc/version ： 查看内核/操作系统/CPU信息 </li>\n<li>lsb_release -a 或 cat /etc/issue（此命令也适用于所有的Linux发行版)： 查看Linux系统版本</li>\n<li>head -n 1 /etc/issue ： 查看操作系统版本 </li>\n<li>lsmod ： 列出加载的内核模块 </li>\n<li>hostname ： 查看计算机名 </li>\n<li>free -m ： 查看内存使用量和交换区使用量 </li>\n<li>uptime ： 查看系统运行时间、用户数、负载 </li>\n<li>ps -ef ： 查看所有进程 </li>\n<li>top ： 实时显示进程状态用户 </li>\n<li>w ： 查看活动用户 </li>\n<li>id &lt;用户名&gt; : 查看指定用户信息 </li>\n<li>last : 查看用户登录日志 </li>\n<li>cut -d: -f1 /etc/passwd : 查看系统所有用户 </li>\n<li>cut -d: -f1 /etc/group : 查看系统所有组 </li>\n<li>crontab -l : 查看当前用户的计划任务服务 </li>\n<li>chkconfig –list : 列出所有系统服务 </li>\n<li>chkconfig –list | grep on : 列出所有启动的系统服务程序 </li>\n</ul>\n<h3 id=\"分屏功能\"><a href=\"#分屏功能\" class=\"headerlink\" title=\"分屏功能\"></a>分屏功能</h3><p>xrandr 命令，用于分屏驱动多个显示器，一般是底层控制的，虽然是显示功能，但分屏并非GUI的独享，图形界面的分屏控制大都是调用 xrandr 这个软件。</p>\n<h3 id=\"管理类\"><a href=\"#管理类\" class=\"headerlink\" title=\"管理类\"></a>管理类</h3><h3 id=\"du\"><a href=\"#du\" class=\"headerlink\" title=\"du\"></a>du</h3><h3 id=\"df\"><a href=\"#df\" class=\"headerlink\" title=\"df\"></a>df</h3><h3 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a>top</h3><h3 id=\"网络类\"><a href=\"#网络类\" class=\"headerlink\" title=\"网络类\"></a>网络类</h3><h3 id=\"ping\"><a href=\"#ping\" class=\"headerlink\" title=\"ping\"></a>ping</h3><h3 id=\"nslookup\"><a href=\"#nslookup\" class=\"headerlink\" title=\"nslookup\"></a>nslookup</h3><h3 id=\"ip\"><a href=\"#ip\" class=\"headerlink\" title=\"ip\"></a>ip</h3><h3 id=\"route\"><a href=\"#route\" class=\"headerlink\" title=\"route\"></a>route</h3><hr>\n<p>To be continued…</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.2cto.com/os/201306/223758.html\">http://www.2cto.com/os/201306/223758.html</a><br><a href=\"http://www.ha97.com/2987.html\">http://www.ha97.com/2987.html</a><br><a href=\"http://blog.csdn.net/lhf_tiger/article/details/7102753\">http://blog.csdn.net/lhf_tiger/article/details/7102753</a><br><a href=\"http://www.cnblogs.com/ggjucheng/archive/2013/01/14/2859613.html\">http://www.cnblogs.com/ggjucheng/archive/2013/01/14/2859613.html</a></p>\n</blockquote>"},{"layout":"post","title":"国内云服务器体验","date":"2016-09-09T08:31:00.000Z","_content":"\n*首先本人作为一个web菜鸟，仅仅是能够基本使用linux的一些操作，对网络和服务器并不熟悉，自己安装过多个系统，也象征性的搭建过一些服务环境，但具体原理了解较少。本文主要是最近想玩些云服务，虽然博客搭建有一段时间了，但一直没使用自己的服务器，本文作为个人学习研究的一部分进行，包括最基础的一些网络搭建操作，重在体验几个国内现有的云服务器公司：阿里，腾讯。*\n\n### 域名申请\n\n要使得能够访问，首先得申请个域名，当然不申请域名，你搭建的服务也可以通过IP地址直接访问的，但是一般都不这么多，一个ip地址相当重要，且在万网（阿里云）上面申请ip也较便宜，一个可以.site,.top,.xyz结尾的一级域名一年也只要几块钱，并且值得推荐的是.top域名，该域名可以在国内备案，买个玩玩也是很不错的。\n\n\n\n### 腾讯云试用\n\n腾讯云注册后有5-7天的免费使用时间，个人感觉这个对从来没接触过云服务，第一次试用的同学来说，还是很不错的，最起码可以自己尝试搭建一些小型的网站如：博客之类的还是很不错的，当然时间很宝贵，要试用的话，还是得抓紧时间。\n\n*这边首先以搭建一个wordpress为例*\n\n\n<!-- more -->\n\n\n\n### 阿里云\n\n阿里云收购了原来万网的一系列服务，目前在 VPS 领域可以说是提供服务最完善，用户群体最多，功能最强的网站了，当然，价格也最贵，不是一般的非商业用户所能够承受的，对于我这样的非专业人士来说，上云暂时也仅仅是体验服务，学习研究之类的，所有阿里云会选择按量购买，毕竟个人觉得按月购买每个月价格还是蛮高的，如果不是有特别需求，或者盈利性质的网站，还是别按量购买为好。\n\n\n\n\n\n***\nTo be continued...\n","source":"_posts/2016/2016-09-09-国内云服务器体验.md","raw":"---\nlayout: \"post\"\ntitle: \"国内云服务器体验\"\ndate: \"2016-09-09 16:31\"\n---\n\n*首先本人作为一个web菜鸟，仅仅是能够基本使用linux的一些操作，对网络和服务器并不熟悉，自己安装过多个系统，也象征性的搭建过一些服务环境，但具体原理了解较少。本文主要是最近想玩些云服务，虽然博客搭建有一段时间了，但一直没使用自己的服务器，本文作为个人学习研究的一部分进行，包括最基础的一些网络搭建操作，重在体验几个国内现有的云服务器公司：阿里，腾讯。*\n\n### 域名申请\n\n要使得能够访问，首先得申请个域名，当然不申请域名，你搭建的服务也可以通过IP地址直接访问的，但是一般都不这么多，一个ip地址相当重要，且在万网（阿里云）上面申请ip也较便宜，一个可以.site,.top,.xyz结尾的一级域名一年也只要几块钱，并且值得推荐的是.top域名，该域名可以在国内备案，买个玩玩也是很不错的。\n\n\n\n### 腾讯云试用\n\n腾讯云注册后有5-7天的免费使用时间，个人感觉这个对从来没接触过云服务，第一次试用的同学来说，还是很不错的，最起码可以自己尝试搭建一些小型的网站如：博客之类的还是很不错的，当然时间很宝贵，要试用的话，还是得抓紧时间。\n\n*这边首先以搭建一个wordpress为例*\n\n\n<!-- more -->\n\n\n\n### 阿里云\n\n阿里云收购了原来万网的一系列服务，目前在 VPS 领域可以说是提供服务最完善，用户群体最多，功能最强的网站了，当然，价格也最贵，不是一般的非商业用户所能够承受的，对于我这样的非专业人士来说，上云暂时也仅仅是体验服务，学习研究之类的，所有阿里云会选择按量购买，毕竟个人觉得按月购买每个月价格还是蛮高的，如果不是有特别需求，或者盈利性质的网站，还是别按量购买为好。\n\n\n\n\n\n***\nTo be continued...\n","slug":"2016/2016-09-09-国内云服务器体验","published":1,"updated":"2017-01-12T05:51:35.859Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aht002cmumupbngx8o9","content":"<p><em>首先本人作为一个web菜鸟，仅仅是能够基本使用linux的一些操作，对网络和服务器并不熟悉，自己安装过多个系统，也象征性的搭建过一些服务环境，但具体原理了解较少。本文主要是最近想玩些云服务，虽然博客搭建有一段时间了，但一直没使用自己的服务器，本文作为个人学习研究的一部分进行，包括最基础的一些网络搭建操作，重在体验几个国内现有的云服务器公司：阿里，腾讯。</em></p>\n<h3 id=\"域名申请\"><a href=\"#域名申请\" class=\"headerlink\" title=\"域名申请\"></a>域名申请</h3><p>要使得能够访问，首先得申请个域名，当然不申请域名，你搭建的服务也可以通过IP地址直接访问的，但是一般都不这么多，一个ip地址相当重要，且在万网（阿里云）上面申请ip也较便宜，一个可以.site,.top,.xyz结尾的一级域名一年也只要几块钱，并且值得推荐的是.top域名，该域名可以在国内备案，买个玩玩也是很不错的。</p>\n<h3 id=\"腾讯云试用\"><a href=\"#腾讯云试用\" class=\"headerlink\" title=\"腾讯云试用\"></a>腾讯云试用</h3><p>腾讯云注册后有5-7天的免费使用时间，个人感觉这个对从来没接触过云服务，第一次试用的同学来说，还是很不错的，最起码可以自己尝试搭建一些小型的网站如：博客之类的还是很不错的，当然时间很宝贵，要试用的话，还是得抓紧时间。</p>\n<p><em>这边首先以搭建一个wordpress为例</em></p>\n<a id=\"more\"></a>\n<h3 id=\"阿里云\"><a href=\"#阿里云\" class=\"headerlink\" title=\"阿里云\"></a>阿里云</h3><p>阿里云收购了原来万网的一系列服务，目前在 VPS 领域可以说是提供服务最完善，用户群体最多，功能最强的网站了，当然，价格也最贵，不是一般的非商业用户所能够承受的，对于我这样的非专业人士来说，上云暂时也仅仅是体验服务，学习研究之类的，所有阿里云会选择按量购买，毕竟个人觉得按月购买每个月价格还是蛮高的，如果不是有特别需求，或者盈利性质的网站，还是别按量购买为好。</p>\n<hr>\n<p>To be continued…</p>\n","excerpt":"<p><em>首先本人作为一个web菜鸟，仅仅是能够基本使用linux的一些操作，对网络和服务器并不熟悉，自己安装过多个系统，也象征性的搭建过一些服务环境，但具体原理了解较少。本文主要是最近想玩些云服务，虽然博客搭建有一段时间了，但一直没使用自己的服务器，本文作为个人学习研究的一部分进行，包括最基础的一些网络搭建操作，重在体验几个国内现有的云服务器公司：阿里，腾讯。</em></p>\n<h3 id=\"域名申请\"><a href=\"#域名申请\" class=\"headerlink\" title=\"域名申请\"></a>域名申请</h3><p>要使得能够访问，首先得申请个域名，当然不申请域名，你搭建的服务也可以通过IP地址直接访问的，但是一般都不这么多，一个ip地址相当重要，且在万网（阿里云）上面申请ip也较便宜，一个可以.site,.top,.xyz结尾的一级域名一年也只要几块钱，并且值得推荐的是.top域名，该域名可以在国内备案，买个玩玩也是很不错的。</p>\n<h3 id=\"腾讯云试用\"><a href=\"#腾讯云试用\" class=\"headerlink\" title=\"腾讯云试用\"></a>腾讯云试用</h3><p>腾讯云注册后有5-7天的免费使用时间，个人感觉这个对从来没接触过云服务，第一次试用的同学来说，还是很不错的，最起码可以自己尝试搭建一些小型的网站如：博客之类的还是很不错的，当然时间很宝贵，要试用的话，还是得抓紧时间。</p>\n<p><em>这边首先以搭建一个wordpress为例</em></p>","more":"<h3 id=\"阿里云\"><a href=\"#阿里云\" class=\"headerlink\" title=\"阿里云\"></a>阿里云</h3><p>阿里云收购了原来万网的一系列服务，目前在 VPS 领域可以说是提供服务最完善，用户群体最多，功能最强的网站了，当然，价格也最贵，不是一般的非商业用户所能够承受的，对于我这样的非专业人士来说，上云暂时也仅仅是体验服务，学习研究之类的，所有阿里云会选择按量购买，毕竟个人觉得按月购买每个月价格还是蛮高的，如果不是有特别需求，或者盈利性质的网站，还是别按量购买为好。</p>\n<hr>\n<p>To be continued…</p>"},{"layout":"post","title":"ssh相关使用","date":"2016-09-09T09:41:00.000Z","_content":"\n*使用ssh已经很多次，但每次用到都得查看相关说明，一些操作也不是特别熟悉，本文将总结自己使用的ssh服务说明。*\n\n### 本地SSH配置\n\n- 首先我们需要检查你电脑上现有的ssh key：\n\n```\n$ cd ~/.ssh 检查本机的ssh密钥\n```\n\n如果提示：No such file or directory 说明你是第一次使用git。\n\n- 生成新的SSH Key：\n\n```\nssh-keygen -t rsa -C \"邮件地址@youremail.com\"\n```\n*此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」*\n\n- 然后系统会要你输入密码：\n\n```\nEnter passphrase (empty for no passphrase):<输入加密串>\nEnter same passphrase again:<再次输入加密串>\n```\n*在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，相当于二次的加密，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。个人嫌麻烦一般不会再设定密码，本身ssh的访问就属于本地自动加密认真，就比较安全，除非你秘钥丢失，否则一般不会出问题，*\n\n- 看到这样的界面，就成功设置了本地的ssh key了：\n\n- ~/.ssh/id_rsa.pub 就是需要使用的公钥，将该公钥加入到其他系统上面或者支持ssh服务的软件上面即可实现访问。\n\n\n<!-- more -->\n\n\n### 将本地公钥上传到远程linux服务器\n\n\n> 不同的Linux之间copy文件常用有3种方法：\n\n```\n第一种就是ftp，也就是其中一台Linux安装ftp Server，这样可以另外一台使用ftp的client程序来进行文件的copy。\n\n第二种方法就是采用samba服务，类似Windows文件copy 的方式来操作，比较简洁方便。\n\n第三种就是利用scp命令来进行文件复制。\n```\n\n**scp是有Security的文件copy，基于ssh登录。操作起来比较方便，比如要把当前一个文件copy到远程另外一台主机上，可以如下命令。**\n\n```\nscp /home/daisy/full.tar.gz root@172.19.2.75:/home/root\n```\n\n然后会提示你输入另外那台172.19.2.75主机的root用户的登录密码，接着就开始copy了。如果想反过来操作，把文件从远程主机copy到当前系统，也很简单。\n\n```\nscp root@/full.tar.gz 172.19.2.75:/home/root/full.tar.gz home/daisy/full.tar.gz\n```\n\n- 我们将原始机的公钥拷贝到目标服务器的.ssh目录下，且命名为authorized_keys。\n\n```\nscp /home/git/.ssh/id_rsa.pub git@ubuntu_server:/home/git/.ssh/authorized_keys\n```\n\n*注意，ubuntu_server为ip对应的名称，这边可以改成ip地址，git为用户名。修改实体机(本地机而不是服务器)的ip配置文件`/ect/hosts`，加入如下行：`192.168.18.202 ubuntu_server`，ubuntu_server是你的虚拟机的主机名称，而ubuntu_server以后将代替192.168.18.202出现。如果你的虚拟机名不是ubuntu_server,可以修改/etc/hostname中的名称。*\n\n**注意：ssh在使用时无法通过VPN，需要人为手动做一些修改，这边主要是通过将需要ssh访问的ip地址直接经过网卡而不经过vpn。详细内容参见*linux下ssh通过VPN推送失败*文章。**\n\n> http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/\n> http://www.cnblogs.com/hitwtx/archive/2011/11/16/2251254.html\n> http://blog.csdn.net/hunanchenxingyu/article/details/40544513\n","source":"_posts/2016/2016-09-09-ssh相关使用.md","raw":"---\nlayout: \"post\"\ntitle: \"ssh相关使用\"\ndate: \"2016-09-09 17:41\"\n---\n\n*使用ssh已经很多次，但每次用到都得查看相关说明，一些操作也不是特别熟悉，本文将总结自己使用的ssh服务说明。*\n\n### 本地SSH配置\n\n- 首先我们需要检查你电脑上现有的ssh key：\n\n```\n$ cd ~/.ssh 检查本机的ssh密钥\n```\n\n如果提示：No such file or directory 说明你是第一次使用git。\n\n- 生成新的SSH Key：\n\n```\nssh-keygen -t rsa -C \"邮件地址@youremail.com\"\n```\n*此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」*\n\n- 然后系统会要你输入密码：\n\n```\nEnter passphrase (empty for no passphrase):<输入加密串>\nEnter same passphrase again:<再次输入加密串>\n```\n*在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，相当于二次的加密，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。个人嫌麻烦一般不会再设定密码，本身ssh的访问就属于本地自动加密认真，就比较安全，除非你秘钥丢失，否则一般不会出问题，*\n\n- 看到这样的界面，就成功设置了本地的ssh key了：\n\n- ~/.ssh/id_rsa.pub 就是需要使用的公钥，将该公钥加入到其他系统上面或者支持ssh服务的软件上面即可实现访问。\n\n\n<!-- more -->\n\n\n### 将本地公钥上传到远程linux服务器\n\n\n> 不同的Linux之间copy文件常用有3种方法：\n\n```\n第一种就是ftp，也就是其中一台Linux安装ftp Server，这样可以另外一台使用ftp的client程序来进行文件的copy。\n\n第二种方法就是采用samba服务，类似Windows文件copy 的方式来操作，比较简洁方便。\n\n第三种就是利用scp命令来进行文件复制。\n```\n\n**scp是有Security的文件copy，基于ssh登录。操作起来比较方便，比如要把当前一个文件copy到远程另外一台主机上，可以如下命令。**\n\n```\nscp /home/daisy/full.tar.gz root@172.19.2.75:/home/root\n```\n\n然后会提示你输入另外那台172.19.2.75主机的root用户的登录密码，接着就开始copy了。如果想反过来操作，把文件从远程主机copy到当前系统，也很简单。\n\n```\nscp root@/full.tar.gz 172.19.2.75:/home/root/full.tar.gz home/daisy/full.tar.gz\n```\n\n- 我们将原始机的公钥拷贝到目标服务器的.ssh目录下，且命名为authorized_keys。\n\n```\nscp /home/git/.ssh/id_rsa.pub git@ubuntu_server:/home/git/.ssh/authorized_keys\n```\n\n*注意，ubuntu_server为ip对应的名称，这边可以改成ip地址，git为用户名。修改实体机(本地机而不是服务器)的ip配置文件`/ect/hosts`，加入如下行：`192.168.18.202 ubuntu_server`，ubuntu_server是你的虚拟机的主机名称，而ubuntu_server以后将代替192.168.18.202出现。如果你的虚拟机名不是ubuntu_server,可以修改/etc/hostname中的名称。*\n\n**注意：ssh在使用时无法通过VPN，需要人为手动做一些修改，这边主要是通过将需要ssh访问的ip地址直接经过网卡而不经过vpn。详细内容参见*linux下ssh通过VPN推送失败*文章。**\n\n> http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/\n> http://www.cnblogs.com/hitwtx/archive/2011/11/16/2251254.html\n> http://blog.csdn.net/hunanchenxingyu/article/details/40544513\n","slug":"2016/2016-09-09-ssh相关使用","published":1,"updated":"2016-12-16T01:47:32.918Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahu002dmumuaaok0zwx","content":"<p><em>使用ssh已经很多次，但每次用到都得查看相关说明，一些操作也不是特别熟悉，本文将总结自己使用的ssh服务说明。</em></p>\n<h3 id=\"本地SSH配置\"><a href=\"#本地SSH配置\" class=\"headerlink\" title=\"本地SSH配置\"></a>本地SSH配置</h3><ul>\n<li>首先我们需要检查你电脑上现有的ssh key：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd ~/.ssh 检查本机的ssh密钥</div></pre></td></tr></table></figure>\n<p>如果提示：No such file or directory 说明你是第一次使用git。</p>\n<ul>\n<li>生成新的SSH Key：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</div></pre></td></tr></table></figure>\n<p><em>此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」</em></p>\n<ul>\n<li>然后系统会要你输入密码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;</div><div class=\"line\">Enter same passphrase again:&lt;再次输入加密串&gt;</div></pre></td></tr></table></figure>\n<p><em>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，相当于二次的加密，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。个人嫌麻烦一般不会再设定密码，本身ssh的访问就属于本地自动加密认真，就比较安全，除非你秘钥丢失，否则一般不会出问题，</em></p>\n<ul>\n<li><p>看到这样的界面，就成功设置了本地的ssh key了：</p>\n</li>\n<li><p>~/.ssh/id_rsa.pub 就是需要使用的公钥，将该公钥加入到其他系统上面或者支持ssh服务的软件上面即可实现访问。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"将本地公钥上传到远程linux服务器\"><a href=\"#将本地公钥上传到远程linux服务器\" class=\"headerlink\" title=\"将本地公钥上传到远程linux服务器\"></a>将本地公钥上传到远程linux服务器</h3><blockquote>\n<p>不同的Linux之间copy文件常用有3种方法：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">第一种就是ftp，也就是其中一台Linux安装ftp Server，这样可以另外一台使用ftp的client程序来进行文件的copy。</div><div class=\"line\"></div><div class=\"line\">第二种方法就是采用samba服务，类似Windows文件copy 的方式来操作，比较简洁方便。</div><div class=\"line\"></div><div class=\"line\">第三种就是利用scp命令来进行文件复制。</div></pre></td></tr></table></figure>\n<p><strong>scp是有Security的文件copy，基于ssh登录。操作起来比较方便，比如要把当前一个文件copy到远程另外一台主机上，可以如下命令。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scp /home/daisy/full.tar.gz root@172.19.2.75:/home/root</div></pre></td></tr></table></figure>\n<p>然后会提示你输入另外那台172.19.2.75主机的root用户的登录密码，接着就开始copy了。如果想反过来操作，把文件从远程主机copy到当前系统，也很简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scp root@/full.tar.gz 172.19.2.75:/home/root/full.tar.gz home/daisy/full.tar.gz</div></pre></td></tr></table></figure>\n<ul>\n<li>我们将原始机的公钥拷贝到目标服务器的.ssh目录下，且命名为authorized_keys。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scp /home/git/.ssh/id_rsa.pub git@ubuntu_server:/home/git/.ssh/authorized_keys</div></pre></td></tr></table></figure>\n<p><em>注意，ubuntu_server为ip对应的名称，这边可以改成ip地址，git为用户名。修改实体机(本地机而不是服务器)的ip配置文件<code>/ect/hosts</code>，加入如下行：<code>192.168.18.202 ubuntu_server</code>，ubuntu_server是你的虚拟机的主机名称，而ubuntu_server以后将代替192.168.18.202出现。如果你的虚拟机名不是ubuntu_server,可以修改/etc/hostname中的名称。</em></p>\n<p><strong>注意：ssh在使用时无法通过VPN，需要人为手动做一些修改，这边主要是通过将需要ssh访问的ip地址直接经过网卡而不经过vpn。详细内容参见<em>linux下ssh通过VPN推送失败</em>文章。</strong></p>\n<blockquote>\n<p><a href=\"http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/\" target=\"_blank\" rel=\"external\">http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/</a><br><a href=\"http://www.cnblogs.com/hitwtx/archive/2011/11/16/2251254.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/hitwtx/archive/2011/11/16/2251254.html</a><br><a href=\"http://blog.csdn.net/hunanchenxingyu/article/details/40544513\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/hunanchenxingyu/article/details/40544513</a></p>\n</blockquote>\n","excerpt":"<p><em>使用ssh已经很多次，但每次用到都得查看相关说明，一些操作也不是特别熟悉，本文将总结自己使用的ssh服务说明。</em></p>\n<h3 id=\"本地SSH配置\"><a href=\"#本地SSH配置\" class=\"headerlink\" title=\"本地SSH配置\"></a>本地SSH配置</h3><ul>\n<li>首先我们需要检查你电脑上现有的ssh key：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd ~/.ssh 检查本机的ssh密钥</div></pre></td></tr></table></figure>\n<p>如果提示：No such file or directory 说明你是第一次使用git。</p>\n<ul>\n<li>生成新的SSH Key：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</div></pre></td></tr></table></figure>\n<p><em>此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」</em></p>\n<ul>\n<li>然后系统会要你输入密码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;</div><div class=\"line\">Enter same passphrase again:&lt;再次输入加密串&gt;</div></pre></td></tr></table></figure>\n<p><em>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，相当于二次的加密，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。个人嫌麻烦一般不会再设定密码，本身ssh的访问就属于本地自动加密认真，就比较安全，除非你秘钥丢失，否则一般不会出问题，</em></p>\n<ul>\n<li><p>看到这样的界面，就成功设置了本地的ssh key了：</p>\n</li>\n<li><p>~/.ssh/id_rsa.pub 就是需要使用的公钥，将该公钥加入到其他系统上面或者支持ssh服务的软件上面即可实现访问。</p>\n</li>\n</ul>","more":"<h3 id=\"将本地公钥上传到远程linux服务器\"><a href=\"#将本地公钥上传到远程linux服务器\" class=\"headerlink\" title=\"将本地公钥上传到远程linux服务器\"></a>将本地公钥上传到远程linux服务器</h3><blockquote>\n<p>不同的Linux之间copy文件常用有3种方法：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">第一种就是ftp，也就是其中一台Linux安装ftp Server，这样可以另外一台使用ftp的client程序来进行文件的copy。</div><div class=\"line\"></div><div class=\"line\">第二种方法就是采用samba服务，类似Windows文件copy 的方式来操作，比较简洁方便。</div><div class=\"line\"></div><div class=\"line\">第三种就是利用scp命令来进行文件复制。</div></pre></td></tr></table></figure>\n<p><strong>scp是有Security的文件copy，基于ssh登录。操作起来比较方便，比如要把当前一个文件copy到远程另外一台主机上，可以如下命令。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scp /home/daisy/full.tar.gz root@172.19.2.75:/home/root</div></pre></td></tr></table></figure>\n<p>然后会提示你输入另外那台172.19.2.75主机的root用户的登录密码，接着就开始copy了。如果想反过来操作，把文件从远程主机copy到当前系统，也很简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scp root@/full.tar.gz 172.19.2.75:/home/root/full.tar.gz home/daisy/full.tar.gz</div></pre></td></tr></table></figure>\n<ul>\n<li>我们将原始机的公钥拷贝到目标服务器的.ssh目录下，且命名为authorized_keys。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scp /home/git/.ssh/id_rsa.pub git@ubuntu_server:/home/git/.ssh/authorized_keys</div></pre></td></tr></table></figure>\n<p><em>注意，ubuntu_server为ip对应的名称，这边可以改成ip地址，git为用户名。修改实体机(本地机而不是服务器)的ip配置文件<code>/ect/hosts</code>，加入如下行：<code>192.168.18.202 ubuntu_server</code>，ubuntu_server是你的虚拟机的主机名称，而ubuntu_server以后将代替192.168.18.202出现。如果你的虚拟机名不是ubuntu_server,可以修改/etc/hostname中的名称。</em></p>\n<p><strong>注意：ssh在使用时无法通过VPN，需要人为手动做一些修改，这边主要是通过将需要ssh访问的ip地址直接经过网卡而不经过vpn。详细内容参见<em>linux下ssh通过VPN推送失败</em>文章。</strong></p>\n<blockquote>\n<p><a href=\"http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/\">http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/</a><br><a href=\"http://www.cnblogs.com/hitwtx/archive/2011/11/16/2251254.html\">http://www.cnblogs.com/hitwtx/archive/2011/11/16/2251254.html</a><br><a href=\"http://blog.csdn.net/hunanchenxingyu/article/details/40544513\">http://blog.csdn.net/hunanchenxingyu/article/details/40544513</a></p>\n</blockquote>"},{"layout":"post","title":"（转）谈谈写程序与学英语","date":"2016-08-25T05:47:00.000Z","_content":"*注: 本文的作者是宋劲杉，[原文链接](http://songjinshan.com/blog/index.php/%E8%B0%88%E8%B0%88%E5%86%99%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%AD%A6%E8%8B%B1%E8%AF%AD%EF%BC%8D%EF%BC%8D%E8%87%B4%E4%BA%9A%E5%B5%8C%E5%B0%B1%E4%B8%9A%E7%8F%AD%E5%AD%A6%E5%91%98/)。转载自[网址](http://happypeter.github.io/on-english-and-prog.html)*\n\n俗话说，没有金刚钻，就别揽瓷器活儿。套用到IT业，英语不行，就别做程序员。网上关于程序员学英语的文章不少，但我想谈谈我自己的看法。首先详细讨论一下为什么程序员离了英语不行，然后针对程序员应该怎么学英语说说我的体会。\n\n**英语是计算机的母语，是程序的母语，所以必然是程序员的母语。**程序中的变量名、函数名起得好不好是决定代码质量和可维护性的最关键因素。高质量的代码应该是这样的：代码基本上是自解释的（self-explanatory），不需要太多注释，不管代码的规模有多大，具有相关知识背景的读过文档的人都可以立刻上手、立刻参与维护和开发。要想使代码能够自解释，给变量和函数起个好名字很关键，很显然，只能用英文起名字，一是用汉语拼音起名字可读性很差，二是英文单词通常比汉语更expressive（看吧，如果用汉语来说，就得说“表达能力更强”、“更有表现力”这么罗嗦），由于程序的复杂性，变量和函数往往表示一些很抽象的概念，起个既准确又简洁的名字并不容易，可是很多时候，用汉语需要很多字才能说清楚的一件事，用英文一个单词再加点词形变化就能说清楚了。例如APUE上讲sleep函数的实现，其中有个变量表示“本来应该睡到某个时刻，但是提前被信号唤醒了，唤醒时与本来应该睡到的时刻相差的时间”，如果为了简洁而不求准确，这个变量名至少也得叫“未睡到”，而书中只用了一个单词unslept，非常准确、简洁地表达了这个意思。为了写程序而学英语需要学到什么水平？我认为能起出这种变量名就够水平了。很多在IT外企工作的中国人，说话写文章经常夹杂着英文单词（比我严重多了因为我不在外企），非常可以理解，确实是为了表达得更准确简洁的需要，而不是纯为了play zhuangbility。总之，要写程序必须学好英语，否则连变量名都起不好，这虽然是一个非技术问题，但却是个根本问题，比任何技术问题都重要。当然，现在很多编程语言也支持用Unicode字符给变量和函数起名，但是你见过有人用汉字写程序吗？根本不实用。有人会辩驳说一页英文翻译成中文往往只占半页，中文不是更简洁吗？但是你算算打一页英文和打半页中文哪个敲键盘次数多。另外，要读别人的代码也必须学好英语，如果你不知道unslept是由 sleep变形而来的，就体会不到其中的精妙，只有大量阅读高质量的代码，才能写出高质量的代码，创作都是从模仿开始的。\n\n<!-- more -->\n\n\n**说说英语对于看书学习的重要性。**中文技术书和英文技术书的水平根本不在一个量级上，这是有很多原因的，不能全归结于中文书的作者水平差。最重要的是，出中文书的低回报率决定了作者不可能花太多心血在上面，你去amazon看看一本书卖多少美刀，再去chinapub看看一本书卖几块钱。老外写一本书，可以做到全书没有一个拼写错误（当然英文的拼写检查工具更完善也是部分原因），中文能找出一本没有错别字的书吗？Knuth可以悬赏让全世界读者来找磋，中文书作者有哪个敢这么做？不是因为老外态度有多认真治学有多严谨，而是因为他们赚到了，就应该拿出高质量的作品来，不然会被读者骂的。\n\n**英文技术书的翻译质量通常很差。**也不能归结于译者的水平差，我也翻译过书，也努力想译好，但真的很难译好。IT业的新名词层出不穷，像“内核”、“网络” 这种常见术语还好，稍微专一点的术语都没有统一的译名。我们在教学中发现，很多学员看书时搞不清这本书的名词A和那本书的名词B是什么区别，来问老师，才发现原来A和B就是一回事儿。这是一个单词对应多个译名的情况，还有一个译名对应多个单词的情况，比如field、domain、realm都译成 “域”，block、 bulk都译成“块”，argument、parameter都译成“参数”，attribute、property都译成“属性”，虽然这些词的意思本来就差不多，但是在一篇文章里，作者可以换着用，不同的单词表示不同的概念，翻译完了一看，都成一个概念了。英文书背后都有index，看到一半忘了某个名词是怎么定义的就可以翻index，而译文通常没有index，名词都已经乱七八糟了，没法做index。还有更发指的是，老外喜欢造词，现有的单词上加一点变化和组合（例如有人喜欢说automagically），看着心领神会，想译出来就很费劲。老外即使在技术书中也经常用一些生动的表达方式和俏皮话，而中文的书面语言非常死板，生动的表达方式只存在于口语中，如果写在书上就很不像话，这也是很难翻译的一个重要原因。看中文译本，不仅质量差，而且跟不上时代，通常一本英文书出来，至少要等一到两年才能看到中文译本。两年啊！等你看到这本书的中文译本时，这个版本都快淘汰了。\n\n**然后说说英语在开发工作中的重要性。**看书学习通常只起一个引导入门的作用，在工作中更有用的是手册、文档。学完了C语言开始写程序了，谁还会去查 K&R附录中的库函数？查man page才是最有效率的。然而手册比入门书更少有中文译版，因为手册是随时变的，会随着软件版本更新，而且需要看这些开发手册的人通常不会有英文障碍，有英文障碍的人即使看了翻译的手册也写不出好程序来，所以当然没必要翻译了。*不管什么技术，官方的手册和技术标准才是最原始的第一手资料，看别的书都是以讹传讹，由于自然语言不可避免是有歧义的，文档中表达得不准确的地方就会被文档的读者也就是技术书的作者误解，技术书中再有表达不准确的地方又被译者误解。*我们小时候都玩过传话的游戏，几个人站一排，通过悄悄话传一句话，传到最后变成什么了？所以，学网络协议，就得看RFC，学ARM，就得看ARM公司的 Architecture Reference Manual，要学习C语言就得看C99，有歧义不要紧，自己去揣测原作者的意思，总比道听途说的可靠。\n\n我们的学员出去面试经常被问到的一个问题就是：在开发工作中遇到问题，书和文档上都没有答案，网上搜一下也没有答案，怎么办？要我说，能看懂源代码的就去源代码中找答案，这称为hacking，不管是内核、libc还是各种framework，你调用的东西有问题都能从它的代码中找到原因。如果没有能力 hacking，或者时间紧不想去hacking，最好的办法就是去官方邮件列表和IRC问。如果英文不行就没办法了，只能去一些中文论坛：“各位大虾帮忙，小弟有一个问题求救！跪求！！在线等！！！”在线等了好几天也无人问津，或者答非所问。岂不知逛这些论坛的没有大虾，都是菜鸟，大虾们都在IRC上聊得正欢呢。我在做Qt开发时曾经有一个问题，当时在教育网，上国外网不方便，去各大中文论坛问了好几天也没人给出满意的回答，后来花钱连了国外网，去 trolltech官方新闻组提问，只等了几分钟就得到了满意的解决办法。这次经历给我留下了深刻印象，从此以后再也没有去中文论坛。\n\n那么，如果现在英文水平很差，又想做程序员，应该怎么学英语呢？我下面说的方法有两个前提，一是你的英文至少达到高中毕业水平，也就是语法基本都学完了，即使用得不熟练也知道有那么回事儿，二是你希望尽快在工作中用上英语，写程序够用就行，而不是有考T考G这样的更高要求。\n\n学习英语有听说读写四个方面的要求，做程序员至少需要读和写非常流畅，如果在外企工作还需要听和说的能力。技术英语和考T考G是不一样的，一是听和说不像读和写那么重要，不必担心自己是“聋哑英语”，没关系，丝毫不影响你成为编程高手，二是要求的词汇量要小得多。考T考G都要拿一本单词书背，很少有人会觉得背单词很有意思，至少我是觉得很痛苦，幸运的是看技术书不需要多少词汇量。技术书的描述对象都是局限于一个很窄的领域的，就那么几个单词翻来覆去地用，而且技术书是为了让人看懂的（不像诗是为了让人看不懂的），比较复杂的词在书中都有定义或解释。有些作者喜欢卖弄词汇量，用一些很生僻的单词，也有些作者卖弄一些典故，由于文化背景不同很难理解，不过这些通常都可以无视，不会影响阅读，还是因为技术书是为了让人看懂的。对于学习者来说，阅读能力是最重要的，等你完成了学习，成为一个合格的开发者时，需要写代码注释，需要写文档，需要通过邮件交流，写作的能力才开始重要了。所以应该首先从阅读开始练习英语。\n\n现在就拿起一本英文原版书开始看吧。和学游泳一样，阅读的能力只能通过阅读本身来练习。我的经验是，不必先系统学习了单词和语法再看书，可以在看书时用到什么就补什么。我建议初学者看电子版，因为现在的词典软件都可以鼠标取词，边看边查很方便，很多勤快人喜欢把查过的单词都抄下来，我觉得没有必要，反正查字典很方便，下次再看到了就再查，多查几次总会记住的，抄下来就打断了看书的思路，而且不见得抄下来就能记住。也许是因为我这人比较懒，我用的都是懒办法。很多人不喜欢看电子书，理由是盯着屏幕看书太累，那么盯着屏幕写程序累不累？这种人显然不适合做程序员。语法不熟练怎么办？大多数情况下单词的意思都明白了就不影响阅读。技术书有时候喜欢用长句，其中可能包含各种从句，如果实在读不懂就去查语法书，同样也不需要把这种从句彻底弄明白，只要这一句能看过去就行了，以后多查几遍书，自然就掌握了。另外，技术书是说明文，通常不应该有过去时，看到过去时就需要注意了，很可能是虚拟语气，如果不注意这一点，看到的意思可能和真实的意思正好相反。\n\n应该从哪本书开始看起呢？从你当前最需要学的技术书看起。看书是相当花时间的，如果能一边学英语一边学技术，这时间利用得就很有效率。比如，如果你的C语言已经学得相当好了，不要专门为了学英语去重看一遍原版的K&R。市面上有一些专门的计算机英语教材，我的建议是不要看，浪费时间，nonsense。初学时最好选一本有中文译本的书，有看不懂的地方可以翻中文版来对照，但是不要相信中文的翻译，原因在前面讨论过了。如果你是初学编程，没有任何基础，我可以推荐一本英文很浅显技术也很浅显的书：[How To Think Like a Computer Scientist](http://interactivepython.org/runestone/static/thinkcspy/index.html)，有Python、Java和C++版本，可自由下载。\n\n要逐渐养成良好的阅读习惯:\n- 不要每个生单词都去查，有些单词很生僻，查了也记不住，记住了也不会再见到它了，但是前面讲过，都是作者在卖弄词汇量，无视它丝毫不影响阅读，因此要学会猜测单词的意思，能不查就不查，继续贯彻“懒”的原则。\n- 看书不要动口，不念出声也不行，就是不要动口，要努力在大脑中建立从词形到语义的直接映射，如果只能从词形到读音再到语义就太慢了，严重影响阅读速度。\n- 努力做到每句话都从头到尾只看一遍，不许回头反复看，这一点比较难，必须注意力高度集中，经常在记忆中暂存前面半句的内容和句式才能做到，但是一旦神功练成就会成倍地提高阅读速度。\n- 学会skim，就是略读，很多优秀的作者在组织材料时会给读者一些建议，比如这一段是扩展的高级话题，和主线的相关度较低，可以先skim到后面，注意不是让你skip到后面，这一段还是要读的，但是不必逐字句地读，而是抓主旨，大概讲了个什么概念（有一些下定义的句式），有哪些要点（有数字编号或bullet列表项），适用于哪些场合有哪些注意事项（有 caveat、gotcha、noteworthy这种字眼），后面可能还会碰到这个概念，虽然你没有仔细看这是个什么东西，但大体上也知道了，这样就能不影响后面的阅读，这不仅需要高度集中的注意力、熟练的语言能力，而且要有足够的背景知识去猜测性地理解。但是语言能力还是最重要的因素，我和几个同学交流过，他们也能熟练地看英文书，但是需要skim查一个东西时就觉得还是不如中文书查得快。skim的技能在查阅手册时尤其重要，没有人会像看入门书一样把上千页的手册从头到尾看一遍，都是用到哪儿就查哪儿。总之，锻炼各种阅读习惯就为了一个目的：如何在最短的时间内，在保证正确性的前提下，获取尽可能多的知识。程序员的学习时间都是非常宝贵的。\n\n以上本着“够用就好”的原则，多次提到用懒办法，但是学技术学英语这两件事不能懒，贵在坚持。要养成良好的阅读习惯也有很多东西需要坚持，其中**最根本的是持续高度集中注意力，充分调动记忆能力、推理能力、猜测能力，就像考试做阅读题一样看每一段话。**最根本也是最重要的，**“有英文原版就不看中文版”这个原则一定要坚持。**一开始看英文书可能会很慢，但只要一直坚持就会慢慢达到原来看中文书的速度，再坚持下去就会比中文书看得更有效率，因为避免了很多歧义和术语翻译的问题。有人会说，项目紧任务急，看英文资料太慢，这次就先用中文尽快解决工作中的问题吧，等以后有时间了再看英文书学习。可是什么时候才会有时间呢？工作总是一个接一个的，老板怎么会付了工资让你闲着呢？如果你有这样的困难，我的建议是干脆辞职，学好了英文再去工作。你只要想想，你的同行们在外企全英文的环境下工作，英文和技术每天都在突飞猛进，而你还在用效率极其低下的方式学习和工作，你和别人的差距不是越来越大了吗？另一方面，现在的在校学生从小学就开始抓英语，基础都很好，很多高校也逐渐重视引进原版教材，开设很多英文授课的专业课。你再不奋起直追，就不觉得以后的职业道路充满危机吗？\n\n最后说说写作。刚开始练习时不要怕写错，能表达清楚自己的意思即可。我看过很多源代码和文档中的英文，一看就是中国人写的，谓语动词不分单复数，名词复数不加s，处处可见中国式英语，但是丝毫不影响我对这些编程大牛的景仰，因为其中的思想我看懂了，并且我认为很强大。我有一个朋友，中学毕业就出来混的，由于工作的性质总要跟老外打交道，他从来不惧和老外交流，虽然连一个囫囵的句子都说不出来，但总是能用中学学的那点单词让老外明白他的意思，这一点我就非常佩服。总之就是说，**不要因为不知道怎么写是对的就不敢动笔写，只要敢交流，并且别人能懂你的意思，就是很有效的交流。而且随着阅读量的增加，自然能写出一手好英文，前面讲过了，创作总是从模仿开始的。不怕出错才能有一个好的开始，才能逐步练习提高，而练习的最终目的当然还是希望写好，不仅字句通顺无语法错误，还能适当修辞。*\n","source":"_posts/2016/2016-08-25-（转）谈谈写程序与学英语.md","raw":"---\nlayout: \"post\"\ntitle: \"（转）谈谈写程序与学英语\"\ndate: \"2016-08-25 13:47\"\n---\n*注: 本文的作者是宋劲杉，[原文链接](http://songjinshan.com/blog/index.php/%E8%B0%88%E8%B0%88%E5%86%99%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%AD%A6%E8%8B%B1%E8%AF%AD%EF%BC%8D%EF%BC%8D%E8%87%B4%E4%BA%9A%E5%B5%8C%E5%B0%B1%E4%B8%9A%E7%8F%AD%E5%AD%A6%E5%91%98/)。转载自[网址](http://happypeter.github.io/on-english-and-prog.html)*\n\n俗话说，没有金刚钻，就别揽瓷器活儿。套用到IT业，英语不行，就别做程序员。网上关于程序员学英语的文章不少，但我想谈谈我自己的看法。首先详细讨论一下为什么程序员离了英语不行，然后针对程序员应该怎么学英语说说我的体会。\n\n**英语是计算机的母语，是程序的母语，所以必然是程序员的母语。**程序中的变量名、函数名起得好不好是决定代码质量和可维护性的最关键因素。高质量的代码应该是这样的：代码基本上是自解释的（self-explanatory），不需要太多注释，不管代码的规模有多大，具有相关知识背景的读过文档的人都可以立刻上手、立刻参与维护和开发。要想使代码能够自解释，给变量和函数起个好名字很关键，很显然，只能用英文起名字，一是用汉语拼音起名字可读性很差，二是英文单词通常比汉语更expressive（看吧，如果用汉语来说，就得说“表达能力更强”、“更有表现力”这么罗嗦），由于程序的复杂性，变量和函数往往表示一些很抽象的概念，起个既准确又简洁的名字并不容易，可是很多时候，用汉语需要很多字才能说清楚的一件事，用英文一个单词再加点词形变化就能说清楚了。例如APUE上讲sleep函数的实现，其中有个变量表示“本来应该睡到某个时刻，但是提前被信号唤醒了，唤醒时与本来应该睡到的时刻相差的时间”，如果为了简洁而不求准确，这个变量名至少也得叫“未睡到”，而书中只用了一个单词unslept，非常准确、简洁地表达了这个意思。为了写程序而学英语需要学到什么水平？我认为能起出这种变量名就够水平了。很多在IT外企工作的中国人，说话写文章经常夹杂着英文单词（比我严重多了因为我不在外企），非常可以理解，确实是为了表达得更准确简洁的需要，而不是纯为了play zhuangbility。总之，要写程序必须学好英语，否则连变量名都起不好，这虽然是一个非技术问题，但却是个根本问题，比任何技术问题都重要。当然，现在很多编程语言也支持用Unicode字符给变量和函数起名，但是你见过有人用汉字写程序吗？根本不实用。有人会辩驳说一页英文翻译成中文往往只占半页，中文不是更简洁吗？但是你算算打一页英文和打半页中文哪个敲键盘次数多。另外，要读别人的代码也必须学好英语，如果你不知道unslept是由 sleep变形而来的，就体会不到其中的精妙，只有大量阅读高质量的代码，才能写出高质量的代码，创作都是从模仿开始的。\n\n<!-- more -->\n\n\n**说说英语对于看书学习的重要性。**中文技术书和英文技术书的水平根本不在一个量级上，这是有很多原因的，不能全归结于中文书的作者水平差。最重要的是，出中文书的低回报率决定了作者不可能花太多心血在上面，你去amazon看看一本书卖多少美刀，再去chinapub看看一本书卖几块钱。老外写一本书，可以做到全书没有一个拼写错误（当然英文的拼写检查工具更完善也是部分原因），中文能找出一本没有错别字的书吗？Knuth可以悬赏让全世界读者来找磋，中文书作者有哪个敢这么做？不是因为老外态度有多认真治学有多严谨，而是因为他们赚到了，就应该拿出高质量的作品来，不然会被读者骂的。\n\n**英文技术书的翻译质量通常很差。**也不能归结于译者的水平差，我也翻译过书，也努力想译好，但真的很难译好。IT业的新名词层出不穷，像“内核”、“网络” 这种常见术语还好，稍微专一点的术语都没有统一的译名。我们在教学中发现，很多学员看书时搞不清这本书的名词A和那本书的名词B是什么区别，来问老师，才发现原来A和B就是一回事儿。这是一个单词对应多个译名的情况，还有一个译名对应多个单词的情况，比如field、domain、realm都译成 “域”，block、 bulk都译成“块”，argument、parameter都译成“参数”，attribute、property都译成“属性”，虽然这些词的意思本来就差不多，但是在一篇文章里，作者可以换着用，不同的单词表示不同的概念，翻译完了一看，都成一个概念了。英文书背后都有index，看到一半忘了某个名词是怎么定义的就可以翻index，而译文通常没有index，名词都已经乱七八糟了，没法做index。还有更发指的是，老外喜欢造词，现有的单词上加一点变化和组合（例如有人喜欢说automagically），看着心领神会，想译出来就很费劲。老外即使在技术书中也经常用一些生动的表达方式和俏皮话，而中文的书面语言非常死板，生动的表达方式只存在于口语中，如果写在书上就很不像话，这也是很难翻译的一个重要原因。看中文译本，不仅质量差，而且跟不上时代，通常一本英文书出来，至少要等一到两年才能看到中文译本。两年啊！等你看到这本书的中文译本时，这个版本都快淘汰了。\n\n**然后说说英语在开发工作中的重要性。**看书学习通常只起一个引导入门的作用，在工作中更有用的是手册、文档。学完了C语言开始写程序了，谁还会去查 K&R附录中的库函数？查man page才是最有效率的。然而手册比入门书更少有中文译版，因为手册是随时变的，会随着软件版本更新，而且需要看这些开发手册的人通常不会有英文障碍，有英文障碍的人即使看了翻译的手册也写不出好程序来，所以当然没必要翻译了。*不管什么技术，官方的手册和技术标准才是最原始的第一手资料，看别的书都是以讹传讹，由于自然语言不可避免是有歧义的，文档中表达得不准确的地方就会被文档的读者也就是技术书的作者误解，技术书中再有表达不准确的地方又被译者误解。*我们小时候都玩过传话的游戏，几个人站一排，通过悄悄话传一句话，传到最后变成什么了？所以，学网络协议，就得看RFC，学ARM，就得看ARM公司的 Architecture Reference Manual，要学习C语言就得看C99，有歧义不要紧，自己去揣测原作者的意思，总比道听途说的可靠。\n\n我们的学员出去面试经常被问到的一个问题就是：在开发工作中遇到问题，书和文档上都没有答案，网上搜一下也没有答案，怎么办？要我说，能看懂源代码的就去源代码中找答案，这称为hacking，不管是内核、libc还是各种framework，你调用的东西有问题都能从它的代码中找到原因。如果没有能力 hacking，或者时间紧不想去hacking，最好的办法就是去官方邮件列表和IRC问。如果英文不行就没办法了，只能去一些中文论坛：“各位大虾帮忙，小弟有一个问题求救！跪求！！在线等！！！”在线等了好几天也无人问津，或者答非所问。岂不知逛这些论坛的没有大虾，都是菜鸟，大虾们都在IRC上聊得正欢呢。我在做Qt开发时曾经有一个问题，当时在教育网，上国外网不方便，去各大中文论坛问了好几天也没人给出满意的回答，后来花钱连了国外网，去 trolltech官方新闻组提问，只等了几分钟就得到了满意的解决办法。这次经历给我留下了深刻印象，从此以后再也没有去中文论坛。\n\n那么，如果现在英文水平很差，又想做程序员，应该怎么学英语呢？我下面说的方法有两个前提，一是你的英文至少达到高中毕业水平，也就是语法基本都学完了，即使用得不熟练也知道有那么回事儿，二是你希望尽快在工作中用上英语，写程序够用就行，而不是有考T考G这样的更高要求。\n\n学习英语有听说读写四个方面的要求，做程序员至少需要读和写非常流畅，如果在外企工作还需要听和说的能力。技术英语和考T考G是不一样的，一是听和说不像读和写那么重要，不必担心自己是“聋哑英语”，没关系，丝毫不影响你成为编程高手，二是要求的词汇量要小得多。考T考G都要拿一本单词书背，很少有人会觉得背单词很有意思，至少我是觉得很痛苦，幸运的是看技术书不需要多少词汇量。技术书的描述对象都是局限于一个很窄的领域的，就那么几个单词翻来覆去地用，而且技术书是为了让人看懂的（不像诗是为了让人看不懂的），比较复杂的词在书中都有定义或解释。有些作者喜欢卖弄词汇量，用一些很生僻的单词，也有些作者卖弄一些典故，由于文化背景不同很难理解，不过这些通常都可以无视，不会影响阅读，还是因为技术书是为了让人看懂的。对于学习者来说，阅读能力是最重要的，等你完成了学习，成为一个合格的开发者时，需要写代码注释，需要写文档，需要通过邮件交流，写作的能力才开始重要了。所以应该首先从阅读开始练习英语。\n\n现在就拿起一本英文原版书开始看吧。和学游泳一样，阅读的能力只能通过阅读本身来练习。我的经验是，不必先系统学习了单词和语法再看书，可以在看书时用到什么就补什么。我建议初学者看电子版，因为现在的词典软件都可以鼠标取词，边看边查很方便，很多勤快人喜欢把查过的单词都抄下来，我觉得没有必要，反正查字典很方便，下次再看到了就再查，多查几次总会记住的，抄下来就打断了看书的思路，而且不见得抄下来就能记住。也许是因为我这人比较懒，我用的都是懒办法。很多人不喜欢看电子书，理由是盯着屏幕看书太累，那么盯着屏幕写程序累不累？这种人显然不适合做程序员。语法不熟练怎么办？大多数情况下单词的意思都明白了就不影响阅读。技术书有时候喜欢用长句，其中可能包含各种从句，如果实在读不懂就去查语法书，同样也不需要把这种从句彻底弄明白，只要这一句能看过去就行了，以后多查几遍书，自然就掌握了。另外，技术书是说明文，通常不应该有过去时，看到过去时就需要注意了，很可能是虚拟语气，如果不注意这一点，看到的意思可能和真实的意思正好相反。\n\n应该从哪本书开始看起呢？从你当前最需要学的技术书看起。看书是相当花时间的，如果能一边学英语一边学技术，这时间利用得就很有效率。比如，如果你的C语言已经学得相当好了，不要专门为了学英语去重看一遍原版的K&R。市面上有一些专门的计算机英语教材，我的建议是不要看，浪费时间，nonsense。初学时最好选一本有中文译本的书，有看不懂的地方可以翻中文版来对照，但是不要相信中文的翻译，原因在前面讨论过了。如果你是初学编程，没有任何基础，我可以推荐一本英文很浅显技术也很浅显的书：[How To Think Like a Computer Scientist](http://interactivepython.org/runestone/static/thinkcspy/index.html)，有Python、Java和C++版本，可自由下载。\n\n要逐渐养成良好的阅读习惯:\n- 不要每个生单词都去查，有些单词很生僻，查了也记不住，记住了也不会再见到它了，但是前面讲过，都是作者在卖弄词汇量，无视它丝毫不影响阅读，因此要学会猜测单词的意思，能不查就不查，继续贯彻“懒”的原则。\n- 看书不要动口，不念出声也不行，就是不要动口，要努力在大脑中建立从词形到语义的直接映射，如果只能从词形到读音再到语义就太慢了，严重影响阅读速度。\n- 努力做到每句话都从头到尾只看一遍，不许回头反复看，这一点比较难，必须注意力高度集中，经常在记忆中暂存前面半句的内容和句式才能做到，但是一旦神功练成就会成倍地提高阅读速度。\n- 学会skim，就是略读，很多优秀的作者在组织材料时会给读者一些建议，比如这一段是扩展的高级话题，和主线的相关度较低，可以先skim到后面，注意不是让你skip到后面，这一段还是要读的，但是不必逐字句地读，而是抓主旨，大概讲了个什么概念（有一些下定义的句式），有哪些要点（有数字编号或bullet列表项），适用于哪些场合有哪些注意事项（有 caveat、gotcha、noteworthy这种字眼），后面可能还会碰到这个概念，虽然你没有仔细看这是个什么东西，但大体上也知道了，这样就能不影响后面的阅读，这不仅需要高度集中的注意力、熟练的语言能力，而且要有足够的背景知识去猜测性地理解。但是语言能力还是最重要的因素，我和几个同学交流过，他们也能熟练地看英文书，但是需要skim查一个东西时就觉得还是不如中文书查得快。skim的技能在查阅手册时尤其重要，没有人会像看入门书一样把上千页的手册从头到尾看一遍，都是用到哪儿就查哪儿。总之，锻炼各种阅读习惯就为了一个目的：如何在最短的时间内，在保证正确性的前提下，获取尽可能多的知识。程序员的学习时间都是非常宝贵的。\n\n以上本着“够用就好”的原则，多次提到用懒办法，但是学技术学英语这两件事不能懒，贵在坚持。要养成良好的阅读习惯也有很多东西需要坚持，其中**最根本的是持续高度集中注意力，充分调动记忆能力、推理能力、猜测能力，就像考试做阅读题一样看每一段话。**最根本也是最重要的，**“有英文原版就不看中文版”这个原则一定要坚持。**一开始看英文书可能会很慢，但只要一直坚持就会慢慢达到原来看中文书的速度，再坚持下去就会比中文书看得更有效率，因为避免了很多歧义和术语翻译的问题。有人会说，项目紧任务急，看英文资料太慢，这次就先用中文尽快解决工作中的问题吧，等以后有时间了再看英文书学习。可是什么时候才会有时间呢？工作总是一个接一个的，老板怎么会付了工资让你闲着呢？如果你有这样的困难，我的建议是干脆辞职，学好了英文再去工作。你只要想想，你的同行们在外企全英文的环境下工作，英文和技术每天都在突飞猛进，而你还在用效率极其低下的方式学习和工作，你和别人的差距不是越来越大了吗？另一方面，现在的在校学生从小学就开始抓英语，基础都很好，很多高校也逐渐重视引进原版教材，开设很多英文授课的专业课。你再不奋起直追，就不觉得以后的职业道路充满危机吗？\n\n最后说说写作。刚开始练习时不要怕写错，能表达清楚自己的意思即可。我看过很多源代码和文档中的英文，一看就是中国人写的，谓语动词不分单复数，名词复数不加s，处处可见中国式英语，但是丝毫不影响我对这些编程大牛的景仰，因为其中的思想我看懂了，并且我认为很强大。我有一个朋友，中学毕业就出来混的，由于工作的性质总要跟老外打交道，他从来不惧和老外交流，虽然连一个囫囵的句子都说不出来，但总是能用中学学的那点单词让老外明白他的意思，这一点我就非常佩服。总之就是说，**不要因为不知道怎么写是对的就不敢动笔写，只要敢交流，并且别人能懂你的意思，就是很有效的交流。而且随着阅读量的增加，自然能写出一手好英文，前面讲过了，创作总是从模仿开始的。不怕出错才能有一个好的开始，才能逐步练习提高，而练习的最终目的当然还是希望写好，不仅字句通顺无语法错误，还能适当修辞。*\n","slug":"2016/2016-08-25-（转）谈谈写程序与学英语","published":1,"updated":"2017-01-05T01:22:59.697Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahu002emumuotbptk9i","content":"<p><em>注: 本文的作者是宋劲杉，<a href=\"http://songjinshan.com/blog/index.php/%E8%B0%88%E8%B0%88%E5%86%99%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%AD%A6%E8%8B%B1%E8%AF%AD%EF%BC%8D%EF%BC%8D%E8%87%B4%E4%BA%9A%E5%B5%8C%E5%B0%B1%E4%B8%9A%E7%8F%AD%E5%AD%A6%E5%91%98/\" target=\"_blank\" rel=\"external\">原文链接</a>。转载自<a href=\"http://happypeter.github.io/on-english-and-prog.html\" target=\"_blank\" rel=\"external\">网址</a></em></p>\n<p>俗话说，没有金刚钻，就别揽瓷器活儿。套用到IT业，英语不行，就别做程序员。网上关于程序员学英语的文章不少，但我想谈谈我自己的看法。首先详细讨论一下为什么程序员离了英语不行，然后针对程序员应该怎么学英语说说我的体会。</p>\n<p><strong>英语是计算机的母语，是程序的母语，所以必然是程序员的母语。</strong>程序中的变量名、函数名起得好不好是决定代码质量和可维护性的最关键因素。高质量的代码应该是这样的：代码基本上是自解释的（self-explanatory），不需要太多注释，不管代码的规模有多大，具有相关知识背景的读过文档的人都可以立刻上手、立刻参与维护和开发。要想使代码能够自解释，给变量和函数起个好名字很关键，很显然，只能用英文起名字，一是用汉语拼音起名字可读性很差，二是英文单词通常比汉语更expressive（看吧，如果用汉语来说，就得说“表达能力更强”、“更有表现力”这么罗嗦），由于程序的复杂性，变量和函数往往表示一些很抽象的概念，起个既准确又简洁的名字并不容易，可是很多时候，用汉语需要很多字才能说清楚的一件事，用英文一个单词再加点词形变化就能说清楚了。例如APUE上讲sleep函数的实现，其中有个变量表示“本来应该睡到某个时刻，但是提前被信号唤醒了，唤醒时与本来应该睡到的时刻相差的时间”，如果为了简洁而不求准确，这个变量名至少也得叫“未睡到”，而书中只用了一个单词unslept，非常准确、简洁地表达了这个意思。为了写程序而学英语需要学到什么水平？我认为能起出这种变量名就够水平了。很多在IT外企工作的中国人，说话写文章经常夹杂着英文单词（比我严重多了因为我不在外企），非常可以理解，确实是为了表达得更准确简洁的需要，而不是纯为了play zhuangbility。总之，要写程序必须学好英语，否则连变量名都起不好，这虽然是一个非技术问题，但却是个根本问题，比任何技术问题都重要。当然，现在很多编程语言也支持用Unicode字符给变量和函数起名，但是你见过有人用汉字写程序吗？根本不实用。有人会辩驳说一页英文翻译成中文往往只占半页，中文不是更简洁吗？但是你算算打一页英文和打半页中文哪个敲键盘次数多。另外，要读别人的代码也必须学好英语，如果你不知道unslept是由 sleep变形而来的，就体会不到其中的精妙，只有大量阅读高质量的代码，才能写出高质量的代码，创作都是从模仿开始的。</p>\n<a id=\"more\"></a>\n<p><strong>说说英语对于看书学习的重要性。</strong>中文技术书和英文技术书的水平根本不在一个量级上，这是有很多原因的，不能全归结于中文书的作者水平差。最重要的是，出中文书的低回报率决定了作者不可能花太多心血在上面，你去amazon看看一本书卖多少美刀，再去chinapub看看一本书卖几块钱。老外写一本书，可以做到全书没有一个拼写错误（当然英文的拼写检查工具更完善也是部分原因），中文能找出一本没有错别字的书吗？Knuth可以悬赏让全世界读者来找磋，中文书作者有哪个敢这么做？不是因为老外态度有多认真治学有多严谨，而是因为他们赚到了，就应该拿出高质量的作品来，不然会被读者骂的。</p>\n<p><strong>英文技术书的翻译质量通常很差。</strong>也不能归结于译者的水平差，我也翻译过书，也努力想译好，但真的很难译好。IT业的新名词层出不穷，像“内核”、“网络” 这种常见术语还好，稍微专一点的术语都没有统一的译名。我们在教学中发现，很多学员看书时搞不清这本书的名词A和那本书的名词B是什么区别，来问老师，才发现原来A和B就是一回事儿。这是一个单词对应多个译名的情况，还有一个译名对应多个单词的情况，比如field、domain、realm都译成 “域”，block、 bulk都译成“块”，argument、parameter都译成“参数”，attribute、property都译成“属性”，虽然这些词的意思本来就差不多，但是在一篇文章里，作者可以换着用，不同的单词表示不同的概念，翻译完了一看，都成一个概念了。英文书背后都有index，看到一半忘了某个名词是怎么定义的就可以翻index，而译文通常没有index，名词都已经乱七八糟了，没法做index。还有更发指的是，老外喜欢造词，现有的单词上加一点变化和组合（例如有人喜欢说automagically），看着心领神会，想译出来就很费劲。老外即使在技术书中也经常用一些生动的表达方式和俏皮话，而中文的书面语言非常死板，生动的表达方式只存在于口语中，如果写在书上就很不像话，这也是很难翻译的一个重要原因。看中文译本，不仅质量差，而且跟不上时代，通常一本英文书出来，至少要等一到两年才能看到中文译本。两年啊！等你看到这本书的中文译本时，这个版本都快淘汰了。</p>\n<p><strong>然后说说英语在开发工作中的重要性。</strong>看书学习通常只起一个引导入门的作用，在工作中更有用的是手册、文档。学完了C语言开始写程序了，谁还会去查 K&amp;R附录中的库函数？查man page才是最有效率的。然而手册比入门书更少有中文译版，因为手册是随时变的，会随着软件版本更新，而且需要看这些开发手册的人通常不会有英文障碍，有英文障碍的人即使看了翻译的手册也写不出好程序来，所以当然没必要翻译了。<em>不管什么技术，官方的手册和技术标准才是最原始的第一手资料，看别的书都是以讹传讹，由于自然语言不可避免是有歧义的，文档中表达得不准确的地方就会被文档的读者也就是技术书的作者误解，技术书中再有表达不准确的地方又被译者误解。</em>我们小时候都玩过传话的游戏，几个人站一排，通过悄悄话传一句话，传到最后变成什么了？所以，学网络协议，就得看RFC，学ARM，就得看ARM公司的 Architecture Reference Manual，要学习C语言就得看C99，有歧义不要紧，自己去揣测原作者的意思，总比道听途说的可靠。</p>\n<p>我们的学员出去面试经常被问到的一个问题就是：在开发工作中遇到问题，书和文档上都没有答案，网上搜一下也没有答案，怎么办？要我说，能看懂源代码的就去源代码中找答案，这称为hacking，不管是内核、libc还是各种framework，你调用的东西有问题都能从它的代码中找到原因。如果没有能力 hacking，或者时间紧不想去hacking，最好的办法就是去官方邮件列表和IRC问。如果英文不行就没办法了，只能去一些中文论坛：“各位大虾帮忙，小弟有一个问题求救！跪求！！在线等！！！”在线等了好几天也无人问津，或者答非所问。岂不知逛这些论坛的没有大虾，都是菜鸟，大虾们都在IRC上聊得正欢呢。我在做Qt开发时曾经有一个问题，当时在教育网，上国外网不方便，去各大中文论坛问了好几天也没人给出满意的回答，后来花钱连了国外网，去 trolltech官方新闻组提问，只等了几分钟就得到了满意的解决办法。这次经历给我留下了深刻印象，从此以后再也没有去中文论坛。</p>\n<p>那么，如果现在英文水平很差，又想做程序员，应该怎么学英语呢？我下面说的方法有两个前提，一是你的英文至少达到高中毕业水平，也就是语法基本都学完了，即使用得不熟练也知道有那么回事儿，二是你希望尽快在工作中用上英语，写程序够用就行，而不是有考T考G这样的更高要求。</p>\n<p>学习英语有听说读写四个方面的要求，做程序员至少需要读和写非常流畅，如果在外企工作还需要听和说的能力。技术英语和考T考G是不一样的，一是听和说不像读和写那么重要，不必担心自己是“聋哑英语”，没关系，丝毫不影响你成为编程高手，二是要求的词汇量要小得多。考T考G都要拿一本单词书背，很少有人会觉得背单词很有意思，至少我是觉得很痛苦，幸运的是看技术书不需要多少词汇量。技术书的描述对象都是局限于一个很窄的领域的，就那么几个单词翻来覆去地用，而且技术书是为了让人看懂的（不像诗是为了让人看不懂的），比较复杂的词在书中都有定义或解释。有些作者喜欢卖弄词汇量，用一些很生僻的单词，也有些作者卖弄一些典故，由于文化背景不同很难理解，不过这些通常都可以无视，不会影响阅读，还是因为技术书是为了让人看懂的。对于学习者来说，阅读能力是最重要的，等你完成了学习，成为一个合格的开发者时，需要写代码注释，需要写文档，需要通过邮件交流，写作的能力才开始重要了。所以应该首先从阅读开始练习英语。</p>\n<p>现在就拿起一本英文原版书开始看吧。和学游泳一样，阅读的能力只能通过阅读本身来练习。我的经验是，不必先系统学习了单词和语法再看书，可以在看书时用到什么就补什么。我建议初学者看电子版，因为现在的词典软件都可以鼠标取词，边看边查很方便，很多勤快人喜欢把查过的单词都抄下来，我觉得没有必要，反正查字典很方便，下次再看到了就再查，多查几次总会记住的，抄下来就打断了看书的思路，而且不见得抄下来就能记住。也许是因为我这人比较懒，我用的都是懒办法。很多人不喜欢看电子书，理由是盯着屏幕看书太累，那么盯着屏幕写程序累不累？这种人显然不适合做程序员。语法不熟练怎么办？大多数情况下单词的意思都明白了就不影响阅读。技术书有时候喜欢用长句，其中可能包含各种从句，如果实在读不懂就去查语法书，同样也不需要把这种从句彻底弄明白，只要这一句能看过去就行了，以后多查几遍书，自然就掌握了。另外，技术书是说明文，通常不应该有过去时，看到过去时就需要注意了，很可能是虚拟语气，如果不注意这一点，看到的意思可能和真实的意思正好相反。</p>\n<p>应该从哪本书开始看起呢？从你当前最需要学的技术书看起。看书是相当花时间的，如果能一边学英语一边学技术，这时间利用得就很有效率。比如，如果你的C语言已经学得相当好了，不要专门为了学英语去重看一遍原版的K&amp;R。市面上有一些专门的计算机英语教材，我的建议是不要看，浪费时间，nonsense。初学时最好选一本有中文译本的书，有看不懂的地方可以翻中文版来对照，但是不要相信中文的翻译，原因在前面讨论过了。如果你是初学编程，没有任何基础，我可以推荐一本英文很浅显技术也很浅显的书：<a href=\"http://interactivepython.org/runestone/static/thinkcspy/index.html\" target=\"_blank\" rel=\"external\">How To Think Like a Computer Scientist</a>，有Python、Java和C++版本，可自由下载。</p>\n<p>要逐渐养成良好的阅读习惯:</p>\n<ul>\n<li>不要每个生单词都去查，有些单词很生僻，查了也记不住，记住了也不会再见到它了，但是前面讲过，都是作者在卖弄词汇量，无视它丝毫不影响阅读，因此要学会猜测单词的意思，能不查就不查，继续贯彻“懒”的原则。</li>\n<li>看书不要动口，不念出声也不行，就是不要动口，要努力在大脑中建立从词形到语义的直接映射，如果只能从词形到读音再到语义就太慢了，严重影响阅读速度。</li>\n<li>努力做到每句话都从头到尾只看一遍，不许回头反复看，这一点比较难，必须注意力高度集中，经常在记忆中暂存前面半句的内容和句式才能做到，但是一旦神功练成就会成倍地提高阅读速度。</li>\n<li>学会skim，就是略读，很多优秀的作者在组织材料时会给读者一些建议，比如这一段是扩展的高级话题，和主线的相关度较低，可以先skim到后面，注意不是让你skip到后面，这一段还是要读的，但是不必逐字句地读，而是抓主旨，大概讲了个什么概念（有一些下定义的句式），有哪些要点（有数字编号或bullet列表项），适用于哪些场合有哪些注意事项（有 caveat、gotcha、noteworthy这种字眼），后面可能还会碰到这个概念，虽然你没有仔细看这是个什么东西，但大体上也知道了，这样就能不影响后面的阅读，这不仅需要高度集中的注意力、熟练的语言能力，而且要有足够的背景知识去猜测性地理解。但是语言能力还是最重要的因素，我和几个同学交流过，他们也能熟练地看英文书，但是需要skim查一个东西时就觉得还是不如中文书查得快。skim的技能在查阅手册时尤其重要，没有人会像看入门书一样把上千页的手册从头到尾看一遍，都是用到哪儿就查哪儿。总之，锻炼各种阅读习惯就为了一个目的：如何在最短的时间内，在保证正确性的前提下，获取尽可能多的知识。程序员的学习时间都是非常宝贵的。</li>\n</ul>\n<p>以上本着“够用就好”的原则，多次提到用懒办法，但是学技术学英语这两件事不能懒，贵在坚持。要养成良好的阅读习惯也有很多东西需要坚持，其中<strong>最根本的是持续高度集中注意力，充分调动记忆能力、推理能力、猜测能力，就像考试做阅读题一样看每一段话。</strong>最根本也是最重要的，<strong>“有英文原版就不看中文版”这个原则一定要坚持。</strong>一开始看英文书可能会很慢，但只要一直坚持就会慢慢达到原来看中文书的速度，再坚持下去就会比中文书看得更有效率，因为避免了很多歧义和术语翻译的问题。有人会说，项目紧任务急，看英文资料太慢，这次就先用中文尽快解决工作中的问题吧，等以后有时间了再看英文书学习。可是什么时候才会有时间呢？工作总是一个接一个的，老板怎么会付了工资让你闲着呢？如果你有这样的困难，我的建议是干脆辞职，学好了英文再去工作。你只要想想，你的同行们在外企全英文的环境下工作，英文和技术每天都在突飞猛进，而你还在用效率极其低下的方式学习和工作，你和别人的差距不是越来越大了吗？另一方面，现在的在校学生从小学就开始抓英语，基础都很好，很多高校也逐渐重视引进原版教材，开设很多英文授课的专业课。你再不奋起直追，就不觉得以后的职业道路充满危机吗？</p>\n<p>最后说说写作。刚开始练习时不要怕写错，能表达清楚自己的意思即可。我看过很多源代码和文档中的英文，一看就是中国人写的，谓语动词不分单复数，名词复数不加s，处处可见中国式英语，但是丝毫不影响我对这些编程大牛的景仰，因为其中的思想我看懂了，并且我认为很强大。我有一个朋友，中学毕业就出来混的，由于工作的性质总要跟老外打交道，他从来不惧和老外交流，虽然连一个囫囵的句子都说不出来，但总是能用中学学的那点单词让老外明白他的意思，这一点我就非常佩服。总之就是说，<em>*不要因为不知道怎么写是对的就不敢动笔写，只要敢交流，并且别人能懂你的意思，就是很有效的交流。而且随着阅读量的增加，自然能写出一手好英文，前面讲过了，创作总是从模仿开始的。不怕出错才能有一个好的开始，才能逐步练习提高，而练习的最终目的当然还是希望写好，不仅字句通顺无语法错误，还能适当修辞。</em></p>\n","excerpt":"<p><em>注: 本文的作者是宋劲杉，<a href=\"http://songjinshan.com/blog/index.php/%E8%B0%88%E8%B0%88%E5%86%99%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%AD%A6%E8%8B%B1%E8%AF%AD%EF%BC%8D%EF%BC%8D%E8%87%B4%E4%BA%9A%E5%B5%8C%E5%B0%B1%E4%B8%9A%E7%8F%AD%E5%AD%A6%E5%91%98/\">原文链接</a>。转载自<a href=\"http://happypeter.github.io/on-english-and-prog.html\">网址</a></em></p>\n<p>俗话说，没有金刚钻，就别揽瓷器活儿。套用到IT业，英语不行，就别做程序员。网上关于程序员学英语的文章不少，但我想谈谈我自己的看法。首先详细讨论一下为什么程序员离了英语不行，然后针对程序员应该怎么学英语说说我的体会。</p>\n<p><strong>英语是计算机的母语，是程序的母语，所以必然是程序员的母语。</strong>程序中的变量名、函数名起得好不好是决定代码质量和可维护性的最关键因素。高质量的代码应该是这样的：代码基本上是自解释的（self-explanatory），不需要太多注释，不管代码的规模有多大，具有相关知识背景的读过文档的人都可以立刻上手、立刻参与维护和开发。要想使代码能够自解释，给变量和函数起个好名字很关键，很显然，只能用英文起名字，一是用汉语拼音起名字可读性很差，二是英文单词通常比汉语更expressive（看吧，如果用汉语来说，就得说“表达能力更强”、“更有表现力”这么罗嗦），由于程序的复杂性，变量和函数往往表示一些很抽象的概念，起个既准确又简洁的名字并不容易，可是很多时候，用汉语需要很多字才能说清楚的一件事，用英文一个单词再加点词形变化就能说清楚了。例如APUE上讲sleep函数的实现，其中有个变量表示“本来应该睡到某个时刻，但是提前被信号唤醒了，唤醒时与本来应该睡到的时刻相差的时间”，如果为了简洁而不求准确，这个变量名至少也得叫“未睡到”，而书中只用了一个单词unslept，非常准确、简洁地表达了这个意思。为了写程序而学英语需要学到什么水平？我认为能起出这种变量名就够水平了。很多在IT外企工作的中国人，说话写文章经常夹杂着英文单词（比我严重多了因为我不在外企），非常可以理解，确实是为了表达得更准确简洁的需要，而不是纯为了play zhuangbility。总之，要写程序必须学好英语，否则连变量名都起不好，这虽然是一个非技术问题，但却是个根本问题，比任何技术问题都重要。当然，现在很多编程语言也支持用Unicode字符给变量和函数起名，但是你见过有人用汉字写程序吗？根本不实用。有人会辩驳说一页英文翻译成中文往往只占半页，中文不是更简洁吗？但是你算算打一页英文和打半页中文哪个敲键盘次数多。另外，要读别人的代码也必须学好英语，如果你不知道unslept是由 sleep变形而来的，就体会不到其中的精妙，只有大量阅读高质量的代码，才能写出高质量的代码，创作都是从模仿开始的。</p>","more":"<p><strong>说说英语对于看书学习的重要性。</strong>中文技术书和英文技术书的水平根本不在一个量级上，这是有很多原因的，不能全归结于中文书的作者水平差。最重要的是，出中文书的低回报率决定了作者不可能花太多心血在上面，你去amazon看看一本书卖多少美刀，再去chinapub看看一本书卖几块钱。老外写一本书，可以做到全书没有一个拼写错误（当然英文的拼写检查工具更完善也是部分原因），中文能找出一本没有错别字的书吗？Knuth可以悬赏让全世界读者来找磋，中文书作者有哪个敢这么做？不是因为老外态度有多认真治学有多严谨，而是因为他们赚到了，就应该拿出高质量的作品来，不然会被读者骂的。</p>\n<p><strong>英文技术书的翻译质量通常很差。</strong>也不能归结于译者的水平差，我也翻译过书，也努力想译好，但真的很难译好。IT业的新名词层出不穷，像“内核”、“网络” 这种常见术语还好，稍微专一点的术语都没有统一的译名。我们在教学中发现，很多学员看书时搞不清这本书的名词A和那本书的名词B是什么区别，来问老师，才发现原来A和B就是一回事儿。这是一个单词对应多个译名的情况，还有一个译名对应多个单词的情况，比如field、domain、realm都译成 “域”，block、 bulk都译成“块”，argument、parameter都译成“参数”，attribute、property都译成“属性”，虽然这些词的意思本来就差不多，但是在一篇文章里，作者可以换着用，不同的单词表示不同的概念，翻译完了一看，都成一个概念了。英文书背后都有index，看到一半忘了某个名词是怎么定义的就可以翻index，而译文通常没有index，名词都已经乱七八糟了，没法做index。还有更发指的是，老外喜欢造词，现有的单词上加一点变化和组合（例如有人喜欢说automagically），看着心领神会，想译出来就很费劲。老外即使在技术书中也经常用一些生动的表达方式和俏皮话，而中文的书面语言非常死板，生动的表达方式只存在于口语中，如果写在书上就很不像话，这也是很难翻译的一个重要原因。看中文译本，不仅质量差，而且跟不上时代，通常一本英文书出来，至少要等一到两年才能看到中文译本。两年啊！等你看到这本书的中文译本时，这个版本都快淘汰了。</p>\n<p><strong>然后说说英语在开发工作中的重要性。</strong>看书学习通常只起一个引导入门的作用，在工作中更有用的是手册、文档。学完了C语言开始写程序了，谁还会去查 K&amp;R附录中的库函数？查man page才是最有效率的。然而手册比入门书更少有中文译版，因为手册是随时变的，会随着软件版本更新，而且需要看这些开发手册的人通常不会有英文障碍，有英文障碍的人即使看了翻译的手册也写不出好程序来，所以当然没必要翻译了。<em>不管什么技术，官方的手册和技术标准才是最原始的第一手资料，看别的书都是以讹传讹，由于自然语言不可避免是有歧义的，文档中表达得不准确的地方就会被文档的读者也就是技术书的作者误解，技术书中再有表达不准确的地方又被译者误解。</em>我们小时候都玩过传话的游戏，几个人站一排，通过悄悄话传一句话，传到最后变成什么了？所以，学网络协议，就得看RFC，学ARM，就得看ARM公司的 Architecture Reference Manual，要学习C语言就得看C99，有歧义不要紧，自己去揣测原作者的意思，总比道听途说的可靠。</p>\n<p>我们的学员出去面试经常被问到的一个问题就是：在开发工作中遇到问题，书和文档上都没有答案，网上搜一下也没有答案，怎么办？要我说，能看懂源代码的就去源代码中找答案，这称为hacking，不管是内核、libc还是各种framework，你调用的东西有问题都能从它的代码中找到原因。如果没有能力 hacking，或者时间紧不想去hacking，最好的办法就是去官方邮件列表和IRC问。如果英文不行就没办法了，只能去一些中文论坛：“各位大虾帮忙，小弟有一个问题求救！跪求！！在线等！！！”在线等了好几天也无人问津，或者答非所问。岂不知逛这些论坛的没有大虾，都是菜鸟，大虾们都在IRC上聊得正欢呢。我在做Qt开发时曾经有一个问题，当时在教育网，上国外网不方便，去各大中文论坛问了好几天也没人给出满意的回答，后来花钱连了国外网，去 trolltech官方新闻组提问，只等了几分钟就得到了满意的解决办法。这次经历给我留下了深刻印象，从此以后再也没有去中文论坛。</p>\n<p>那么，如果现在英文水平很差，又想做程序员，应该怎么学英语呢？我下面说的方法有两个前提，一是你的英文至少达到高中毕业水平，也就是语法基本都学完了，即使用得不熟练也知道有那么回事儿，二是你希望尽快在工作中用上英语，写程序够用就行，而不是有考T考G这样的更高要求。</p>\n<p>学习英语有听说读写四个方面的要求，做程序员至少需要读和写非常流畅，如果在外企工作还需要听和说的能力。技术英语和考T考G是不一样的，一是听和说不像读和写那么重要，不必担心自己是“聋哑英语”，没关系，丝毫不影响你成为编程高手，二是要求的词汇量要小得多。考T考G都要拿一本单词书背，很少有人会觉得背单词很有意思，至少我是觉得很痛苦，幸运的是看技术书不需要多少词汇量。技术书的描述对象都是局限于一个很窄的领域的，就那么几个单词翻来覆去地用，而且技术书是为了让人看懂的（不像诗是为了让人看不懂的），比较复杂的词在书中都有定义或解释。有些作者喜欢卖弄词汇量，用一些很生僻的单词，也有些作者卖弄一些典故，由于文化背景不同很难理解，不过这些通常都可以无视，不会影响阅读，还是因为技术书是为了让人看懂的。对于学习者来说，阅读能力是最重要的，等你完成了学习，成为一个合格的开发者时，需要写代码注释，需要写文档，需要通过邮件交流，写作的能力才开始重要了。所以应该首先从阅读开始练习英语。</p>\n<p>现在就拿起一本英文原版书开始看吧。和学游泳一样，阅读的能力只能通过阅读本身来练习。我的经验是，不必先系统学习了单词和语法再看书，可以在看书时用到什么就补什么。我建议初学者看电子版，因为现在的词典软件都可以鼠标取词，边看边查很方便，很多勤快人喜欢把查过的单词都抄下来，我觉得没有必要，反正查字典很方便，下次再看到了就再查，多查几次总会记住的，抄下来就打断了看书的思路，而且不见得抄下来就能记住。也许是因为我这人比较懒，我用的都是懒办法。很多人不喜欢看电子书，理由是盯着屏幕看书太累，那么盯着屏幕写程序累不累？这种人显然不适合做程序员。语法不熟练怎么办？大多数情况下单词的意思都明白了就不影响阅读。技术书有时候喜欢用长句，其中可能包含各种从句，如果实在读不懂就去查语法书，同样也不需要把这种从句彻底弄明白，只要这一句能看过去就行了，以后多查几遍书，自然就掌握了。另外，技术书是说明文，通常不应该有过去时，看到过去时就需要注意了，很可能是虚拟语气，如果不注意这一点，看到的意思可能和真实的意思正好相反。</p>\n<p>应该从哪本书开始看起呢？从你当前最需要学的技术书看起。看书是相当花时间的，如果能一边学英语一边学技术，这时间利用得就很有效率。比如，如果你的C语言已经学得相当好了，不要专门为了学英语去重看一遍原版的K&amp;R。市面上有一些专门的计算机英语教材，我的建议是不要看，浪费时间，nonsense。初学时最好选一本有中文译本的书，有看不懂的地方可以翻中文版来对照，但是不要相信中文的翻译，原因在前面讨论过了。如果你是初学编程，没有任何基础，我可以推荐一本英文很浅显技术也很浅显的书：<a href=\"http://interactivepython.org/runestone/static/thinkcspy/index.html\">How To Think Like a Computer Scientist</a>，有Python、Java和C++版本，可自由下载。</p>\n<p>要逐渐养成良好的阅读习惯:</p>\n<ul>\n<li>不要每个生单词都去查，有些单词很生僻，查了也记不住，记住了也不会再见到它了，但是前面讲过，都是作者在卖弄词汇量，无视它丝毫不影响阅读，因此要学会猜测单词的意思，能不查就不查，继续贯彻“懒”的原则。</li>\n<li>看书不要动口，不念出声也不行，就是不要动口，要努力在大脑中建立从词形到语义的直接映射，如果只能从词形到读音再到语义就太慢了，严重影响阅读速度。</li>\n<li>努力做到每句话都从头到尾只看一遍，不许回头反复看，这一点比较难，必须注意力高度集中，经常在记忆中暂存前面半句的内容和句式才能做到，但是一旦神功练成就会成倍地提高阅读速度。</li>\n<li>学会skim，就是略读，很多优秀的作者在组织材料时会给读者一些建议，比如这一段是扩展的高级话题，和主线的相关度较低，可以先skim到后面，注意不是让你skip到后面，这一段还是要读的，但是不必逐字句地读，而是抓主旨，大概讲了个什么概念（有一些下定义的句式），有哪些要点（有数字编号或bullet列表项），适用于哪些场合有哪些注意事项（有 caveat、gotcha、noteworthy这种字眼），后面可能还会碰到这个概念，虽然你没有仔细看这是个什么东西，但大体上也知道了，这样就能不影响后面的阅读，这不仅需要高度集中的注意力、熟练的语言能力，而且要有足够的背景知识去猜测性地理解。但是语言能力还是最重要的因素，我和几个同学交流过，他们也能熟练地看英文书，但是需要skim查一个东西时就觉得还是不如中文书查得快。skim的技能在查阅手册时尤其重要，没有人会像看入门书一样把上千页的手册从头到尾看一遍，都是用到哪儿就查哪儿。总之，锻炼各种阅读习惯就为了一个目的：如何在最短的时间内，在保证正确性的前提下，获取尽可能多的知识。程序员的学习时间都是非常宝贵的。</li>\n</ul>\n<p>以上本着“够用就好”的原则，多次提到用懒办法，但是学技术学英语这两件事不能懒，贵在坚持。要养成良好的阅读习惯也有很多东西需要坚持，其中<strong>最根本的是持续高度集中注意力，充分调动记忆能力、推理能力、猜测能力，就像考试做阅读题一样看每一段话。</strong>最根本也是最重要的，<strong>“有英文原版就不看中文版”这个原则一定要坚持。</strong>一开始看英文书可能会很慢，但只要一直坚持就会慢慢达到原来看中文书的速度，再坚持下去就会比中文书看得更有效率，因为避免了很多歧义和术语翻译的问题。有人会说，项目紧任务急，看英文资料太慢，这次就先用中文尽快解决工作中的问题吧，等以后有时间了再看英文书学习。可是什么时候才会有时间呢？工作总是一个接一个的，老板怎么会付了工资让你闲着呢？如果你有这样的困难，我的建议是干脆辞职，学好了英文再去工作。你只要想想，你的同行们在外企全英文的环境下工作，英文和技术每天都在突飞猛进，而你还在用效率极其低下的方式学习和工作，你和别人的差距不是越来越大了吗？另一方面，现在的在校学生从小学就开始抓英语，基础都很好，很多高校也逐渐重视引进原版教材，开设很多英文授课的专业课。你再不奋起直追，就不觉得以后的职业道路充满危机吗？</p>\n<p>最后说说写作。刚开始练习时不要怕写错，能表达清楚自己的意思即可。我看过很多源代码和文档中的英文，一看就是中国人写的，谓语动词不分单复数，名词复数不加s，处处可见中国式英语，但是丝毫不影响我对这些编程大牛的景仰，因为其中的思想我看懂了，并且我认为很强大。我有一个朋友，中学毕业就出来混的，由于工作的性质总要跟老外打交道，他从来不惧和老外交流，虽然连一个囫囵的句子都说不出来，但总是能用中学学的那点单词让老外明白他的意思，这一点我就非常佩服。总之就是说，<em>*不要因为不知道怎么写是对的就不敢动笔写，只要敢交流，并且别人能懂你的意思，就是很有效的交流。而且随着阅读量的增加，自然能写出一手好英文，前面讲过了，创作总是从模仿开始的。不怕出错才能有一个好的开始，才能逐步练习提高，而练习的最终目的当然还是希望写好，不仅字句通顺无语法错误，还能适当修辞。</em></p>"},{"layout":"post","title":"git问题总结FAQ","date":"2016-08-28T04:00:00.000Z","_content":"\ngit的使用过程真心不容易，尤其对于我这样的初学者且没有其他版本控制器的使用经验，另外也比较容易丢三落四的人来说。按照网上所给的步骤操作，但万一漏做了一些步骤，或者做错了一些步骤，所引起的问题也是致命的，虽然肯定有解决问题的办法，但往往会引起分支结构混乱，经常做了一次提交然后就回不去了，或者经常不知名的无法进行提交，无法进行回退，pull失败等等。\n\n**可见要想真正让git成为你版本控制的工具，git的工作原理必定要相当清楚，版本控制的结构要特别清晰，一单出现问题立马就知道是哪一步做错了才行。**\n\n\n### 问题总结：\n\n\n\n#### git checkout -- filename:\n\n在文件没有stage时可以通过这个命令将该文件撤销回来。一旦文件add后用该命令不再有效。这时需要使用 git reset HEAD -- filename 意味着将文件unstage出库，还原到add之前，再使用git checkout -- filename撤销文件。而如果你使用git checkout HEAD -- filename 则直接会丢弃掉stage中的暂存内容，将文件还原。\n\n<!-- more -->\n\n\n#### git push -u origin master：\n\n远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。*由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。*\n\n\n\n\n#### 从github上面拉取库的方法：\n\n- 方法1：使用git clone address：如果是其他人的库address必须是一个http地址，如果是自己的库，且本地配置好了ssh，则可以通过ssh协议拉取需要的文件。**值得注意这种拉取是完整拉取，会建立一个库名的文件夹。**如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。\n- 方法2：本地已经存在git库的情况下，需要在本地库目录下使用git remote add origin address 将可以把一个已有的本地仓库与之关联。git push -u origin master把当前分支master推送到远程。我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，以后可以简化操作使用 git push origin master。\n\n*推荐使用方法1，直接从远程库clone下来，需要工程时直接clone下来避免没必要的合并，每次使用前可以先pull一下远程库。*\n\n\n\n#### github的协议：\n\nGit支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。默认的git://使用ssh，但也可以使用https等其他协议。clone他人或者自己的版本库的时候，都可以使用https或者ssh下载，但是配置好git的ssh的话，可以本地推送免密码，https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令。\n\n\n\n#### git的分支和HEAD：\n\n贯穿git的整个结构的核心就是分支，每个分支都有一个名称，如主分支一般名称为master，master本身类似一个指针名，永远指向了该分支的最后一次提交的版本。而HEAD则是指向了这个指针。因此在创建分支branch test时，master和test指向同一个位置，这时候如果执行checkout test，则HEAD会从指向master变成指向test（因此git的切换高效事实是指针的操作高效），对这个test的分支相关操作会建立起新的分支结构，而master仍然停留在原处，这时如果checkout master对master进一步的操作提交，会发现版本中真正的形成了两条分支结构。\n\n#### git合并分支：\n\ngit merge \"branchname\"：将两个分支进行合并\n\n- Fast-forward：分支合并完成后出现Fast-forward，意味着快速合并，即合并分支时分支指针仅仅是直接更改了指向，而没有出现其他增删改查的文件。*这种情况一般是需要合并的分支仅仅是建立了一个节点，而没有将分支扩展出去，因此可以直接快速向前合并两个分支指针。*\n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\n- Automatic merge failed; fix conflicts and then commit the result：这种情况虽然合并失败了，但相关文件已经进行了一些变动修改，用户手动更改好，这些文件，然后add,commit 即可完成提交以及分支合并。\n\n\n\n#### 查看分支结构：\n\n- git log --graph --pretty=oneline --abbrev-commit\n- 使用插件tig，该插件在github上面有托管，可以下载源码安装编译，注意提示需要安装一些依赖库*托管，可以下载源码安装编译，注意提示需要安装一些依赖库。*。\n- 如果使用了checkout的话，使用git log则看到内容有限，这时使用git log --all可以查看所有的提交结果。\n- 值得注意的是使用了git reset之后，使用git log 就无法看到最近的一些提交了，因为reset属于版本回退，相当于整个时光倒流回去了，不会在看到未发生的内容，只能通过git reflog查看库里面的所有备份内容。\n\n\n\n#### stash的用处：\n\nGit还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n- git stash：在git add之后可以通过stash将文件修改暂存。\n- git stash list： 查看暂存的信息。\n一些不需要的修改也可以存入stash中，相比而言stash不像commit那么严格，可以随便存入，随便删除。\n\n\n\n#### 远程库如何操作caozuo：\n\n*当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote，返回origin。可以看出远程库也是可以有多个的。*\n\n*实际的远程建立库一般为--bare裸库是不存在实际工程文件的，相当于.git文件直接被展开了，实际使用的时候，需要clone下来才能够看到文件内容。*\n\n- git remote -v：显示更详细的信息,可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。\n- push：就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上`git push origin master`，可以看到origin为远程库的名称，而master为本地需要推送的分支。在Git中，分支完全可以在本地自己，到底要不要推送则完全由你自己决定。\n- clone：从某一个位置将目录完整克隆下来，注意clone后面可以类似：`git clone git@github.com:hard/learngit.git`，也可以使用`git clone ~/home/gitname`但注意gitname必须得是个git的版本库，也就是说在里面执行过`git init`。\n- 推送冲突失败：你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，则会推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git会提示我们：*先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。*git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接:`git branch --set-upstream dev origin/dev`，然后再pull。**这边尤其需要每次输完指令后，看提示，有的未必会报错，但也没有执行相关操作，出现git command的时候，往往是你指令执行已经异常了。**\n\n\n\n#### 同步已有本地库到远程：\n\n*大多数时候，本地存在已有的库，而远程并没有，这个时候不能通过git clone来复制，需要通过以下的一些步骤*\n\n- 删除本地的.git残留文件，如果本地已经有了git操作，但不明具体内容，则首先执行`rm -rf .git`清除掉无关内容，git的设置相当科学，几乎所有的记录信息全在.git目录下。\n- 初始化这个库，`git init`这是必备步骤，建立一个空的默认库。\n- 随意添加几个文件，例如：`echo \"hello world\" >> test.txt`，如果是实验的话可以操作本步骤，如果已有功能则跳过此步骤。\n- 常规git操作，加入stage并提交，`git add .  &&  git commit -m \"test\" `，必备步骤，该步骤是相当于建立提交，放入到master中。\n- 查看下本地库的状态：git status，一般提示，没有可提交的内容，则代表上面步骤成功了。\n- 一切正常的话，将远程库与本地库建立关系：`git remote add origin git@ubuntu_server:/home/git/myRep.git`。这边的test为远程库的名称，默认一般为origin，但如果你一个项目中同时有多个库，则建议你将origin修改为其他名称。\n- `git remote –v`，可查看版本库的网址，以及相关的库名称\n- 推送远程分支很简单:git push origin local_branch_name:remote_branch_name,一般可以省略local分支名，则会自动推送当前分支。\n\n\n\n#### tag和branch的区别：\n\n我们可以认为tag是一个静态标签，tag一定设定后，它的位置就永远不会再改变了，tag就是哪个commit对应的一系列数字英文字符的别名。如正常情况下我们需要checkout某个提交的时候需要git log查看版本名称，然后可以使用类似git checkout a228来切换到这个版本上去。但给这个版本起了名字edition1，则这时，我们可以通过git checkout edition1直接切换这个版本，而无需再查看log。\n\n**但一般我们不随便给任何提交打上tag，大多数情况只给某一次或几次特殊重要的提交打tag，比如发行版v1.0，测试版beta1.2等等。**\n\n而branch则是分支，最为常见的就是master分支，注意分支实际是一个指针，分支的指向永远指向这条分支结构的最末尾端（及最后的一次提交），所以分支是会不断变动的，而tag是静态的，两者区别很明显。\n\n\n\n#### MDK工程管理出错：\n\n本人在工作中会使用到MDK来做一些MCU的编程开发，而MDK虽然配置简单，调试功能强大，但编辑扩展等其他功能都奇差无比。在使用git进行管理的过程中发现，MDK会对多个工程类文件进行不断修改，而这些文件，如果不进行提交的话，又会出现工程缺失文件，工程错误等现象，另外经常出现无法回退或者无法提交等现象。\n\n经过查看和分析，最终发现：MDK只要打开的情况下，就会不断的对工程文件进行修改，即便你仅仅是查看没有做任何事情，因此下面推荐几种方法和技巧：\n- gitignore中只排除MDK的编译文件。\n- 每次要提交和回退的时候将MDK关闭再执行。\n- 如果忘记关闭或者出现突然没法回退或者提交的情况下，git查看状态，如果仅仅是工程文件出现改动，而源文件和头文件不变的话，则直接丢弃这些修改或者将修改存入stash中，再继续要做的操作。\n\n\n#### checkout和reset的区别：\n\n**git checkout**(*该命令的理解贯穿git的始终，如果理解不精准，往往会遇到很多莫名其妙的错误。)*：**用于控制head指针所指向的位置**，也就是说控制当前用户的工作位置。该指令尤为重要，**一般都是通过checkout找到过去的某个版本，然后在该位置创建分支结构，再进行相应修改。**(*注意是切换HEAD的位置，此时仅仅用于查看该版本，而如果你没有在该位置建立新的分支，则无法对该版本进行修改，git的所有修改都是基于分支进行的，每条枝干的前后各个版本都是存在强关联性的，所有枝干的后一个节点都是基于前一个节点建立的，如果checkout到前一个节点对它进行了破坏，则后面也必然会受影响，这种情况一般是不允许发生的，因此checkout的每次修改都是要求该节点必须要重新开枝散叶，这样新的修改会在新的枝干上面进行，不会影响原有的内容。*)checkout的好处在于不会破坏原有的分支结构，可以任意在整个的目录树上面对head进行移动，方便用户查看各个版本。（**再次注意：checkout只是用来控制head的，如果head通过checkout发生了移动，不再指向原有分支的末尾如：master，则必须建立新分支，才可以对文件进行提交修改。另外即便checkout指向原有分支的末尾，但如果是版本号的话也是没法进行修改的，必须要是指向master这个分支名才可以进行修改，类似于HEAD必须指向指针才可以，而不是指向某一个节点，这一点有指针操作经验的话，较容易理解。**），*checkout -- filename：回退某一个文件，注意需要加--，这一步并不是更改HEAD指向，而仅仅是回退某一个错误修改了的文件，这也是撤销修改文件最常用的命令。*\n\ngit reset \"branchname/editionnum\"：事实上这个指令很少用的，或者说谨慎使用，一旦使用了就会破坏原有的分支结构，reset是一个回退功能，会将原有的分支剪掉，虽然仍然可以通过reflog查找出版本信息，强制指向某个回退之前的版本，但这并不是该有的操作，且很可能因为误操作造成更大麻烦。建议：*只有在确定很清楚自己要进行的操作和上次提交错误的情况下使用该指令，其他时候都不使用。*版本回退使用reset后面一般加上--hard彻底回退，否则有些修改了的未建立版本的文件仍然会保留，reset是一剂后悔药，只有在万不得已的情况下才会使用，但往往reset的滥用，也会让你的分支结构混乱。\n\n综上所述，可以看出checkout是用来切换版本和分支的（分支其实是特殊的版本），而reset则是用来回退版本的。通常一般都是使用checkout来操作，只有发生重大错误，无法挽救时，才会使用reset。\n","source":"_posts/2016/2016-08-28-git问题总结FAQ.md","raw":"---\nlayout: \"post\"\ntitle: \"git问题总结FAQ\"\ndate: \"2016-08-28 12:00\"\n---\n\ngit的使用过程真心不容易，尤其对于我这样的初学者且没有其他版本控制器的使用经验，另外也比较容易丢三落四的人来说。按照网上所给的步骤操作，但万一漏做了一些步骤，或者做错了一些步骤，所引起的问题也是致命的，虽然肯定有解决问题的办法，但往往会引起分支结构混乱，经常做了一次提交然后就回不去了，或者经常不知名的无法进行提交，无法进行回退，pull失败等等。\n\n**可见要想真正让git成为你版本控制的工具，git的工作原理必定要相当清楚，版本控制的结构要特别清晰，一单出现问题立马就知道是哪一步做错了才行。**\n\n\n### 问题总结：\n\n\n\n#### git checkout -- filename:\n\n在文件没有stage时可以通过这个命令将该文件撤销回来。一旦文件add后用该命令不再有效。这时需要使用 git reset HEAD -- filename 意味着将文件unstage出库，还原到add之前，再使用git checkout -- filename撤销文件。而如果你使用git checkout HEAD -- filename 则直接会丢弃掉stage中的暂存内容，将文件还原。\n\n<!-- more -->\n\n\n#### git push -u origin master：\n\n远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。*由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。*\n\n\n\n\n#### 从github上面拉取库的方法：\n\n- 方法1：使用git clone address：如果是其他人的库address必须是一个http地址，如果是自己的库，且本地配置好了ssh，则可以通过ssh协议拉取需要的文件。**值得注意这种拉取是完整拉取，会建立一个库名的文件夹。**如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。\n- 方法2：本地已经存在git库的情况下，需要在本地库目录下使用git remote add origin address 将可以把一个已有的本地仓库与之关联。git push -u origin master把当前分支master推送到远程。我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，以后可以简化操作使用 git push origin master。\n\n*推荐使用方法1，直接从远程库clone下来，需要工程时直接clone下来避免没必要的合并，每次使用前可以先pull一下远程库。*\n\n\n\n#### github的协议：\n\nGit支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。默认的git://使用ssh，但也可以使用https等其他协议。clone他人或者自己的版本库的时候，都可以使用https或者ssh下载，但是配置好git的ssh的话，可以本地推送免密码，https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令。\n\n\n\n#### git的分支和HEAD：\n\n贯穿git的整个结构的核心就是分支，每个分支都有一个名称，如主分支一般名称为master，master本身类似一个指针名，永远指向了该分支的最后一次提交的版本。而HEAD则是指向了这个指针。因此在创建分支branch test时，master和test指向同一个位置，这时候如果执行checkout test，则HEAD会从指向master变成指向test（因此git的切换高效事实是指针的操作高效），对这个test的分支相关操作会建立起新的分支结构，而master仍然停留在原处，这时如果checkout master对master进一步的操作提交，会发现版本中真正的形成了两条分支结构。\n\n#### git合并分支：\n\ngit merge \"branchname\"：将两个分支进行合并\n\n- Fast-forward：分支合并完成后出现Fast-forward，意味着快速合并，即合并分支时分支指针仅仅是直接更改了指向，而没有出现其他增删改查的文件。*这种情况一般是需要合并的分支仅仅是建立了一个节点，而没有将分支扩展出去，因此可以直接快速向前合并两个分支指针。*\n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\n- Automatic merge failed; fix conflicts and then commit the result：这种情况虽然合并失败了，但相关文件已经进行了一些变动修改，用户手动更改好，这些文件，然后add,commit 即可完成提交以及分支合并。\n\n\n\n#### 查看分支结构：\n\n- git log --graph --pretty=oneline --abbrev-commit\n- 使用插件tig，该插件在github上面有托管，可以下载源码安装编译，注意提示需要安装一些依赖库*托管，可以下载源码安装编译，注意提示需要安装一些依赖库。*。\n- 如果使用了checkout的话，使用git log则看到内容有限，这时使用git log --all可以查看所有的提交结果。\n- 值得注意的是使用了git reset之后，使用git log 就无法看到最近的一些提交了，因为reset属于版本回退，相当于整个时光倒流回去了，不会在看到未发生的内容，只能通过git reflog查看库里面的所有备份内容。\n\n\n\n#### stash的用处：\n\nGit还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n- git stash：在git add之后可以通过stash将文件修改暂存。\n- git stash list： 查看暂存的信息。\n一些不需要的修改也可以存入stash中，相比而言stash不像commit那么严格，可以随便存入，随便删除。\n\n\n\n#### 远程库如何操作caozuo：\n\n*当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote，返回origin。可以看出远程库也是可以有多个的。*\n\n*实际的远程建立库一般为--bare裸库是不存在实际工程文件的，相当于.git文件直接被展开了，实际使用的时候，需要clone下来才能够看到文件内容。*\n\n- git remote -v：显示更详细的信息,可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。\n- push：就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上`git push origin master`，可以看到origin为远程库的名称，而master为本地需要推送的分支。在Git中，分支完全可以在本地自己，到底要不要推送则完全由你自己决定。\n- clone：从某一个位置将目录完整克隆下来，注意clone后面可以类似：`git clone git@github.com:hard/learngit.git`，也可以使用`git clone ~/home/gitname`但注意gitname必须得是个git的版本库，也就是说在里面执行过`git init`。\n- 推送冲突失败：你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，则会推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git会提示我们：*先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。*git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接:`git branch --set-upstream dev origin/dev`，然后再pull。**这边尤其需要每次输完指令后，看提示，有的未必会报错，但也没有执行相关操作，出现git command的时候，往往是你指令执行已经异常了。**\n\n\n\n#### 同步已有本地库到远程：\n\n*大多数时候，本地存在已有的库，而远程并没有，这个时候不能通过git clone来复制，需要通过以下的一些步骤*\n\n- 删除本地的.git残留文件，如果本地已经有了git操作，但不明具体内容，则首先执行`rm -rf .git`清除掉无关内容，git的设置相当科学，几乎所有的记录信息全在.git目录下。\n- 初始化这个库，`git init`这是必备步骤，建立一个空的默认库。\n- 随意添加几个文件，例如：`echo \"hello world\" >> test.txt`，如果是实验的话可以操作本步骤，如果已有功能则跳过此步骤。\n- 常规git操作，加入stage并提交，`git add .  &&  git commit -m \"test\" `，必备步骤，该步骤是相当于建立提交，放入到master中。\n- 查看下本地库的状态：git status，一般提示，没有可提交的内容，则代表上面步骤成功了。\n- 一切正常的话，将远程库与本地库建立关系：`git remote add origin git@ubuntu_server:/home/git/myRep.git`。这边的test为远程库的名称，默认一般为origin，但如果你一个项目中同时有多个库，则建议你将origin修改为其他名称。\n- `git remote –v`，可查看版本库的网址，以及相关的库名称\n- 推送远程分支很简单:git push origin local_branch_name:remote_branch_name,一般可以省略local分支名，则会自动推送当前分支。\n\n\n\n#### tag和branch的区别：\n\n我们可以认为tag是一个静态标签，tag一定设定后，它的位置就永远不会再改变了，tag就是哪个commit对应的一系列数字英文字符的别名。如正常情况下我们需要checkout某个提交的时候需要git log查看版本名称，然后可以使用类似git checkout a228来切换到这个版本上去。但给这个版本起了名字edition1，则这时，我们可以通过git checkout edition1直接切换这个版本，而无需再查看log。\n\n**但一般我们不随便给任何提交打上tag，大多数情况只给某一次或几次特殊重要的提交打tag，比如发行版v1.0，测试版beta1.2等等。**\n\n而branch则是分支，最为常见的就是master分支，注意分支实际是一个指针，分支的指向永远指向这条分支结构的最末尾端（及最后的一次提交），所以分支是会不断变动的，而tag是静态的，两者区别很明显。\n\n\n\n#### MDK工程管理出错：\n\n本人在工作中会使用到MDK来做一些MCU的编程开发，而MDK虽然配置简单，调试功能强大，但编辑扩展等其他功能都奇差无比。在使用git进行管理的过程中发现，MDK会对多个工程类文件进行不断修改，而这些文件，如果不进行提交的话，又会出现工程缺失文件，工程错误等现象，另外经常出现无法回退或者无法提交等现象。\n\n经过查看和分析，最终发现：MDK只要打开的情况下，就会不断的对工程文件进行修改，即便你仅仅是查看没有做任何事情，因此下面推荐几种方法和技巧：\n- gitignore中只排除MDK的编译文件。\n- 每次要提交和回退的时候将MDK关闭再执行。\n- 如果忘记关闭或者出现突然没法回退或者提交的情况下，git查看状态，如果仅仅是工程文件出现改动，而源文件和头文件不变的话，则直接丢弃这些修改或者将修改存入stash中，再继续要做的操作。\n\n\n#### checkout和reset的区别：\n\n**git checkout**(*该命令的理解贯穿git的始终，如果理解不精准，往往会遇到很多莫名其妙的错误。)*：**用于控制head指针所指向的位置**，也就是说控制当前用户的工作位置。该指令尤为重要，**一般都是通过checkout找到过去的某个版本，然后在该位置创建分支结构，再进行相应修改。**(*注意是切换HEAD的位置，此时仅仅用于查看该版本，而如果你没有在该位置建立新的分支，则无法对该版本进行修改，git的所有修改都是基于分支进行的，每条枝干的前后各个版本都是存在强关联性的，所有枝干的后一个节点都是基于前一个节点建立的，如果checkout到前一个节点对它进行了破坏，则后面也必然会受影响，这种情况一般是不允许发生的，因此checkout的每次修改都是要求该节点必须要重新开枝散叶，这样新的修改会在新的枝干上面进行，不会影响原有的内容。*)checkout的好处在于不会破坏原有的分支结构，可以任意在整个的目录树上面对head进行移动，方便用户查看各个版本。（**再次注意：checkout只是用来控制head的，如果head通过checkout发生了移动，不再指向原有分支的末尾如：master，则必须建立新分支，才可以对文件进行提交修改。另外即便checkout指向原有分支的末尾，但如果是版本号的话也是没法进行修改的，必须要是指向master这个分支名才可以进行修改，类似于HEAD必须指向指针才可以，而不是指向某一个节点，这一点有指针操作经验的话，较容易理解。**），*checkout -- filename：回退某一个文件，注意需要加--，这一步并不是更改HEAD指向，而仅仅是回退某一个错误修改了的文件，这也是撤销修改文件最常用的命令。*\n\ngit reset \"branchname/editionnum\"：事实上这个指令很少用的，或者说谨慎使用，一旦使用了就会破坏原有的分支结构，reset是一个回退功能，会将原有的分支剪掉，虽然仍然可以通过reflog查找出版本信息，强制指向某个回退之前的版本，但这并不是该有的操作，且很可能因为误操作造成更大麻烦。建议：*只有在确定很清楚自己要进行的操作和上次提交错误的情况下使用该指令，其他时候都不使用。*版本回退使用reset后面一般加上--hard彻底回退，否则有些修改了的未建立版本的文件仍然会保留，reset是一剂后悔药，只有在万不得已的情况下才会使用，但往往reset的滥用，也会让你的分支结构混乱。\n\n综上所述，可以看出checkout是用来切换版本和分支的（分支其实是特殊的版本），而reset则是用来回退版本的。通常一般都是使用checkout来操作，只有发生重大错误，无法挽救时，才会使用reset。\n","slug":"2016/2016-08-28-git问题总结FAQ","published":1,"updated":"2016-12-16T01:47:01.297Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahv002fmumu3svfaxdx","content":"<p>git的使用过程真心不容易，尤其对于我这样的初学者且没有其他版本控制器的使用经验，另外也比较容易丢三落四的人来说。按照网上所给的步骤操作，但万一漏做了一些步骤，或者做错了一些步骤，所引起的问题也是致命的，虽然肯定有解决问题的办法，但往往会引起分支结构混乱，经常做了一次提交然后就回不去了，或者经常不知名的无法进行提交，无法进行回退，pull失败等等。</p>\n<p><strong>可见要想真正让git成为你版本控制的工具，git的工作原理必定要相当清楚，版本控制的结构要特别清晰，一单出现问题立马就知道是哪一步做错了才行。</strong></p>\n<h3 id=\"问题总结：\"><a href=\"#问题总结：\" class=\"headerlink\" title=\"问题总结：\"></a>问题总结：</h3><h4 id=\"git-checkout-–-filename\"><a href=\"#git-checkout-–-filename\" class=\"headerlink\" title=\"git checkout – filename:\"></a>git checkout – filename:</h4><p>在文件没有stage时可以通过这个命令将该文件撤销回来。一旦文件add后用该命令不再有效。这时需要使用 git reset HEAD – filename 意味着将文件unstage出库，还原到add之前，再使用git checkout – filename撤销文件。而如果你使用git checkout HEAD – filename 则直接会丢弃掉stage中的暂存内容，将文件还原。</p>\n<a id=\"more\"></a>\n<h4 id=\"git-push-u-origin-master：\"><a href=\"#git-push-u-origin-master：\" class=\"headerlink\" title=\"git push -u origin master：\"></a>git push -u origin master：</h4><p>远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。<em>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</em></p>\n<h4 id=\"从github上面拉取库的方法：\"><a href=\"#从github上面拉取库的方法：\" class=\"headerlink\" title=\"从github上面拉取库的方法：\"></a>从github上面拉取库的方法：</h4><ul>\n<li>方法1：使用git clone address：如果是其他人的库address必须是一个http地址，如果是自己的库，且本地配置好了ssh，则可以通过ssh协议拉取需要的文件。<strong>值得注意这种拉取是完整拉取，会建立一个库名的文件夹。</strong>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</li>\n<li>方法2：本地已经存在git库的情况下，需要在本地库目录下使用git remote add origin address 将可以把一个已有的本地仓库与之关联。git push -u origin master把当前分支master推送到远程。我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，以后可以简化操作使用 git push origin master。</li>\n</ul>\n<p><em>推荐使用方法1，直接从远程库clone下来，需要工程时直接clone下来避免没必要的合并，每次使用前可以先pull一下远程库。</em></p>\n<h4 id=\"github的协议：\"><a href=\"#github的协议：\" class=\"headerlink\" title=\"github的协议：\"></a>github的协议：</h4><p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。默认的git://使用ssh，但也可以使用https等其他协议。clone他人或者自己的版本库的时候，都可以使用https或者ssh下载，但是配置好git的ssh的话，可以本地推送免密码，https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令。</p>\n<h4 id=\"git的分支和HEAD：\"><a href=\"#git的分支和HEAD：\" class=\"headerlink\" title=\"git的分支和HEAD：\"></a>git的分支和HEAD：</h4><p>贯穿git的整个结构的核心就是分支，每个分支都有一个名称，如主分支一般名称为master，master本身类似一个指针名，永远指向了该分支的最后一次提交的版本。而HEAD则是指向了这个指针。因此在创建分支branch test时，master和test指向同一个位置，这时候如果执行checkout test，则HEAD会从指向master变成指向test（因此git的切换高效事实是指针的操作高效），对这个test的分支相关操作会建立起新的分支结构，而master仍然停留在原处，这时如果checkout master对master进一步的操作提交，会发现版本中真正的形成了两条分支结构。</p>\n<h4 id=\"git合并分支：\"><a href=\"#git合并分支：\" class=\"headerlink\" title=\"git合并分支：\"></a>git合并分支：</h4><p>git merge “branchname”：将两个分支进行合并</p>\n<ul>\n<li>Fast-forward：分支合并完成后出现Fast-forward，意味着快速合并，即合并分支时分支指针仅仅是直接更改了指向，而没有出现其他增删改查的文件。<em>这种情况一般是需要合并的分支仅仅是建立了一个节点，而没有将分支扩展出去，因此可以直接快速向前合并两个分支指针。</em><br>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</li>\n<li>Automatic merge failed; fix conflicts and then commit the result：这种情况虽然合并失败了，但相关文件已经进行了一些变动修改，用户手动更改好，这些文件，然后add,commit 即可完成提交以及分支合并。</li>\n</ul>\n<h4 id=\"查看分支结构：\"><a href=\"#查看分支结构：\" class=\"headerlink\" title=\"查看分支结构：\"></a>查看分支结构：</h4><ul>\n<li>git log –graph –pretty=oneline –abbrev-commit</li>\n<li>使用插件tig，该插件在github上面有托管，可以下载源码安装编译，注意提示需要安装一些依赖库<em>托管，可以下载源码安装编译，注意提示需要安装一些依赖库。</em>。</li>\n<li>如果使用了checkout的话，使用git log则看到内容有限，这时使用git log –all可以查看所有的提交结果。</li>\n<li>值得注意的是使用了git reset之后，使用git log 就无法看到最近的一些提交了，因为reset属于版本回退，相当于整个时光倒流回去了，不会在看到未发生的内容，只能通过git reflog查看库里面的所有备份内容。</li>\n</ul>\n<h4 id=\"stash的用处：\"><a href=\"#stash的用处：\" class=\"headerlink\" title=\"stash的用处：\"></a>stash的用处：</h4><p>Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>\n<ul>\n<li>git stash：在git add之后可以通过stash将文件修改暂存。</li>\n<li>git stash list： 查看暂存的信息。<br>一些不需要的修改也可以存入stash中，相比而言stash不像commit那么严格，可以随便存入，随便删除。</li>\n</ul>\n<h4 id=\"远程库如何操作caozuo：\"><a href=\"#远程库如何操作caozuo：\" class=\"headerlink\" title=\"远程库如何操作caozuo：\"></a>远程库如何操作caozuo：</h4><p><em>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote，返回origin。可以看出远程库也是可以有多个的。</em></p>\n<p><em>实际的远程建立库一般为–bare裸库是不存在实际工程文件的，相当于.git文件直接被展开了，实际使用的时候，需要clone下来才能够看到文件内容。</em></p>\n<ul>\n<li>git remote -v：显示更详细的信息,可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</li>\n<li>push：就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上<code>git push origin master</code>，可以看到origin为远程库的名称，而master为本地需要推送的分支。在Git中，分支完全可以在本地自己，到底要不要推送则完全由你自己决定。</li>\n<li>clone：从某一个位置将目录完整克隆下来，注意clone后面可以类似：<code>git clone git@github.com:hard/learngit.git</code>，也可以使用<code>git clone ~/home/gitname</code>但注意gitname必须得是个git的版本库，也就是说在里面执行过<code>git init</code>。</li>\n<li>推送冲突失败：你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，则会推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git会提示我们：<em>先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。</em>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接:<code>git branch --set-upstream dev origin/dev</code>，然后再pull。<strong>这边尤其需要每次输完指令后，看提示，有的未必会报错，但也没有执行相关操作，出现git command的时候，往往是你指令执行已经异常了。</strong></li>\n</ul>\n<h4 id=\"同步已有本地库到远程：\"><a href=\"#同步已有本地库到远程：\" class=\"headerlink\" title=\"同步已有本地库到远程：\"></a>同步已有本地库到远程：</h4><p><em>大多数时候，本地存在已有的库，而远程并没有，这个时候不能通过git clone来复制，需要通过以下的一些步骤</em></p>\n<ul>\n<li>删除本地的.git残留文件，如果本地已经有了git操作，但不明具体内容，则首先执行<code>rm -rf .git</code>清除掉无关内容，git的设置相当科学，几乎所有的记录信息全在.git目录下。</li>\n<li>初始化这个库，<code>git init</code>这是必备步骤，建立一个空的默认库。</li>\n<li>随意添加几个文件，例如：<code>echo &quot;hello world&quot; &gt;&gt; test.txt</code>，如果是实验的话可以操作本步骤，如果已有功能则跳过此步骤。</li>\n<li>常规git操作，加入stage并提交，<code>git add .  &amp;&amp;  git commit -m &quot;test&quot;</code>，必备步骤，该步骤是相当于建立提交，放入到master中。</li>\n<li>查看下本地库的状态：git status，一般提示，没有可提交的内容，则代表上面步骤成功了。</li>\n<li>一切正常的话，将远程库与本地库建立关系：<code>git remote add origin git@ubuntu_server:/home/git/myRep.git</code>。这边的test为远程库的名称，默认一般为origin，但如果你一个项目中同时有多个库，则建议你将origin修改为其他名称。</li>\n<li><code>git remote –v</code>，可查看版本库的网址，以及相关的库名称</li>\n<li>推送远程分支很简单:git push origin local_branch_name:remote_branch_name,一般可以省略local分支名，则会自动推送当前分支。</li>\n</ul>\n<h4 id=\"tag和branch的区别：\"><a href=\"#tag和branch的区别：\" class=\"headerlink\" title=\"tag和branch的区别：\"></a>tag和branch的区别：</h4><p>我们可以认为tag是一个静态标签，tag一定设定后，它的位置就永远不会再改变了，tag就是哪个commit对应的一系列数字英文字符的别名。如正常情况下我们需要checkout某个提交的时候需要git log查看版本名称，然后可以使用类似git checkout a228来切换到这个版本上去。但给这个版本起了名字edition1，则这时，我们可以通过git checkout edition1直接切换这个版本，而无需再查看log。</p>\n<p><strong>但一般我们不随便给任何提交打上tag，大多数情况只给某一次或几次特殊重要的提交打tag，比如发行版v1.0，测试版beta1.2等等。</strong></p>\n<p>而branch则是分支，最为常见的就是master分支，注意分支实际是一个指针，分支的指向永远指向这条分支结构的最末尾端（及最后的一次提交），所以分支是会不断变动的，而tag是静态的，两者区别很明显。</p>\n<h4 id=\"MDK工程管理出错：\"><a href=\"#MDK工程管理出错：\" class=\"headerlink\" title=\"MDK工程管理出错：\"></a>MDK工程管理出错：</h4><p>本人在工作中会使用到MDK来做一些MCU的编程开发，而MDK虽然配置简单，调试功能强大，但编辑扩展等其他功能都奇差无比。在使用git进行管理的过程中发现，MDK会对多个工程类文件进行不断修改，而这些文件，如果不进行提交的话，又会出现工程缺失文件，工程错误等现象，另外经常出现无法回退或者无法提交等现象。</p>\n<p>经过查看和分析，最终发现：MDK只要打开的情况下，就会不断的对工程文件进行修改，即便你仅仅是查看没有做任何事情，因此下面推荐几种方法和技巧：</p>\n<ul>\n<li>gitignore中只排除MDK的编译文件。</li>\n<li>每次要提交和回退的时候将MDK关闭再执行。</li>\n<li>如果忘记关闭或者出现突然没法回退或者提交的情况下，git查看状态，如果仅仅是工程文件出现改动，而源文件和头文件不变的话，则直接丢弃这些修改或者将修改存入stash中，再继续要做的操作。</li>\n</ul>\n<h4 id=\"checkout和reset的区别：\"><a href=\"#checkout和reset的区别：\" class=\"headerlink\" title=\"checkout和reset的区别：\"></a>checkout和reset的区别：</h4><p><strong>git checkout</strong>(<em>该命令的理解贯穿git的始终，如果理解不精准，往往会遇到很多莫名其妙的错误。)</em>：<strong>用于控制head指针所指向的位置</strong>，也就是说控制当前用户的工作位置。该指令尤为重要，<strong>一般都是通过checkout找到过去的某个版本，然后在该位置创建分支结构，再进行相应修改。</strong>(<em>注意是切换HEAD的位置，此时仅仅用于查看该版本，而如果你没有在该位置建立新的分支，则无法对该版本进行修改，git的所有修改都是基于分支进行的，每条枝干的前后各个版本都是存在强关联性的，所有枝干的后一个节点都是基于前一个节点建立的，如果checkout到前一个节点对它进行了破坏，则后面也必然会受影响，这种情况一般是不允许发生的，因此checkout的每次修改都是要求该节点必须要重新开枝散叶，这样新的修改会在新的枝干上面进行，不会影响原有的内容。</em>)checkout的好处在于不会破坏原有的分支结构，可以任意在整个的目录树上面对head进行移动，方便用户查看各个版本。（<strong>再次注意：checkout只是用来控制head的，如果head通过checkout发生了移动，不再指向原有分支的末尾如：master，则必须建立新分支，才可以对文件进行提交修改。另外即便checkout指向原有分支的末尾，但如果是版本号的话也是没法进行修改的，必须要是指向master这个分支名才可以进行修改，类似于HEAD必须指向指针才可以，而不是指向某一个节点，这一点有指针操作经验的话，较容易理解。</strong>），<em>checkout – filename：回退某一个文件，注意需要加–，这一步并不是更改HEAD指向，而仅仅是回退某一个错误修改了的文件，这也是撤销修改文件最常用的命令。</em></p>\n<p>git reset “branchname/editionnum”：事实上这个指令很少用的，或者说谨慎使用，一旦使用了就会破坏原有的分支结构，reset是一个回退功能，会将原有的分支剪掉，虽然仍然可以通过reflog查找出版本信息，强制指向某个回退之前的版本，但这并不是该有的操作，且很可能因为误操作造成更大麻烦。建议：<em>只有在确定很清楚自己要进行的操作和上次提交错误的情况下使用该指令，其他时候都不使用。</em>版本回退使用reset后面一般加上–hard彻底回退，否则有些修改了的未建立版本的文件仍然会保留，reset是一剂后悔药，只有在万不得已的情况下才会使用，但往往reset的滥用，也会让你的分支结构混乱。</p>\n<p>综上所述，可以看出checkout是用来切换版本和分支的（分支其实是特殊的版本），而reset则是用来回退版本的。通常一般都是使用checkout来操作，只有发生重大错误，无法挽救时，才会使用reset。</p>\n","excerpt":"<p>git的使用过程真心不容易，尤其对于我这样的初学者且没有其他版本控制器的使用经验，另外也比较容易丢三落四的人来说。按照网上所给的步骤操作，但万一漏做了一些步骤，或者做错了一些步骤，所引起的问题也是致命的，虽然肯定有解决问题的办法，但往往会引起分支结构混乱，经常做了一次提交然后就回不去了，或者经常不知名的无法进行提交，无法进行回退，pull失败等等。</p>\n<p><strong>可见要想真正让git成为你版本控制的工具，git的工作原理必定要相当清楚，版本控制的结构要特别清晰，一单出现问题立马就知道是哪一步做错了才行。</strong></p>\n<h3 id=\"问题总结：\"><a href=\"#问题总结：\" class=\"headerlink\" title=\"问题总结：\"></a>问题总结：</h3><h4 id=\"git-checkout-–-filename\"><a href=\"#git-checkout-–-filename\" class=\"headerlink\" title=\"git checkout – filename:\"></a>git checkout – filename:</h4><p>在文件没有stage时可以通过这个命令将该文件撤销回来。一旦文件add后用该命令不再有效。这时需要使用 git reset HEAD – filename 意味着将文件unstage出库，还原到add之前，再使用git checkout – filename撤销文件。而如果你使用git checkout HEAD – filename 则直接会丢弃掉stage中的暂存内容，将文件还原。</p>","more":"<h4 id=\"git-push-u-origin-master：\"><a href=\"#git-push-u-origin-master：\" class=\"headerlink\" title=\"git push -u origin master：\"></a>git push -u origin master：</h4><p>远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。<em>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</em></p>\n<h4 id=\"从github上面拉取库的方法：\"><a href=\"#从github上面拉取库的方法：\" class=\"headerlink\" title=\"从github上面拉取库的方法：\"></a>从github上面拉取库的方法：</h4><ul>\n<li>方法1：使用git clone address：如果是其他人的库address必须是一个http地址，如果是自己的库，且本地配置好了ssh，则可以通过ssh协议拉取需要的文件。<strong>值得注意这种拉取是完整拉取，会建立一个库名的文件夹。</strong>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</li>\n<li>方法2：本地已经存在git库的情况下，需要在本地库目录下使用git remote add origin address 将可以把一个已有的本地仓库与之关联。git push -u origin master把当前分支master推送到远程。我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，以后可以简化操作使用 git push origin master。</li>\n</ul>\n<p><em>推荐使用方法1，直接从远程库clone下来，需要工程时直接clone下来避免没必要的合并，每次使用前可以先pull一下远程库。</em></p>\n<h4 id=\"github的协议：\"><a href=\"#github的协议：\" class=\"headerlink\" title=\"github的协议：\"></a>github的协议：</h4><p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。默认的git://使用ssh，但也可以使用https等其他协议。clone他人或者自己的版本库的时候，都可以使用https或者ssh下载，但是配置好git的ssh的话，可以本地推送免密码，https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令。</p>\n<h4 id=\"git的分支和HEAD：\"><a href=\"#git的分支和HEAD：\" class=\"headerlink\" title=\"git的分支和HEAD：\"></a>git的分支和HEAD：</h4><p>贯穿git的整个结构的核心就是分支，每个分支都有一个名称，如主分支一般名称为master，master本身类似一个指针名，永远指向了该分支的最后一次提交的版本。而HEAD则是指向了这个指针。因此在创建分支branch test时，master和test指向同一个位置，这时候如果执行checkout test，则HEAD会从指向master变成指向test（因此git的切换高效事实是指针的操作高效），对这个test的分支相关操作会建立起新的分支结构，而master仍然停留在原处，这时如果checkout master对master进一步的操作提交，会发现版本中真正的形成了两条分支结构。</p>\n<h4 id=\"git合并分支：\"><a href=\"#git合并分支：\" class=\"headerlink\" title=\"git合并分支：\"></a>git合并分支：</h4><p>git merge “branchname”：将两个分支进行合并</p>\n<ul>\n<li>Fast-forward：分支合并完成后出现Fast-forward，意味着快速合并，即合并分支时分支指针仅仅是直接更改了指向，而没有出现其他增删改查的文件。<em>这种情况一般是需要合并的分支仅仅是建立了一个节点，而没有将分支扩展出去，因此可以直接快速向前合并两个分支指针。</em><br>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</li>\n<li>Automatic merge failed; fix conflicts and then commit the result：这种情况虽然合并失败了，但相关文件已经进行了一些变动修改，用户手动更改好，这些文件，然后add,commit 即可完成提交以及分支合并。</li>\n</ul>\n<h4 id=\"查看分支结构：\"><a href=\"#查看分支结构：\" class=\"headerlink\" title=\"查看分支结构：\"></a>查看分支结构：</h4><ul>\n<li>git log –graph –pretty=oneline –abbrev-commit</li>\n<li>使用插件tig，该插件在github上面有托管，可以下载源码安装编译，注意提示需要安装一些依赖库<em>托管，可以下载源码安装编译，注意提示需要安装一些依赖库。</em>。</li>\n<li>如果使用了checkout的话，使用git log则看到内容有限，这时使用git log –all可以查看所有的提交结果。</li>\n<li>值得注意的是使用了git reset之后，使用git log 就无法看到最近的一些提交了，因为reset属于版本回退，相当于整个时光倒流回去了，不会在看到未发生的内容，只能通过git reflog查看库里面的所有备份内容。</li>\n</ul>\n<h4 id=\"stash的用处：\"><a href=\"#stash的用处：\" class=\"headerlink\" title=\"stash的用处：\"></a>stash的用处：</h4><p>Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>\n<ul>\n<li>git stash：在git add之后可以通过stash将文件修改暂存。</li>\n<li>git stash list： 查看暂存的信息。<br>一些不需要的修改也可以存入stash中，相比而言stash不像commit那么严格，可以随便存入，随便删除。</li>\n</ul>\n<h4 id=\"远程库如何操作caozuo：\"><a href=\"#远程库如何操作caozuo：\" class=\"headerlink\" title=\"远程库如何操作caozuo：\"></a>远程库如何操作caozuo：</h4><p><em>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote，返回origin。可以看出远程库也是可以有多个的。</em></p>\n<p><em>实际的远程建立库一般为–bare裸库是不存在实际工程文件的，相当于.git文件直接被展开了，实际使用的时候，需要clone下来才能够看到文件内容。</em></p>\n<ul>\n<li>git remote -v：显示更详细的信息,可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</li>\n<li>push：就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上<code>git push origin master</code>，可以看到origin为远程库的名称，而master为本地需要推送的分支。在Git中，分支完全可以在本地自己，到底要不要推送则完全由你自己决定。</li>\n<li>clone：从某一个位置将目录完整克隆下来，注意clone后面可以类似：<code>git clone git@github.com:hard/learngit.git</code>，也可以使用<code>git clone ~/home/gitname</code>但注意gitname必须得是个git的版本库，也就是说在里面执行过<code>git init</code>。</li>\n<li>推送冲突失败：你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，则会推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git会提示我们：<em>先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。</em>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接:<code>git branch --set-upstream dev origin/dev</code>，然后再pull。<strong>这边尤其需要每次输完指令后，看提示，有的未必会报错，但也没有执行相关操作，出现git command的时候，往往是你指令执行已经异常了。</strong></li>\n</ul>\n<h4 id=\"同步已有本地库到远程：\"><a href=\"#同步已有本地库到远程：\" class=\"headerlink\" title=\"同步已有本地库到远程：\"></a>同步已有本地库到远程：</h4><p><em>大多数时候，本地存在已有的库，而远程并没有，这个时候不能通过git clone来复制，需要通过以下的一些步骤</em></p>\n<ul>\n<li>删除本地的.git残留文件，如果本地已经有了git操作，但不明具体内容，则首先执行<code>rm -rf .git</code>清除掉无关内容，git的设置相当科学，几乎所有的记录信息全在.git目录下。</li>\n<li>初始化这个库，<code>git init</code>这是必备步骤，建立一个空的默认库。</li>\n<li>随意添加几个文件，例如：<code>echo &quot;hello world&quot; &gt;&gt; test.txt</code>，如果是实验的话可以操作本步骤，如果已有功能则跳过此步骤。</li>\n<li>常规git操作，加入stage并提交，<code>git add .  &amp;&amp;  git commit -m &quot;test&quot;</code>，必备步骤，该步骤是相当于建立提交，放入到master中。</li>\n<li>查看下本地库的状态：git status，一般提示，没有可提交的内容，则代表上面步骤成功了。</li>\n<li>一切正常的话，将远程库与本地库建立关系：<code>git remote add origin git@ubuntu_server:/home/git/myRep.git</code>。这边的test为远程库的名称，默认一般为origin，但如果你一个项目中同时有多个库，则建议你将origin修改为其他名称。</li>\n<li><code>git remote –v</code>，可查看版本库的网址，以及相关的库名称</li>\n<li>推送远程分支很简单:git push origin local_branch_name:remote_branch_name,一般可以省略local分支名，则会自动推送当前分支。</li>\n</ul>\n<h4 id=\"tag和branch的区别：\"><a href=\"#tag和branch的区别：\" class=\"headerlink\" title=\"tag和branch的区别：\"></a>tag和branch的区别：</h4><p>我们可以认为tag是一个静态标签，tag一定设定后，它的位置就永远不会再改变了，tag就是哪个commit对应的一系列数字英文字符的别名。如正常情况下我们需要checkout某个提交的时候需要git log查看版本名称，然后可以使用类似git checkout a228来切换到这个版本上去。但给这个版本起了名字edition1，则这时，我们可以通过git checkout edition1直接切换这个版本，而无需再查看log。</p>\n<p><strong>但一般我们不随便给任何提交打上tag，大多数情况只给某一次或几次特殊重要的提交打tag，比如发行版v1.0，测试版beta1.2等等。</strong></p>\n<p>而branch则是分支，最为常见的就是master分支，注意分支实际是一个指针，分支的指向永远指向这条分支结构的最末尾端（及最后的一次提交），所以分支是会不断变动的，而tag是静态的，两者区别很明显。</p>\n<h4 id=\"MDK工程管理出错：\"><a href=\"#MDK工程管理出错：\" class=\"headerlink\" title=\"MDK工程管理出错：\"></a>MDK工程管理出错：</h4><p>本人在工作中会使用到MDK来做一些MCU的编程开发，而MDK虽然配置简单，调试功能强大，但编辑扩展等其他功能都奇差无比。在使用git进行管理的过程中发现，MDK会对多个工程类文件进行不断修改，而这些文件，如果不进行提交的话，又会出现工程缺失文件，工程错误等现象，另外经常出现无法回退或者无法提交等现象。</p>\n<p>经过查看和分析，最终发现：MDK只要打开的情况下，就会不断的对工程文件进行修改，即便你仅仅是查看没有做任何事情，因此下面推荐几种方法和技巧：</p>\n<ul>\n<li>gitignore中只排除MDK的编译文件。</li>\n<li>每次要提交和回退的时候将MDK关闭再执行。</li>\n<li>如果忘记关闭或者出现突然没法回退或者提交的情况下，git查看状态，如果仅仅是工程文件出现改动，而源文件和头文件不变的话，则直接丢弃这些修改或者将修改存入stash中，再继续要做的操作。</li>\n</ul>\n<h4 id=\"checkout和reset的区别：\"><a href=\"#checkout和reset的区别：\" class=\"headerlink\" title=\"checkout和reset的区别：\"></a>checkout和reset的区别：</h4><p><strong>git checkout</strong>(<em>该命令的理解贯穿git的始终，如果理解不精准，往往会遇到很多莫名其妙的错误。)</em>：<strong>用于控制head指针所指向的位置</strong>，也就是说控制当前用户的工作位置。该指令尤为重要，<strong>一般都是通过checkout找到过去的某个版本，然后在该位置创建分支结构，再进行相应修改。</strong>(<em>注意是切换HEAD的位置，此时仅仅用于查看该版本，而如果你没有在该位置建立新的分支，则无法对该版本进行修改，git的所有修改都是基于分支进行的，每条枝干的前后各个版本都是存在强关联性的，所有枝干的后一个节点都是基于前一个节点建立的，如果checkout到前一个节点对它进行了破坏，则后面也必然会受影响，这种情况一般是不允许发生的，因此checkout的每次修改都是要求该节点必须要重新开枝散叶，这样新的修改会在新的枝干上面进行，不会影响原有的内容。</em>)checkout的好处在于不会破坏原有的分支结构，可以任意在整个的目录树上面对head进行移动，方便用户查看各个版本。（<strong>再次注意：checkout只是用来控制head的，如果head通过checkout发生了移动，不再指向原有分支的末尾如：master，则必须建立新分支，才可以对文件进行提交修改。另外即便checkout指向原有分支的末尾，但如果是版本号的话也是没法进行修改的，必须要是指向master这个分支名才可以进行修改，类似于HEAD必须指向指针才可以，而不是指向某一个节点，这一点有指针操作经验的话，较容易理解。</strong>），<em>checkout – filename：回退某一个文件，注意需要加–，这一步并不是更改HEAD指向，而仅仅是回退某一个错误修改了的文件，这也是撤销修改文件最常用的命令。</em></p>\n<p>git reset “branchname/editionnum”：事实上这个指令很少用的，或者说谨慎使用，一旦使用了就会破坏原有的分支结构，reset是一个回退功能，会将原有的分支剪掉，虽然仍然可以通过reflog查找出版本信息，强制指向某个回退之前的版本，但这并不是该有的操作，且很可能因为误操作造成更大麻烦。建议：<em>只有在确定很清楚自己要进行的操作和上次提交错误的情况下使用该指令，其他时候都不使用。</em>版本回退使用reset后面一般加上–hard彻底回退，否则有些修改了的未建立版本的文件仍然会保留，reset是一剂后悔药，只有在万不得已的情况下才会使用，但往往reset的滥用，也会让你的分支结构混乱。</p>\n<p>综上所述，可以看出checkout是用来切换版本和分支的（分支其实是特殊的版本），而reset则是用来回退版本的。通常一般都是使用checkout来操作，只有发生重大错误，无法挽救时，才会使用reset。</p>"},{"layout":"post","title":"解决重启网卡后ip route add丢失","date":"2016-09-12T02:47:00.000Z","_content":"\n<!-- more -->\n","source":"_posts/2016/2016-09-12-解决重启网卡后ip-route-add丢失.md","raw":"---\nlayout: \"post\"\ntitle: \"解决重启网卡后ip route add丢失\"\ndate: \"2016-09-12 10:47\"\n---\n\n<!-- more -->\n","slug":"2016/2016-09-12-解决重启网卡后ip-route-add丢失","published":1,"updated":"2016-12-16T01:47:53.430Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahw002gmumumw36ps1e","content":"<a id=\"more\"></a>\n","excerpt":"","more":""},{"layout":"post","title":"网络监控工具wireshark","date":"2016-09-12T02:17:00.000Z","_content":"\n### wireshark简介\n\nWireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。网络封包分析软件的功能可想像成 \"电工技师使用电表来量测电流、电压、电阻\" 的工作 - 只是将场景移植到网络上，并将电线替换成网络线。在过去，网络封包分析软件是非常昂贵的，或是专门属于营利用的软件。Ethereal的出现改变了这一切。在GNUGPL通用许可证的保障范围底下，使用者可以以免费的代价取得软件与其源代码，并拥有针对其源代码修改及客制化的权利。Ethereal是目前全世界最广泛的网络封包分析软件之一。\n\n<!-- more -->\n\n\n### 软件安装\n\n#### linux下的安装\n\n首先，安装只要一个命令行(由于之前装过了，所以没有在安装什么了)：sudo apt-get install wireshark 。已经将wireshark安装完毕，接下来我没就可以通过：终端输入wireshark 用来启动它的图形界面。\n然而，dumpcap需要root权限才能使用的,以普通用户打开Wireshark，Wireshark当然没有权限使用dumpcap进行截取封包。虽然可以用:sudo wireshark来完成。但是，以sudo的方式用root打开Wireshark显然是不安全的，也不是很方便，因为得到的封包数据也属于root用户。于是，我们提供下面的方法来完成普通用户下的操作。\n\n- 添加wireshark用户组`sudo groupadd  wireshark`，一般软件安装完成后，可能已经自动帮你生成了这个组。\n- 将dumpcap程序更改为所属组为wireshark用户组`sudo chgrp wireshark /usr/bin/dumpcap`\n- 让wireshark用户组有root权限使用dumpcap即更改dumpcap的科执行权限，赋予所属组执行权限 `sudo chmod 4755 /usr/bin/dumpcap`\n- 将需要使用的普通用户名加入wireshark用户组，我的用户是“demon”（需要根据具体用户名修改！在#前面可以找到哟），则需要使用命令：` sudo gpasswd -a demon wireshark `\n\n通过以上步骤就可以以普通用户登陆打开Wireshark，也会有权限进行抓包了。\n\n### 常规用法\n\n\n\n\n> 参考链接：\n> http://fangxin.blog.51cto.com/1125131/735178\n> http://blog.sina.com.cn/s/blog_5d527ff00100dwph.html\n> https://openmaniak.com/cn/wireshark_filters.php\n> http://www.jianshu.com/p/400d4430a74a\n> https://wiki.wireshark.org/CaptureSetup/CapturePrivileges\n> https://anonscm.debian.org/viewvc/collab-maint/ext-maint/wireshark/trunk/debian/README.Debian?view=markup\n> http://jingyan.baidu.com/article/c74d60009d992f0f6a595de6.html\n","source":"_posts/2016/2016-09-12-网络监控工具wireshark.md","raw":"---\nlayout: \"post\"\ntitle: \"网络监控工具wireshark\"\ndate: \"2016-09-12 10:17\"\n---\n\n### wireshark简介\n\nWireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。网络封包分析软件的功能可想像成 \"电工技师使用电表来量测电流、电压、电阻\" 的工作 - 只是将场景移植到网络上，并将电线替换成网络线。在过去，网络封包分析软件是非常昂贵的，或是专门属于营利用的软件。Ethereal的出现改变了这一切。在GNUGPL通用许可证的保障范围底下，使用者可以以免费的代价取得软件与其源代码，并拥有针对其源代码修改及客制化的权利。Ethereal是目前全世界最广泛的网络封包分析软件之一。\n\n<!-- more -->\n\n\n### 软件安装\n\n#### linux下的安装\n\n首先，安装只要一个命令行(由于之前装过了，所以没有在安装什么了)：sudo apt-get install wireshark 。已经将wireshark安装完毕，接下来我没就可以通过：终端输入wireshark 用来启动它的图形界面。\n然而，dumpcap需要root权限才能使用的,以普通用户打开Wireshark，Wireshark当然没有权限使用dumpcap进行截取封包。虽然可以用:sudo wireshark来完成。但是，以sudo的方式用root打开Wireshark显然是不安全的，也不是很方便，因为得到的封包数据也属于root用户。于是，我们提供下面的方法来完成普通用户下的操作。\n\n- 添加wireshark用户组`sudo groupadd  wireshark`，一般软件安装完成后，可能已经自动帮你生成了这个组。\n- 将dumpcap程序更改为所属组为wireshark用户组`sudo chgrp wireshark /usr/bin/dumpcap`\n- 让wireshark用户组有root权限使用dumpcap即更改dumpcap的科执行权限，赋予所属组执行权限 `sudo chmod 4755 /usr/bin/dumpcap`\n- 将需要使用的普通用户名加入wireshark用户组，我的用户是“demon”（需要根据具体用户名修改！在#前面可以找到哟），则需要使用命令：` sudo gpasswd -a demon wireshark `\n\n通过以上步骤就可以以普通用户登陆打开Wireshark，也会有权限进行抓包了。\n\n### 常规用法\n\n\n\n\n> 参考链接：\n> http://fangxin.blog.51cto.com/1125131/735178\n> http://blog.sina.com.cn/s/blog_5d527ff00100dwph.html\n> https://openmaniak.com/cn/wireshark_filters.php\n> http://www.jianshu.com/p/400d4430a74a\n> https://wiki.wireshark.org/CaptureSetup/CapturePrivileges\n> https://anonscm.debian.org/viewvc/collab-maint/ext-maint/wireshark/trunk/debian/README.Debian?view=markup\n> http://jingyan.baidu.com/article/c74d60009d992f0f6a595de6.html\n","slug":"2016/2016-09-12-网络监控工具wireshark","published":1,"updated":"2016-12-16T01:47:49.966Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahx002hmumutevf0878","content":"<h3 id=\"wireshark简介\"><a href=\"#wireshark简介\" class=\"headerlink\" title=\"wireshark简介\"></a>wireshark简介</h3><p>Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。网络封包分析软件的功能可想像成 “电工技师使用电表来量测电流、电压、电阻” 的工作 - 只是将场景移植到网络上，并将电线替换成网络线。在过去，网络封包分析软件是非常昂贵的，或是专门属于营利用的软件。Ethereal的出现改变了这一切。在GNUGPL通用许可证的保障范围底下，使用者可以以免费的代价取得软件与其源代码，并拥有针对其源代码修改及客制化的权利。Ethereal是目前全世界最广泛的网络封包分析软件之一。</p>\n<a id=\"more\"></a>\n<h3 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h3><h4 id=\"linux下的安装\"><a href=\"#linux下的安装\" class=\"headerlink\" title=\"linux下的安装\"></a>linux下的安装</h4><p>首先，安装只要一个命令行(由于之前装过了，所以没有在安装什么了)：sudo apt-get install wireshark 。已经将wireshark安装完毕，接下来我没就可以通过：终端输入wireshark 用来启动它的图形界面。<br>然而，dumpcap需要root权限才能使用的,以普通用户打开Wireshark，Wireshark当然没有权限使用dumpcap进行截取封包。虽然可以用:sudo wireshark来完成。但是，以sudo的方式用root打开Wireshark显然是不安全的，也不是很方便，因为得到的封包数据也属于root用户。于是，我们提供下面的方法来完成普通用户下的操作。</p>\n<ul>\n<li>添加wireshark用户组<code>sudo groupadd  wireshark</code>，一般软件安装完成后，可能已经自动帮你生成了这个组。</li>\n<li>将dumpcap程序更改为所属组为wireshark用户组<code>sudo chgrp wireshark /usr/bin/dumpcap</code></li>\n<li>让wireshark用户组有root权限使用dumpcap即更改dumpcap的科执行权限，赋予所属组执行权限 <code>sudo chmod 4755 /usr/bin/dumpcap</code></li>\n<li>将需要使用的普通用户名加入wireshark用户组，我的用户是“demon”（需要根据具体用户名修改！在#前面可以找到哟），则需要使用命令：<code>sudo gpasswd -a demon wireshark</code></li>\n</ul>\n<p>通过以上步骤就可以以普通用户登陆打开Wireshark，也会有权限进行抓包了。</p>\n<h3 id=\"常规用法\"><a href=\"#常规用法\" class=\"headerlink\" title=\"常规用法\"></a>常规用法</h3><blockquote>\n<p>参考链接：<br><a href=\"http://fangxin.blog.51cto.com/1125131/735178\" target=\"_blank\" rel=\"external\">http://fangxin.blog.51cto.com/1125131/735178</a><br><a href=\"http://blog.sina.com.cn/s/blog_5d527ff00100dwph.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_5d527ff00100dwph.html</a><br><a href=\"https://openmaniak.com/cn/wireshark_filters.php\" target=\"_blank\" rel=\"external\">https://openmaniak.com/cn/wireshark_filters.php</a><br><a href=\"http://www.jianshu.com/p/400d4430a74a\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/400d4430a74a</a><br><a href=\"https://wiki.wireshark.org/CaptureSetup/CapturePrivileges\" target=\"_blank\" rel=\"external\">https://wiki.wireshark.org/CaptureSetup/CapturePrivileges</a><br><a href=\"https://anonscm.debian.org/viewvc/collab-maint/ext-maint/wireshark/trunk/debian/README.Debian?view=markup\" target=\"_blank\" rel=\"external\">https://anonscm.debian.org/viewvc/collab-maint/ext-maint/wireshark/trunk/debian/README.Debian?view=markup</a><br><a href=\"http://jingyan.baidu.com/article/c74d60009d992f0f6a595de6.html\" target=\"_blank\" rel=\"external\">http://jingyan.baidu.com/article/c74d60009d992f0f6a595de6.html</a></p>\n</blockquote>\n","excerpt":"<h3 id=\"wireshark简介\"><a href=\"#wireshark简介\" class=\"headerlink\" title=\"wireshark简介\"></a>wireshark简介</h3><p>Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。网络封包分析软件的功能可想像成 “电工技师使用电表来量测电流、电压、电阻” 的工作 - 只是将场景移植到网络上，并将电线替换成网络线。在过去，网络封包分析软件是非常昂贵的，或是专门属于营利用的软件。Ethereal的出现改变了这一切。在GNUGPL通用许可证的保障范围底下，使用者可以以免费的代价取得软件与其源代码，并拥有针对其源代码修改及客制化的权利。Ethereal是目前全世界最广泛的网络封包分析软件之一。</p>","more":"<h3 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h3><h4 id=\"linux下的安装\"><a href=\"#linux下的安装\" class=\"headerlink\" title=\"linux下的安装\"></a>linux下的安装</h4><p>首先，安装只要一个命令行(由于之前装过了，所以没有在安装什么了)：sudo apt-get install wireshark 。已经将wireshark安装完毕，接下来我没就可以通过：终端输入wireshark 用来启动它的图形界面。<br>然而，dumpcap需要root权限才能使用的,以普通用户打开Wireshark，Wireshark当然没有权限使用dumpcap进行截取封包。虽然可以用:sudo wireshark来完成。但是，以sudo的方式用root打开Wireshark显然是不安全的，也不是很方便，因为得到的封包数据也属于root用户。于是，我们提供下面的方法来完成普通用户下的操作。</p>\n<ul>\n<li>添加wireshark用户组<code>sudo groupadd  wireshark</code>，一般软件安装完成后，可能已经自动帮你生成了这个组。</li>\n<li>将dumpcap程序更改为所属组为wireshark用户组<code>sudo chgrp wireshark /usr/bin/dumpcap</code></li>\n<li>让wireshark用户组有root权限使用dumpcap即更改dumpcap的科执行权限，赋予所属组执行权限 <code>sudo chmod 4755 /usr/bin/dumpcap</code></li>\n<li>将需要使用的普通用户名加入wireshark用户组，我的用户是“demon”（需要根据具体用户名修改！在#前面可以找到哟），则需要使用命令：<code>sudo gpasswd -a demon wireshark</code></li>\n</ul>\n<p>通过以上步骤就可以以普通用户登陆打开Wireshark，也会有权限进行抓包了。</p>\n<h3 id=\"常规用法\"><a href=\"#常规用法\" class=\"headerlink\" title=\"常规用法\"></a>常规用法</h3><blockquote>\n<p>参考链接：<br><a href=\"http://fangxin.blog.51cto.com/1125131/735178\">http://fangxin.blog.51cto.com/1125131/735178</a><br><a href=\"http://blog.sina.com.cn/s/blog_5d527ff00100dwph.html\">http://blog.sina.com.cn/s/blog_5d527ff00100dwph.html</a><br><a href=\"https://openmaniak.com/cn/wireshark_filters.php\">https://openmaniak.com/cn/wireshark_filters.php</a><br><a href=\"http://www.jianshu.com/p/400d4430a74a\">http://www.jianshu.com/p/400d4430a74a</a><br><a href=\"https://wiki.wireshark.org/CaptureSetup/CapturePrivileges\">https://wiki.wireshark.org/CaptureSetup/CapturePrivileges</a><br><a href=\"https://anonscm.debian.org/viewvc/collab-maint/ext-maint/wireshark/trunk/debian/README.Debian?view=markup\">https://anonscm.debian.org/viewvc/collab-maint/ext-maint/wireshark/trunk/debian/README.Debian?view=markup</a><br><a href=\"http://jingyan.baidu.com/article/c74d60009d992f0f6a595de6.html\">http://jingyan.baidu.com/article/c74d60009d992f0f6a595de6.html</a></p>\n</blockquote>"},{"layout":"post","title":"ubuntu搭建wordpress服务","date":"2016-09-14T01:02:00.000Z","_content":"\n\n*[wordpress](https://cn.wordpress.org/) 是目前比较流行的博客模板，精美的外观强可定制性收到了国内外很多bloger的亲睐，之前在虚拟机的ubuntu_server上面搭建过这个环境，个人所使用的blog是基于jekyll的静态页面，所以对wordpress不是特别了解，这边以腾讯云的ubuntu服务器为基础搭建自己的wordpress服务，当然现在很多云服务已经支持一键搭建wordpress的功能，但据说“访问速度和灵活性会受到很大影响”，这边有兴趣的朋友可以自己去尝试一下。*\n\n### 简述\n\n- 需要搭建一个服务器，首先需要选定自己使用哪些服务套件，这边我选用LAMP套装，即linux(ubuntu), apache2.0, mysql, php(wordpress)。\n\n<!-- more -->\n\n\n### 详细安装步骤\n\n#### 1.检查电脑是否安装了这些服务。\n\n```\ndpkg -l | grep apache\ndpkg -l | grep php\ndpkg -l | grep mysql\n```\n\n#### 2.根据提示信息，如果没有安装则补安装。\n\n```\nsudo apt-get install apache2 mysql-server php5 libapache2-mod-php5\n重启apache服务 `sudo /etc/init.d/apache2 restart`\n```\n\n#### 3.让apache、php支持mysql\n\n```\nsudo apt-get install libapache2-mod-auth-mysql php5-mysql\n重启apache服务 `sudo /etc/init.d/apache2 restart`\n```\n\n#### 4.安装phpMyAdmin \n\n```\nsudo apt-get install phpmyadmin\n此时的phpmyadmin文件夹被安装在/usr/share/phpmyadmin下，为了能在浏览器中访问到phpmyadmin，需要在/var/www下做一个软连接到该文件夹。\n进入/var/www文件夹，在该目录下执行如下操作:\nsudo ln -s /usr/share/phpmyadmin\n```\n\n#### 5.[为Wordpress新建mysql数据库](https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E7.AC.AC.E4.BA.8C.E6.AD.A5.EF.BC.9A.E5.88.9B.E5.BB.BAWordPress.E6.95.B0.E6.8D.AE.E5.BA.93.E5.92.8C.E4.B8.80.E4.B8.AA.E7.94.A8.E6.88.B7)\n\n```\n$ mysql -u root -p\t// 登陆管理数据库\nEnter password:\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 5340 to server version: 3.23.54\n \nType 'help;' or '\\h' for help. Type '\\c' to clear the buffer.\n \nmysql> CREATE DATABASE blog;\t// 创建数据库名称\nQuery OK, 1 row affected (0.00 sec)\n \nmysql> GRANT ALL PRIVILEGES ON blog.* TO \"demon\"@\"hostname\" // 受理权限\n    -> IDENTIFIED BY \"password\";\nQuery OK, 0 rows affected (0.00 sec)\n  \nmysql> FLUSH PRIVILEGES;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> EXIT\nBye\n$ \n```\n\n***\n\nto be continued...\n\n\n> 参考链接：\n> https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E6.AD.A5.E9.AA.A43:.E8.AE.BE.E7.BD.AEwp-config.php\n> http://www.jianshu.com/p/7e6566b613a7\n> http://www.jianshu.com/p/26d9e752994e\n","source":"_posts/2016/2016-09-14-ubuntu搭建wordpress服务.md","raw":"---\nlayout: \"post\"\ntitle: \"ubuntu搭建wordpress服务\"\ndate: \"2016-09-14 09:02\"\n---\n\n\n*[wordpress](https://cn.wordpress.org/) 是目前比较流行的博客模板，精美的外观强可定制性收到了国内外很多bloger的亲睐，之前在虚拟机的ubuntu_server上面搭建过这个环境，个人所使用的blog是基于jekyll的静态页面，所以对wordpress不是特别了解，这边以腾讯云的ubuntu服务器为基础搭建自己的wordpress服务，当然现在很多云服务已经支持一键搭建wordpress的功能，但据说“访问速度和灵活性会受到很大影响”，这边有兴趣的朋友可以自己去尝试一下。*\n\n### 简述\n\n- 需要搭建一个服务器，首先需要选定自己使用哪些服务套件，这边我选用LAMP套装，即linux(ubuntu), apache2.0, mysql, php(wordpress)。\n\n<!-- more -->\n\n\n### 详细安装步骤\n\n#### 1.检查电脑是否安装了这些服务。\n\n```\ndpkg -l | grep apache\ndpkg -l | grep php\ndpkg -l | grep mysql\n```\n\n#### 2.根据提示信息，如果没有安装则补安装。\n\n```\nsudo apt-get install apache2 mysql-server php5 libapache2-mod-php5\n重启apache服务 `sudo /etc/init.d/apache2 restart`\n```\n\n#### 3.让apache、php支持mysql\n\n```\nsudo apt-get install libapache2-mod-auth-mysql php5-mysql\n重启apache服务 `sudo /etc/init.d/apache2 restart`\n```\n\n#### 4.安装phpMyAdmin \n\n```\nsudo apt-get install phpmyadmin\n此时的phpmyadmin文件夹被安装在/usr/share/phpmyadmin下，为了能在浏览器中访问到phpmyadmin，需要在/var/www下做一个软连接到该文件夹。\n进入/var/www文件夹，在该目录下执行如下操作:\nsudo ln -s /usr/share/phpmyadmin\n```\n\n#### 5.[为Wordpress新建mysql数据库](https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E7.AC.AC.E4.BA.8C.E6.AD.A5.EF.BC.9A.E5.88.9B.E5.BB.BAWordPress.E6.95.B0.E6.8D.AE.E5.BA.93.E5.92.8C.E4.B8.80.E4.B8.AA.E7.94.A8.E6.88.B7)\n\n```\n$ mysql -u root -p\t// 登陆管理数据库\nEnter password:\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 5340 to server version: 3.23.54\n \nType 'help;' or '\\h' for help. Type '\\c' to clear the buffer.\n \nmysql> CREATE DATABASE blog;\t// 创建数据库名称\nQuery OK, 1 row affected (0.00 sec)\n \nmysql> GRANT ALL PRIVILEGES ON blog.* TO \"demon\"@\"hostname\" // 受理权限\n    -> IDENTIFIED BY \"password\";\nQuery OK, 0 rows affected (0.00 sec)\n  \nmysql> FLUSH PRIVILEGES;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> EXIT\nBye\n$ \n```\n\n***\n\nto be continued...\n\n\n> 参考链接：\n> https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E6.AD.A5.E9.AA.A43:.E8.AE.BE.E7.BD.AEwp-config.php\n> http://www.jianshu.com/p/7e6566b613a7\n> http://www.jianshu.com/p/26d9e752994e\n","slug":"2016/2016-09-14-ubuntu搭建wordpress服务","published":1,"updated":"2016-12-16T01:48:01.586Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ahz002imumu4f57uygs","content":"<p><em><a href=\"https://cn.wordpress.org/\" target=\"_blank\" rel=\"external\">wordpress</a> 是目前比较流行的博客模板，精美的外观强可定制性收到了国内外很多bloger的亲睐，之前在虚拟机的ubuntu_server上面搭建过这个环境，个人所使用的blog是基于jekyll的静态页面，所以对wordpress不是特别了解，这边以腾讯云的ubuntu服务器为基础搭建自己的wordpress服务，当然现在很多云服务已经支持一键搭建wordpress的功能，但据说“访问速度和灵活性会受到很大影响”，这边有兴趣的朋友可以自己去尝试一下。</em></p>\n<h3 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h3><ul>\n<li>需要搭建一个服务器，首先需要选定自己使用哪些服务套件，这边我选用LAMP套装，即linux(ubuntu), apache2.0, mysql, php(wordpress)。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"详细安装步骤\"><a href=\"#详细安装步骤\" class=\"headerlink\" title=\"详细安装步骤\"></a>详细安装步骤</h3><h4 id=\"1-检查电脑是否安装了这些服务。\"><a href=\"#1-检查电脑是否安装了这些服务。\" class=\"headerlink\" title=\"1.检查电脑是否安装了这些服务。\"></a>1.检查电脑是否安装了这些服务。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dpkg -l | grep apache</div><div class=\"line\">dpkg -l | grep php</div><div class=\"line\">dpkg -l | grep mysql</div></pre></td></tr></table></figure>\n<h4 id=\"2-根据提示信息，如果没有安装则补安装。\"><a href=\"#2-根据提示信息，如果没有安装则补安装。\" class=\"headerlink\" title=\"2.根据提示信息，如果没有安装则补安装。\"></a>2.根据提示信息，如果没有安装则补安装。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install apache2 mysql-server php5 libapache2-mod-php5</div><div class=\"line\">重启apache服务 `sudo /etc/init.d/apache2 restart`</div></pre></td></tr></table></figure>\n<h4 id=\"3-让apache、php支持mysql\"><a href=\"#3-让apache、php支持mysql\" class=\"headerlink\" title=\"3.让apache、php支持mysql\"></a>3.让apache、php支持mysql</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install libapache2-mod-auth-mysql php5-mysql</div><div class=\"line\">重启apache服务 `sudo /etc/init.d/apache2 restart`</div></pre></td></tr></table></figure>\n<h4 id=\"4-安装phpMyAdmin\"><a href=\"#4-安装phpMyAdmin\" class=\"headerlink\" title=\"4.安装phpMyAdmin\"></a>4.安装phpMyAdmin</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install phpmyadmin</div><div class=\"line\">此时的phpmyadmin文件夹被安装在/usr/share/phpmyadmin下，为了能在浏览器中访问到phpmyadmin，需要在/var/www下做一个软连接到该文件夹。</div><div class=\"line\">进入/var/www文件夹，在该目录下执行如下操作:</div><div class=\"line\">sudo ln -s /usr/share/phpmyadmin</div></pre></td></tr></table></figure>\n<h4 id=\"5-为Wordpress新建mysql数据库\"><a href=\"#5-为Wordpress新建mysql数据库\" class=\"headerlink\" title=\"5.为Wordpress新建mysql数据库\"></a>5.<a href=\"https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E7.AC.AC.E4.BA.8C.E6.AD.A5.EF.BC.9A.E5.88.9B.E5.BB.BAWordPress.E6.95.B0.E6.8D.AE.E5.BA.93.E5.92.8C.E4.B8.80.E4.B8.AA.E7.94.A8.E6.88.B7\" target=\"_blank\" rel=\"external\">为Wordpress新建mysql数据库</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mysql -u root -p\t// 登陆管理数据库</div><div class=\"line\">Enter password:</div><div class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</div><div class=\"line\">Your MySQL connection id is 5340 to server version: 3.23.54</div><div class=\"line\"> </div><div class=\"line\">Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the buffer.</div><div class=\"line\"> </div><div class=\"line\">mysql&gt; CREATE DATABASE blog;\t// 创建数据库名称</div><div class=\"line\">Query OK, 1 row affected (0.00 sec)</div><div class=\"line\"> </div><div class=\"line\">mysql&gt; GRANT ALL PRIVILEGES ON blog.* TO &quot;demon&quot;@&quot;hostname&quot; // 受理权限</div><div class=\"line\">    -&gt; IDENTIFIED BY &quot;password&quot;;</div><div class=\"line\">Query OK, 0 rows affected (0.00 sec)</div><div class=\"line\">  </div><div class=\"line\">mysql&gt; FLUSH PRIVILEGES;</div><div class=\"line\">Query OK, 0 rows affected (0.01 sec)</div><div class=\"line\"></div><div class=\"line\">mysql&gt; EXIT</div><div class=\"line\">Bye</div><div class=\"line\">$</div></pre></td></tr></table></figure>\n<hr>\n<p>to be continued…</p>\n<blockquote>\n<p>参考链接：<br><a href=\"https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E6.AD.A5.E9.AA.A43:.E8.AE.BE.E7.BD.AEwp-config.php\" target=\"_blank\" rel=\"external\">https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E6.AD.A5.E9.AA.A43:.E8.AE.BE.E7.BD.AEwp-config.php</a><br><a href=\"http://www.jianshu.com/p/7e6566b613a7\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/7e6566b613a7</a><br><a href=\"http://www.jianshu.com/p/26d9e752994e\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/26d9e752994e</a></p>\n</blockquote>\n","excerpt":"<p><em><a href=\"https://cn.wordpress.org/\">wordpress</a> 是目前比较流行的博客模板，精美的外观强可定制性收到了国内外很多bloger的亲睐，之前在虚拟机的ubuntu_server上面搭建过这个环境，个人所使用的blog是基于jekyll的静态页面，所以对wordpress不是特别了解，这边以腾讯云的ubuntu服务器为基础搭建自己的wordpress服务，当然现在很多云服务已经支持一键搭建wordpress的功能，但据说“访问速度和灵活性会受到很大影响”，这边有兴趣的朋友可以自己去尝试一下。</em></p>\n<h3 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h3><ul>\n<li>需要搭建一个服务器，首先需要选定自己使用哪些服务套件，这边我选用LAMP套装，即linux(ubuntu), apache2.0, mysql, php(wordpress)。</li>\n</ul>","more":"<h3 id=\"详细安装步骤\"><a href=\"#详细安装步骤\" class=\"headerlink\" title=\"详细安装步骤\"></a>详细安装步骤</h3><h4 id=\"1-检查电脑是否安装了这些服务。\"><a href=\"#1-检查电脑是否安装了这些服务。\" class=\"headerlink\" title=\"1.检查电脑是否安装了这些服务。\"></a>1.检查电脑是否安装了这些服务。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dpkg -l | grep apache</div><div class=\"line\">dpkg -l | grep php</div><div class=\"line\">dpkg -l | grep mysql</div></pre></td></tr></table></figure>\n<h4 id=\"2-根据提示信息，如果没有安装则补安装。\"><a href=\"#2-根据提示信息，如果没有安装则补安装。\" class=\"headerlink\" title=\"2.根据提示信息，如果没有安装则补安装。\"></a>2.根据提示信息，如果没有安装则补安装。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install apache2 mysql-server php5 libapache2-mod-php5</div><div class=\"line\">重启apache服务 `sudo /etc/init.d/apache2 restart`</div></pre></td></tr></table></figure>\n<h4 id=\"3-让apache、php支持mysql\"><a href=\"#3-让apache、php支持mysql\" class=\"headerlink\" title=\"3.让apache、php支持mysql\"></a>3.让apache、php支持mysql</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install libapache2-mod-auth-mysql php5-mysql</div><div class=\"line\">重启apache服务 `sudo /etc/init.d/apache2 restart`</div></pre></td></tr></table></figure>\n<h4 id=\"4-安装phpMyAdmin\"><a href=\"#4-安装phpMyAdmin\" class=\"headerlink\" title=\"4.安装phpMyAdmin\"></a>4.安装phpMyAdmin</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install phpmyadmin</div><div class=\"line\">此时的phpmyadmin文件夹被安装在/usr/share/phpmyadmin下，为了能在浏览器中访问到phpmyadmin，需要在/var/www下做一个软连接到该文件夹。</div><div class=\"line\">进入/var/www文件夹，在该目录下执行如下操作:</div><div class=\"line\">sudo ln -s /usr/share/phpmyadmin</div></pre></td></tr></table></figure>\n<h4 id=\"5-为Wordpress新建mysql数据库\"><a href=\"#5-为Wordpress新建mysql数据库\" class=\"headerlink\" title=\"5.为Wordpress新建mysql数据库\"></a>5.<a href=\"https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E7.AC.AC.E4.BA.8C.E6.AD.A5.EF.BC.9A.E5.88.9B.E5.BB.BAWordPress.E6.95.B0.E6.8D.AE.E5.BA.93.E5.92.8C.E4.B8.80.E4.B8.AA.E7.94.A8.E6.88.B7\">为Wordpress新建mysql数据库</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mysql -u root -p\t// 登陆管理数据库</div><div class=\"line\">Enter password:</div><div class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</div><div class=\"line\">Your MySQL connection id is 5340 to server version: 3.23.54</div><div class=\"line\"> </div><div class=\"line\">Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the buffer.</div><div class=\"line\"> </div><div class=\"line\">mysql&gt; CREATE DATABASE blog;\t// 创建数据库名称</div><div class=\"line\">Query OK, 1 row affected (0.00 sec)</div><div class=\"line\"> </div><div class=\"line\">mysql&gt; GRANT ALL PRIVILEGES ON blog.* TO &quot;demon&quot;@&quot;hostname&quot; // 受理权限</div><div class=\"line\">    -&gt; IDENTIFIED BY &quot;password&quot;;</div><div class=\"line\">Query OK, 0 rows affected (0.00 sec)</div><div class=\"line\">  </div><div class=\"line\">mysql&gt; FLUSH PRIVILEGES;</div><div class=\"line\">Query OK, 0 rows affected (0.01 sec)</div><div class=\"line\"></div><div class=\"line\">mysql&gt; EXIT</div><div class=\"line\">Bye</div><div class=\"line\">$</div></pre></td></tr></table></figure>\n<hr>\n<p>to be continued…</p>\n<blockquote>\n<p>参考链接：<br><a href=\"https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E6.AD.A5.E9.AA.A43:.E8.AE.BE.E7.BD.AEwp-config.php\">https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E6.AD.A5.E9.AA.A43:.E8.AE.BE.E7.BD.AEwp-config.php</a><br><a href=\"http://www.jianshu.com/p/7e6566b613a7\">http://www.jianshu.com/p/7e6566b613a7</a><br><a href=\"http://www.jianshu.com/p/26d9e752994e\">http://www.jianshu.com/p/26d9e752994e</a></p>\n</blockquote>"},{"layout":"post","title":"字符编码","date":"2016-09-22T02:26:00.000Z","_content":"\n\n<!-- more -->\n\n\n\n> https://www.zhihu.com/question/20650946\n","source":"_posts/2016/2016-09-22-字符编码.md","raw":"---\nlayout: \"post\"\ntitle: \"字符编码\"\ndate: \"2016-09-22 10:26\"\n---\n\n\n<!-- more -->\n\n\n\n> https://www.zhihu.com/question/20650946\n","slug":"2016/2016-09-22-字符编码","published":1,"updated":"2016-12-16T01:48:17.146Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ai0002jmumugw2urzko","content":"<a id=\"more\"></a>\n<blockquote>\n<p><a href=\"https://www.zhihu.com/question/20650946\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/20650946</a></p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p><a href=\"https://www.zhihu.com/question/20650946\">https://www.zhihu.com/question/20650946</a></p>\n</blockquote>"},{"layout":"post","title":"git的配置及相关插件","date":"2016-09-28T08:45:00.000Z","_content":"\n一个好的工具，需要不断的打磨和熟悉使用技巧才可以把它用的炉火纯青，git同样如此，本文主要是推荐一些git常用的配置以及配套的一些工具。\n\n### git的相关配置：\n\n#### .gitignore配置\n\n\n\n\n\n<!-- more -->\n\n\n\n### 推荐的git插件：\n\n#### tig\n\n首先推荐[tig](http://jonas.nitro.dk/tig/)（名字刚好和git相反），是一个专门针对git的小软件，官方这么介绍*text-mode interface for Git*。\n\n推荐可以访问[tig的github页面](https://github.com/jonas/tig),里面有相关的下载安装说明。\n\n- 软件能够恨清晰的看到你的版本目录结构\n\n\n#### zsh\n\n\n#### 小乌龟插件\n\n\n#### atom\n","source":"_posts/2016/2016-09-28-git的配置及相关插件.md","raw":"---\nlayout: \"post\"\ntitle: \"git的配置及相关插件\"\ndate: \"2016-09-28 16:45\"\n---\n\n一个好的工具，需要不断的打磨和熟悉使用技巧才可以把它用的炉火纯青，git同样如此，本文主要是推荐一些git常用的配置以及配套的一些工具。\n\n### git的相关配置：\n\n#### .gitignore配置\n\n\n\n\n\n<!-- more -->\n\n\n\n### 推荐的git插件：\n\n#### tig\n\n首先推荐[tig](http://jonas.nitro.dk/tig/)（名字刚好和git相反），是一个专门针对git的小软件，官方这么介绍*text-mode interface for Git*。\n\n推荐可以访问[tig的github页面](https://github.com/jonas/tig),里面有相关的下载安装说明。\n\n- 软件能够恨清晰的看到你的版本目录结构\n\n\n#### zsh\n\n\n#### 小乌龟插件\n\n\n#### atom\n","slug":"2016/2016-09-28-git的配置及相关插件","published":1,"updated":"2016-12-16T01:48:39.050Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ai1002kmumuacpkbokg","content":"<p>一个好的工具，需要不断的打磨和熟悉使用技巧才可以把它用的炉火纯青，git同样如此，本文主要是推荐一些git常用的配置以及配套的一些工具。</p>\n<h3 id=\"git的相关配置：\"><a href=\"#git的相关配置：\" class=\"headerlink\" title=\"git的相关配置：\"></a>git的相关配置：</h3><h4 id=\"gitignore配置\"><a href=\"#gitignore配置\" class=\"headerlink\" title=\".gitignore配置\"></a>.gitignore配置</h4><a id=\"more\"></a>\n<h3 id=\"推荐的git插件：\"><a href=\"#推荐的git插件：\" class=\"headerlink\" title=\"推荐的git插件：\"></a>推荐的git插件：</h3><h4 id=\"tig\"><a href=\"#tig\" class=\"headerlink\" title=\"tig\"></a>tig</h4><p>首先推荐<a href=\"http://jonas.nitro.dk/tig/\" target=\"_blank\" rel=\"external\">tig</a>（名字刚好和git相反），是一个专门针对git的小软件，官方这么介绍<em>text-mode interface for Git</em>。</p>\n<p>推荐可以访问<a href=\"https://github.com/jonas/tig\" target=\"_blank\" rel=\"external\">tig的github页面</a>,里面有相关的下载安装说明。</p>\n<ul>\n<li>软件能够恨清晰的看到你的版本目录结构</li>\n</ul>\n<h4 id=\"zsh\"><a href=\"#zsh\" class=\"headerlink\" title=\"zsh\"></a>zsh</h4><h4 id=\"小乌龟插件\"><a href=\"#小乌龟插件\" class=\"headerlink\" title=\"小乌龟插件\"></a>小乌龟插件</h4><h4 id=\"atom\"><a href=\"#atom\" class=\"headerlink\" title=\"atom\"></a>atom</h4>","excerpt":"<p>一个好的工具，需要不断的打磨和熟悉使用技巧才可以把它用的炉火纯青，git同样如此，本文主要是推荐一些git常用的配置以及配套的一些工具。</p>\n<h3 id=\"git的相关配置：\"><a href=\"#git的相关配置：\" class=\"headerlink\" title=\"git的相关配置：\"></a>git的相关配置：</h3><h4 id=\"gitignore配置\"><a href=\"#gitignore配置\" class=\"headerlink\" title=\".gitignore配置\"></a>.gitignore配置</h4>","more":"<h3 id=\"推荐的git插件：\"><a href=\"#推荐的git插件：\" class=\"headerlink\" title=\"推荐的git插件：\"></a>推荐的git插件：</h3><h4 id=\"tig\"><a href=\"#tig\" class=\"headerlink\" title=\"tig\"></a>tig</h4><p>首先推荐<a href=\"http://jonas.nitro.dk/tig/\">tig</a>（名字刚好和git相反），是一个专门针对git的小软件，官方这么介绍<em>text-mode interface for Git</em>。</p>\n<p>推荐可以访问<a href=\"https://github.com/jonas/tig\">tig的github页面</a>,里面有相关的下载安装说明。</p>\n<ul>\n<li>软件能够恨清晰的看到你的版本目录结构</li>\n</ul>\n<h4 id=\"zsh\"><a href=\"#zsh\" class=\"headerlink\" title=\"zsh\"></a>zsh</h4><h4 id=\"小乌龟插件\"><a href=\"#小乌龟插件\" class=\"headerlink\" title=\"小乌龟插件\"></a>小乌龟插件</h4><h4 id=\"atom\"><a href=\"#atom\" class=\"headerlink\" title=\"atom\"></a>atom</h4>"},{"layout":"post","title":"关于手机的一些个人看法","date":"2016-09-28T10:39:00.000Z","_content":"\n\n个人一直很喜欢电子产品，且关于电子科技类新闻较多，近几年来可以说每日必看，曾经也经常混迹于各大论坛贴吧微博等。本文当然仅仅代表本人（一个非专业人事）对各个手机厂家品牌的一些看法，文章可能不会一次性写完，会随着我对手机了解成都的不断加深而更新本文。\n\n\n<!-- more -->\n\n\nTo be continued...\n\n***\n","source":"_posts/2016/2016-09-28-关于手机的一些个人看法.md","raw":"---\nlayout: \"post\"\ntitle: \"关于手机的一些个人看法\"\ndate: \"2016-09-28 18:39\"\n---\n\n\n个人一直很喜欢电子产品，且关于电子科技类新闻较多，近几年来可以说每日必看，曾经也经常混迹于各大论坛贴吧微博等。本文当然仅仅代表本人（一个非专业人事）对各个手机厂家品牌的一些看法，文章可能不会一次性写完，会随着我对手机了解成都的不断加深而更新本文。\n\n\n<!-- more -->\n\n\nTo be continued...\n\n***\n","slug":"2016/2016-09-28-关于手机的一些个人看法","published":1,"updated":"2016-12-16T01:48:42.850Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ai2002lmumuyxmo37l1","content":"<p>个人一直很喜欢电子产品，且关于电子科技类新闻较多，近几年来可以说每日必看，曾经也经常混迹于各大论坛贴吧微博等。本文当然仅仅代表本人（一个非专业人事）对各个手机厂家品牌的一些看法，文章可能不会一次性写完，会随着我对手机了解成都的不断加深而更新本文。</p>\n<a id=\"more\"></a>\n<p>To be continued…</p>\n<hr>\n","excerpt":"<p>个人一直很喜欢电子产品，且关于电子科技类新闻较多，近几年来可以说每日必看，曾经也经常混迹于各大论坛贴吧微博等。本文当然仅仅代表本人（一个非专业人事）对各个手机厂家品牌的一些看法，文章可能不会一次性写完，会随着我对手机了解成都的不断加深而更新本文。</p>","more":"<p>To be continued…</p>\n<hr>"},{"layout":"post","title":"windows 7个人使用环境配置","date":"2016-09-20T14:18:00.000Z","_content":"\nwindows 7作为个人使用最久的一个系统，无论是稳定性美观程度等等都相当优秀，虽然windows是商业软件，源代码不开放定制性差，但通过一些日常的配置，配合常用的软件还是能够将它打造成一个个性化很强用起来恨顺畅的系统。本人因为工作需要经常会用到windows系统，另外周围也有不少朋友都用的这个系统，所以这边着重总结个人的一些常用配置，以及推荐一些非专业类软件。通过本文的文章和截图，后续重装系统，也能够轻松对照配置修改回来。\n\n**假设你已经安装完了系统，这一个纯净版（非ghost版本，一般我都是安装这个版本）的windows 7，桌面仅有一个垃圾桶，没有其他软件。**\n\n### windows 配置\n\n#### 配置任务栏\n\n个人习惯采用小图标，窄任务栏，这样的好处是屏幕可以显示更多的内容。见下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/1.png)\n\n#### 修改窗体颜色\n\n一是为了美观，修改aero的透明窗体颜色，可以让窗体和任务栏，另外改变窗体颜色外观可以起到护眼的作用。见下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2.png)\n\n#### 修改显示器颜色\n\n如果是台式机显示器，则显示器上面的配置按键可以进行手动修改，无需参照下面方式，下列方式主要适用于笔记本软件调节的方式，见下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/3.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/4.png)\n\n*通过调整这些参数可以过滤部分蓝光效果，让颜色显暖色更易于护眼，当然这样做的坏处就是整体颜色失真，观看电影视频时候观感下降，另外如果设计图片视频时会对你有较大的影响，这边也可以使用第三方软件更加智能的调节，软件部分会推荐介绍该软件。*\n\n#### 电池管理\n\n这边针对笔记本在会待机，合上盖子会休眠等进行修改。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/5.png)\n\n#### 修改输入法的切换按键\n\n*实现该功能的目的主要是切换中英文输入法，在使用ctrl或者shift切换时，很明显这两个键的位置远不如caps按起来方便，且shift往往作为大小写功能使用，用来作为切换中英文输入会恨混乱，而caps作为大小写时用起来相当罕见。大写完全可以用shift代替的用户群中，无疑是占用了一个最好的位置，却几乎完全被遗忘的一个按键。**这边将右ctrl和caps进行功能对调。***\n\n打开注册表，在运行（win+R）中输入regedit，注册表位置：[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Keyboard Layout]  （注意： KeyBoard Layout, 而不是 KeyBoard Layouts）如果没有此键，就新建一个二进制值的Key，名叫：Scancode Map（注意名称不能够写错，错一个字母都没法实现功能）。\n\n```\n输入如下的值：\n　　00,00,00,00\n　　00,00,00,00\n　　03,00,00,00\n　　3A,00,1D,E0\n　　1D,E0,3A,00\n　　00,00,00,00\n```\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/6.png)\n\n**详细内容可以参见我的另外一篇专门介绍按键互换的文章。**\n\n<!-- more -->\n\n\n### 常用基础软件\n\n#### 编辑器\n\n*windows 自带的记事本，记事本的问题较多，例如：WINDOWS自带的记事本等软件，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。但对于 PHP来说，BOM是个大麻烦。所以windows下如果适用记事本会给跨平台编码带来巨大的麻烦，一旦出现很难发现和解决。另外记事本的编辑能力弱，可读性差等特点，也让大伙儿一致的决定抛弃这个软件。下面推荐两款比较好的文本编辑软件，无论是查看普通文本编辑，还是要少量的修改代码，这个两个软件都是不错的选择。*\n\n- editplus\n\n本人一般都用这个来编辑普通文件，如.txt,.md等需要阅读的文件，一般不需要怎么配置即可轻松上手使用，功能很强大，但个人主要用作查阅写说明文档等，一般不会对它单独定制。总之一点，这个软件配合上面我设置的窗口调色，用起来就是阅读舒服，写起来顺畅。但**该软件是商业软件，需要付费使用。**\n\n- notepad++\n\nwindows下最喜欢的一款编辑器，功能强大，可定制性强，运行速度快，占用资源小，免费开源软件，可以说众多优点集一身。一般我只会对它进行简单的配置即可，主要用来修改文件代码。当然你也可以只用它即可，无需使用上面的editplus，因为个人将颜色调整为暗黑色，不易于阅读文本文字，所以同时安装了这两个软件。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/7.png)\n\n\n#### 输入法(有详细文章)\n\n选择**搜狗或者qq拼音精简版**，这两个都是不错的选择，百度占用资源较大，且，另外一些配置设置不够人性化，使用起来较麻烦，需要注意的是，拼音中开启两个功能：\n- 按ctrl按键切换中英文输入，上述设置了*键盘映射*，需要开启这个功能才可以。\n- 安装截图插件，qq简版的截图功能较差，无法自动命名，可以选择搜狗拼音。\n\n*主要强调的是windows下输入法的配置，因为完全使用第三方输入中的中英文，所以不再需要自带的输入法了，具体参见如下图片：*\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/8.png)\n\n\n#### 检索软件\n\n也是个强烈推荐的一款可以快速检索的软件，软件特点如下：\n- 占用资源较大，长期占用一定的内存，且会影响开机时间，但现在内存都很大，这点可以接收，开机根据个人情况，一般无所谓，如果是固态硬盘，那就更没有什么影响了。\n- 类似于linux下的locate命令吧，将所有文件信息生成一个数据库，然后每次搜索时能够快速定位，但当日修改的文件，信息更新的未必及时。\n\n国内软件中可以选用*稻田搜搜*,该软件界面好看，该有的功能也都有，但不支持通配符搜索，另外占用资源貌似也比较大。这边主要推荐使用 everything 这个老牌搜索软件，软件虽然小，但可定制性相当强，个人配置如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e1.png)\n上图可见布局，右侧预览效果相当强大。\n\n下面是一些我个人的定制，仅供参考：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e2.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e3.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e4.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e5.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e6.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e7.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e8.png)\n\n\n#### 金山词霸\n\n一款查单词较方便的软件，这边不推荐有道，是因为有道现在广告泛滥了，金山词霸还拥有离线版本，如果在公司不方便上网一样可以使用。我一般设置：\n- 双击alt将字典调出\n- 选中单词双击ctrl调出解释\n\n\n\n> https://www.zhihu.com/question/20650946\n> http://www.huangbowei.com/archives/92.html\n> http://baike.baidu.com/subview/126558/5073180.htm\n","source":"_posts/2016/2016-09-20-windows-7个人使用环境配置.md","raw":"---\nlayout: \"post\"\ntitle: \"windows 7个人使用环境配置\"\ndate: \"2016-09-20 22:18\"\n---\n\nwindows 7作为个人使用最久的一个系统，无论是稳定性美观程度等等都相当优秀，虽然windows是商业软件，源代码不开放定制性差，但通过一些日常的配置，配合常用的软件还是能够将它打造成一个个性化很强用起来恨顺畅的系统。本人因为工作需要经常会用到windows系统，另外周围也有不少朋友都用的这个系统，所以这边着重总结个人的一些常用配置，以及推荐一些非专业类软件。通过本文的文章和截图，后续重装系统，也能够轻松对照配置修改回来。\n\n**假设你已经安装完了系统，这一个纯净版（非ghost版本，一般我都是安装这个版本）的windows 7，桌面仅有一个垃圾桶，没有其他软件。**\n\n### windows 配置\n\n#### 配置任务栏\n\n个人习惯采用小图标，窄任务栏，这样的好处是屏幕可以显示更多的内容。见下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/1.png)\n\n#### 修改窗体颜色\n\n一是为了美观，修改aero的透明窗体颜色，可以让窗体和任务栏，另外改变窗体颜色外观可以起到护眼的作用。见下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2.png)\n\n#### 修改显示器颜色\n\n如果是台式机显示器，则显示器上面的配置按键可以进行手动修改，无需参照下面方式，下列方式主要适用于笔记本软件调节的方式，见下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/3.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/4.png)\n\n*通过调整这些参数可以过滤部分蓝光效果，让颜色显暖色更易于护眼，当然这样做的坏处就是整体颜色失真，观看电影视频时候观感下降，另外如果设计图片视频时会对你有较大的影响，这边也可以使用第三方软件更加智能的调节，软件部分会推荐介绍该软件。*\n\n#### 电池管理\n\n这边针对笔记本在会待机，合上盖子会休眠等进行修改。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/5.png)\n\n#### 修改输入法的切换按键\n\n*实现该功能的目的主要是切换中英文输入法，在使用ctrl或者shift切换时，很明显这两个键的位置远不如caps按起来方便，且shift往往作为大小写功能使用，用来作为切换中英文输入会恨混乱，而caps作为大小写时用起来相当罕见。大写完全可以用shift代替的用户群中，无疑是占用了一个最好的位置，却几乎完全被遗忘的一个按键。**这边将右ctrl和caps进行功能对调。***\n\n打开注册表，在运行（win+R）中输入regedit，注册表位置：[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Keyboard Layout]  （注意： KeyBoard Layout, 而不是 KeyBoard Layouts）如果没有此键，就新建一个二进制值的Key，名叫：Scancode Map（注意名称不能够写错，错一个字母都没法实现功能）。\n\n```\n输入如下的值：\n　　00,00,00,00\n　　00,00,00,00\n　　03,00,00,00\n　　3A,00,1D,E0\n　　1D,E0,3A,00\n　　00,00,00,00\n```\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/6.png)\n\n**详细内容可以参见我的另外一篇专门介绍按键互换的文章。**\n\n<!-- more -->\n\n\n### 常用基础软件\n\n#### 编辑器\n\n*windows 自带的记事本，记事本的问题较多，例如：WINDOWS自带的记事本等软件，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。但对于 PHP来说，BOM是个大麻烦。所以windows下如果适用记事本会给跨平台编码带来巨大的麻烦，一旦出现很难发现和解决。另外记事本的编辑能力弱，可读性差等特点，也让大伙儿一致的决定抛弃这个软件。下面推荐两款比较好的文本编辑软件，无论是查看普通文本编辑，还是要少量的修改代码，这个两个软件都是不错的选择。*\n\n- editplus\n\n本人一般都用这个来编辑普通文件，如.txt,.md等需要阅读的文件，一般不需要怎么配置即可轻松上手使用，功能很强大，但个人主要用作查阅写说明文档等，一般不会对它单独定制。总之一点，这个软件配合上面我设置的窗口调色，用起来就是阅读舒服，写起来顺畅。但**该软件是商业软件，需要付费使用。**\n\n- notepad++\n\nwindows下最喜欢的一款编辑器，功能强大，可定制性强，运行速度快，占用资源小，免费开源软件，可以说众多优点集一身。一般我只会对它进行简单的配置即可，主要用来修改文件代码。当然你也可以只用它即可，无需使用上面的editplus，因为个人将颜色调整为暗黑色，不易于阅读文本文字，所以同时安装了这两个软件。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/7.png)\n\n\n#### 输入法(有详细文章)\n\n选择**搜狗或者qq拼音精简版**，这两个都是不错的选择，百度占用资源较大，且，另外一些配置设置不够人性化，使用起来较麻烦，需要注意的是，拼音中开启两个功能：\n- 按ctrl按键切换中英文输入，上述设置了*键盘映射*，需要开启这个功能才可以。\n- 安装截图插件，qq简版的截图功能较差，无法自动命名，可以选择搜狗拼音。\n\n*主要强调的是windows下输入法的配置，因为完全使用第三方输入中的中英文，所以不再需要自带的输入法了，具体参见如下图片：*\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/8.png)\n\n\n#### 检索软件\n\n也是个强烈推荐的一款可以快速检索的软件，软件特点如下：\n- 占用资源较大，长期占用一定的内存，且会影响开机时间，但现在内存都很大，这点可以接收，开机根据个人情况，一般无所谓，如果是固态硬盘，那就更没有什么影响了。\n- 类似于linux下的locate命令吧，将所有文件信息生成一个数据库，然后每次搜索时能够快速定位，但当日修改的文件，信息更新的未必及时。\n\n国内软件中可以选用*稻田搜搜*,该软件界面好看，该有的功能也都有，但不支持通配符搜索，另外占用资源貌似也比较大。这边主要推荐使用 everything 这个老牌搜索软件，软件虽然小，但可定制性相当强，个人配置如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e1.png)\n上图可见布局，右侧预览效果相当强大。\n\n下面是一些我个人的定制，仅供参考：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e2.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e3.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e4.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e5.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e6.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e7.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e8.png)\n\n\n#### 金山词霸\n\n一款查单词较方便的软件，这边不推荐有道，是因为有道现在广告泛滥了，金山词霸还拥有离线版本，如果在公司不方便上网一样可以使用。我一般设置：\n- 双击alt将字典调出\n- 选中单词双击ctrl调出解释\n\n\n\n> https://www.zhihu.com/question/20650946\n> http://www.huangbowei.com/archives/92.html\n> http://baike.baidu.com/subview/126558/5073180.htm\n","slug":"2016/2016-09-20-windows-7个人使用环境配置","published":1,"updated":"2016-12-16T01:48:13.282Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ai3002mmumu1lx3kb24","content":"<p>windows 7作为个人使用最久的一个系统，无论是稳定性美观程度等等都相当优秀，虽然windows是商业软件，源代码不开放定制性差，但通过一些日常的配置，配合常用的软件还是能够将它打造成一个个性化很强用起来恨顺畅的系统。本人因为工作需要经常会用到windows系统，另外周围也有不少朋友都用的这个系统，所以这边着重总结个人的一些常用配置，以及推荐一些非专业类软件。通过本文的文章和截图，后续重装系统，也能够轻松对照配置修改回来。</p>\n<p><strong>假设你已经安装完了系统，这一个纯净版（非ghost版本，一般我都是安装这个版本）的windows 7，桌面仅有一个垃圾桶，没有其他软件。</strong></p>\n<h3 id=\"windows-配置\"><a href=\"#windows-配置\" class=\"headerlink\" title=\"windows 配置\"></a>windows 配置</h3><h4 id=\"配置任务栏\"><a href=\"#配置任务栏\" class=\"headerlink\" title=\"配置任务栏\"></a>配置任务栏</h4><p>个人习惯采用小图标，窄任务栏，这样的好处是屏幕可以显示更多的内容。见下图：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/1.png\" alt=\"\"></p>\n<h4 id=\"修改窗体颜色\"><a href=\"#修改窗体颜色\" class=\"headerlink\" title=\"修改窗体颜色\"></a>修改窗体颜色</h4><p>一是为了美观，修改aero的透明窗体颜色，可以让窗体和任务栏，另外改变窗体颜色外观可以起到护眼的作用。见下图：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2.png\" alt=\"\"></p>\n<h4 id=\"修改显示器颜色\"><a href=\"#修改显示器颜色\" class=\"headerlink\" title=\"修改显示器颜色\"></a>修改显示器颜色</h4><p>如果是台式机显示器，则显示器上面的配置按键可以进行手动修改，无需参照下面方式，下列方式主要适用于笔记本软件调节的方式，见下图：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/3.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/4.png\" alt=\"\"></p>\n<p><em>通过调整这些参数可以过滤部分蓝光效果，让颜色显暖色更易于护眼，当然这样做的坏处就是整体颜色失真，观看电影视频时候观感下降，另外如果设计图片视频时会对你有较大的影响，这边也可以使用第三方软件更加智能的调节，软件部分会推荐介绍该软件。</em></p>\n<h4 id=\"电池管理\"><a href=\"#电池管理\" class=\"headerlink\" title=\"电池管理\"></a>电池管理</h4><p>这边针对笔记本在会待机，合上盖子会休眠等进行修改。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/5.png\" alt=\"\"></p>\n<h4 id=\"修改输入法的切换按键\"><a href=\"#修改输入法的切换按键\" class=\"headerlink\" title=\"修改输入法的切换按键\"></a>修改输入法的切换按键</h4><p><em>实现该功能的目的主要是切换中英文输入法，在使用ctrl或者shift切换时，很明显这两个键的位置远不如caps按起来方便，且shift往往作为大小写功能使用，用来作为切换中英文输入会恨混乱，而caps作为大小写时用起来相当罕见。大写完全可以用shift代替的用户群中，无疑是占用了一个最好的位置，却几乎完全被遗忘的一个按键。<strong>这边将右ctrl和caps进行功能对调。</strong></em></p>\n<p>打开注册表，在运行（win+R）中输入regedit，注册表位置：[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Keyboard Layout]  （注意： KeyBoard Layout, 而不是 KeyBoard Layouts）如果没有此键，就新建一个二进制值的Key，名叫：Scancode Map（注意名称不能够写错，错一个字母都没法实现功能）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">输入如下的值：</div><div class=\"line\">　　00,00,00,00</div><div class=\"line\">　　00,00,00,00</div><div class=\"line\">　　03,00,00,00</div><div class=\"line\">　　3A,00,1D,E0</div><div class=\"line\">　　1D,E0,3A,00</div><div class=\"line\">　　00,00,00,00</div></pre></td></tr></table></figure>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/6.png\" alt=\"\"></p>\n<p><strong>详细内容可以参见我的另外一篇专门介绍按键互换的文章。</strong></p>\n<a id=\"more\"></a>\n<h3 id=\"常用基础软件\"><a href=\"#常用基础软件\" class=\"headerlink\" title=\"常用基础软件\"></a>常用基础软件</h3><h4 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h4><p><em>windows 自带的记事本，记事本的问题较多，例如：WINDOWS自带的记事本等软件，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。但对于 PHP来说，BOM是个大麻烦。所以windows下如果适用记事本会给跨平台编码带来巨大的麻烦，一旦出现很难发现和解决。另外记事本的编辑能力弱，可读性差等特点，也让大伙儿一致的决定抛弃这个软件。下面推荐两款比较好的文本编辑软件，无论是查看普通文本编辑，还是要少量的修改代码，这个两个软件都是不错的选择。</em></p>\n<ul>\n<li>editplus</li>\n</ul>\n<p>本人一般都用这个来编辑普通文件，如.txt,.md等需要阅读的文件，一般不需要怎么配置即可轻松上手使用，功能很强大，但个人主要用作查阅写说明文档等，一般不会对它单独定制。总之一点，这个软件配合上面我设置的窗口调色，用起来就是阅读舒服，写起来顺畅。但<strong>该软件是商业软件，需要付费使用。</strong></p>\n<ul>\n<li>notepad++</li>\n</ul>\n<p>windows下最喜欢的一款编辑器，功能强大，可定制性强，运行速度快，占用资源小，免费开源软件，可以说众多优点集一身。一般我只会对它进行简单的配置即可，主要用来修改文件代码。当然你也可以只用它即可，无需使用上面的editplus，因为个人将颜色调整为暗黑色，不易于阅读文本文字，所以同时安装了这两个软件。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/7.png\" alt=\"\"></p>\n<h4 id=\"输入法-有详细文章\"><a href=\"#输入法-有详细文章\" class=\"headerlink\" title=\"输入法(有详细文章)\"></a>输入法(有详细文章)</h4><p>选择<strong>搜狗或者qq拼音精简版</strong>，这两个都是不错的选择，百度占用资源较大，且，另外一些配置设置不够人性化，使用起来较麻烦，需要注意的是，拼音中开启两个功能：</p>\n<ul>\n<li>按ctrl按键切换中英文输入，上述设置了<em>键盘映射</em>，需要开启这个功能才可以。</li>\n<li>安装截图插件，qq简版的截图功能较差，无法自动命名，可以选择搜狗拼音。</li>\n</ul>\n<p><em>主要强调的是windows下输入法的配置，因为完全使用第三方输入中的中英文，所以不再需要自带的输入法了，具体参见如下图片：</em></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/8.png\" alt=\"\"></p>\n<h4 id=\"检索软件\"><a href=\"#检索软件\" class=\"headerlink\" title=\"检索软件\"></a>检索软件</h4><p>也是个强烈推荐的一款可以快速检索的软件，软件特点如下：</p>\n<ul>\n<li>占用资源较大，长期占用一定的内存，且会影响开机时间，但现在内存都很大，这点可以接收，开机根据个人情况，一般无所谓，如果是固态硬盘，那就更没有什么影响了。</li>\n<li>类似于linux下的locate命令吧，将所有文件信息生成一个数据库，然后每次搜索时能够快速定位，但当日修改的文件，信息更新的未必及时。</li>\n</ul>\n<p>国内软件中可以选用<em>稻田搜搜</em>,该软件界面好看，该有的功能也都有，但不支持通配符搜索，另外占用资源貌似也比较大。这边主要推荐使用 everything 这个老牌搜索软件，软件虽然小，但可定制性相当强，个人配置如下：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e1.png\" alt=\"\"><br>上图可见布局，右侧预览效果相当强大。</p>\n<p>下面是一些我个人的定制，仅供参考：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e2.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e3.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e4.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e5.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e6.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e7.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e8.png\" alt=\"\"></p>\n<h4 id=\"金山词霸\"><a href=\"#金山词霸\" class=\"headerlink\" title=\"金山词霸\"></a>金山词霸</h4><p>一款查单词较方便的软件，这边不推荐有道，是因为有道现在广告泛滥了，金山词霸还拥有离线版本，如果在公司不方便上网一样可以使用。我一般设置：</p>\n<ul>\n<li>双击alt将字典调出</li>\n<li>选中单词双击ctrl调出解释</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.zhihu.com/question/20650946\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/20650946</a><br><a href=\"http://www.huangbowei.com/archives/92.html\" target=\"_blank\" rel=\"external\">http://www.huangbowei.com/archives/92.html</a><br><a href=\"http://baike.baidu.com/subview/126558/5073180.htm\" target=\"_blank\" rel=\"external\">http://baike.baidu.com/subview/126558/5073180.htm</a></p>\n</blockquote>\n","excerpt":"<p>windows 7作为个人使用最久的一个系统，无论是稳定性美观程度等等都相当优秀，虽然windows是商业软件，源代码不开放定制性差，但通过一些日常的配置，配合常用的软件还是能够将它打造成一个个性化很强用起来恨顺畅的系统。本人因为工作需要经常会用到windows系统，另外周围也有不少朋友都用的这个系统，所以这边着重总结个人的一些常用配置，以及推荐一些非专业类软件。通过本文的文章和截图，后续重装系统，也能够轻松对照配置修改回来。</p>\n<p><strong>假设你已经安装完了系统，这一个纯净版（非ghost版本，一般我都是安装这个版本）的windows 7，桌面仅有一个垃圾桶，没有其他软件。</strong></p>\n<h3 id=\"windows-配置\"><a href=\"#windows-配置\" class=\"headerlink\" title=\"windows 配置\"></a>windows 配置</h3><h4 id=\"配置任务栏\"><a href=\"#配置任务栏\" class=\"headerlink\" title=\"配置任务栏\"></a>配置任务栏</h4><p>个人习惯采用小图标，窄任务栏，这样的好处是屏幕可以显示更多的内容。见下图：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/1.png\" alt=\"\"></p>\n<h4 id=\"修改窗体颜色\"><a href=\"#修改窗体颜色\" class=\"headerlink\" title=\"修改窗体颜色\"></a>修改窗体颜色</h4><p>一是为了美观，修改aero的透明窗体颜色，可以让窗体和任务栏，另外改变窗体颜色外观可以起到护眼的作用。见下图：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2.png\" alt=\"\"></p>\n<h4 id=\"修改显示器颜色\"><a href=\"#修改显示器颜色\" class=\"headerlink\" title=\"修改显示器颜色\"></a>修改显示器颜色</h4><p>如果是台式机显示器，则显示器上面的配置按键可以进行手动修改，无需参照下面方式，下列方式主要适用于笔记本软件调节的方式，见下图：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/3.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/4.png\" alt=\"\"></p>\n<p><em>通过调整这些参数可以过滤部分蓝光效果，让颜色显暖色更易于护眼，当然这样做的坏处就是整体颜色失真，观看电影视频时候观感下降，另外如果设计图片视频时会对你有较大的影响，这边也可以使用第三方软件更加智能的调节，软件部分会推荐介绍该软件。</em></p>\n<h4 id=\"电池管理\"><a href=\"#电池管理\" class=\"headerlink\" title=\"电池管理\"></a>电池管理</h4><p>这边针对笔记本在会待机，合上盖子会休眠等进行修改。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/5.png\" alt=\"\"></p>\n<h4 id=\"修改输入法的切换按键\"><a href=\"#修改输入法的切换按键\" class=\"headerlink\" title=\"修改输入法的切换按键\"></a>修改输入法的切换按键</h4><p><em>实现该功能的目的主要是切换中英文输入法，在使用ctrl或者shift切换时，很明显这两个键的位置远不如caps按起来方便，且shift往往作为大小写功能使用，用来作为切换中英文输入会恨混乱，而caps作为大小写时用起来相当罕见。大写完全可以用shift代替的用户群中，无疑是占用了一个最好的位置，却几乎完全被遗忘的一个按键。<strong>这边将右ctrl和caps进行功能对调。</strong></em></p>\n<p>打开注册表，在运行（win+R）中输入regedit，注册表位置：[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Keyboard Layout]  （注意： KeyBoard Layout, 而不是 KeyBoard Layouts）如果没有此键，就新建一个二进制值的Key，名叫：Scancode Map（注意名称不能够写错，错一个字母都没法实现功能）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">输入如下的值：</div><div class=\"line\">　　00,00,00,00</div><div class=\"line\">　　00,00,00,00</div><div class=\"line\">　　03,00,00,00</div><div class=\"line\">　　3A,00,1D,E0</div><div class=\"line\">　　1D,E0,3A,00</div><div class=\"line\">　　00,00,00,00</div></pre></td></tr></table></figure>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/6.png\" alt=\"\"></p>\n<p><strong>详细内容可以参见我的另外一篇专门介绍按键互换的文章。</strong></p>","more":"<h3 id=\"常用基础软件\"><a href=\"#常用基础软件\" class=\"headerlink\" title=\"常用基础软件\"></a>常用基础软件</h3><h4 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h4><p><em>windows 自带的记事本，记事本的问题较多，例如：WINDOWS自带的记事本等软件，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。但对于 PHP来说，BOM是个大麻烦。所以windows下如果适用记事本会给跨平台编码带来巨大的麻烦，一旦出现很难发现和解决。另外记事本的编辑能力弱，可读性差等特点，也让大伙儿一致的决定抛弃这个软件。下面推荐两款比较好的文本编辑软件，无论是查看普通文本编辑，还是要少量的修改代码，这个两个软件都是不错的选择。</em></p>\n<ul>\n<li>editplus</li>\n</ul>\n<p>本人一般都用这个来编辑普通文件，如.txt,.md等需要阅读的文件，一般不需要怎么配置即可轻松上手使用，功能很强大，但个人主要用作查阅写说明文档等，一般不会对它单独定制。总之一点，这个软件配合上面我设置的窗口调色，用起来就是阅读舒服，写起来顺畅。但<strong>该软件是商业软件，需要付费使用。</strong></p>\n<ul>\n<li>notepad++</li>\n</ul>\n<p>windows下最喜欢的一款编辑器，功能强大，可定制性强，运行速度快，占用资源小，免费开源软件，可以说众多优点集一身。一般我只会对它进行简单的配置即可，主要用来修改文件代码。当然你也可以只用它即可，无需使用上面的editplus，因为个人将颜色调整为暗黑色，不易于阅读文本文字，所以同时安装了这两个软件。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/7.png\" alt=\"\"></p>\n<h4 id=\"输入法-有详细文章\"><a href=\"#输入法-有详细文章\" class=\"headerlink\" title=\"输入法(有详细文章)\"></a>输入法(有详细文章)</h4><p>选择<strong>搜狗或者qq拼音精简版</strong>，这两个都是不错的选择，百度占用资源较大，且，另外一些配置设置不够人性化，使用起来较麻烦，需要注意的是，拼音中开启两个功能：</p>\n<ul>\n<li>按ctrl按键切换中英文输入，上述设置了<em>键盘映射</em>，需要开启这个功能才可以。</li>\n<li>安装截图插件，qq简版的截图功能较差，无法自动命名，可以选择搜狗拼音。</li>\n</ul>\n<p><em>主要强调的是windows下输入法的配置，因为完全使用第三方输入中的中英文，所以不再需要自带的输入法了，具体参见如下图片：</em></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/8.png\" alt=\"\"></p>\n<h4 id=\"检索软件\"><a href=\"#检索软件\" class=\"headerlink\" title=\"检索软件\"></a>检索软件</h4><p>也是个强烈推荐的一款可以快速检索的软件，软件特点如下：</p>\n<ul>\n<li>占用资源较大，长期占用一定的内存，且会影响开机时间，但现在内存都很大，这点可以接收，开机根据个人情况，一般无所谓，如果是固态硬盘，那就更没有什么影响了。</li>\n<li>类似于linux下的locate命令吧，将所有文件信息生成一个数据库，然后每次搜索时能够快速定位，但当日修改的文件，信息更新的未必及时。</li>\n</ul>\n<p>国内软件中可以选用<em>稻田搜搜</em>,该软件界面好看，该有的功能也都有，但不支持通配符搜索，另外占用资源貌似也比较大。这边主要推荐使用 everything 这个老牌搜索软件，软件虽然小，但可定制性相当强，个人配置如下：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e1.png\" alt=\"\"><br>上图可见布局，右侧预览效果相当强大。</p>\n<p>下面是一些我个人的定制，仅供参考：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e2.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e3.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e4.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e5.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e6.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e7.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e8.png\" alt=\"\"></p>\n<h4 id=\"金山词霸\"><a href=\"#金山词霸\" class=\"headerlink\" title=\"金山词霸\"></a>金山词霸</h4><p>一款查单词较方便的软件，这边不推荐有道，是因为有道现在广告泛滥了，金山词霸还拥有离线版本，如果在公司不方便上网一样可以使用。我一般设置：</p>\n<ul>\n<li>双击alt将字典调出</li>\n<li>选中单词双击ctrl调出解释</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.zhihu.com/question/20650946\">https://www.zhihu.com/question/20650946</a><br><a href=\"http://www.huangbowei.com/archives/92.html\">http://www.huangbowei.com/archives/92.html</a><br><a href=\"http://baike.baidu.com/subview/126558/5073180.htm\">http://baike.baidu.com/subview/126558/5073180.htm</a></p>\n</blockquote>"},{"layout":"post","title":"windows7和虚拟机中的ubuntu实现文件共享","date":"2016-09-26T06:06:00.000Z","_content":"\n### 简介\n\n国内很多用户习惯于使用windows系类操作系统，然而其中部分人员需要使用ubuntu进行一些开发测试，但他们并不想完全脱离windows系统，这时候虚拟机满足了他们的需求，虚拟机以安装配置简单，镜像还原起来方便安全，而被广大学习爱好者所喜爱。但有些时候，需要将真实机中的一些文档或者数据传输到虚拟机中，而如何实现虚拟机同真实机的共享往往是一些初学者头痛的事情。下面我列举出几种方法，可以满足解决这些问题。\n\n### 通过网盘进行传输\n\n首先可以参照我之前写的*桥接、nat、host-only上网方式的区别*里面介绍了如何配置虚拟机上网，一般虚拟机上方较为方便，如：vmware或者virtualbox之类的都可以一键安装系统，即便手动安装，通过虚拟机拓展工具也都可以补全网卡显示上网的。如果对你所使用的linux发行版不是太熟悉，且极少传输文件的话，可以使用这种方法。推荐使用百度云之类的网盘，先将本地数据文件上传，然后再通过linux中的浏览器将数据文件下载下来。这种方式的好处是无需学习，没有门槛，不需要了解任何linux的知识，只需要当做一个桌面系统使用即可，坏处显而易见：1.依赖外网，2.机密文件不方便上传，3.必须上传下载，大型文件速度慢。\n\n\n<!-- more -->\n\n\n### **进行以下几种方法前建议先关闭linux和windows的防火墙**\n\n### 通过虚拟机扩展直接拖动\n\n一般虚拟机中的linux安装扩展插件就可以直接将windows下的文件托进linux去了，或者将linux的文件拖到windows下，但前提要求是：**需要虚拟机和操作系统的内核版本兼容，各方面切合度高，能够完美支持的情况下，最好使用虚拟机要和两个操作系统都是同一时期发型的，推荐是使用新版windows，最新版虚拟机还有最新发行版的linux系统。**\n\n### 通过scp命令\n\nLinux与Linux之间传送文件，使用scp命令，这是一种基于ssh的方式，因此**两个系统都必须要支持ssh协议**，安装方式：\n\n- ubuntu：`sudo apt-get install ssh或sudo apt-get install openssh-server`，`sudo /etc/init.d/ssh restart`重启ssh服务，其他发行版该命令未必适用。查看ssh服务是否启动, `ps –e | grep ssh`，响应的sshd和ssh-agent如果未打开则运行指令名字。\n- windows系统本身不支持ssh协议，所以，要想上面的命令成功执行，必须在windows客户端安装ssh for windows的客户端软件，比如WinSCP（开源），winsshd，使windows系统支持ssh协议才行。\n\n从linux系统复制文件到windows系统：  \n`scp /tmp/a.txt administrator@192.168.3.181:/d:/`\n\n在linux环境下，将windows下的文件复制到linux系统中：  \n`scp  administrator@192.168.3.181:/d:/test/config.ips  /tmp`\n\n*。scp的方法于只安装了CLI的linux版本使用，所有操作无需图形界面，且能够在linux下完成。另外该方法也并非任何地方都能够完成，和虚拟机扩展类似，对系统环境有一定要求，尤其是一定要找到可用的windows下的ssh协议，往往是linux的ssh完美运行，但无法登陆windows。*\n\n### 通过WinSCP软件\n\n该软件主要就是实现同一网段内的windows和linux的数据互传，本质上应该和scp命令原理是相同的，好处是图形化界面操作简单，登陆后无需再输入指令。WinSCP 是一个支持SSH（Secure SHell）的SCP（Secure CoPy）文件传输软件。只要文件主机支持SSH协定，你就可以安心的下载、上传文件。他的操作界面是参考NC（Norton Commander）的双视窗排列方式，使用起来不会有太大的困难。在WinSCP中，一般的文件操作都没有问题，如：复制、移动、更名文件或文件夹等。\n\n输入主机名，用户名，密码，点击保存。通过下图中的界面，实现登陆：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-26-windows7%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84ubuntu%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/1.jpg)\n\n*第一登陆的时候，会告诉你服务器的主秘钥不再缓存中，确认修改后，即可远程登陆，另外如果使用root用户的话，新安装的ubuntu系统需要设置root密码，以及修改ssh的配置文件：`sudo vi /etc/ssh/sshd-config`，将PermitRootLogin修改为yes。重启ssh服务：`sudo /etc/init.d/ssh restart`*\n\n文件的上传与下载跟Windows的资源管理器差不多了，如果要编辑目录或文件，只要右键就会出相应的可选的项目。下图为登陆后的资源管理界面：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-26-windows7%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84ubuntu%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/2.jpg)\n\n\n### 通过虚拟机共享文件夹的方式\n\n#### 安装VMware tools或者virtualboxaddition等工具\n\n- 在VMware虚拟机界面，点VM->Install VMware Tools。之后，点击Ubuntu 窗口中主文件 按钮然后再左边会看见设备里有VMware tools文件夹，双击之，并且解压其中的压缩文件，把它拷贝到主文件夹\n- 打开Terminal终端，进入解压的文件夹中，输入以下命令：\n\n```\nsudo tar zxf VMwareTools-xxx.tar.gz (注：xxx为版本号)\ncd /vmware-tools-distrib\nsudo ./vmware-install.pl\n安装过程中一直按enter即可，或者输入【】提示yes和no，直到安装完毕。\n```\n\n- 查看结果：lsmod | grep vmblock\n\n#### 设置共享文件夹的目录\n\n- 将Ubuntu关机（power off），否则不能添加共享文件夹\n- 在VMware虚拟机窗口，选择VM->Settings->Options->Shared Folders\n- 点右边的Add，点Next->选择Win7共享目录的路径，然后点Next->选中Enable this share->Finish\n- 在VM->Settings->Options->Shared Folders窗口的右边，Folder sharing栏里选择Always enabled\n- 点 OK 确定退出\n\n#### 在Ubuntu虚拟机下安装插件\n\n- 执行 sudo apt-get install open-vm-dkms (注：如果无法查到open-vm-dkms，则可能更名为：open-vm-tools-dkms)\n- 执行 sudo mount -t vmhgfs .host:/ /mnt/hgfs \n- cd /mnt/hgfs\n\n注意：即便完成了这个方法的所有步骤也未必能够完成共享文件夹，同虚*拟机扩展直接拖动*类似，该方法对系统和虚拟机切合度要求较高，vmtools和ubuntu内核存在版本不兼容的问题，mount经常支持不够好。也就是说同样的方法，相同的步骤，有的人轻松就可以实现，有的需要不断的去修补linux的脚本头文件等，当然解决是一定可以解决，但往往较为麻烦，如果该方法不行，建议尝试其他方法。\n\n### 总结：\n\n*通过scp命令*和*通过虚拟机共享文件夹的方式*并不推荐，建议首先尝试安装虚拟机扩展工具，如果可以直接拖拽文件则问题已解决，无需参考文章中的方法，如果不行的话，推荐通过WinSCP软件来操作，适用的场景多且不容易出错，本人尝试过如centos 6.5，ubuntu 16.04等多个主流操作系统，均可以实现传输。\n\n\n***\n\n> 参考链接：\n> http://huangfuff.blog.51cto.com/2632203/1604500\n> https://my.oschina.net/u/811744/blog/179229\n> https://www.centos.bz/2011/03/windows-linux-transfer-data-tool-winscp/\n> http://blog.csdn.net/warringah1/article/details/8927437\n> http://fancyseeker.github.io/2013/12/31/ssh_connect/\n> http://blog.csdn.net/lulitianyu/article/details/50446015\n","source":"_posts/2016/2016-09-26-windows7和虚拟机中的ubuntu实现文件共享.md","raw":"---\nlayout: \"post\"\ntitle: \"windows7和虚拟机中的ubuntu实现文件共享\"\ndate: \"2016-09-26 14:06\"\n---\n\n### 简介\n\n国内很多用户习惯于使用windows系类操作系统，然而其中部分人员需要使用ubuntu进行一些开发测试，但他们并不想完全脱离windows系统，这时候虚拟机满足了他们的需求，虚拟机以安装配置简单，镜像还原起来方便安全，而被广大学习爱好者所喜爱。但有些时候，需要将真实机中的一些文档或者数据传输到虚拟机中，而如何实现虚拟机同真实机的共享往往是一些初学者头痛的事情。下面我列举出几种方法，可以满足解决这些问题。\n\n### 通过网盘进行传输\n\n首先可以参照我之前写的*桥接、nat、host-only上网方式的区别*里面介绍了如何配置虚拟机上网，一般虚拟机上方较为方便，如：vmware或者virtualbox之类的都可以一键安装系统，即便手动安装，通过虚拟机拓展工具也都可以补全网卡显示上网的。如果对你所使用的linux发行版不是太熟悉，且极少传输文件的话，可以使用这种方法。推荐使用百度云之类的网盘，先将本地数据文件上传，然后再通过linux中的浏览器将数据文件下载下来。这种方式的好处是无需学习，没有门槛，不需要了解任何linux的知识，只需要当做一个桌面系统使用即可，坏处显而易见：1.依赖外网，2.机密文件不方便上传，3.必须上传下载，大型文件速度慢。\n\n\n<!-- more -->\n\n\n### **进行以下几种方法前建议先关闭linux和windows的防火墙**\n\n### 通过虚拟机扩展直接拖动\n\n一般虚拟机中的linux安装扩展插件就可以直接将windows下的文件托进linux去了，或者将linux的文件拖到windows下，但前提要求是：**需要虚拟机和操作系统的内核版本兼容，各方面切合度高，能够完美支持的情况下，最好使用虚拟机要和两个操作系统都是同一时期发型的，推荐是使用新版windows，最新版虚拟机还有最新发行版的linux系统。**\n\n### 通过scp命令\n\nLinux与Linux之间传送文件，使用scp命令，这是一种基于ssh的方式，因此**两个系统都必须要支持ssh协议**，安装方式：\n\n- ubuntu：`sudo apt-get install ssh或sudo apt-get install openssh-server`，`sudo /etc/init.d/ssh restart`重启ssh服务，其他发行版该命令未必适用。查看ssh服务是否启动, `ps –e | grep ssh`，响应的sshd和ssh-agent如果未打开则运行指令名字。\n- windows系统本身不支持ssh协议，所以，要想上面的命令成功执行，必须在windows客户端安装ssh for windows的客户端软件，比如WinSCP（开源），winsshd，使windows系统支持ssh协议才行。\n\n从linux系统复制文件到windows系统：  \n`scp /tmp/a.txt administrator@192.168.3.181:/d:/`\n\n在linux环境下，将windows下的文件复制到linux系统中：  \n`scp  administrator@192.168.3.181:/d:/test/config.ips  /tmp`\n\n*。scp的方法于只安装了CLI的linux版本使用，所有操作无需图形界面，且能够在linux下完成。另外该方法也并非任何地方都能够完成，和虚拟机扩展类似，对系统环境有一定要求，尤其是一定要找到可用的windows下的ssh协议，往往是linux的ssh完美运行，但无法登陆windows。*\n\n### 通过WinSCP软件\n\n该软件主要就是实现同一网段内的windows和linux的数据互传，本质上应该和scp命令原理是相同的，好处是图形化界面操作简单，登陆后无需再输入指令。WinSCP 是一个支持SSH（Secure SHell）的SCP（Secure CoPy）文件传输软件。只要文件主机支持SSH协定，你就可以安心的下载、上传文件。他的操作界面是参考NC（Norton Commander）的双视窗排列方式，使用起来不会有太大的困难。在WinSCP中，一般的文件操作都没有问题，如：复制、移动、更名文件或文件夹等。\n\n输入主机名，用户名，密码，点击保存。通过下图中的界面，实现登陆：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-26-windows7%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84ubuntu%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/1.jpg)\n\n*第一登陆的时候，会告诉你服务器的主秘钥不再缓存中，确认修改后，即可远程登陆，另外如果使用root用户的话，新安装的ubuntu系统需要设置root密码，以及修改ssh的配置文件：`sudo vi /etc/ssh/sshd-config`，将PermitRootLogin修改为yes。重启ssh服务：`sudo /etc/init.d/ssh restart`*\n\n文件的上传与下载跟Windows的资源管理器差不多了，如果要编辑目录或文件，只要右键就会出相应的可选的项目。下图为登陆后的资源管理界面：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-26-windows7%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84ubuntu%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/2.jpg)\n\n\n### 通过虚拟机共享文件夹的方式\n\n#### 安装VMware tools或者virtualboxaddition等工具\n\n- 在VMware虚拟机界面，点VM->Install VMware Tools。之后，点击Ubuntu 窗口中主文件 按钮然后再左边会看见设备里有VMware tools文件夹，双击之，并且解压其中的压缩文件，把它拷贝到主文件夹\n- 打开Terminal终端，进入解压的文件夹中，输入以下命令：\n\n```\nsudo tar zxf VMwareTools-xxx.tar.gz (注：xxx为版本号)\ncd /vmware-tools-distrib\nsudo ./vmware-install.pl\n安装过程中一直按enter即可，或者输入【】提示yes和no，直到安装完毕。\n```\n\n- 查看结果：lsmod | grep vmblock\n\n#### 设置共享文件夹的目录\n\n- 将Ubuntu关机（power off），否则不能添加共享文件夹\n- 在VMware虚拟机窗口，选择VM->Settings->Options->Shared Folders\n- 点右边的Add，点Next->选择Win7共享目录的路径，然后点Next->选中Enable this share->Finish\n- 在VM->Settings->Options->Shared Folders窗口的右边，Folder sharing栏里选择Always enabled\n- 点 OK 确定退出\n\n#### 在Ubuntu虚拟机下安装插件\n\n- 执行 sudo apt-get install open-vm-dkms (注：如果无法查到open-vm-dkms，则可能更名为：open-vm-tools-dkms)\n- 执行 sudo mount -t vmhgfs .host:/ /mnt/hgfs \n- cd /mnt/hgfs\n\n注意：即便完成了这个方法的所有步骤也未必能够完成共享文件夹，同虚*拟机扩展直接拖动*类似，该方法对系统和虚拟机切合度要求较高，vmtools和ubuntu内核存在版本不兼容的问题，mount经常支持不够好。也就是说同样的方法，相同的步骤，有的人轻松就可以实现，有的需要不断的去修补linux的脚本头文件等，当然解决是一定可以解决，但往往较为麻烦，如果该方法不行，建议尝试其他方法。\n\n### 总结：\n\n*通过scp命令*和*通过虚拟机共享文件夹的方式*并不推荐，建议首先尝试安装虚拟机扩展工具，如果可以直接拖拽文件则问题已解决，无需参考文章中的方法，如果不行的话，推荐通过WinSCP软件来操作，适用的场景多且不容易出错，本人尝试过如centos 6.5，ubuntu 16.04等多个主流操作系统，均可以实现传输。\n\n\n***\n\n> 参考链接：\n> http://huangfuff.blog.51cto.com/2632203/1604500\n> https://my.oschina.net/u/811744/blog/179229\n> https://www.centos.bz/2011/03/windows-linux-transfer-data-tool-winscp/\n> http://blog.csdn.net/warringah1/article/details/8927437\n> http://fancyseeker.github.io/2013/12/31/ssh_connect/\n> http://blog.csdn.net/lulitianyu/article/details/50446015\n","slug":"2016/2016-09-26-windows7和虚拟机中的ubuntu实现文件共享","published":1,"updated":"2016-12-16T01:48:21.586Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ai4002nmumuhz5pbpgp","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>国内很多用户习惯于使用windows系类操作系统，然而其中部分人员需要使用ubuntu进行一些开发测试，但他们并不想完全脱离windows系统，这时候虚拟机满足了他们的需求，虚拟机以安装配置简单，镜像还原起来方便安全，而被广大学习爱好者所喜爱。但有些时候，需要将真实机中的一些文档或者数据传输到虚拟机中，而如何实现虚拟机同真实机的共享往往是一些初学者头痛的事情。下面我列举出几种方法，可以满足解决这些问题。</p>\n<h3 id=\"通过网盘进行传输\"><a href=\"#通过网盘进行传输\" class=\"headerlink\" title=\"通过网盘进行传输\"></a>通过网盘进行传输</h3><p>首先可以参照我之前写的<em>桥接、nat、host-only上网方式的区别</em>里面介绍了如何配置虚拟机上网，一般虚拟机上方较为方便，如：vmware或者virtualbox之类的都可以一键安装系统，即便手动安装，通过虚拟机拓展工具也都可以补全网卡显示上网的。如果对你所使用的linux发行版不是太熟悉，且极少传输文件的话，可以使用这种方法。推荐使用百度云之类的网盘，先将本地数据文件上传，然后再通过linux中的浏览器将数据文件下载下来。这种方式的好处是无需学习，没有门槛，不需要了解任何linux的知识，只需要当做一个桌面系统使用即可，坏处显而易见：1.依赖外网，2.机密文件不方便上传，3.必须上传下载，大型文件速度慢。</p>\n<a id=\"more\"></a>\n<h3 id=\"进行以下几种方法前建议先关闭linux和windows的防火墙\"><a href=\"#进行以下几种方法前建议先关闭linux和windows的防火墙\" class=\"headerlink\" title=\"进行以下几种方法前建议先关闭linux和windows的防火墙\"></a><strong>进行以下几种方法前建议先关闭linux和windows的防火墙</strong></h3><h3 id=\"通过虚拟机扩展直接拖动\"><a href=\"#通过虚拟机扩展直接拖动\" class=\"headerlink\" title=\"通过虚拟机扩展直接拖动\"></a>通过虚拟机扩展直接拖动</h3><p>一般虚拟机中的linux安装扩展插件就可以直接将windows下的文件托进linux去了，或者将linux的文件拖到windows下，但前提要求是：<strong>需要虚拟机和操作系统的内核版本兼容，各方面切合度高，能够完美支持的情况下，最好使用虚拟机要和两个操作系统都是同一时期发型的，推荐是使用新版windows，最新版虚拟机还有最新发行版的linux系统。</strong></p>\n<h3 id=\"通过scp命令\"><a href=\"#通过scp命令\" class=\"headerlink\" title=\"通过scp命令\"></a>通过scp命令</h3><p>Linux与Linux之间传送文件，使用scp命令，这是一种基于ssh的方式，因此<strong>两个系统都必须要支持ssh协议</strong>，安装方式：</p>\n<ul>\n<li>ubuntu：<code>sudo apt-get install ssh或sudo apt-get install openssh-server</code>，<code>sudo /etc/init.d/ssh restart</code>重启ssh服务，其他发行版该命令未必适用。查看ssh服务是否启动, <code>ps –e | grep ssh</code>，响应的sshd和ssh-agent如果未打开则运行指令名字。</li>\n<li>windows系统本身不支持ssh协议，所以，要想上面的命令成功执行，必须在windows客户端安装ssh for windows的客户端软件，比如WinSCP（开源），winsshd，使windows系统支持ssh协议才行。</li>\n</ul>\n<p>从linux系统复制文件到windows系统：<br><code>scp /tmp/a.txt administrator@192.168.3.181:/d:/</code></p>\n<p>在linux环境下，将windows下的文件复制到linux系统中：<br><code>scp  administrator@192.168.3.181:/d:/test/config.ips  /tmp</code></p>\n<p><em>。scp的方法于只安装了CLI的linux版本使用，所有操作无需图形界面，且能够在linux下完成。另外该方法也并非任何地方都能够完成，和虚拟机扩展类似，对系统环境有一定要求，尤其是一定要找到可用的windows下的ssh协议，往往是linux的ssh完美运行，但无法登陆windows。</em></p>\n<h3 id=\"通过WinSCP软件\"><a href=\"#通过WinSCP软件\" class=\"headerlink\" title=\"通过WinSCP软件\"></a>通过WinSCP软件</h3><p>该软件主要就是实现同一网段内的windows和linux的数据互传，本质上应该和scp命令原理是相同的，好处是图形化界面操作简单，登陆后无需再输入指令。WinSCP 是一个支持SSH（Secure SHell）的SCP（Secure CoPy）文件传输软件。只要文件主机支持SSH协定，你就可以安心的下载、上传文件。他的操作界面是参考NC（Norton Commander）的双视窗排列方式，使用起来不会有太大的困难。在WinSCP中，一般的文件操作都没有问题，如：复制、移动、更名文件或文件夹等。</p>\n<p>输入主机名，用户名，密码，点击保存。通过下图中的界面，实现登陆：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-26-windows7%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84ubuntu%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/1.jpg\" alt=\"\"></p>\n<p><em>第一登陆的时候，会告诉你服务器的主秘钥不再缓存中，确认修改后，即可远程登陆，另外如果使用root用户的话，新安装的ubuntu系统需要设置root密码，以及修改ssh的配置文件：<code>sudo vi /etc/ssh/sshd-config</code>，将PermitRootLogin修改为yes。重启ssh服务：<code>sudo /etc/init.d/ssh restart</code></em></p>\n<p>文件的上传与下载跟Windows的资源管理器差不多了，如果要编辑目录或文件，只要右键就会出相应的可选的项目。下图为登陆后的资源管理界面：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-26-windows7%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84ubuntu%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/2.jpg\" alt=\"\"></p>\n<h3 id=\"通过虚拟机共享文件夹的方式\"><a href=\"#通过虚拟机共享文件夹的方式\" class=\"headerlink\" title=\"通过虚拟机共享文件夹的方式\"></a>通过虚拟机共享文件夹的方式</h3><h4 id=\"安装VMware-tools或者virtualboxaddition等工具\"><a href=\"#安装VMware-tools或者virtualboxaddition等工具\" class=\"headerlink\" title=\"安装VMware tools或者virtualboxaddition等工具\"></a>安装VMware tools或者virtualboxaddition等工具</h4><ul>\n<li>在VMware虚拟机界面，点VM-&gt;Install VMware Tools。之后，点击Ubuntu 窗口中主文件 按钮然后再左边会看见设备里有VMware tools文件夹，双击之，并且解压其中的压缩文件，把它拷贝到主文件夹</li>\n<li>打开Terminal终端，进入解压的文件夹中，输入以下命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo tar zxf VMwareTools-xxx.tar.gz (注：xxx为版本号)</div><div class=\"line\">cd /vmware-tools-distrib</div><div class=\"line\">sudo ./vmware-install.pl</div><div class=\"line\">安装过程中一直按enter即可，或者输入【】提示yes和no，直到安装完毕。</div></pre></td></tr></table></figure>\n<ul>\n<li>查看结果：lsmod | grep vmblock</li>\n</ul>\n<h4 id=\"设置共享文件夹的目录\"><a href=\"#设置共享文件夹的目录\" class=\"headerlink\" title=\"设置共享文件夹的目录\"></a>设置共享文件夹的目录</h4><ul>\n<li>将Ubuntu关机（power off），否则不能添加共享文件夹</li>\n<li>在VMware虚拟机窗口，选择VM-&gt;Settings-&gt;Options-&gt;Shared Folders</li>\n<li>点右边的Add，点Next-&gt;选择Win7共享目录的路径，然后点Next-&gt;选中Enable this share-&gt;Finish</li>\n<li>在VM-&gt;Settings-&gt;Options-&gt;Shared Folders窗口的右边，Folder sharing栏里选择Always enabled</li>\n<li>点 OK 确定退出</li>\n</ul>\n<h4 id=\"在Ubuntu虚拟机下安装插件\"><a href=\"#在Ubuntu虚拟机下安装插件\" class=\"headerlink\" title=\"在Ubuntu虚拟机下安装插件\"></a>在Ubuntu虚拟机下安装插件</h4><ul>\n<li>执行 sudo apt-get install open-vm-dkms (注：如果无法查到open-vm-dkms，则可能更名为：open-vm-tools-dkms)</li>\n<li>执行 sudo mount -t vmhgfs .host:/ /mnt/hgfs </li>\n<li>cd /mnt/hgfs</li>\n</ul>\n<p>注意：即便完成了这个方法的所有步骤也未必能够完成共享文件夹，同虚<em>拟机扩展直接拖动</em>类似，该方法对系统和虚拟机切合度要求较高，vmtools和ubuntu内核存在版本不兼容的问题，mount经常支持不够好。也就是说同样的方法，相同的步骤，有的人轻松就可以实现，有的需要不断的去修补linux的脚本头文件等，当然解决是一定可以解决，但往往较为麻烦，如果该方法不行，建议尝试其他方法。</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p><em>通过scp命令</em>和<em>通过虚拟机共享文件夹的方式</em>并不推荐，建议首先尝试安装虚拟机扩展工具，如果可以直接拖拽文件则问题已解决，无需参考文章中的方法，如果不行的话，推荐通过WinSCP软件来操作，适用的场景多且不容易出错，本人尝试过如centos 6.5，ubuntu 16.04等多个主流操作系统，均可以实现传输。</p>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://huangfuff.blog.51cto.com/2632203/1604500\" target=\"_blank\" rel=\"external\">http://huangfuff.blog.51cto.com/2632203/1604500</a><br><a href=\"https://my.oschina.net/u/811744/blog/179229\" target=\"_blank\" rel=\"external\">https://my.oschina.net/u/811744/blog/179229</a><br><a href=\"https://www.centos.bz/2011/03/windows-linux-transfer-data-tool-winscp/\" target=\"_blank\" rel=\"external\">https://www.centos.bz/2011/03/windows-linux-transfer-data-tool-winscp/</a><br><a href=\"http://blog.csdn.net/warringah1/article/details/8927437\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/warringah1/article/details/8927437</a><br><a href=\"http://fancyseeker.github.io/2013/12/31/ssh_connect/\" target=\"_blank\" rel=\"external\">http://fancyseeker.github.io/2013/12/31/ssh_connect/</a><br><a href=\"http://blog.csdn.net/lulitianyu/article/details/50446015\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lulitianyu/article/details/50446015</a></p>\n</blockquote>\n","excerpt":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>国内很多用户习惯于使用windows系类操作系统，然而其中部分人员需要使用ubuntu进行一些开发测试，但他们并不想完全脱离windows系统，这时候虚拟机满足了他们的需求，虚拟机以安装配置简单，镜像还原起来方便安全，而被广大学习爱好者所喜爱。但有些时候，需要将真实机中的一些文档或者数据传输到虚拟机中，而如何实现虚拟机同真实机的共享往往是一些初学者头痛的事情。下面我列举出几种方法，可以满足解决这些问题。</p>\n<h3 id=\"通过网盘进行传输\"><a href=\"#通过网盘进行传输\" class=\"headerlink\" title=\"通过网盘进行传输\"></a>通过网盘进行传输</h3><p>首先可以参照我之前写的<em>桥接、nat、host-only上网方式的区别</em>里面介绍了如何配置虚拟机上网，一般虚拟机上方较为方便，如：vmware或者virtualbox之类的都可以一键安装系统，即便手动安装，通过虚拟机拓展工具也都可以补全网卡显示上网的。如果对你所使用的linux发行版不是太熟悉，且极少传输文件的话，可以使用这种方法。推荐使用百度云之类的网盘，先将本地数据文件上传，然后再通过linux中的浏览器将数据文件下载下来。这种方式的好处是无需学习，没有门槛，不需要了解任何linux的知识，只需要当做一个桌面系统使用即可，坏处显而易见：1.依赖外网，2.机密文件不方便上传，3.必须上传下载，大型文件速度慢。</p>","more":"<h3 id=\"进行以下几种方法前建议先关闭linux和windows的防火墙\"><a href=\"#进行以下几种方法前建议先关闭linux和windows的防火墙\" class=\"headerlink\" title=\"进行以下几种方法前建议先关闭linux和windows的防火墙\"></a><strong>进行以下几种方法前建议先关闭linux和windows的防火墙</strong></h3><h3 id=\"通过虚拟机扩展直接拖动\"><a href=\"#通过虚拟机扩展直接拖动\" class=\"headerlink\" title=\"通过虚拟机扩展直接拖动\"></a>通过虚拟机扩展直接拖动</h3><p>一般虚拟机中的linux安装扩展插件就可以直接将windows下的文件托进linux去了，或者将linux的文件拖到windows下，但前提要求是：<strong>需要虚拟机和操作系统的内核版本兼容，各方面切合度高，能够完美支持的情况下，最好使用虚拟机要和两个操作系统都是同一时期发型的，推荐是使用新版windows，最新版虚拟机还有最新发行版的linux系统。</strong></p>\n<h3 id=\"通过scp命令\"><a href=\"#通过scp命令\" class=\"headerlink\" title=\"通过scp命令\"></a>通过scp命令</h3><p>Linux与Linux之间传送文件，使用scp命令，这是一种基于ssh的方式，因此<strong>两个系统都必须要支持ssh协议</strong>，安装方式：</p>\n<ul>\n<li>ubuntu：<code>sudo apt-get install ssh或sudo apt-get install openssh-server</code>，<code>sudo /etc/init.d/ssh restart</code>重启ssh服务，其他发行版该命令未必适用。查看ssh服务是否启动, <code>ps –e | grep ssh</code>，响应的sshd和ssh-agent如果未打开则运行指令名字。</li>\n<li>windows系统本身不支持ssh协议，所以，要想上面的命令成功执行，必须在windows客户端安装ssh for windows的客户端软件，比如WinSCP（开源），winsshd，使windows系统支持ssh协议才行。</li>\n</ul>\n<p>从linux系统复制文件到windows系统：<br><code>scp /tmp/a.txt administrator@192.168.3.181:/d:/</code></p>\n<p>在linux环境下，将windows下的文件复制到linux系统中：<br><code>scp  administrator@192.168.3.181:/d:/test/config.ips  /tmp</code></p>\n<p><em>。scp的方法于只安装了CLI的linux版本使用，所有操作无需图形界面，且能够在linux下完成。另外该方法也并非任何地方都能够完成，和虚拟机扩展类似，对系统环境有一定要求，尤其是一定要找到可用的windows下的ssh协议，往往是linux的ssh完美运行，但无法登陆windows。</em></p>\n<h3 id=\"通过WinSCP软件\"><a href=\"#通过WinSCP软件\" class=\"headerlink\" title=\"通过WinSCP软件\"></a>通过WinSCP软件</h3><p>该软件主要就是实现同一网段内的windows和linux的数据互传，本质上应该和scp命令原理是相同的，好处是图形化界面操作简单，登陆后无需再输入指令。WinSCP 是一个支持SSH（Secure SHell）的SCP（Secure CoPy）文件传输软件。只要文件主机支持SSH协定，你就可以安心的下载、上传文件。他的操作界面是参考NC（Norton Commander）的双视窗排列方式，使用起来不会有太大的困难。在WinSCP中，一般的文件操作都没有问题，如：复制、移动、更名文件或文件夹等。</p>\n<p>输入主机名，用户名，密码，点击保存。通过下图中的界面，实现登陆：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-26-windows7%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84ubuntu%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/1.jpg\" alt=\"\"></p>\n<p><em>第一登陆的时候，会告诉你服务器的主秘钥不再缓存中，确认修改后，即可远程登陆，另外如果使用root用户的话，新安装的ubuntu系统需要设置root密码，以及修改ssh的配置文件：<code>sudo vi /etc/ssh/sshd-config</code>，将PermitRootLogin修改为yes。重启ssh服务：<code>sudo /etc/init.d/ssh restart</code></em></p>\n<p>文件的上传与下载跟Windows的资源管理器差不多了，如果要编辑目录或文件，只要右键就会出相应的可选的项目。下图为登陆后的资源管理界面：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-26-windows7%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84ubuntu%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/2.jpg\" alt=\"\"></p>\n<h3 id=\"通过虚拟机共享文件夹的方式\"><a href=\"#通过虚拟机共享文件夹的方式\" class=\"headerlink\" title=\"通过虚拟机共享文件夹的方式\"></a>通过虚拟机共享文件夹的方式</h3><h4 id=\"安装VMware-tools或者virtualboxaddition等工具\"><a href=\"#安装VMware-tools或者virtualboxaddition等工具\" class=\"headerlink\" title=\"安装VMware tools或者virtualboxaddition等工具\"></a>安装VMware tools或者virtualboxaddition等工具</h4><ul>\n<li>在VMware虚拟机界面，点VM-&gt;Install VMware Tools。之后，点击Ubuntu 窗口中主文件 按钮然后再左边会看见设备里有VMware tools文件夹，双击之，并且解压其中的压缩文件，把它拷贝到主文件夹</li>\n<li>打开Terminal终端，进入解压的文件夹中，输入以下命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo tar zxf VMwareTools-xxx.tar.gz (注：xxx为版本号)</div><div class=\"line\">cd /vmware-tools-distrib</div><div class=\"line\">sudo ./vmware-install.pl</div><div class=\"line\">安装过程中一直按enter即可，或者输入【】提示yes和no，直到安装完毕。</div></pre></td></tr></table></figure>\n<ul>\n<li>查看结果：lsmod | grep vmblock</li>\n</ul>\n<h4 id=\"设置共享文件夹的目录\"><a href=\"#设置共享文件夹的目录\" class=\"headerlink\" title=\"设置共享文件夹的目录\"></a>设置共享文件夹的目录</h4><ul>\n<li>将Ubuntu关机（power off），否则不能添加共享文件夹</li>\n<li>在VMware虚拟机窗口，选择VM-&gt;Settings-&gt;Options-&gt;Shared Folders</li>\n<li>点右边的Add，点Next-&gt;选择Win7共享目录的路径，然后点Next-&gt;选中Enable this share-&gt;Finish</li>\n<li>在VM-&gt;Settings-&gt;Options-&gt;Shared Folders窗口的右边，Folder sharing栏里选择Always enabled</li>\n<li>点 OK 确定退出</li>\n</ul>\n<h4 id=\"在Ubuntu虚拟机下安装插件\"><a href=\"#在Ubuntu虚拟机下安装插件\" class=\"headerlink\" title=\"在Ubuntu虚拟机下安装插件\"></a>在Ubuntu虚拟机下安装插件</h4><ul>\n<li>执行 sudo apt-get install open-vm-dkms (注：如果无法查到open-vm-dkms，则可能更名为：open-vm-tools-dkms)</li>\n<li>执行 sudo mount -t vmhgfs .host:/ /mnt/hgfs </li>\n<li>cd /mnt/hgfs</li>\n</ul>\n<p>注意：即便完成了这个方法的所有步骤也未必能够完成共享文件夹，同虚<em>拟机扩展直接拖动</em>类似，该方法对系统和虚拟机切合度要求较高，vmtools和ubuntu内核存在版本不兼容的问题，mount经常支持不够好。也就是说同样的方法，相同的步骤，有的人轻松就可以实现，有的需要不断的去修补linux的脚本头文件等，当然解决是一定可以解决，但往往较为麻烦，如果该方法不行，建议尝试其他方法。</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p><em>通过scp命令</em>和<em>通过虚拟机共享文件夹的方式</em>并不推荐，建议首先尝试安装虚拟机扩展工具，如果可以直接拖拽文件则问题已解决，无需参考文章中的方法，如果不行的话，推荐通过WinSCP软件来操作，适用的场景多且不容易出错，本人尝试过如centos 6.5，ubuntu 16.04等多个主流操作系统，均可以实现传输。</p>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://huangfuff.blog.51cto.com/2632203/1604500\">http://huangfuff.blog.51cto.com/2632203/1604500</a><br><a href=\"https://my.oschina.net/u/811744/blog/179229\">https://my.oschina.net/u/811744/blog/179229</a><br><a href=\"https://www.centos.bz/2011/03/windows-linux-transfer-data-tool-winscp/\">https://www.centos.bz/2011/03/windows-linux-transfer-data-tool-winscp/</a><br><a href=\"http://blog.csdn.net/warringah1/article/details/8927437\">http://blog.csdn.net/warringah1/article/details/8927437</a><br><a href=\"http://fancyseeker.github.io/2013/12/31/ssh_connect/\">http://fancyseeker.github.io/2013/12/31/ssh_connect/</a><br><a href=\"http://blog.csdn.net/lulitianyu/article/details/50446015\">http://blog.csdn.net/lulitianyu/article/details/50446015</a></p>\n</blockquote>"},{"layout":"post","title":"通过git管理一个工程","date":"2016-09-28T08:45:00.000Z","_content":"\n\nGIT虽然能够实现各种版本控制，且功能强大，可以做到随时切换版本，回退等各种功能，但过多的分支，无效的分支，杂乱的提交，无意义的命名等等问题，往往会让像我这样的初学者，异常头痛，网络上关于git的往往都是指导你各个命令如何去用，部分命令的使用场景等，但却缺少一个完整工程项目的管理步骤。部分大神的确总结出了自己的使用习惯，但却不是作为教程来陈述的，下面我会将自己的一些习惯进行总结，后续可能遇到更好的也还会不断的更改。\n\n下面是一张团队协作示意图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-28-%E9%80%9A%E8%BF%87git%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B/0.png)\n\n通过这张图，我们可以初步了解git的工作流程，接下来将以这张图为基础，进行详细分析论述。\n\n### 思路分析：\n\n个人的GIT使用习惯，注意：不在master上面轻易进行提交，一般所有的工作步骤都放在develop分支上面进行，不做无意义的提交，所有提交最起码是能够通过编译的版本，有一定程度上的修改优化，且每次提交必须付上详细的commit说明。基于develop，如果平行进行多种不同类型版本的开发，则所有都建立相应的新分支dev_name，而基于dev_name，每个开发人员再次建立各自的分支，只有在完成相关开发后将各自分支合并到dev_name中。通过测试多个dev_name，选择最终确定的方案，将develop分支合并到某条dev_name上，继续开发，后续如果在遇到类似问题，继续重复上述步骤。默认的master分支只用来快速合并develop分支来确定发行版，对所有发行版都加入tag(release_name)。简单来说就是：GIT不断创建分支，master用来合并develop分支作为发行版发布；develop分支用来合并dev_name分支作为开发的主要分支；dev_name合并所有开发人员的各个提交的分支，在没有dev_name的情况下（即只有一个develop分支），develop分支用来合并所有开发人员的各个提交的分支。\n\n**git控制版本的过程就是分支不断提交合并的过程。**\n\n<!-- more -->\n\n\n### 版本控制步骤：\n\n- 对项目初始化版本库（注意不能是裸库，裸库只能远程下载查看，无法本地查看，类似的github和git服务就是这种裸库）\n- 编辑好相应的.gitignore文件，该文件用来忽略一些文件，不让提交，一般可以是非必要的工程文件，编译生成的文件等。（.git目录下也存在类似.gitignore的忽略文件，但该文件不能被提交和push，因此强烈建议使用.gitignore）\n- 进行第一次空工程的提交，主要将.gitignore提交给master。\n- 建立分支develop，将工作分支切换到develop上。\n- 进行相应的程序编辑和编译，完成后，提交版本库。（因为上面已经checkout到了develop，所以默认的提交就是到develop，不进行分支切换的话，以后默认也都在这个分支上面进行。）\n- 假如这时候需要建立多个版本进行分别开发，这时候需要建立多个dev_name分支（注意这边是建议对所有版本都建立新的分支，作为develop的分支进行开发测试，而develop只用于最后对他们做合并。），需要开发哪个版本就切换到哪条dev_name分支上面进行开发提交。\n- 假设多个版本开发测试完毕，用户需要某个功能的测试版本，则给该分支的某个版本再建立新分支test_release，然后打上tag标记，可以简单发布。\n- 然而项目仍然需要推进，最终你需要在所有测试版本中选择出最优的一个合并到develop分支上，做接下来的开发。\n- 在develop分支上进一步进行开发，假设现在不再仅仅是你一个人接手这个项目，而是多个人的团队，则需要基于develop建立多个分支，让每个单独负责其中的一个分支。每个人所要进行的工作都各自在自己的分支上面进行。假如这时团队成员都各自任务完成了，所有人都提交版本，这时则由组长专门将所有分支再次逐个合并到develop分支上，当然这部分可能会有冲突，需要手动合并。\n- 假如再次需要建立多个版本进行分别开发测试，这时同上述步骤一只，再次建立多个dev_name分支，然后基于每个dev_name，为每个组员生成多个dev_name的子分支，每个组员各负责一条子分支。组员完成工作后，各个分支的负责人再次将把所有分支合并到各自的dev_name上，当所有版本测试完毕后，组长再次将所有dev_name合并\ndevelop上。\n- 如此，开发过程中反复进行上述建立分支合并分支的操作。最终需要发布正式版本的时候，组长将develop的内容快速合并到master分支上，然后为这个节点打上tag（如：v1.0）。注意：master分支只用来快速合并和发布版本。\n\n上述步骤详细的导图：\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-28-%E9%80%9A%E8%BF%87git%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B/master.png)\n\n***\n\n> 参考链接：\n> http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\n> http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_\n","source":"_posts/2016/2016-09-28-通过git管理一个工程.md","raw":"---\nlayout: \"post\"\ntitle: \"通过git管理一个工程\"\ndate: \"2016-09-28 16:45\"\n---\n\n\nGIT虽然能够实现各种版本控制，且功能强大，可以做到随时切换版本，回退等各种功能，但过多的分支，无效的分支，杂乱的提交，无意义的命名等等问题，往往会让像我这样的初学者，异常头痛，网络上关于git的往往都是指导你各个命令如何去用，部分命令的使用场景等，但却缺少一个完整工程项目的管理步骤。部分大神的确总结出了自己的使用习惯，但却不是作为教程来陈述的，下面我会将自己的一些习惯进行总结，后续可能遇到更好的也还会不断的更改。\n\n下面是一张团队协作示意图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-28-%E9%80%9A%E8%BF%87git%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B/0.png)\n\n通过这张图，我们可以初步了解git的工作流程，接下来将以这张图为基础，进行详细分析论述。\n\n### 思路分析：\n\n个人的GIT使用习惯，注意：不在master上面轻易进行提交，一般所有的工作步骤都放在develop分支上面进行，不做无意义的提交，所有提交最起码是能够通过编译的版本，有一定程度上的修改优化，且每次提交必须付上详细的commit说明。基于develop，如果平行进行多种不同类型版本的开发，则所有都建立相应的新分支dev_name，而基于dev_name，每个开发人员再次建立各自的分支，只有在完成相关开发后将各自分支合并到dev_name中。通过测试多个dev_name，选择最终确定的方案，将develop分支合并到某条dev_name上，继续开发，后续如果在遇到类似问题，继续重复上述步骤。默认的master分支只用来快速合并develop分支来确定发行版，对所有发行版都加入tag(release_name)。简单来说就是：GIT不断创建分支，master用来合并develop分支作为发行版发布；develop分支用来合并dev_name分支作为开发的主要分支；dev_name合并所有开发人员的各个提交的分支，在没有dev_name的情况下（即只有一个develop分支），develop分支用来合并所有开发人员的各个提交的分支。\n\n**git控制版本的过程就是分支不断提交合并的过程。**\n\n<!-- more -->\n\n\n### 版本控制步骤：\n\n- 对项目初始化版本库（注意不能是裸库，裸库只能远程下载查看，无法本地查看，类似的github和git服务就是这种裸库）\n- 编辑好相应的.gitignore文件，该文件用来忽略一些文件，不让提交，一般可以是非必要的工程文件，编译生成的文件等。（.git目录下也存在类似.gitignore的忽略文件，但该文件不能被提交和push，因此强烈建议使用.gitignore）\n- 进行第一次空工程的提交，主要将.gitignore提交给master。\n- 建立分支develop，将工作分支切换到develop上。\n- 进行相应的程序编辑和编译，完成后，提交版本库。（因为上面已经checkout到了develop，所以默认的提交就是到develop，不进行分支切换的话，以后默认也都在这个分支上面进行。）\n- 假如这时候需要建立多个版本进行分别开发，这时候需要建立多个dev_name分支（注意这边是建议对所有版本都建立新的分支，作为develop的分支进行开发测试，而develop只用于最后对他们做合并。），需要开发哪个版本就切换到哪条dev_name分支上面进行开发提交。\n- 假设多个版本开发测试完毕，用户需要某个功能的测试版本，则给该分支的某个版本再建立新分支test_release，然后打上tag标记，可以简单发布。\n- 然而项目仍然需要推进，最终你需要在所有测试版本中选择出最优的一个合并到develop分支上，做接下来的开发。\n- 在develop分支上进一步进行开发，假设现在不再仅仅是你一个人接手这个项目，而是多个人的团队，则需要基于develop建立多个分支，让每个单独负责其中的一个分支。每个人所要进行的工作都各自在自己的分支上面进行。假如这时团队成员都各自任务完成了，所有人都提交版本，这时则由组长专门将所有分支再次逐个合并到develop分支上，当然这部分可能会有冲突，需要手动合并。\n- 假如再次需要建立多个版本进行分别开发测试，这时同上述步骤一只，再次建立多个dev_name分支，然后基于每个dev_name，为每个组员生成多个dev_name的子分支，每个组员各负责一条子分支。组员完成工作后，各个分支的负责人再次将把所有分支合并到各自的dev_name上，当所有版本测试完毕后，组长再次将所有dev_name合并\ndevelop上。\n- 如此，开发过程中反复进行上述建立分支合并分支的操作。最终需要发布正式版本的时候，组长将develop的内容快速合并到master分支上，然后为这个节点打上tag（如：v1.0）。注意：master分支只用来快速合并和发布版本。\n\n上述步骤详细的导图：\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-28-%E9%80%9A%E8%BF%87git%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B/master.png)\n\n***\n\n> 参考链接：\n> http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\n> http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_\n","slug":"2016/2016-09-28-通过git管理一个工程","published":1,"updated":"2016-12-16T01:48:46.738Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ai4002omumuepvwtl27","content":"<p>GIT虽然能够实现各种版本控制，且功能强大，可以做到随时切换版本，回退等各种功能，但过多的分支，无效的分支，杂乱的提交，无意义的命名等等问题，往往会让像我这样的初学者，异常头痛，网络上关于git的往往都是指导你各个命令如何去用，部分命令的使用场景等，但却缺少一个完整工程项目的管理步骤。部分大神的确总结出了自己的使用习惯，但却不是作为教程来陈述的，下面我会将自己的一些习惯进行总结，后续可能遇到更好的也还会不断的更改。</p>\n<p>下面是一张团队协作示意图：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-28-%E9%80%9A%E8%BF%87git%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B/0.png\" alt=\"\"></p>\n<p>通过这张图，我们可以初步了解git的工作流程，接下来将以这张图为基础，进行详细分析论述。</p>\n<h3 id=\"思路分析：\"><a href=\"#思路分析：\" class=\"headerlink\" title=\"思路分析：\"></a>思路分析：</h3><p>个人的GIT使用习惯，注意：不在master上面轻易进行提交，一般所有的工作步骤都放在develop分支上面进行，不做无意义的提交，所有提交最起码是能够通过编译的版本，有一定程度上的修改优化，且每次提交必须付上详细的commit说明。基于develop，如果平行进行多种不同类型版本的开发，则所有都建立相应的新分支dev_name，而基于dev_name，每个开发人员再次建立各自的分支，只有在完成相关开发后将各自分支合并到dev_name中。通过测试多个dev_name，选择最终确定的方案，将develop分支合并到某条dev_name上，继续开发，后续如果在遇到类似问题，继续重复上述步骤。默认的master分支只用来快速合并develop分支来确定发行版，对所有发行版都加入tag(release_name)。简单来说就是：GIT不断创建分支，master用来合并develop分支作为发行版发布；develop分支用来合并dev_name分支作为开发的主要分支；dev_name合并所有开发人员的各个提交的分支，在没有dev_name的情况下（即只有一个develop分支），develop分支用来合并所有开发人员的各个提交的分支。</p>\n<p><strong>git控制版本的过程就是分支不断提交合并的过程。</strong></p>\n<a id=\"more\"></a>\n<h3 id=\"版本控制步骤：\"><a href=\"#版本控制步骤：\" class=\"headerlink\" title=\"版本控制步骤：\"></a>版本控制步骤：</h3><ul>\n<li>对项目初始化版本库（注意不能是裸库，裸库只能远程下载查看，无法本地查看，类似的github和git服务就是这种裸库）</li>\n<li>编辑好相应的.gitignore文件，该文件用来忽略一些文件，不让提交，一般可以是非必要的工程文件，编译生成的文件等。（.git目录下也存在类似.gitignore的忽略文件，但该文件不能被提交和push，因此强烈建议使用.gitignore）</li>\n<li>进行第一次空工程的提交，主要将.gitignore提交给master。</li>\n<li>建立分支develop，将工作分支切换到develop上。</li>\n<li>进行相应的程序编辑和编译，完成后，提交版本库。（因为上面已经checkout到了develop，所以默认的提交就是到develop，不进行分支切换的话，以后默认也都在这个分支上面进行。）</li>\n<li>假如这时候需要建立多个版本进行分别开发，这时候需要建立多个dev_name分支（注意这边是建议对所有版本都建立新的分支，作为develop的分支进行开发测试，而develop只用于最后对他们做合并。），需要开发哪个版本就切换到哪条dev_name分支上面进行开发提交。</li>\n<li>假设多个版本开发测试完毕，用户需要某个功能的测试版本，则给该分支的某个版本再建立新分支test_release，然后打上tag标记，可以简单发布。</li>\n<li>然而项目仍然需要推进，最终你需要在所有测试版本中选择出最优的一个合并到develop分支上，做接下来的开发。</li>\n<li>在develop分支上进一步进行开发，假设现在不再仅仅是你一个人接手这个项目，而是多个人的团队，则需要基于develop建立多个分支，让每个单独负责其中的一个分支。每个人所要进行的工作都各自在自己的分支上面进行。假如这时团队成员都各自任务完成了，所有人都提交版本，这时则由组长专门将所有分支再次逐个合并到develop分支上，当然这部分可能会有冲突，需要手动合并。</li>\n<li>假如再次需要建立多个版本进行分别开发测试，这时同上述步骤一只，再次建立多个dev_name分支，然后基于每个dev_name，为每个组员生成多个dev_name的子分支，每个组员各负责一条子分支。组员完成工作后，各个分支的负责人再次将把所有分支合并到各自的dev_name上，当所有版本测试完毕后，组长再次将所有dev_name合并<br>develop上。</li>\n<li>如此，开发过程中反复进行上述建立分支合并分支的操作。最终需要发布正式版本的时候，组长将develop的内容快速合并到master分支上，然后为这个节点打上tag（如：v1.0）。注意：master分支只用来快速合并和发布版本。</li>\n</ul>\n<p>上述步骤详细的导图：<br><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-28-%E9%80%9A%E8%BF%87git%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B/master.png\" alt=\"\"></p>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"external\">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a><br><a href=\"http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_\" target=\"_blank\" rel=\"external\">http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_</a></p>\n</blockquote>\n","excerpt":"<p>GIT虽然能够实现各种版本控制，且功能强大，可以做到随时切换版本，回退等各种功能，但过多的分支，无效的分支，杂乱的提交，无意义的命名等等问题，往往会让像我这样的初学者，异常头痛，网络上关于git的往往都是指导你各个命令如何去用，部分命令的使用场景等，但却缺少一个完整工程项目的管理步骤。部分大神的确总结出了自己的使用习惯，但却不是作为教程来陈述的，下面我会将自己的一些习惯进行总结，后续可能遇到更好的也还会不断的更改。</p>\n<p>下面是一张团队协作示意图：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-28-%E9%80%9A%E8%BF%87git%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B/0.png\" alt=\"\"></p>\n<p>通过这张图，我们可以初步了解git的工作流程，接下来将以这张图为基础，进行详细分析论述。</p>\n<h3 id=\"思路分析：\"><a href=\"#思路分析：\" class=\"headerlink\" title=\"思路分析：\"></a>思路分析：</h3><p>个人的GIT使用习惯，注意：不在master上面轻易进行提交，一般所有的工作步骤都放在develop分支上面进行，不做无意义的提交，所有提交最起码是能够通过编译的版本，有一定程度上的修改优化，且每次提交必须付上详细的commit说明。基于develop，如果平行进行多种不同类型版本的开发，则所有都建立相应的新分支dev_name，而基于dev_name，每个开发人员再次建立各自的分支，只有在完成相关开发后将各自分支合并到dev_name中。通过测试多个dev_name，选择最终确定的方案，将develop分支合并到某条dev_name上，继续开发，后续如果在遇到类似问题，继续重复上述步骤。默认的master分支只用来快速合并develop分支来确定发行版，对所有发行版都加入tag(release_name)。简单来说就是：GIT不断创建分支，master用来合并develop分支作为发行版发布；develop分支用来合并dev_name分支作为开发的主要分支；dev_name合并所有开发人员的各个提交的分支，在没有dev_name的情况下（即只有一个develop分支），develop分支用来合并所有开发人员的各个提交的分支。</p>\n<p><strong>git控制版本的过程就是分支不断提交合并的过程。</strong></p>","more":"<h3 id=\"版本控制步骤：\"><a href=\"#版本控制步骤：\" class=\"headerlink\" title=\"版本控制步骤：\"></a>版本控制步骤：</h3><ul>\n<li>对项目初始化版本库（注意不能是裸库，裸库只能远程下载查看，无法本地查看，类似的github和git服务就是这种裸库）</li>\n<li>编辑好相应的.gitignore文件，该文件用来忽略一些文件，不让提交，一般可以是非必要的工程文件，编译生成的文件等。（.git目录下也存在类似.gitignore的忽略文件，但该文件不能被提交和push，因此强烈建议使用.gitignore）</li>\n<li>进行第一次空工程的提交，主要将.gitignore提交给master。</li>\n<li>建立分支develop，将工作分支切换到develop上。</li>\n<li>进行相应的程序编辑和编译，完成后，提交版本库。（因为上面已经checkout到了develop，所以默认的提交就是到develop，不进行分支切换的话，以后默认也都在这个分支上面进行。）</li>\n<li>假如这时候需要建立多个版本进行分别开发，这时候需要建立多个dev_name分支（注意这边是建议对所有版本都建立新的分支，作为develop的分支进行开发测试，而develop只用于最后对他们做合并。），需要开发哪个版本就切换到哪条dev_name分支上面进行开发提交。</li>\n<li>假设多个版本开发测试完毕，用户需要某个功能的测试版本，则给该分支的某个版本再建立新分支test_release，然后打上tag标记，可以简单发布。</li>\n<li>然而项目仍然需要推进，最终你需要在所有测试版本中选择出最优的一个合并到develop分支上，做接下来的开发。</li>\n<li>在develop分支上进一步进行开发，假设现在不再仅仅是你一个人接手这个项目，而是多个人的团队，则需要基于develop建立多个分支，让每个单独负责其中的一个分支。每个人所要进行的工作都各自在自己的分支上面进行。假如这时团队成员都各自任务完成了，所有人都提交版本，这时则由组长专门将所有分支再次逐个合并到develop分支上，当然这部分可能会有冲突，需要手动合并。</li>\n<li>假如再次需要建立多个版本进行分别开发测试，这时同上述步骤一只，再次建立多个dev_name分支，然后基于每个dev_name，为每个组员生成多个dev_name的子分支，每个组员各负责一条子分支。组员完成工作后，各个分支的负责人再次将把所有分支合并到各自的dev_name上，当所有版本测试完毕后，组长再次将所有dev_name合并<br>develop上。</li>\n<li>如此，开发过程中反复进行上述建立分支合并分支的操作。最终需要发布正式版本的时候，组长将develop的内容快速合并到master分支上，然后为这个节点打上tag（如：v1.0）。注意：master分支只用来快速合并和发布版本。</li>\n</ul>\n<p>上述步骤详细的导图：<br><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-09-28-%E9%80%9A%E8%BF%87git%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B/master.png\" alt=\"\"></p>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a><br><a href=\"http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_\">http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_</a></p>\n</blockquote>"},{"layout":"post","title":"GP22芯片详解","date":"2016-09-30T14:55:00.000Z","_content":"\n\nGP22是一款工业计算时间的芯片，由于其精度高在几十ps级别，所以被广泛的应用在气表水表上面。本人由于工作上面的原因，有机会接触到这款芯片，但该芯片的研究学习并不简单，由于有多个寄存器，再加上寄存器的配置复用位数很多，所以注定这款芯片不简单，另外一些模拟数字电路，晶振校准能耗，采样精度等等各种功能很是繁杂，所以可以说这款芯片已经是类似于51单片机这种需要学习研究一下的芯片了。这篇文章将不断地总结记录，在使用这种芯片的重点，已经一些问题的总结。\n\n\n<!-- more -->\n\n\n***\n\n> 参考链接：\n> \n","source":"_posts/2016/2016-09-30-GP22芯片详解.md","raw":"---\nlayout: \"post\"\ntitle: \"GP22芯片详解\"\ndate: \"2016-09-30 22:55\"\n---\n\n\nGP22是一款工业计算时间的芯片，由于其精度高在几十ps级别，所以被广泛的应用在气表水表上面。本人由于工作上面的原因，有机会接触到这款芯片，但该芯片的研究学习并不简单，由于有多个寄存器，再加上寄存器的配置复用位数很多，所以注定这款芯片不简单，另外一些模拟数字电路，晶振校准能耗，采样精度等等各种功能很是繁杂，所以可以说这款芯片已经是类似于51单片机这种需要学习研究一下的芯片了。这篇文章将不断地总结记录，在使用这种芯片的重点，已经一些问题的总结。\n\n\n<!-- more -->\n\n\n***\n\n> 参考链接：\n> \n","slug":"2016/2016-09-30-GP22芯片详解","published":1,"updated":"2016-12-16T01:48:50.654Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ai5002pmumu16wbyall","content":"<p>GP22是一款工业计算时间的芯片，由于其精度高在几十ps级别，所以被广泛的应用在气表水表上面。本人由于工作上面的原因，有机会接触到这款芯片，但该芯片的研究学习并不简单，由于有多个寄存器，再加上寄存器的配置复用位数很多，所以注定这款芯片不简单，另外一些模拟数字电路，晶振校准能耗，采样精度等等各种功能很是繁杂，所以可以说这款芯片已经是类似于51单片机这种需要学习研究一下的芯片了。这篇文章将不断地总结记录，在使用这种芯片的重点，已经一些问题的总结。</p>\n<a id=\"more\"></a>\n<hr>\n<blockquote>\n<p>参考链接：</p>\n</blockquote>\n","excerpt":"<p>GP22是一款工业计算时间的芯片，由于其精度高在几十ps级别，所以被广泛的应用在气表水表上面。本人由于工作上面的原因，有机会接触到这款芯片，但该芯片的研究学习并不简单，由于有多个寄存器，再加上寄存器的配置复用位数很多，所以注定这款芯片不简单，另外一些模拟数字电路，晶振校准能耗，采样精度等等各种功能很是繁杂，所以可以说这款芯片已经是类似于51单片机这种需要学习研究一下的芯片了。这篇文章将不断地总结记录，在使用这种芯片的重点，已经一些问题的总结。</p>","more":"<hr>\n<blockquote>\n<p>参考链接：</p>\n</blockquote>"},{"layout":"post","title":"ubuntu下安装搜狗输入法","date":"2016-10-01T14:55:00.000Z","_content":"\n\n一个系统输入法很重要，尤其对于中文输入法来说，而国内目前而言，肯定是搜狗的输入法最本土化，制作的也最出众了，主要还是有网络词库的功能，除了无法实现账户登录同步外，其他基本和windows没有任何区别。\n\n\n搜狗输入法的配置针对不同的系统有时还真有点小麻烦，本来是不打算写这篇文章的，因为之前的几次配置都是轻松的完成了，但这次就花了个吧小时都没搞定，主要原因还是对ubuntu图形界面一些设置位置无法找到，加上搜狗输入依赖诸如fcitx之类的软件并不能即装即用。错误往往出在某一部做的不够完善，下面列举出详细安装配置步骤。\n\n### 安装步骤\n\n- 从[官网](http://pinyin.sogou.com/linux/?r=pinyin)下载下来[sogou for linux](http://cdn2.ime.sogou.com/dl/index/1475147394/sogoupinyin_2.1.0.0082_amd64.deb?st=C24ANiLdi7HwWFenlPkG-w&e=1476682538&fn=sogoupinyin_2.1.0.0082_amd64.deb)\n- 注意搜狗拼音依赖于fcitx框架，但这边使用的是ubuntu 16.04已经预装了fcitx，如果是更老的版本则需要手动安装fcitx，[安装方法](http://pinyin.sogou.com/linux/help.php)。\n- 接下来需要选择默认的键盘输入系统，在ubuntu的所有设置（All Settings）中选择语言支持（Language Support）将Keyboard input method system：fcitx。\n- 配置fcitx，可以通过ubuntu的软件直接打开，也可以终端输入运行fcitx-config-gtk3。使用左下角的添加按钮，手动添加sogou输入法，*注意：当前输入法如果不是中文，则需要手动将默认勾选的only show current language去掉，然后才可以找出搜狗拼音，同时需要保留一个默认的英文输入法*。\n- 完成以上步骤后，基本完成了搜狗拼音的安装，已经可以简单的使用了。\n\n<!-- more -->\n\n\n### 简单配置\n\n- 隐藏状态栏\n- 中英文切换使用ctrl键，切换时保留输入窗口字符上屏，个人[将ctrl和caps lock进行互换](http://noparkinghere.site/posts/Caps_Lock%E4%B8%8E%E5%8F%B3Ctrl%E4%BA%92%E6%8D%A2.html)了，这样切换起来更加方便\n- 候选词9个，模糊拼音等 \n\n### 存在问题\n\n每次开机重启后，第一次使用搜狗都会出现无法加载，只是一个小框显示正在输入，不载入搜狗的皮肤也不显示中文，然后等几秒钟状态栏会切换一次fcitx，再切换回搜狗拼音，就可以使用了。有没有什么解决问题的办法？系统是ubuntu16.04，WM用的是awesome。\n\n*如果有兴趣，也可以去搜狗拼音的论坛看一下，但有价值的帖子较少，论坛比较混杂。*\n\n**(2016-10-30)上述问题已经解决，具体方法：**\n\n- 查看fcitx帮助文档，得知该软件是个汉字管理软件，因此将fcitx -d加入开启自启动进程。\n- 使用ps -aux | grep fcitx和ps -aux | grep sogou查看当前运行的进程。\n- 在任意地方开始使用搜狗输入法一段时间，然后再次执行ps -aux | grep fcitx和ps -aux | grep sogou，将该指令和上次执行过的比对，发现上次执行缺少sogou-qimpanel，人为将该指令加入到awesome的rc.lua开机单次执行中去。\n\n**搜狗拼音输入法 v2.1.0.0082 存在 bug：**\n\n- 该版本存在较大的问题，主要是输入中文 jinjin 时，软件会自动崩溃，需要重启 fcitx 和 搜狗拼音\n\n\n***\n\n> 参考链接：\n> http://pinyin.sogou.com/bbs/forum.php?mod=forumdisplay&fid=115\n","source":"_posts/2016/2016-10-01-ubuntu下安装搜狗输入法.md","raw":"---\nlayout: \"post\"\ntitle: \"ubuntu下安装搜狗输入法\"\ndate: \"2016-10-01 22:55\"\n---\n\n\n一个系统输入法很重要，尤其对于中文输入法来说，而国内目前而言，肯定是搜狗的输入法最本土化，制作的也最出众了，主要还是有网络词库的功能，除了无法实现账户登录同步外，其他基本和windows没有任何区别。\n\n\n搜狗输入法的配置针对不同的系统有时还真有点小麻烦，本来是不打算写这篇文章的，因为之前的几次配置都是轻松的完成了，但这次就花了个吧小时都没搞定，主要原因还是对ubuntu图形界面一些设置位置无法找到，加上搜狗输入依赖诸如fcitx之类的软件并不能即装即用。错误往往出在某一部做的不够完善，下面列举出详细安装配置步骤。\n\n### 安装步骤\n\n- 从[官网](http://pinyin.sogou.com/linux/?r=pinyin)下载下来[sogou for linux](http://cdn2.ime.sogou.com/dl/index/1475147394/sogoupinyin_2.1.0.0082_amd64.deb?st=C24ANiLdi7HwWFenlPkG-w&e=1476682538&fn=sogoupinyin_2.1.0.0082_amd64.deb)\n- 注意搜狗拼音依赖于fcitx框架，但这边使用的是ubuntu 16.04已经预装了fcitx，如果是更老的版本则需要手动安装fcitx，[安装方法](http://pinyin.sogou.com/linux/help.php)。\n- 接下来需要选择默认的键盘输入系统，在ubuntu的所有设置（All Settings）中选择语言支持（Language Support）将Keyboard input method system：fcitx。\n- 配置fcitx，可以通过ubuntu的软件直接打开，也可以终端输入运行fcitx-config-gtk3。使用左下角的添加按钮，手动添加sogou输入法，*注意：当前输入法如果不是中文，则需要手动将默认勾选的only show current language去掉，然后才可以找出搜狗拼音，同时需要保留一个默认的英文输入法*。\n- 完成以上步骤后，基本完成了搜狗拼音的安装，已经可以简单的使用了。\n\n<!-- more -->\n\n\n### 简单配置\n\n- 隐藏状态栏\n- 中英文切换使用ctrl键，切换时保留输入窗口字符上屏，个人[将ctrl和caps lock进行互换](http://noparkinghere.site/posts/Caps_Lock%E4%B8%8E%E5%8F%B3Ctrl%E4%BA%92%E6%8D%A2.html)了，这样切换起来更加方便\n- 候选词9个，模糊拼音等 \n\n### 存在问题\n\n每次开机重启后，第一次使用搜狗都会出现无法加载，只是一个小框显示正在输入，不载入搜狗的皮肤也不显示中文，然后等几秒钟状态栏会切换一次fcitx，再切换回搜狗拼音，就可以使用了。有没有什么解决问题的办法？系统是ubuntu16.04，WM用的是awesome。\n\n*如果有兴趣，也可以去搜狗拼音的论坛看一下，但有价值的帖子较少，论坛比较混杂。*\n\n**(2016-10-30)上述问题已经解决，具体方法：**\n\n- 查看fcitx帮助文档，得知该软件是个汉字管理软件，因此将fcitx -d加入开启自启动进程。\n- 使用ps -aux | grep fcitx和ps -aux | grep sogou查看当前运行的进程。\n- 在任意地方开始使用搜狗输入法一段时间，然后再次执行ps -aux | grep fcitx和ps -aux | grep sogou，将该指令和上次执行过的比对，发现上次执行缺少sogou-qimpanel，人为将该指令加入到awesome的rc.lua开机单次执行中去。\n\n**搜狗拼音输入法 v2.1.0.0082 存在 bug：**\n\n- 该版本存在较大的问题，主要是输入中文 jinjin 时，软件会自动崩溃，需要重启 fcitx 和 搜狗拼音\n\n\n***\n\n> 参考链接：\n> http://pinyin.sogou.com/bbs/forum.php?mod=forumdisplay&fid=115\n","slug":"2016/2016-10-01-ubuntu下安装搜狗输入法","published":1,"updated":"2017-01-25T03:21:29.223Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ai6002qmumurv53slt6","content":"<p>一个系统输入法很重要，尤其对于中文输入法来说，而国内目前而言，肯定是搜狗的输入法最本土化，制作的也最出众了，主要还是有网络词库的功能，除了无法实现账户登录同步外，其他基本和windows没有任何区别。</p>\n<p>搜狗输入法的配置针对不同的系统有时还真有点小麻烦，本来是不打算写这篇文章的，因为之前的几次配置都是轻松的完成了，但这次就花了个吧小时都没搞定，主要原因还是对ubuntu图形界面一些设置位置无法找到，加上搜狗输入依赖诸如fcitx之类的软件并不能即装即用。错误往往出在某一部做的不够完善，下面列举出详细安装配置步骤。</p>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><ul>\n<li>从<a href=\"http://pinyin.sogou.com/linux/?r=pinyin\" target=\"_blank\" rel=\"external\">官网</a>下载下来<a href=\"http://cdn2.ime.sogou.com/dl/index/1475147394/sogoupinyin_2.1.0.0082_amd64.deb?st=C24ANiLdi7HwWFenlPkG-w&amp;e=1476682538&amp;fn=sogoupinyin_2.1.0.0082_amd64.deb\" target=\"_blank\" rel=\"external\">sogou for linux</a></li>\n<li>注意搜狗拼音依赖于fcitx框架，但这边使用的是ubuntu 16.04已经预装了fcitx，如果是更老的版本则需要手动安装fcitx，<a href=\"http://pinyin.sogou.com/linux/help.php\" target=\"_blank\" rel=\"external\">安装方法</a>。</li>\n<li>接下来需要选择默认的键盘输入系统，在ubuntu的所有设置（All Settings）中选择语言支持（Language Support）将Keyboard input method system：fcitx。</li>\n<li>配置fcitx，可以通过ubuntu的软件直接打开，也可以终端输入运行fcitx-config-gtk3。使用左下角的添加按钮，手动添加sogou输入法，<em>注意：当前输入法如果不是中文，则需要手动将默认勾选的only show current language去掉，然后才可以找出搜狗拼音，同时需要保留一个默认的英文输入法</em>。</li>\n<li>完成以上步骤后，基本完成了搜狗拼音的安装，已经可以简单的使用了。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"简单配置\"><a href=\"#简单配置\" class=\"headerlink\" title=\"简单配置\"></a>简单配置</h3><ul>\n<li>隐藏状态栏</li>\n<li>中英文切换使用ctrl键，切换时保留输入窗口字符上屏，个人<a href=\"http://noparkinghere.site/posts/Caps_Lock%E4%B8%8E%E5%8F%B3Ctrl%E4%BA%92%E6%8D%A2.html\" target=\"_blank\" rel=\"external\">将ctrl和caps lock进行互换</a>了，这样切换起来更加方便</li>\n<li>候选词9个，模糊拼音等 </li>\n</ul>\n<h3 id=\"存在问题\"><a href=\"#存在问题\" class=\"headerlink\" title=\"存在问题\"></a>存在问题</h3><p>每次开机重启后，第一次使用搜狗都会出现无法加载，只是一个小框显示正在输入，不载入搜狗的皮肤也不显示中文，然后等几秒钟状态栏会切换一次fcitx，再切换回搜狗拼音，就可以使用了。有没有什么解决问题的办法？系统是ubuntu16.04，WM用的是awesome。</p>\n<p><em>如果有兴趣，也可以去搜狗拼音的论坛看一下，但有价值的帖子较少，论坛比较混杂。</em></p>\n<p><strong>(2016-10-30)上述问题已经解决，具体方法：</strong></p>\n<ul>\n<li>查看fcitx帮助文档，得知该软件是个汉字管理软件，因此将fcitx -d加入开启自启动进程。</li>\n<li>使用ps -aux | grep fcitx和ps -aux | grep sogou查看当前运行的进程。</li>\n<li>在任意地方开始使用搜狗输入法一段时间，然后再次执行ps -aux | grep fcitx和ps -aux | grep sogou，将该指令和上次执行过的比对，发现上次执行缺少sogou-qimpanel，人为将该指令加入到awesome的rc.lua开机单次执行中去。</li>\n</ul>\n<p><strong>搜狗拼音输入法 v2.1.0.0082 存在 bug：</strong></p>\n<ul>\n<li>该版本存在较大的问题，主要是输入中文 jinjin 时，软件会自动崩溃，需要重启 fcitx 和 搜狗拼音</li>\n</ul>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://pinyin.sogou.com/bbs/forum.php?mod=forumdisplay&amp;fid=115\" target=\"_blank\" rel=\"external\">http://pinyin.sogou.com/bbs/forum.php?mod=forumdisplay&amp;fid=115</a></p>\n</blockquote>\n","excerpt":"<p>一个系统输入法很重要，尤其对于中文输入法来说，而国内目前而言，肯定是搜狗的输入法最本土化，制作的也最出众了，主要还是有网络词库的功能，除了无法实现账户登录同步外，其他基本和windows没有任何区别。</p>\n<p>搜狗输入法的配置针对不同的系统有时还真有点小麻烦，本来是不打算写这篇文章的，因为之前的几次配置都是轻松的完成了，但这次就花了个吧小时都没搞定，主要原因还是对ubuntu图形界面一些设置位置无法找到，加上搜狗输入依赖诸如fcitx之类的软件并不能即装即用。错误往往出在某一部做的不够完善，下面列举出详细安装配置步骤。</p>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><ul>\n<li>从<a href=\"http://pinyin.sogou.com/linux/?r=pinyin\">官网</a>下载下来<a href=\"http://cdn2.ime.sogou.com/dl/index/1475147394/sogoupinyin_2.1.0.0082_amd64.deb?st=C24ANiLdi7HwWFenlPkG-w&amp;e=1476682538&amp;fn=sogoupinyin_2.1.0.0082_amd64.deb\">sogou for linux</a></li>\n<li>注意搜狗拼音依赖于fcitx框架，但这边使用的是ubuntu 16.04已经预装了fcitx，如果是更老的版本则需要手动安装fcitx，<a href=\"http://pinyin.sogou.com/linux/help.php\">安装方法</a>。</li>\n<li>接下来需要选择默认的键盘输入系统，在ubuntu的所有设置（All Settings）中选择语言支持（Language Support）将Keyboard input method system：fcitx。</li>\n<li>配置fcitx，可以通过ubuntu的软件直接打开，也可以终端输入运行fcitx-config-gtk3。使用左下角的添加按钮，手动添加sogou输入法，<em>注意：当前输入法如果不是中文，则需要手动将默认勾选的only show current language去掉，然后才可以找出搜狗拼音，同时需要保留一个默认的英文输入法</em>。</li>\n<li>完成以上步骤后，基本完成了搜狗拼音的安装，已经可以简单的使用了。</li>\n</ul>","more":"<h3 id=\"简单配置\"><a href=\"#简单配置\" class=\"headerlink\" title=\"简单配置\"></a>简单配置</h3><ul>\n<li>隐藏状态栏</li>\n<li>中英文切换使用ctrl键，切换时保留输入窗口字符上屏，个人<a href=\"http://noparkinghere.site/posts/Caps_Lock%E4%B8%8E%E5%8F%B3Ctrl%E4%BA%92%E6%8D%A2.html\">将ctrl和caps lock进行互换</a>了，这样切换起来更加方便</li>\n<li>候选词9个，模糊拼音等 </li>\n</ul>\n<h3 id=\"存在问题\"><a href=\"#存在问题\" class=\"headerlink\" title=\"存在问题\"></a>存在问题</h3><p>每次开机重启后，第一次使用搜狗都会出现无法加载，只是一个小框显示正在输入，不载入搜狗的皮肤也不显示中文，然后等几秒钟状态栏会切换一次fcitx，再切换回搜狗拼音，就可以使用了。有没有什么解决问题的办法？系统是ubuntu16.04，WM用的是awesome。</p>\n<p><em>如果有兴趣，也可以去搜狗拼音的论坛看一下，但有价值的帖子较少，论坛比较混杂。</em></p>\n<p><strong>(2016-10-30)上述问题已经解决，具体方法：</strong></p>\n<ul>\n<li>查看fcitx帮助文档，得知该软件是个汉字管理软件，因此将fcitx -d加入开启自启动进程。</li>\n<li>使用ps -aux | grep fcitx和ps -aux | grep sogou查看当前运行的进程。</li>\n<li>在任意地方开始使用搜狗输入法一段时间，然后再次执行ps -aux | grep fcitx和ps -aux | grep sogou，将该指令和上次执行过的比对，发现上次执行缺少sogou-qimpanel，人为将该指令加入到awesome的rc.lua开机单次执行中去。</li>\n</ul>\n<p><strong>搜狗拼音输入法 v2.1.0.0082 存在 bug：</strong></p>\n<ul>\n<li>该版本存在较大的问题，主要是输入中文 jinjin 时，软件会自动崩溃，需要重启 fcitx 和 搜狗拼音</li>\n</ul>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://pinyin.sogou.com/bbs/forum.php?mod=forumdisplay&amp;fid=115\">http://pinyin.sogou.com/bbs/forum.php?mod=forumdisplay&amp;fid=115</a></p>\n</blockquote>"},{"layout":"post","title":"多种电平的区分","date":"2016-10-09T13:35:00.000Z","_content":"\n**电平**就是指电路中两点或几点在相同阻抗下电量的相对比值，即电量水平。常用逻辑电平：有TTL、CMOS、LVTTL、ECL、PECL、GTL；RS232、RS422、LVDS等。\n\n### TTL电平\n\nTTL和CMOS的逻辑电平按典型电压可分为四类：5V系列（5V TTL和5V CMOS）、3.3V系列，2.5V系列和1.8V系列。\n\n- 5V TTL和5V CMOS逻辑电平是通用的逻辑电平。\n- 3.3V及以下的逻辑电平被称为低电压逻辑电平，常用的为LVTTL电平。\n- 低电压的逻辑电平还有2.5V和1.8V两种。\n\n\n<!-- more -->\n\n\n\n### RS232电平\n\n电脑的串口是标准RS232电平，最高电压 可达 +15V 或 -15V\n\n### RS485电平\n\n\n> 参考链接：\n> http://baike.baidu.com/link?url=UVcbZUUncOJC2yUDXBsf57HftheFOg6HGbIJ44CWrfuYCFaNZWefP8lWY9ra71kli9F_YalPAgV8h83yDpP_hJFk4yaasIizwquDUBaXWeO\n","source":"_posts/2016/2016-10-09-多种电平的区分.md","raw":"---\nlayout: \"post\"\ntitle: \"多种电平的区分\"\ndate: \"2016-10-09 21:35\"\n---\n\n**电平**就是指电路中两点或几点在相同阻抗下电量的相对比值，即电量水平。常用逻辑电平：有TTL、CMOS、LVTTL、ECL、PECL、GTL；RS232、RS422、LVDS等。\n\n### TTL电平\n\nTTL和CMOS的逻辑电平按典型电压可分为四类：5V系列（5V TTL和5V CMOS）、3.3V系列，2.5V系列和1.8V系列。\n\n- 5V TTL和5V CMOS逻辑电平是通用的逻辑电平。\n- 3.3V及以下的逻辑电平被称为低电压逻辑电平，常用的为LVTTL电平。\n- 低电压的逻辑电平还有2.5V和1.8V两种。\n\n\n<!-- more -->\n\n\n\n### RS232电平\n\n电脑的串口是标准RS232电平，最高电压 可达 +15V 或 -15V\n\n### RS485电平\n\n\n> 参考链接：\n> http://baike.baidu.com/link?url=UVcbZUUncOJC2yUDXBsf57HftheFOg6HGbIJ44CWrfuYCFaNZWefP8lWY9ra71kli9F_YalPAgV8h83yDpP_hJFk4yaasIizwquDUBaXWeO\n","slug":"2016/2016-10-09-多种电平的区分","published":1,"updated":"2016-12-16T01:49:03.446Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ai7002rmumuvkh7uw39","content":"<p><strong>电平</strong>就是指电路中两点或几点在相同阻抗下电量的相对比值，即电量水平。常用逻辑电平：有TTL、CMOS、LVTTL、ECL、PECL、GTL；RS232、RS422、LVDS等。</p>\n<h3 id=\"TTL电平\"><a href=\"#TTL电平\" class=\"headerlink\" title=\"TTL电平\"></a>TTL电平</h3><p>TTL和CMOS的逻辑电平按典型电压可分为四类：5V系列（5V TTL和5V CMOS）、3.3V系列，2.5V系列和1.8V系列。</p>\n<ul>\n<li>5V TTL和5V CMOS逻辑电平是通用的逻辑电平。</li>\n<li>3.3V及以下的逻辑电平被称为低电压逻辑电平，常用的为LVTTL电平。</li>\n<li>低电压的逻辑电平还有2.5V和1.8V两种。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"RS232电平\"><a href=\"#RS232电平\" class=\"headerlink\" title=\"RS232电平\"></a>RS232电平</h3><p>电脑的串口是标准RS232电平，最高电压 可达 +15V 或 -15V</p>\n<h3 id=\"RS485电平\"><a href=\"#RS485电平\" class=\"headerlink\" title=\"RS485电平\"></a>RS485电平</h3><blockquote>\n<p>参考链接：<br><a href=\"http://baike.baidu.com/link?url=UVcbZUUncOJC2yUDXBsf57HftheFOg6HGbIJ44CWrfuYCFaNZWefP8lWY9ra71kli9F_YalPAgV8h83yDpP_hJFk4yaasIizwquDUBaXWeO\" target=\"_blank\" rel=\"external\">http://baike.baidu.com/link?url=UVcbZUUncOJC2yUDXBsf57HftheFOg6HGbIJ44CWrfuYCFaNZWefP8lWY9ra71kli9F_YalPAgV8h83yDpP_hJFk4yaasIizwquDUBaXWeO</a></p>\n</blockquote>\n","excerpt":"<p><strong>电平</strong>就是指电路中两点或几点在相同阻抗下电量的相对比值，即电量水平。常用逻辑电平：有TTL、CMOS、LVTTL、ECL、PECL、GTL；RS232、RS422、LVDS等。</p>\n<h3 id=\"TTL电平\"><a href=\"#TTL电平\" class=\"headerlink\" title=\"TTL电平\"></a>TTL电平</h3><p>TTL和CMOS的逻辑电平按典型电压可分为四类：5V系列（5V TTL和5V CMOS）、3.3V系列，2.5V系列和1.8V系列。</p>\n<ul>\n<li>5V TTL和5V CMOS逻辑电平是通用的逻辑电平。</li>\n<li>3.3V及以下的逻辑电平被称为低电压逻辑电平，常用的为LVTTL电平。</li>\n<li>低电压的逻辑电平还有2.5V和1.8V两种。</li>\n</ul>","more":"<h3 id=\"RS232电平\"><a href=\"#RS232电平\" class=\"headerlink\" title=\"RS232电平\"></a>RS232电平</h3><p>电脑的串口是标准RS232电平，最高电压 可达 +15V 或 -15V</p>\n<h3 id=\"RS485电平\"><a href=\"#RS485电平\" class=\"headerlink\" title=\"RS485电平\"></a>RS485电平</h3><blockquote>\n<p>参考链接：<br><a href=\"http://baike.baidu.com/link?url=UVcbZUUncOJC2yUDXBsf57HftheFOg6HGbIJ44CWrfuYCFaNZWefP8lWY9ra71kli9F_YalPAgV8h83yDpP_hJFk4yaasIizwquDUBaXWeO\">http://baike.baidu.com/link?url=UVcbZUUncOJC2yUDXBsf57HftheFOg6HGbIJ44CWrfuYCFaNZWefP8lWY9ra71kli9F_YalPAgV8h83yDpP_hJFk4yaasIizwquDUBaXWeO</a></p>\n</blockquote>"},{"layout":"post","title":"杂谈小纪","date":"2016-10-17T05:55:00.000Z","_content":"\n2016转眼又快结束，这个月加上国庆休假一下子又过去了半个多月，直到今天才开始上班。今年除了工作上面的几个项目进一步完善外，这边为16年最后几个月制定一个小计划：\n\n- 按照自己的风格，为神州王开发板写一套完整的学习案例，并同步到github。\n- 学习研究python，以视频文档和案例学习为主。\n- 装修自己的blog\n\n<!-- more -->\n","source":"_posts/2016/2016-10-17-杂谈小纪.md","raw":"---\nlayout: \"post\"\ntitle: \"杂谈小纪\"\ndate: \"2016-10-17 13:55\"\n---\n\n2016转眼又快结束，这个月加上国庆休假一下子又过去了半个多月，直到今天才开始上班。今年除了工作上面的几个项目进一步完善外，这边为16年最后几个月制定一个小计划：\n\n- 按照自己的风格，为神州王开发板写一套完整的学习案例，并同步到github。\n- 学习研究python，以视频文档和案例学习为主。\n- 装修自己的blog\n\n<!-- more -->\n","slug":"2016/2016-10-17-杂谈小纪","published":1,"updated":"2016-12-16T01:49:09.538Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ai8002smumunuxpmfdx","content":"<p>2016转眼又快结束，这个月加上国庆休假一下子又过去了半个多月，直到今天才开始上班。今年除了工作上面的几个项目进一步完善外，这边为16年最后几个月制定一个小计划：</p>\n<ul>\n<li>按照自己的风格，为神州王开发板写一套完整的学习案例，并同步到github。</li>\n<li>学习研究python，以视频文档和案例学习为主。</li>\n<li>装修自己的blog</li>\n</ul>\n<a id=\"more\"></a>\n","excerpt":"<p>2016转眼又快结束，这个月加上国庆休假一下子又过去了半个多月，直到今天才开始上班。今年除了工作上面的几个项目进一步完善外，这边为16年最后几个月制定一个小计划：</p>\n<ul>\n<li>按照自己的风格，为神州王开发板写一套完整的学习案例，并同步到github。</li>\n<li>学习研究python，以视频文档和案例学习为主。</li>\n<li>装修自己的blog</li>\n</ul>","more":""},{"layout":"post","title":"传输速率","date":"2016-10-02T08:02:00.000Z","_content":"\n\n数据传输过程中常常会涉及到传输速率，这边详细区分和介绍下波特率和比特率的区别。另一种说法是：在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。码元，承载信息量的基本信号单位。\n\n### 码元：\n\n书面解释：在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为(二进制）码元。 而这个间隔被称为码元长度。值得注意的是当码元的离散状态有大于2个时（如M大于2个） 时，此时码元为M进制码元。\n\n码元通俗的说就是信号，一个数字脉冲就是一个码元。但事实这种解释不够全面，同一个时间段，信号可以变化3次，也可以变化1次。实际上，正如码元的定义一样，码元是与时间相联系的。这边的时间并不是一个明确的时间，例如：串口通信时，双方约定波特率为9600（9600bps），则代表一秒钟传输9600个位（bit），这时每个码元所在的时间片段就约为1/9600s。再例如：I2C的传输速率最大为400Kbps，而I2C的通信更加的自由，实际使用过程中，双方并不会事先指定好通信速度，而是采用一根单独的SCL总线来限定通信的速度即码元所间隔的时间，在SDA保持恒定的情况下，SCL总线每次变化电平时的这段时间间隔就作为一个码元所在的时间片段。\n\n通过定义可以看出，通常来所说的码元就是表示二进制码元，当用一个码元传输一个多重含义的数据时，码元还是码元，但我们称其为M进制码元。但实际我们也可以设计一个M进制的码元，举个栗子：假如基带信号是7536154210.....，直接发送，则每个码元作为（八进制）码元传输，这样一个码元相当于8个不同的待识别状态数据。（每个码元有8种状态，实际早期为何不使用10进制来定义计算机就是因为，一个数据包含的意义越多，越难解析识别，也越容易出错，会增加设计的复杂度，很显然，远距离通讯一般都还是采用二进制码元较多）。而大多数计算机都只能传输2进制数值，假如基带信号是101011000110111010.....，如果直接发送，则每个码元携带一个比特的信息（每个码元只有2种状态），但是如果将信号中的三个比特编为一组，即101，011，000，110，111，010......，三个比特同样可以表述8种不同的排列，我们可以用不同的调制方法来表示这种信，如8种不同的振幅，频率，相位等，如果采用相位调制，相位ϕ0表示000，ϕ1表示001，以此类推，那么接收端如果收到相位是ϕ0的信号就知道表示的是000，以此类推，这样一个码元就不知不觉的传输了三个比特位的信号（每个码元有8种状态，每一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难）。\n\n根据上述内容总结：一个以m波特传送信号的线路，其传送二进制数据的速率不一定是m比特/秒，因为每个信号可以运载几个比特，例如，若使用0、1、2、3、4、5、6、7共8个电平级，则需要  ，即3个比特来表示一个信号值，因而这种条件下比特率将是波特率的3倍。某系统每秒钟传送2400个码元，则该系统的传码率为2400波特或2400B。但要注意，码元传输速率仅仅表征单位时间内传送码元的数目，而没有限定这时的码元是何种进制，因统一系统的各点上可能采用不同的进制，故给出码元速率时必须说明码元的进制和该速率在系统中的位置。\n\n常用进制（或键位数）的码元有：8进制（也称8键制）数字码元键盘，10进制数字码元键盘，5进制笔画数字码元键盘，还有26进制字母码元键盘，26进制部件字母码元键盘，还有韩文的28进制字母码元键盘，俄文的33进制字母码元键盘，以及中国维文的30进制字母码元键盘等。\n\n\n\n<!-- more -->\n\n\n\n\n### 比特率：\n\n在电信行业，码率，比特率或数据传输速率指在一个数据传送系统中，单位时间内通过设备比特、字符、块等的平均量。通常使用比特每秒或字节每秒两单位的复合形式度量。比特率在数字信道中，比特率是数字信号的传输速率（需要注意的是比特率是一个传输速度的单位），比特率显然是以bit位作为最小传输量的，不要和Byte字节进行混淆。它用单位时间内传输的二进制代码的有效位(bit)数来表示，其单位为每秒比特数bit/s(bps)、每秒千比特数(Kbps)或每秒兆比特数(Mbps)来表示(此处K和M分别为1000和1000000，而不是涉及计算机存储器容量时的1024和1048576)，而为何这边换算不是以1024为单位，而是以1000为单位呢，值得一提的是，人类世界习惯于使用十进制来换算，一般除了计算机对存储单元采用1024K=1000M这种换算方式外，人类社会中的大多数的换算方法都是采用1000代表1K，最为常见的现象就是买回来的硬盘厂家生产会以1000作为一个单位级，而插上电脑后会以1024作为一个单位级，因此硬盘等设备插入电脑往往都会比说明上面小很多，传输速率比特率这个单位在使用k是从来都是代表1000的，不幸的是，人们常常错误地用 K 代替 Ki。\n\nk 与 Ki 分别表示 kilo-（千） 与 kibi-（二进制千） 。作为前缀使用时， k 表示 1,000，Ki 表示1,024，因为“Ki”来源于它在计算机方面 210 = 1,024 的使用。不幸的是，人们常常错误地用 K 代替 Ki。此外，不知晓其中微妙差别的广大公众，常常不加区别地使用“Kbps”与“Kibps”，造成了混乱。总之，使用“Kibps”通常是正确的。\n\nb 代表 bit（比特），B 代表 byte（字节），1 字节 即 8 比特。这会导致混淆。比如当“1M（1 Meg，1 兆）网络连接”字样出现在广告上时，它常常表示 1 Mib/s（mebibit per second，二进制兆比特每秒）或者 1.049 Mb/s（megabit per second，兆比特每秒），即可能达到的最大下载速度实际上仅为 128 KiB/s（kibibyte per second，二进制千字节每秒）或者 131 kB/s（kilobyte per second，千字节每秒）。\n\n\n\n### 波特率：\n\n指在电子通信领域，鲍（Baud）即调制速率，指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。它是对符号传输速率的一种度量，1鲍即指每秒传输1个符号，而通过不同的调制方式，可以在一个码元符号上负载多个bit位信息。“鲍”（Baud）本身已是速率，所以不需要写成 Baud Rate（Rate 是赘字）。单位“鲍”本身就已经是代表每秒的调制数，以“鲍每秒”（Baud per second）为单位是一种常见的错误。\n\n**波特率有时候会同比特率混淆**，实际上后者是对信息传输速率（传信率）的度量。波特率可以被理解为单位时间内传输符号的个数（传符号率），通过不同的调制方法可以在一个符号上负载多个比特信息。因此信息传输速率即比特率在数值上和波特率有这样的关系：I = S × log2 (N)  其中I为传信率，S为波特率，N为每个符号负载的信息量，而 log2 (N) 以比特为单位。\n\n以RS232为例，典型的“鲍”是300, 1200, 2400, 9600, 19200, 115200等，假设目前“鲍”为 9600， 则此RS232的比特率计算为I = S × log2 (N) = 9600×log2 (2) = 9600bps。\n\n电路传输信号是靠在一定的时间段内，波形的变化来识别每一位（英文单位bit）信息的，那么\n这一位信息的波形就叫作码元。  当用一个码元传输多个比特位时，码元还是码元，但我们称其为M进制码元。\n\n\n\n\n> 参考链接：\n> http://1992zhong.blog.51cto.com/3963309/1167100\n> https://zh.wikipedia.org/wiki/%E7%A0%81%E7%8E%87%E5%8D%95%E4%BD%8D\n","source":"_posts/2016/2016-10-02-传输速率.md","raw":"---\nlayout: \"post\"\ntitle: \"传输速率\"\ndate: \"2016-10-02 16:02\"\n---\n\n\n数据传输过程中常常会涉及到传输速率，这边详细区分和介绍下波特率和比特率的区别。另一种说法是：在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。码元，承载信息量的基本信号单位。\n\n### 码元：\n\n书面解释：在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为(二进制）码元。 而这个间隔被称为码元长度。值得注意的是当码元的离散状态有大于2个时（如M大于2个） 时，此时码元为M进制码元。\n\n码元通俗的说就是信号，一个数字脉冲就是一个码元。但事实这种解释不够全面，同一个时间段，信号可以变化3次，也可以变化1次。实际上，正如码元的定义一样，码元是与时间相联系的。这边的时间并不是一个明确的时间，例如：串口通信时，双方约定波特率为9600（9600bps），则代表一秒钟传输9600个位（bit），这时每个码元所在的时间片段就约为1/9600s。再例如：I2C的传输速率最大为400Kbps，而I2C的通信更加的自由，实际使用过程中，双方并不会事先指定好通信速度，而是采用一根单独的SCL总线来限定通信的速度即码元所间隔的时间，在SDA保持恒定的情况下，SCL总线每次变化电平时的这段时间间隔就作为一个码元所在的时间片段。\n\n通过定义可以看出，通常来所说的码元就是表示二进制码元，当用一个码元传输一个多重含义的数据时，码元还是码元，但我们称其为M进制码元。但实际我们也可以设计一个M进制的码元，举个栗子：假如基带信号是7536154210.....，直接发送，则每个码元作为（八进制）码元传输，这样一个码元相当于8个不同的待识别状态数据。（每个码元有8种状态，实际早期为何不使用10进制来定义计算机就是因为，一个数据包含的意义越多，越难解析识别，也越容易出错，会增加设计的复杂度，很显然，远距离通讯一般都还是采用二进制码元较多）。而大多数计算机都只能传输2进制数值，假如基带信号是101011000110111010.....，如果直接发送，则每个码元携带一个比特的信息（每个码元只有2种状态），但是如果将信号中的三个比特编为一组，即101，011，000，110，111，010......，三个比特同样可以表述8种不同的排列，我们可以用不同的调制方法来表示这种信，如8种不同的振幅，频率，相位等，如果采用相位调制，相位ϕ0表示000，ϕ1表示001，以此类推，那么接收端如果收到相位是ϕ0的信号就知道表示的是000，以此类推，这样一个码元就不知不觉的传输了三个比特位的信号（每个码元有8种状态，每一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难）。\n\n根据上述内容总结：一个以m波特传送信号的线路，其传送二进制数据的速率不一定是m比特/秒，因为每个信号可以运载几个比特，例如，若使用0、1、2、3、4、5、6、7共8个电平级，则需要  ，即3个比特来表示一个信号值，因而这种条件下比特率将是波特率的3倍。某系统每秒钟传送2400个码元，则该系统的传码率为2400波特或2400B。但要注意，码元传输速率仅仅表征单位时间内传送码元的数目，而没有限定这时的码元是何种进制，因统一系统的各点上可能采用不同的进制，故给出码元速率时必须说明码元的进制和该速率在系统中的位置。\n\n常用进制（或键位数）的码元有：8进制（也称8键制）数字码元键盘，10进制数字码元键盘，5进制笔画数字码元键盘，还有26进制字母码元键盘，26进制部件字母码元键盘，还有韩文的28进制字母码元键盘，俄文的33进制字母码元键盘，以及中国维文的30进制字母码元键盘等。\n\n\n\n<!-- more -->\n\n\n\n\n### 比特率：\n\n在电信行业，码率，比特率或数据传输速率指在一个数据传送系统中，单位时间内通过设备比特、字符、块等的平均量。通常使用比特每秒或字节每秒两单位的复合形式度量。比特率在数字信道中，比特率是数字信号的传输速率（需要注意的是比特率是一个传输速度的单位），比特率显然是以bit位作为最小传输量的，不要和Byte字节进行混淆。它用单位时间内传输的二进制代码的有效位(bit)数来表示，其单位为每秒比特数bit/s(bps)、每秒千比特数(Kbps)或每秒兆比特数(Mbps)来表示(此处K和M分别为1000和1000000，而不是涉及计算机存储器容量时的1024和1048576)，而为何这边换算不是以1024为单位，而是以1000为单位呢，值得一提的是，人类世界习惯于使用十进制来换算，一般除了计算机对存储单元采用1024K=1000M这种换算方式外，人类社会中的大多数的换算方法都是采用1000代表1K，最为常见的现象就是买回来的硬盘厂家生产会以1000作为一个单位级，而插上电脑后会以1024作为一个单位级，因此硬盘等设备插入电脑往往都会比说明上面小很多，传输速率比特率这个单位在使用k是从来都是代表1000的，不幸的是，人们常常错误地用 K 代替 Ki。\n\nk 与 Ki 分别表示 kilo-（千） 与 kibi-（二进制千） 。作为前缀使用时， k 表示 1,000，Ki 表示1,024，因为“Ki”来源于它在计算机方面 210 = 1,024 的使用。不幸的是，人们常常错误地用 K 代替 Ki。此外，不知晓其中微妙差别的广大公众，常常不加区别地使用“Kbps”与“Kibps”，造成了混乱。总之，使用“Kibps”通常是正确的。\n\nb 代表 bit（比特），B 代表 byte（字节），1 字节 即 8 比特。这会导致混淆。比如当“1M（1 Meg，1 兆）网络连接”字样出现在广告上时，它常常表示 1 Mib/s（mebibit per second，二进制兆比特每秒）或者 1.049 Mb/s（megabit per second，兆比特每秒），即可能达到的最大下载速度实际上仅为 128 KiB/s（kibibyte per second，二进制千字节每秒）或者 131 kB/s（kilobyte per second，千字节每秒）。\n\n\n\n### 波特率：\n\n指在电子通信领域，鲍（Baud）即调制速率，指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。它是对符号传输速率的一种度量，1鲍即指每秒传输1个符号，而通过不同的调制方式，可以在一个码元符号上负载多个bit位信息。“鲍”（Baud）本身已是速率，所以不需要写成 Baud Rate（Rate 是赘字）。单位“鲍”本身就已经是代表每秒的调制数，以“鲍每秒”（Baud per second）为单位是一种常见的错误。\n\n**波特率有时候会同比特率混淆**，实际上后者是对信息传输速率（传信率）的度量。波特率可以被理解为单位时间内传输符号的个数（传符号率），通过不同的调制方法可以在一个符号上负载多个比特信息。因此信息传输速率即比特率在数值上和波特率有这样的关系：I = S × log2 (N)  其中I为传信率，S为波特率，N为每个符号负载的信息量，而 log2 (N) 以比特为单位。\n\n以RS232为例，典型的“鲍”是300, 1200, 2400, 9600, 19200, 115200等，假设目前“鲍”为 9600， 则此RS232的比特率计算为I = S × log2 (N) = 9600×log2 (2) = 9600bps。\n\n电路传输信号是靠在一定的时间段内，波形的变化来识别每一位（英文单位bit）信息的，那么\n这一位信息的波形就叫作码元。  当用一个码元传输多个比特位时，码元还是码元，但我们称其为M进制码元。\n\n\n\n\n> 参考链接：\n> http://1992zhong.blog.51cto.com/3963309/1167100\n> https://zh.wikipedia.org/wiki/%E7%A0%81%E7%8E%87%E5%8D%95%E4%BD%8D\n","slug":"2016/2016-10-02-传输速率","published":1,"updated":"2016-12-16T01:48:59.738Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ai9002tmumucb41p0jl","content":"<p>数据传输过程中常常会涉及到传输速率，这边详细区分和介绍下波特率和比特率的区别。另一种说法是：在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。码元，承载信息量的基本信号单位。</p>\n<h3 id=\"码元：\"><a href=\"#码元：\" class=\"headerlink\" title=\"码元：\"></a>码元：</h3><p>书面解释：在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为(二进制）码元。 而这个间隔被称为码元长度。值得注意的是当码元的离散状态有大于2个时（如M大于2个） 时，此时码元为M进制码元。</p>\n<p>码元通俗的说就是信号，一个数字脉冲就是一个码元。但事实这种解释不够全面，同一个时间段，信号可以变化3次，也可以变化1次。实际上，正如码元的定义一样，码元是与时间相联系的。这边的时间并不是一个明确的时间，例如：串口通信时，双方约定波特率为9600（9600bps），则代表一秒钟传输9600个位（bit），这时每个码元所在的时间片段就约为1/9600s。再例如：I2C的传输速率最大为400Kbps，而I2C的通信更加的自由，实际使用过程中，双方并不会事先指定好通信速度，而是采用一根单独的SCL总线来限定通信的速度即码元所间隔的时间，在SDA保持恒定的情况下，SCL总线每次变化电平时的这段时间间隔就作为一个码元所在的时间片段。</p>\n<p>通过定义可以看出，通常来所说的码元就是表示二进制码元，当用一个码元传输一个多重含义的数据时，码元还是码元，但我们称其为M进制码元。但实际我们也可以设计一个M进制的码元，举个栗子：假如基带信号是7536154210…..，直接发送，则每个码元作为（八进制）码元传输，这样一个码元相当于8个不同的待识别状态数据。（每个码元有8种状态，实际早期为何不使用10进制来定义计算机就是因为，一个数据包含的意义越多，越难解析识别，也越容易出错，会增加设计的复杂度，很显然，远距离通讯一般都还是采用二进制码元较多）。而大多数计算机都只能传输2进制数值，假如基带信号是101011000110111010…..，如果直接发送，则每个码元携带一个比特的信息（每个码元只有2种状态），但是如果将信号中的三个比特编为一组，即101，011，000，110，111，010……，三个比特同样可以表述8种不同的排列，我们可以用不同的调制方法来表示这种信，如8种不同的振幅，频率，相位等，如果采用相位调制，相位ϕ0表示000，ϕ1表示001，以此类推，那么接收端如果收到相位是ϕ0的信号就知道表示的是000，以此类推，这样一个码元就不知不觉的传输了三个比特位的信号（每个码元有8种状态，每一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难）。</p>\n<p>根据上述内容总结：一个以m波特传送信号的线路，其传送二进制数据的速率不一定是m比特/秒，因为每个信号可以运载几个比特，例如，若使用0、1、2、3、4、5、6、7共8个电平级，则需要  ，即3个比特来表示一个信号值，因而这种条件下比特率将是波特率的3倍。某系统每秒钟传送2400个码元，则该系统的传码率为2400波特或2400B。但要注意，码元传输速率仅仅表征单位时间内传送码元的数目，而没有限定这时的码元是何种进制，因统一系统的各点上可能采用不同的进制，故给出码元速率时必须说明码元的进制和该速率在系统中的位置。</p>\n<p>常用进制（或键位数）的码元有：8进制（也称8键制）数字码元键盘，10进制数字码元键盘，5进制笔画数字码元键盘，还有26进制字母码元键盘，26进制部件字母码元键盘，还有韩文的28进制字母码元键盘，俄文的33进制字母码元键盘，以及中国维文的30进制字母码元键盘等。</p>\n<a id=\"more\"></a>\n<h3 id=\"比特率：\"><a href=\"#比特率：\" class=\"headerlink\" title=\"比特率：\"></a>比特率：</h3><p>在电信行业，码率，比特率或数据传输速率指在一个数据传送系统中，单位时间内通过设备比特、字符、块等的平均量。通常使用比特每秒或字节每秒两单位的复合形式度量。比特率在数字信道中，比特率是数字信号的传输速率（需要注意的是比特率是一个传输速度的单位），比特率显然是以bit位作为最小传输量的，不要和Byte字节进行混淆。它用单位时间内传输的二进制代码的有效位(bit)数来表示，其单位为每秒比特数bit/s(bps)、每秒千比特数(Kbps)或每秒兆比特数(Mbps)来表示(此处K和M分别为1000和1000000，而不是涉及计算机存储器容量时的1024和1048576)，而为何这边换算不是以1024为单位，而是以1000为单位呢，值得一提的是，人类世界习惯于使用十进制来换算，一般除了计算机对存储单元采用1024K=1000M这种换算方式外，人类社会中的大多数的换算方法都是采用1000代表1K，最为常见的现象就是买回来的硬盘厂家生产会以1000作为一个单位级，而插上电脑后会以1024作为一个单位级，因此硬盘等设备插入电脑往往都会比说明上面小很多，传输速率比特率这个单位在使用k是从来都是代表1000的，不幸的是，人们常常错误地用 K 代替 Ki。</p>\n<p>k 与 Ki 分别表示 kilo-（千） 与 kibi-（二进制千） 。作为前缀使用时， k 表示 1,000，Ki 表示1,024，因为“Ki”来源于它在计算机方面 210 = 1,024 的使用。不幸的是，人们常常错误地用 K 代替 Ki。此外，不知晓其中微妙差别的广大公众，常常不加区别地使用“Kbps”与“Kibps”，造成了混乱。总之，使用“Kibps”通常是正确的。</p>\n<p>b 代表 bit（比特），B 代表 byte（字节），1 字节 即 8 比特。这会导致混淆。比如当“1M（1 Meg，1 兆）网络连接”字样出现在广告上时，它常常表示 1 Mib/s（mebibit per second，二进制兆比特每秒）或者 1.049 Mb/s（megabit per second，兆比特每秒），即可能达到的最大下载速度实际上仅为 128 KiB/s（kibibyte per second，二进制千字节每秒）或者 131 kB/s（kilobyte per second，千字节每秒）。</p>\n<h3 id=\"波特率：\"><a href=\"#波特率：\" class=\"headerlink\" title=\"波特率：\"></a>波特率：</h3><p>指在电子通信领域，鲍（Baud）即调制速率，指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。它是对符号传输速率的一种度量，1鲍即指每秒传输1个符号，而通过不同的调制方式，可以在一个码元符号上负载多个bit位信息。“鲍”（Baud）本身已是速率，所以不需要写成 Baud Rate（Rate 是赘字）。单位“鲍”本身就已经是代表每秒的调制数，以“鲍每秒”（Baud per second）为单位是一种常见的错误。</p>\n<p><strong>波特率有时候会同比特率混淆</strong>，实际上后者是对信息传输速率（传信率）的度量。波特率可以被理解为单位时间内传输符号的个数（传符号率），通过不同的调制方法可以在一个符号上负载多个比特信息。因此信息传输速率即比特率在数值上和波特率有这样的关系：I = S × log2 (N)  其中I为传信率，S为波特率，N为每个符号负载的信息量，而 log2 (N) 以比特为单位。</p>\n<p>以RS232为例，典型的“鲍”是300, 1200, 2400, 9600, 19200, 115200等，假设目前“鲍”为 9600， 则此RS232的比特率计算为I = S × log2 (N) = 9600×log2 (2) = 9600bps。</p>\n<p>电路传输信号是靠在一定的时间段内，波形的变化来识别每一位（英文单位bit）信息的，那么<br>这一位信息的波形就叫作码元。  当用一个码元传输多个比特位时，码元还是码元，但我们称其为M进制码元。</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://1992zhong.blog.51cto.com/3963309/1167100\" target=\"_blank\" rel=\"external\">http://1992zhong.blog.51cto.com/3963309/1167100</a><br><a href=\"https://zh.wikipedia.org/wiki/%E7%A0%81%E7%8E%87%E5%8D%95%E4%BD%8D\" target=\"_blank\" rel=\"external\">https://zh.wikipedia.org/wiki/%E7%A0%81%E7%8E%87%E5%8D%95%E4%BD%8D</a></p>\n</blockquote>\n","excerpt":"<p>数据传输过程中常常会涉及到传输速率，这边详细区分和介绍下波特率和比特率的区别。另一种说法是：在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。码元，承载信息量的基本信号单位。</p>\n<h3 id=\"码元：\"><a href=\"#码元：\" class=\"headerlink\" title=\"码元：\"></a>码元：</h3><p>书面解释：在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为(二进制）码元。 而这个间隔被称为码元长度。值得注意的是当码元的离散状态有大于2个时（如M大于2个） 时，此时码元为M进制码元。</p>\n<p>码元通俗的说就是信号，一个数字脉冲就是一个码元。但事实这种解释不够全面，同一个时间段，信号可以变化3次，也可以变化1次。实际上，正如码元的定义一样，码元是与时间相联系的。这边的时间并不是一个明确的时间，例如：串口通信时，双方约定波特率为9600（9600bps），则代表一秒钟传输9600个位（bit），这时每个码元所在的时间片段就约为1/9600s。再例如：I2C的传输速率最大为400Kbps，而I2C的通信更加的自由，实际使用过程中，双方并不会事先指定好通信速度，而是采用一根单独的SCL总线来限定通信的速度即码元所间隔的时间，在SDA保持恒定的情况下，SCL总线每次变化电平时的这段时间间隔就作为一个码元所在的时间片段。</p>\n<p>通过定义可以看出，通常来所说的码元就是表示二进制码元，当用一个码元传输一个多重含义的数据时，码元还是码元，但我们称其为M进制码元。但实际我们也可以设计一个M进制的码元，举个栗子：假如基带信号是7536154210…..，直接发送，则每个码元作为（八进制）码元传输，这样一个码元相当于8个不同的待识别状态数据。（每个码元有8种状态，实际早期为何不使用10进制来定义计算机就是因为，一个数据包含的意义越多，越难解析识别，也越容易出错，会增加设计的复杂度，很显然，远距离通讯一般都还是采用二进制码元较多）。而大多数计算机都只能传输2进制数值，假如基带信号是101011000110111010…..，如果直接发送，则每个码元携带一个比特的信息（每个码元只有2种状态），但是如果将信号中的三个比特编为一组，即101，011，000，110，111，010……，三个比特同样可以表述8种不同的排列，我们可以用不同的调制方法来表示这种信，如8种不同的振幅，频率，相位等，如果采用相位调制，相位ϕ0表示000，ϕ1表示001，以此类推，那么接收端如果收到相位是ϕ0的信号就知道表示的是000，以此类推，这样一个码元就不知不觉的传输了三个比特位的信号（每个码元有8种状态，每一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难）。</p>\n<p>根据上述内容总结：一个以m波特传送信号的线路，其传送二进制数据的速率不一定是m比特/秒，因为每个信号可以运载几个比特，例如，若使用0、1、2、3、4、5、6、7共8个电平级，则需要  ，即3个比特来表示一个信号值，因而这种条件下比特率将是波特率的3倍。某系统每秒钟传送2400个码元，则该系统的传码率为2400波特或2400B。但要注意，码元传输速率仅仅表征单位时间内传送码元的数目，而没有限定这时的码元是何种进制，因统一系统的各点上可能采用不同的进制，故给出码元速率时必须说明码元的进制和该速率在系统中的位置。</p>\n<p>常用进制（或键位数）的码元有：8进制（也称8键制）数字码元键盘，10进制数字码元键盘，5进制笔画数字码元键盘，还有26进制字母码元键盘，26进制部件字母码元键盘，还有韩文的28进制字母码元键盘，俄文的33进制字母码元键盘，以及中国维文的30进制字母码元键盘等。</p>","more":"<h3 id=\"比特率：\"><a href=\"#比特率：\" class=\"headerlink\" title=\"比特率：\"></a>比特率：</h3><p>在电信行业，码率，比特率或数据传输速率指在一个数据传送系统中，单位时间内通过设备比特、字符、块等的平均量。通常使用比特每秒或字节每秒两单位的复合形式度量。比特率在数字信道中，比特率是数字信号的传输速率（需要注意的是比特率是一个传输速度的单位），比特率显然是以bit位作为最小传输量的，不要和Byte字节进行混淆。它用单位时间内传输的二进制代码的有效位(bit)数来表示，其单位为每秒比特数bit/s(bps)、每秒千比特数(Kbps)或每秒兆比特数(Mbps)来表示(此处K和M分别为1000和1000000，而不是涉及计算机存储器容量时的1024和1048576)，而为何这边换算不是以1024为单位，而是以1000为单位呢，值得一提的是，人类世界习惯于使用十进制来换算，一般除了计算机对存储单元采用1024K=1000M这种换算方式外，人类社会中的大多数的换算方法都是采用1000代表1K，最为常见的现象就是买回来的硬盘厂家生产会以1000作为一个单位级，而插上电脑后会以1024作为一个单位级，因此硬盘等设备插入电脑往往都会比说明上面小很多，传输速率比特率这个单位在使用k是从来都是代表1000的，不幸的是，人们常常错误地用 K 代替 Ki。</p>\n<p>k 与 Ki 分别表示 kilo-（千） 与 kibi-（二进制千） 。作为前缀使用时， k 表示 1,000，Ki 表示1,024，因为“Ki”来源于它在计算机方面 210 = 1,024 的使用。不幸的是，人们常常错误地用 K 代替 Ki。此外，不知晓其中微妙差别的广大公众，常常不加区别地使用“Kbps”与“Kibps”，造成了混乱。总之，使用“Kibps”通常是正确的。</p>\n<p>b 代表 bit（比特），B 代表 byte（字节），1 字节 即 8 比特。这会导致混淆。比如当“1M（1 Meg，1 兆）网络连接”字样出现在广告上时，它常常表示 1 Mib/s（mebibit per second，二进制兆比特每秒）或者 1.049 Mb/s（megabit per second，兆比特每秒），即可能达到的最大下载速度实际上仅为 128 KiB/s（kibibyte per second，二进制千字节每秒）或者 131 kB/s（kilobyte per second，千字节每秒）。</p>\n<h3 id=\"波特率：\"><a href=\"#波特率：\" class=\"headerlink\" title=\"波特率：\"></a>波特率：</h3><p>指在电子通信领域，鲍（Baud）即调制速率，指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。它是对符号传输速率的一种度量，1鲍即指每秒传输1个符号，而通过不同的调制方式，可以在一个码元符号上负载多个bit位信息。“鲍”（Baud）本身已是速率，所以不需要写成 Baud Rate（Rate 是赘字）。单位“鲍”本身就已经是代表每秒的调制数，以“鲍每秒”（Baud per second）为单位是一种常见的错误。</p>\n<p><strong>波特率有时候会同比特率混淆</strong>，实际上后者是对信息传输速率（传信率）的度量。波特率可以被理解为单位时间内传输符号的个数（传符号率），通过不同的调制方法可以在一个符号上负载多个比特信息。因此信息传输速率即比特率在数值上和波特率有这样的关系：I = S × log2 (N)  其中I为传信率，S为波特率，N为每个符号负载的信息量，而 log2 (N) 以比特为单位。</p>\n<p>以RS232为例，典型的“鲍”是300, 1200, 2400, 9600, 19200, 115200等，假设目前“鲍”为 9600， 则此RS232的比特率计算为I = S × log2 (N) = 9600×log2 (2) = 9600bps。</p>\n<p>电路传输信号是靠在一定的时间段内，波形的变化来识别每一位（英文单位bit）信息的，那么<br>这一位信息的波形就叫作码元。  当用一个码元传输多个比特位时，码元还是码元，但我们称其为M进制码元。</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://1992zhong.blog.51cto.com/3963309/1167100\">http://1992zhong.blog.51cto.com/3963309/1167100</a><br><a href=\"https://zh.wikipedia.org/wiki/%E7%A0%81%E7%8E%87%E5%8D%95%E4%BD%8D\">https://zh.wikipedia.org/wiki/%E7%A0%81%E7%8E%87%E5%8D%95%E4%BD%8D</a></p>\n</blockquote>"},{"layout":"post","title":"Note 7 的一些个人看法","date":"2016-10-16T06:04:00.000Z","_content":"\n\n*本文是一篇杂谈笔记，一直比较关注科技圈多年，喜欢各种电子产品，且能够DIY或者修理一些小东西，虽然对三星这家公司一直缺乏好感，但还是吐槽一番。*\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-16-note-7-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/1.jpg)\n\n最近闹的比较火的三星Note 7手榴弹事件，终于在这两天落下了帷幕，最终三星将中国市场和海外市场同等对待，停售并回收所有该款机型，无需退还相关赠送配件，允许用户退换或者置换手机，并作出一系列相关补偿。事情看起来似乎是皆大欢喜，恶势力最终向国人低头。\n\n但换而言之，通过三星的一些列举动不得不说是：**搬起石头砸自己的脚**。首先三星和苹果一直是占据高端手机市场几乎所有份额的，三星早些时候在12年以前可以说是国内最最畅销的手机厂家。原因是：产品线广，覆盖低中高多个销售人群，品牌大众认可度高，国内缺乏有力的竞争对手，那时候小米，华为等也才刚刚起步没多久。三星的衰亡也恰恰因为这些原因，首先，13年以后，国内主打性价比性能的手机层出不穷，而三星天然的重广告轻研发的基因，也让它的中低端机型用户体验奇差无比。国内中低端市场逐渐被国产手机厂家占领，三星从此排名一落千丈，且这几年似乎已经从中国主流消费者眼中销声匿迹了。\n\n<!-- more -->\n\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-16-note-7-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/2.jpg)\n\n三星的再次复兴应该是从galaxy S6开始的，虽然中低端市场挫败，但高端市场推出曲面屏，防水等一些列更加满足用户差别需求的产品，让三星在多个方面包括：拍照成像等都成为了市面上面最好的手机。而这次Note 7更加是来势汹汹的，wacom顶尖手绘笔技术，红魔识别，高成像画质等等众多功能，确实让三星这次绝对有秒杀市面一切手机的资本。但恰恰是这颗手榴弹毁了三星，手机本身是一个附加的用户产品，意义在于让用户更加方便的交流通信，没有手机我们一样可以完成很多事情，一样可以活，而手机本身仅仅是个工具为了方便交流，所以一切的附加属性再好的用户体验都离不开工具本身的属性，而如果这个工具需要大家冒着生命危险去使用，那又有哪个人不会望而却步呢？！有人说一个产品不能有任何的马虎，三星这次就是一个螺丝没上的好导致满盘皆输，事实上三星这次不仅仅是一个螺丝的问题，民用产品本身不会要求精益求精，苹果也有天线门，各家手机也会有各种问题等，三星这次是躺在了最不该出问题的事件上面，试想：一个手机被旅客禁止携带，简直是闻所未闻。\n\n抛开国外市场，暂且不说，其实在国内尚且没有发生重大变故的前提下，三星最该去做好各种公关，积极响应用户号召，和国外市场一视同仁，直接退换机型，这样，虽然会有一定的经济损失，但一定可以建立一个更好的口碑市场。其实中国用户很好打发，尤其是国人有“伸手不打笑脸人”的思想，中国人一直有种奇怪的认知，不在乎你犯错，但你认错的态度一定要诚恳，很多时候甚至媒体艺人喜欢拿这些来炒作自己。三星如果这次一开始就积极认错，最终大多数国人会这样认为：不愧是三星，和别的国际厂家就是不一样，能够做到一视同仁，即便产品本身没有问题都可以为用户考虑，这样的大公司值得信赖。而反观这次，三星是被中国用户“逼着”去承认自己的错误，三星国行用的香港的电池可能确实是没有问题，但国内用户关注的早已不是电池的问题，而是区别对待的问题，只要有个别用户愿意，没有问题也可以把你整出问题，而这种调查出来的*真相*又有多少人愿意去相信？只会不断请权威机构证明，陷入死循环。而中国政府这个时候如果帮三星澄清无意是打自己的脸。三星如果还想在中国混，必然不得不向消费者低头，所有不得不说，在有这么多区别对待海内外市场公司的前科下，三星还范这种错误，无疑让人很难理解。\n","source":"_posts/2016/2016-10-16-note-7-的一些个人看法.md","raw":"---\nlayout: \"post\"\ntitle: \"Note 7 的一些个人看法\"\ndate: \"2016-10-16 14:04\"\n---\n\n\n*本文是一篇杂谈笔记，一直比较关注科技圈多年，喜欢各种电子产品，且能够DIY或者修理一些小东西，虽然对三星这家公司一直缺乏好感，但还是吐槽一番。*\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-16-note-7-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/1.jpg)\n\n最近闹的比较火的三星Note 7手榴弹事件，终于在这两天落下了帷幕，最终三星将中国市场和海外市场同等对待，停售并回收所有该款机型，无需退还相关赠送配件，允许用户退换或者置换手机，并作出一系列相关补偿。事情看起来似乎是皆大欢喜，恶势力最终向国人低头。\n\n但换而言之，通过三星的一些列举动不得不说是：**搬起石头砸自己的脚**。首先三星和苹果一直是占据高端手机市场几乎所有份额的，三星早些时候在12年以前可以说是国内最最畅销的手机厂家。原因是：产品线广，覆盖低中高多个销售人群，品牌大众认可度高，国内缺乏有力的竞争对手，那时候小米，华为等也才刚刚起步没多久。三星的衰亡也恰恰因为这些原因，首先，13年以后，国内主打性价比性能的手机层出不穷，而三星天然的重广告轻研发的基因，也让它的中低端机型用户体验奇差无比。国内中低端市场逐渐被国产手机厂家占领，三星从此排名一落千丈，且这几年似乎已经从中国主流消费者眼中销声匿迹了。\n\n<!-- more -->\n\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-16-note-7-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/2.jpg)\n\n三星的再次复兴应该是从galaxy S6开始的，虽然中低端市场挫败，但高端市场推出曲面屏，防水等一些列更加满足用户差别需求的产品，让三星在多个方面包括：拍照成像等都成为了市面上面最好的手机。而这次Note 7更加是来势汹汹的，wacom顶尖手绘笔技术，红魔识别，高成像画质等等众多功能，确实让三星这次绝对有秒杀市面一切手机的资本。但恰恰是这颗手榴弹毁了三星，手机本身是一个附加的用户产品，意义在于让用户更加方便的交流通信，没有手机我们一样可以完成很多事情，一样可以活，而手机本身仅仅是个工具为了方便交流，所以一切的附加属性再好的用户体验都离不开工具本身的属性，而如果这个工具需要大家冒着生命危险去使用，那又有哪个人不会望而却步呢？！有人说一个产品不能有任何的马虎，三星这次就是一个螺丝没上的好导致满盘皆输，事实上三星这次不仅仅是一个螺丝的问题，民用产品本身不会要求精益求精，苹果也有天线门，各家手机也会有各种问题等，三星这次是躺在了最不该出问题的事件上面，试想：一个手机被旅客禁止携带，简直是闻所未闻。\n\n抛开国外市场，暂且不说，其实在国内尚且没有发生重大变故的前提下，三星最该去做好各种公关，积极响应用户号召，和国外市场一视同仁，直接退换机型，这样，虽然会有一定的经济损失，但一定可以建立一个更好的口碑市场。其实中国用户很好打发，尤其是国人有“伸手不打笑脸人”的思想，中国人一直有种奇怪的认知，不在乎你犯错，但你认错的态度一定要诚恳，很多时候甚至媒体艺人喜欢拿这些来炒作自己。三星如果这次一开始就积极认错，最终大多数国人会这样认为：不愧是三星，和别的国际厂家就是不一样，能够做到一视同仁，即便产品本身没有问题都可以为用户考虑，这样的大公司值得信赖。而反观这次，三星是被中国用户“逼着”去承认自己的错误，三星国行用的香港的电池可能确实是没有问题，但国内用户关注的早已不是电池的问题，而是区别对待的问题，只要有个别用户愿意，没有问题也可以把你整出问题，而这种调查出来的*真相*又有多少人愿意去相信？只会不断请权威机构证明，陷入死循环。而中国政府这个时候如果帮三星澄清无意是打自己的脸。三星如果还想在中国混，必然不得不向消费者低头，所有不得不说，在有这么多区别对待海内外市场公司的前科下，三星还范这种错误，无疑让人很难理解。\n","slug":"2016/2016-10-16-note-7-的一些个人看法","published":1,"updated":"2016-12-16T01:49:06.834Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aia002umumubp4y26sv","content":"<p><em>本文是一篇杂谈笔记，一直比较关注科技圈多年，喜欢各种电子产品，且能够DIY或者修理一些小东西，虽然对三星这家公司一直缺乏好感，但还是吐槽一番。</em></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-16-note-7-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/1.jpg\" alt=\"\"></p>\n<p>最近闹的比较火的三星Note 7手榴弹事件，终于在这两天落下了帷幕，最终三星将中国市场和海外市场同等对待，停售并回收所有该款机型，无需退还相关赠送配件，允许用户退换或者置换手机，并作出一系列相关补偿。事情看起来似乎是皆大欢喜，恶势力最终向国人低头。</p>\n<p>但换而言之，通过三星的一些列举动不得不说是：<strong>搬起石头砸自己的脚</strong>。首先三星和苹果一直是占据高端手机市场几乎所有份额的，三星早些时候在12年以前可以说是国内最最畅销的手机厂家。原因是：产品线广，覆盖低中高多个销售人群，品牌大众认可度高，国内缺乏有力的竞争对手，那时候小米，华为等也才刚刚起步没多久。三星的衰亡也恰恰因为这些原因，首先，13年以后，国内主打性价比性能的手机层出不穷，而三星天然的重广告轻研发的基因，也让它的中低端机型用户体验奇差无比。国内中低端市场逐渐被国产手机厂家占领，三星从此排名一落千丈，且这几年似乎已经从中国主流消费者眼中销声匿迹了。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-16-note-7-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/2.jpg\" alt=\"\"></p>\n<p>三星的再次复兴应该是从galaxy S6开始的，虽然中低端市场挫败，但高端市场推出曲面屏，防水等一些列更加满足用户差别需求的产品，让三星在多个方面包括：拍照成像等都成为了市面上面最好的手机。而这次Note 7更加是来势汹汹的，wacom顶尖手绘笔技术，红魔识别，高成像画质等等众多功能，确实让三星这次绝对有秒杀市面一切手机的资本。但恰恰是这颗手榴弹毁了三星，手机本身是一个附加的用户产品，意义在于让用户更加方便的交流通信，没有手机我们一样可以完成很多事情，一样可以活，而手机本身仅仅是个工具为了方便交流，所以一切的附加属性再好的用户体验都离不开工具本身的属性，而如果这个工具需要大家冒着生命危险去使用，那又有哪个人不会望而却步呢？！有人说一个产品不能有任何的马虎，三星这次就是一个螺丝没上的好导致满盘皆输，事实上三星这次不仅仅是一个螺丝的问题，民用产品本身不会要求精益求精，苹果也有天线门，各家手机也会有各种问题等，三星这次是躺在了最不该出问题的事件上面，试想：一个手机被旅客禁止携带，简直是闻所未闻。</p>\n<p>抛开国外市场，暂且不说，其实在国内尚且没有发生重大变故的前提下，三星最该去做好各种公关，积极响应用户号召，和国外市场一视同仁，直接退换机型，这样，虽然会有一定的经济损失，但一定可以建立一个更好的口碑市场。其实中国用户很好打发，尤其是国人有“伸手不打笑脸人”的思想，中国人一直有种奇怪的认知，不在乎你犯错，但你认错的态度一定要诚恳，很多时候甚至媒体艺人喜欢拿这些来炒作自己。三星如果这次一开始就积极认错，最终大多数国人会这样认为：不愧是三星，和别的国际厂家就是不一样，能够做到一视同仁，即便产品本身没有问题都可以为用户考虑，这样的大公司值得信赖。而反观这次，三星是被中国用户“逼着”去承认自己的错误，三星国行用的香港的电池可能确实是没有问题，但国内用户关注的早已不是电池的问题，而是区别对待的问题，只要有个别用户愿意，没有问题也可以把你整出问题，而这种调查出来的<em>真相</em>又有多少人愿意去相信？只会不断请权威机构证明，陷入死循环。而中国政府这个时候如果帮三星澄清无意是打自己的脸。三星如果还想在中国混，必然不得不向消费者低头，所有不得不说，在有这么多区别对待海内外市场公司的前科下，三星还范这种错误，无疑让人很难理解。</p>\n","excerpt":"<p><em>本文是一篇杂谈笔记，一直比较关注科技圈多年，喜欢各种电子产品，且能够DIY或者修理一些小东西，虽然对三星这家公司一直缺乏好感，但还是吐槽一番。</em></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-16-note-7-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/1.jpg\" alt=\"\"></p>\n<p>最近闹的比较火的三星Note 7手榴弹事件，终于在这两天落下了帷幕，最终三星将中国市场和海外市场同等对待，停售并回收所有该款机型，无需退还相关赠送配件，允许用户退换或者置换手机，并作出一系列相关补偿。事情看起来似乎是皆大欢喜，恶势力最终向国人低头。</p>\n<p>但换而言之，通过三星的一些列举动不得不说是：<strong>搬起石头砸自己的脚</strong>。首先三星和苹果一直是占据高端手机市场几乎所有份额的，三星早些时候在12年以前可以说是国内最最畅销的手机厂家。原因是：产品线广，覆盖低中高多个销售人群，品牌大众认可度高，国内缺乏有力的竞争对手，那时候小米，华为等也才刚刚起步没多久。三星的衰亡也恰恰因为这些原因，首先，13年以后，国内主打性价比性能的手机层出不穷，而三星天然的重广告轻研发的基因，也让它的中低端机型用户体验奇差无比。国内中低端市场逐渐被国产手机厂家占领，三星从此排名一落千丈，且这几年似乎已经从中国主流消费者眼中销声匿迹了。</p>","more":"<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-16-note-7-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/2.jpg\" alt=\"\"></p>\n<p>三星的再次复兴应该是从galaxy S6开始的，虽然中低端市场挫败，但高端市场推出曲面屏，防水等一些列更加满足用户差别需求的产品，让三星在多个方面包括：拍照成像等都成为了市面上面最好的手机。而这次Note 7更加是来势汹汹的，wacom顶尖手绘笔技术，红魔识别，高成像画质等等众多功能，确实让三星这次绝对有秒杀市面一切手机的资本。但恰恰是这颗手榴弹毁了三星，手机本身是一个附加的用户产品，意义在于让用户更加方便的交流通信，没有手机我们一样可以完成很多事情，一样可以活，而手机本身仅仅是个工具为了方便交流，所以一切的附加属性再好的用户体验都离不开工具本身的属性，而如果这个工具需要大家冒着生命危险去使用，那又有哪个人不会望而却步呢？！有人说一个产品不能有任何的马虎，三星这次就是一个螺丝没上的好导致满盘皆输，事实上三星这次不仅仅是一个螺丝的问题，民用产品本身不会要求精益求精，苹果也有天线门，各家手机也会有各种问题等，三星这次是躺在了最不该出问题的事件上面，试想：一个手机被旅客禁止携带，简直是闻所未闻。</p>\n<p>抛开国外市场，暂且不说，其实在国内尚且没有发生重大变故的前提下，三星最该去做好各种公关，积极响应用户号召，和国外市场一视同仁，直接退换机型，这样，虽然会有一定的经济损失，但一定可以建立一个更好的口碑市场。其实中国用户很好打发，尤其是国人有“伸手不打笑脸人”的思想，中国人一直有种奇怪的认知，不在乎你犯错，但你认错的态度一定要诚恳，很多时候甚至媒体艺人喜欢拿这些来炒作自己。三星如果这次一开始就积极认错，最终大多数国人会这样认为：不愧是三星，和别的国际厂家就是不一样，能够做到一视同仁，即便产品本身没有问题都可以为用户考虑，这样的大公司值得信赖。而反观这次，三星是被中国用户“逼着”去承认自己的错误，三星国行用的香港的电池可能确实是没有问题，但国内用户关注的早已不是电池的问题，而是区别对待的问题，只要有个别用户愿意，没有问题也可以把你整出问题，而这种调查出来的<em>真相</em>又有多少人愿意去相信？只会不断请权威机构证明，陷入死循环。而中国政府这个时候如果帮三星澄清无意是打自己的脸。三星如果还想在中国混，必然不得不向消费者低头，所有不得不说，在有这么多区别对待海内外市场公司的前科下，三星还范这种错误，无疑让人很难理解。</p>"},{"layout":"post","title":"ubuntu关闭笔记本触摸板","date":"2016-10-18T06:09:00.000Z","_content":"\n*ubuntu 16.04的版本中，试过多个笔记本都可以通过键盘的快捷按键关闭触摸板的使用，但仍然显得不够智能，因为缺乏相关的程序和驱动，无法做到自动选择触摸板和鼠标。另外虽然我用的是ubuntu的系统但因为没有使用它的WM所以触摸板无法直接禁用，必须通过手动的方式才可以实现。*\n\n本文搜集了一些比较通用的触摸板禁用方式，另外后续如果找到更好的方法，还会补充上来。以下在dell的超极本和msi的游戏本上面实现过，且实验环境是ubuntu 16.04，其他系统和笔记本不能确保一定可以实现。\n\n### 详细步骤：\n\n#### 方法1：\n\n- sudo rmmod psmouse    这个是禁用触摸板\n- sudo modprobe psmouse 这个是启用触摸板\n\n方式简单快捷，但是会将触点和触板都禁用了，一般还是希望保持触点是启用的，且仅有启用和禁用的两个功能，每次需要指令才可以实现，无法做到智能识别鼠标自动启用禁用。\n\n\n<!-- more -->\n\n\n#### 方法2：\n \n在软件中心中搜索\"pointing-device\"安装，图形化界面操作简单方便。\n\n但新问题出现了：禁用之后，如果敲击键盘的话，那么触板又会启用。这个问题当时很头大啊。经测试发现，只要将系统自带的管理器中“敲击键盘时禁用触摸板”这一项的勾去掉。那么就不会出问题了。\n小结：以上就是对在Ubuntu系统下关闭触摸板很有用的两种方法，这两种方法使得以后再出现这样的情况时就可以采用的哦！\n\n*该方法我并没有尝试过，因为较少使用ubuntu自带的软件中心，有兴趣的朋友可以尝试下。*\n\n\n> 参考链接：  \n> http://www.285868.com/a/xtjc/5798.html\n","source":"_posts/2016/2016-10-18-ubuntu关闭笔记本触摸板.md","raw":"---\nlayout: \"post\"\ntitle: \"ubuntu关闭笔记本触摸板\"\ndate: \"2016-10-18 14:09\"\n---\n\n*ubuntu 16.04的版本中，试过多个笔记本都可以通过键盘的快捷按键关闭触摸板的使用，但仍然显得不够智能，因为缺乏相关的程序和驱动，无法做到自动选择触摸板和鼠标。另外虽然我用的是ubuntu的系统但因为没有使用它的WM所以触摸板无法直接禁用，必须通过手动的方式才可以实现。*\n\n本文搜集了一些比较通用的触摸板禁用方式，另外后续如果找到更好的方法，还会补充上来。以下在dell的超极本和msi的游戏本上面实现过，且实验环境是ubuntu 16.04，其他系统和笔记本不能确保一定可以实现。\n\n### 详细步骤：\n\n#### 方法1：\n\n- sudo rmmod psmouse    这个是禁用触摸板\n- sudo modprobe psmouse 这个是启用触摸板\n\n方式简单快捷，但是会将触点和触板都禁用了，一般还是希望保持触点是启用的，且仅有启用和禁用的两个功能，每次需要指令才可以实现，无法做到智能识别鼠标自动启用禁用。\n\n\n<!-- more -->\n\n\n#### 方法2：\n \n在软件中心中搜索\"pointing-device\"安装，图形化界面操作简单方便。\n\n但新问题出现了：禁用之后，如果敲击键盘的话，那么触板又会启用。这个问题当时很头大啊。经测试发现，只要将系统自带的管理器中“敲击键盘时禁用触摸板”这一项的勾去掉。那么就不会出问题了。\n小结：以上就是对在Ubuntu系统下关闭触摸板很有用的两种方法，这两种方法使得以后再出现这样的情况时就可以采用的哦！\n\n*该方法我并没有尝试过，因为较少使用ubuntu自带的软件中心，有兴趣的朋友可以尝试下。*\n\n\n> 参考链接：  \n> http://www.285868.com/a/xtjc/5798.html\n","slug":"2016/2016-10-18-ubuntu关闭笔记本触摸板","published":1,"updated":"2016-12-16T01:49:12.946Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aib002vmumu5g8szq8h","content":"<p><em>ubuntu 16.04的版本中，试过多个笔记本都可以通过键盘的快捷按键关闭触摸板的使用，但仍然显得不够智能，因为缺乏相关的程序和驱动，无法做到自动选择触摸板和鼠标。另外虽然我用的是ubuntu的系统但因为没有使用它的WM所以触摸板无法直接禁用，必须通过手动的方式才可以实现。</em></p>\n<p>本文搜集了一些比较通用的触摸板禁用方式，另外后续如果找到更好的方法，还会补充上来。以下在dell的超极本和msi的游戏本上面实现过，且实验环境是ubuntu 16.04，其他系统和笔记本不能确保一定可以实现。</p>\n<h3 id=\"详细步骤：\"><a href=\"#详细步骤：\" class=\"headerlink\" title=\"详细步骤：\"></a>详细步骤：</h3><h4 id=\"方法1：\"><a href=\"#方法1：\" class=\"headerlink\" title=\"方法1：\"></a>方法1：</h4><ul>\n<li>sudo rmmod psmouse    这个是禁用触摸板</li>\n<li>sudo modprobe psmouse 这个是启用触摸板</li>\n</ul>\n<p>方式简单快捷，但是会将触点和触板都禁用了，一般还是希望保持触点是启用的，且仅有启用和禁用的两个功能，每次需要指令才可以实现，无法做到智能识别鼠标自动启用禁用。</p>\n<a id=\"more\"></a>\n<h4 id=\"方法2：\"><a href=\"#方法2：\" class=\"headerlink\" title=\"方法2：\"></a>方法2：</h4><p>在软件中心中搜索”pointing-device”安装，图形化界面操作简单方便。</p>\n<p>但新问题出现了：禁用之后，如果敲击键盘的话，那么触板又会启用。这个问题当时很头大啊。经测试发现，只要将系统自带的管理器中“敲击键盘时禁用触摸板”这一项的勾去掉。那么就不会出问题了。<br>小结：以上就是对在Ubuntu系统下关闭触摸板很有用的两种方法，这两种方法使得以后再出现这样的情况时就可以采用的哦！</p>\n<p><em>该方法我并没有尝试过，因为较少使用ubuntu自带的软件中心，有兴趣的朋友可以尝试下。</em></p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.285868.com/a/xtjc/5798.html\" target=\"_blank\" rel=\"external\">http://www.285868.com/a/xtjc/5798.html</a></p>\n</blockquote>\n","excerpt":"<p><em>ubuntu 16.04的版本中，试过多个笔记本都可以通过键盘的快捷按键关闭触摸板的使用，但仍然显得不够智能，因为缺乏相关的程序和驱动，无法做到自动选择触摸板和鼠标。另外虽然我用的是ubuntu的系统但因为没有使用它的WM所以触摸板无法直接禁用，必须通过手动的方式才可以实现。</em></p>\n<p>本文搜集了一些比较通用的触摸板禁用方式，另外后续如果找到更好的方法，还会补充上来。以下在dell的超极本和msi的游戏本上面实现过，且实验环境是ubuntu 16.04，其他系统和笔记本不能确保一定可以实现。</p>\n<h3 id=\"详细步骤：\"><a href=\"#详细步骤：\" class=\"headerlink\" title=\"详细步骤：\"></a>详细步骤：</h3><h4 id=\"方法1：\"><a href=\"#方法1：\" class=\"headerlink\" title=\"方法1：\"></a>方法1：</h4><ul>\n<li>sudo rmmod psmouse    这个是禁用触摸板</li>\n<li>sudo modprobe psmouse 这个是启用触摸板</li>\n</ul>\n<p>方式简单快捷，但是会将触点和触板都禁用了，一般还是希望保持触点是启用的，且仅有启用和禁用的两个功能，每次需要指令才可以实现，无法做到智能识别鼠标自动启用禁用。</p>","more":"<h4 id=\"方法2：\"><a href=\"#方法2：\" class=\"headerlink\" title=\"方法2：\"></a>方法2：</h4><p>在软件中心中搜索”pointing-device”安装，图形化界面操作简单方便。</p>\n<p>但新问题出现了：禁用之后，如果敲击键盘的话，那么触板又会启用。这个问题当时很头大啊。经测试发现，只要将系统自带的管理器中“敲击键盘时禁用触摸板”这一项的勾去掉。那么就不会出问题了。<br>小结：以上就是对在Ubuntu系统下关闭触摸板很有用的两种方法，这两种方法使得以后再出现这样的情况时就可以采用的哦！</p>\n<p><em>该方法我并没有尝试过，因为较少使用ubuntu自带的软件中心，有兴趣的朋友可以尝试下。</em></p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.285868.com/a/xtjc/5798.html\">http://www.285868.com/a/xtjc/5798.html</a></p>\n</blockquote>"},{"layout":"post","title":"usb转串口","date":"2016-10-19T11:28:00.000Z","_content":"\n使用单片机，对硬件编程的时候，可以说串口是最常用的交互方式，毕竟要安装一个显示器，显示屏等设备需要额外的开销，大量增加代码量，且很多场景并非必备外设。这篇文章将会详细的介绍单片机中最常使用的串口通信功能，这边通过**多篇文章**以51单片机和stm32为例，对串口（以ttl电平，232，485等）进行详细的论述。\n\n在实验调试单片机时，串口相当重要以及常用，而现在电脑却一般仅有usb口（考虑到串口非专业人士不再使用）。因此我们在使用单片机读取串口数据时，往往需要**将相应的串口转换为usb口**。由于串口这边根据串口的不同，主要介绍常见的几种转接方式。\n\n### 串口ttl转usb\n\n常规调试过程中，我们可以将单片机ttl电平的串口信号TX和RX，通过转换芯片变成usb总线的信号。**注意该过程既不是RS232也不是RS485，而是ttl的串口信号，该信号一般仅仅用来测试和下载，仅仅是方便使用而已。**\n\n通常我们用来讲ttl串口信号转换为usb信号的芯片可以分为三种：FT232,CH340,PL2303，价位由高到低。这边我仅仅使用过CH340,PL2303这两款芯片的模块，对比后缺失PL2303误码率较高（当然不排除厂家因素）。一般情况我们使用CH340较多，相对稳定且价格便宜。实现的原理如下，其他集中芯片也大体一致：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/1.png)\n\n建议大家使用CH340的模块，价格也很便宜，这边给出完整的电路原理图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/2.jpg)\n\n<!-- more -->\n\n\n### RS232串口转usb\n\n实际上是先将RS232转换为ttl电平，然后在通过上述方式转为usb通讯。下面详细介绍下RS232如何转换为ttl电平。\n\n一般我们通过使用max232或者max3232将RS232电平（逻辑1(MARK)=-3V～-15V，逻辑0(SPACE)=+3～+15V）转换为ttl电平（5V系列（5V TTL和5V CMOS）、3.3V系列，2.5V系列和1.8V系列）。\n\n- max232 供电电压5v，耗电5mA，外接4个1uF电容，传统5v供电单片机常用。\n- max3232 供电电压5v或3.3V，耗电0.3mA，外接4个0.1uF电容其他特性都一样，价格略有差别。现在更为常用\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/3.png)\n\n也就是说如果RS232串口想要和单片机链接通讯中间必须要有max232或者max3232这样的转换芯片，而如果RS232串口想要通过usb链接电脑，则必须先通过max232或者max3232转换成ttl信号，然后在通过CH340转换为usb通讯。\n\n### RS485串口转usb\n\nRS485的转换就更为丰富了，包括以下几种：RS485<->RS232，RS485<->ttl，RS485<->usb。网上基本也有各种转接头可以购买，这边仅做简要阐述。\n\n- RS485<->ttl：选用芯片MAX485(5V)或MAX3485(3.3V)类似上面提到的max232和max3232。\n- RS485<->RS232：一般核心采用MAX232+MAX485共同设计电路，但设计细节差异较大，可以参加文末给出的链接\n- RS485<->usb：分为两种方式：1.同RS232串口转usb类似，可以通过接MAX485转成ttl电平然后通过CH340转成usb通讯，2.将RS485转成RS232，然后再将RS232转成usb。\n\n\n***\n\n> 参考链接：\n> http://tieba.baidu.com/p/3263424064\n> http://wenku.baidu.com/link?url=_l22igEh5jeC75_3TLzsRkLGv6s08EbKd2VFO_ZfDEUzjN45DeXM5wljNK8_B1Jn0ptTP9es6JNRw-iveGSyWK3WI2jQx8qj9QxkATRjFnO\n> http://www.elecfans.com/article/88/131/189/2015/20150929385089.html\n","source":"_posts/2016/2016-10-19-usb转串口.md","raw":"---\nlayout: \"post\"\ntitle: \"usb转串口\"\ndate: \"2016-10-19 19:28\"\n---\n\n使用单片机，对硬件编程的时候，可以说串口是最常用的交互方式，毕竟要安装一个显示器，显示屏等设备需要额外的开销，大量增加代码量，且很多场景并非必备外设。这篇文章将会详细的介绍单片机中最常使用的串口通信功能，这边通过**多篇文章**以51单片机和stm32为例，对串口（以ttl电平，232，485等）进行详细的论述。\n\n在实验调试单片机时，串口相当重要以及常用，而现在电脑却一般仅有usb口（考虑到串口非专业人士不再使用）。因此我们在使用单片机读取串口数据时，往往需要**将相应的串口转换为usb口**。由于串口这边根据串口的不同，主要介绍常见的几种转接方式。\n\n### 串口ttl转usb\n\n常规调试过程中，我们可以将单片机ttl电平的串口信号TX和RX，通过转换芯片变成usb总线的信号。**注意该过程既不是RS232也不是RS485，而是ttl的串口信号，该信号一般仅仅用来测试和下载，仅仅是方便使用而已。**\n\n通常我们用来讲ttl串口信号转换为usb信号的芯片可以分为三种：FT232,CH340,PL2303，价位由高到低。这边我仅仅使用过CH340,PL2303这两款芯片的模块，对比后缺失PL2303误码率较高（当然不排除厂家因素）。一般情况我们使用CH340较多，相对稳定且价格便宜。实现的原理如下，其他集中芯片也大体一致：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/1.png)\n\n建议大家使用CH340的模块，价格也很便宜，这边给出完整的电路原理图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/2.jpg)\n\n<!-- more -->\n\n\n### RS232串口转usb\n\n实际上是先将RS232转换为ttl电平，然后在通过上述方式转为usb通讯。下面详细介绍下RS232如何转换为ttl电平。\n\n一般我们通过使用max232或者max3232将RS232电平（逻辑1(MARK)=-3V～-15V，逻辑0(SPACE)=+3～+15V）转换为ttl电平（5V系列（5V TTL和5V CMOS）、3.3V系列，2.5V系列和1.8V系列）。\n\n- max232 供电电压5v，耗电5mA，外接4个1uF电容，传统5v供电单片机常用。\n- max3232 供电电压5v或3.3V，耗电0.3mA，外接4个0.1uF电容其他特性都一样，价格略有差别。现在更为常用\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/3.png)\n\n也就是说如果RS232串口想要和单片机链接通讯中间必须要有max232或者max3232这样的转换芯片，而如果RS232串口想要通过usb链接电脑，则必须先通过max232或者max3232转换成ttl信号，然后在通过CH340转换为usb通讯。\n\n### RS485串口转usb\n\nRS485的转换就更为丰富了，包括以下几种：RS485<->RS232，RS485<->ttl，RS485<->usb。网上基本也有各种转接头可以购买，这边仅做简要阐述。\n\n- RS485<->ttl：选用芯片MAX485(5V)或MAX3485(3.3V)类似上面提到的max232和max3232。\n- RS485<->RS232：一般核心采用MAX232+MAX485共同设计电路，但设计细节差异较大，可以参加文末给出的链接\n- RS485<->usb：分为两种方式：1.同RS232串口转usb类似，可以通过接MAX485转成ttl电平然后通过CH340转成usb通讯，2.将RS485转成RS232，然后再将RS232转成usb。\n\n\n***\n\n> 参考链接：\n> http://tieba.baidu.com/p/3263424064\n> http://wenku.baidu.com/link?url=_l22igEh5jeC75_3TLzsRkLGv6s08EbKd2VFO_ZfDEUzjN45DeXM5wljNK8_B1Jn0ptTP9es6JNRw-iveGSyWK3WI2jQx8qj9QxkATRjFnO\n> http://www.elecfans.com/article/88/131/189/2015/20150929385089.html\n","slug":"2016/2016-10-19-usb转串口","published":1,"updated":"2016-12-16T01:49:18.714Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aic002wmumu4u4eo379","content":"<p>使用单片机，对硬件编程的时候，可以说串口是最常用的交互方式，毕竟要安装一个显示器，显示屏等设备需要额外的开销，大量增加代码量，且很多场景并非必备外设。这篇文章将会详细的介绍单片机中最常使用的串口通信功能，这边通过<strong>多篇文章</strong>以51单片机和stm32为例，对串口（以ttl电平，232，485等）进行详细的论述。</p>\n<p>在实验调试单片机时，串口相当重要以及常用，而现在电脑却一般仅有usb口（考虑到串口非专业人士不再使用）。因此我们在使用单片机读取串口数据时，往往需要<strong>将相应的串口转换为usb口</strong>。由于串口这边根据串口的不同，主要介绍常见的几种转接方式。</p>\n<h3 id=\"串口ttl转usb\"><a href=\"#串口ttl转usb\" class=\"headerlink\" title=\"串口ttl转usb\"></a>串口ttl转usb</h3><p>常规调试过程中，我们可以将单片机ttl电平的串口信号TX和RX，通过转换芯片变成usb总线的信号。<strong>注意该过程既不是RS232也不是RS485，而是ttl的串口信号，该信号一般仅仅用来测试和下载，仅仅是方便使用而已。</strong></p>\n<p>通常我们用来讲ttl串口信号转换为usb信号的芯片可以分为三种：FT232,CH340,PL2303，价位由高到低。这边我仅仅使用过CH340,PL2303这两款芯片的模块，对比后缺失PL2303误码率较高（当然不排除厂家因素）。一般情况我们使用CH340较多，相对稳定且价格便宜。实现的原理如下，其他集中芯片也大体一致：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/1.png\" alt=\"\"></p>\n<p>建议大家使用CH340的模块，价格也很便宜，这边给出完整的电路原理图：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/2.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"RS232串口转usb\"><a href=\"#RS232串口转usb\" class=\"headerlink\" title=\"RS232串口转usb\"></a>RS232串口转usb</h3><p>实际上是先将RS232转换为ttl电平，然后在通过上述方式转为usb通讯。下面详细介绍下RS232如何转换为ttl电平。</p>\n<p>一般我们通过使用max232或者max3232将RS232电平（逻辑1(MARK)=-3V～-15V，逻辑0(SPACE)=+3～+15V）转换为ttl电平（5V系列（5V TTL和5V CMOS）、3.3V系列，2.5V系列和1.8V系列）。</p>\n<ul>\n<li>max232 供电电压5v，耗电5mA，外接4个1uF电容，传统5v供电单片机常用。</li>\n<li>max3232 供电电压5v或3.3V，耗电0.3mA，外接4个0.1uF电容其他特性都一样，价格略有差别。现在更为常用</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/3.png\" alt=\"\"></p>\n<p>也就是说如果RS232串口想要和单片机链接通讯中间必须要有max232或者max3232这样的转换芯片，而如果RS232串口想要通过usb链接电脑，则必须先通过max232或者max3232转换成ttl信号，然后在通过CH340转换为usb通讯。</p>\n<h3 id=\"RS485串口转usb\"><a href=\"#RS485串口转usb\" class=\"headerlink\" title=\"RS485串口转usb\"></a>RS485串口转usb</h3><p>RS485的转换就更为丰富了，包括以下几种：RS485&lt;-&gt;RS232，RS485&lt;-&gt;ttl，RS485&lt;-&gt;usb。网上基本也有各种转接头可以购买，这边仅做简要阐述。</p>\n<ul>\n<li>RS485&lt;-&gt;ttl：选用芯片MAX485(5V)或MAX3485(3.3V)类似上面提到的max232和max3232。</li>\n<li>RS485&lt;-&gt;RS232：一般核心采用MAX232+MAX485共同设计电路，但设计细节差异较大，可以参加文末给出的链接</li>\n<li>RS485&lt;-&gt;usb：分为两种方式：1.同RS232串口转usb类似，可以通过接MAX485转成ttl电平然后通过CH340转成usb通讯，2.将RS485转成RS232，然后再将RS232转成usb。</li>\n</ul>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://tieba.baidu.com/p/3263424064\" target=\"_blank\" rel=\"external\">http://tieba.baidu.com/p/3263424064</a><br><a href=\"http://wenku.baidu.com/link?url=_l22igEh5jeC75_3TLzsRkLGv6s08EbKd2VFO_ZfDEUzjN45DeXM5wljNK8_B1Jn0ptTP9es6JNRw-iveGSyWK3WI2jQx8qj9QxkATRjFnO\" target=\"_blank\" rel=\"external\">http://wenku.baidu.com/link?url=_l22igEh5jeC75_3TLzsRkLGv6s08EbKd2VFO_ZfDEUzjN45DeXM5wljNK8_B1Jn0ptTP9es6JNRw-iveGSyWK3WI2jQx8qj9QxkATRjFnO</a><br><a href=\"http://www.elecfans.com/article/88/131/189/2015/20150929385089.html\" target=\"_blank\" rel=\"external\">http://www.elecfans.com/article/88/131/189/2015/20150929385089.html</a></p>\n</blockquote>\n","excerpt":"<p>使用单片机，对硬件编程的时候，可以说串口是最常用的交互方式，毕竟要安装一个显示器，显示屏等设备需要额外的开销，大量增加代码量，且很多场景并非必备外设。这篇文章将会详细的介绍单片机中最常使用的串口通信功能，这边通过<strong>多篇文章</strong>以51单片机和stm32为例，对串口（以ttl电平，232，485等）进行详细的论述。</p>\n<p>在实验调试单片机时，串口相当重要以及常用，而现在电脑却一般仅有usb口（考虑到串口非专业人士不再使用）。因此我们在使用单片机读取串口数据时，往往需要<strong>将相应的串口转换为usb口</strong>。由于串口这边根据串口的不同，主要介绍常见的几种转接方式。</p>\n<h3 id=\"串口ttl转usb\"><a href=\"#串口ttl转usb\" class=\"headerlink\" title=\"串口ttl转usb\"></a>串口ttl转usb</h3><p>常规调试过程中，我们可以将单片机ttl电平的串口信号TX和RX，通过转换芯片变成usb总线的信号。<strong>注意该过程既不是RS232也不是RS485，而是ttl的串口信号，该信号一般仅仅用来测试和下载，仅仅是方便使用而已。</strong></p>\n<p>通常我们用来讲ttl串口信号转换为usb信号的芯片可以分为三种：FT232,CH340,PL2303，价位由高到低。这边我仅仅使用过CH340,PL2303这两款芯片的模块，对比后缺失PL2303误码率较高（当然不排除厂家因素）。一般情况我们使用CH340较多，相对稳定且价格便宜。实现的原理如下，其他集中芯片也大体一致：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/1.png\" alt=\"\"></p>\n<p>建议大家使用CH340的模块，价格也很便宜，这边给出完整的电路原理图：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/2.jpg\" alt=\"\"></p>","more":"<h3 id=\"RS232串口转usb\"><a href=\"#RS232串口转usb\" class=\"headerlink\" title=\"RS232串口转usb\"></a>RS232串口转usb</h3><p>实际上是先将RS232转换为ttl电平，然后在通过上述方式转为usb通讯。下面详细介绍下RS232如何转换为ttl电平。</p>\n<p>一般我们通过使用max232或者max3232将RS232电平（逻辑1(MARK)=-3V～-15V，逻辑0(SPACE)=+3～+15V）转换为ttl电平（5V系列（5V TTL和5V CMOS）、3.3V系列，2.5V系列和1.8V系列）。</p>\n<ul>\n<li>max232 供电电压5v，耗电5mA，外接4个1uF电容，传统5v供电单片机常用。</li>\n<li>max3232 供电电压5v或3.3V，耗电0.3mA，外接4个0.1uF电容其他特性都一样，价格略有差别。现在更为常用</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/3.png\" alt=\"\"></p>\n<p>也就是说如果RS232串口想要和单片机链接通讯中间必须要有max232或者max3232这样的转换芯片，而如果RS232串口想要通过usb链接电脑，则必须先通过max232或者max3232转换成ttl信号，然后在通过CH340转换为usb通讯。</p>\n<h3 id=\"RS485串口转usb\"><a href=\"#RS485串口转usb\" class=\"headerlink\" title=\"RS485串口转usb\"></a>RS485串口转usb</h3><p>RS485的转换就更为丰富了，包括以下几种：RS485&lt;-&gt;RS232，RS485&lt;-&gt;ttl，RS485&lt;-&gt;usb。网上基本也有各种转接头可以购买，这边仅做简要阐述。</p>\n<ul>\n<li>RS485&lt;-&gt;ttl：选用芯片MAX485(5V)或MAX3485(3.3V)类似上面提到的max232和max3232。</li>\n<li>RS485&lt;-&gt;RS232：一般核心采用MAX232+MAX485共同设计电路，但设计细节差异较大，可以参加文末给出的链接</li>\n<li>RS485&lt;-&gt;usb：分为两种方式：1.同RS232串口转usb类似，可以通过接MAX485转成ttl电平然后通过CH340转成usb通讯，2.将RS485转成RS232，然后再将RS232转成usb。</li>\n</ul>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://tieba.baidu.com/p/3263424064\">http://tieba.baidu.com/p/3263424064</a><br><a href=\"http://wenku.baidu.com/link?url=_l22igEh5jeC75_3TLzsRkLGv6s08EbKd2VFO_ZfDEUzjN45DeXM5wljNK8_B1Jn0ptTP9es6JNRw-iveGSyWK3WI2jQx8qj9QxkATRjFnO\">http://wenku.baidu.com/link?url=_l22igEh5jeC75_3TLzsRkLGv6s08EbKd2VFO_ZfDEUzjN45DeXM5wljNK8_B1Jn0ptTP9es6JNRw-iveGSyWK3WI2jQx8qj9QxkATRjFnO</a><br><a href=\"http://www.elecfans.com/article/88/131/189/2015/20150929385089.html\">http://www.elecfans.com/article/88/131/189/2015/20150929385089.html</a></p>\n</blockquote>"},{"layout":"post","title":"计算机中的通信简介","date":"2016-10-17T18:00:00.000Z","_content":"\n计算机从最初发展到现在已经有半个多世纪的历史，众所周知其实计算机就是一堆电路的组成，传统最为通用的计算功能仅仅是控制高低电平，输入输出（0和1）。而计算机中的CPU和其他设备如内存，硬盘，主板的其他电路连接过程中，控制的过程就是通过相关的通信协议，让一堆的高低电平输入输出最终可以转化为我们我们工作需要的内容，而赋予这些0,1实际意义的就是通信协议。计算机中有着众多的通信协议，有些协议已经逐渐被淘汰，而另外一些经过这么多年的发展仍然在各行各业经久不衰，一些更新更稳定更满足这个时代需求的协议也正在被越来越多的智能设备移动设备所采纳。本文仅仅是简要的叙述计算机嵌入式中最常用的一些协议。\n\n这边如果对码元，波特率等还不是恨清除的可以参考**传输速率**这篇文章。\n\n*在了解通信协议和传输前，得先弄明白：总线和协议，串行传输和并行传输，同步通信和异步通信，全双工和半双工等基本概念，至于具体的通信方式和协议，这边仅作简述，有单独文章进行具体阐述。*\n\n### 总线和协议  \n\n在展开讲解之前，先来区分两个概念：总线和协议。\n\n**总线**是一组信号线的集合，它定义了各引线的信号、电机、机械特性，使计算机内部各组成部分之间以及不同的计算机之间建立信号联系，进行信息传送和通信，按照作用范围简单来分可以分为内部总线和外部总线。内部总线：就是计算机内部功能模板之间进行通信的总线，它是构成完整的计算机系统的内部信息枢纽，但按功能仍要分为数据总线DB，地址总线AB，控制总线CB，电源总线PB。外部总线是计算机与计算机之间或计算机与其他智能设备之间进行通信的连接。但随着嵌入式不断的发展，现在在两者的区分已经不是那么严格，USB的传输可以认作是外部串行传输方式，而传统所认为是内部穿行传输方式的IIC现在也被一些外接的传感器所使用，因此在嵌入式领域已经无需再纠结是内部总线还是外部总线，毕竟为了满足需求很多原有的协议已经进行的改进使得传输距离更远，抗干扰性更强了，也有更多曾经的内部总线被在外部所使用了。\n\n通信协议是指双方实体完成通信或服务所必须遵循的规则和约定。协议定义了数据单元使用的格式，信息单元应该包含的信息与含义，连接方式，信息发送和接收的时序，从而确保在通信过程中数据顺利地传送到确定的地方。\n\n*因为总线的种类实在太多，各种总线的衍生品层出不穷，这边就不详细列举，以下仅仅将目前嵌入式/微机上面最为常见的通信方式列举出来。*\n\n\n<!-- more -->\n\n\n### 串行总线和并行总线\n\n采用串行传输方式的总线被成为串行总线，一条信息的各位数据被逐位按顺序传送的通讯方式称为串行通讯。串行通讯的特点是：数据位传送，传按位顺序进行，最少只需一根传输线即可完成，成本低但送速度慢。串行通讯的距离可以从几米到几千米。 根据信息的传送方向，串行通讯可以进一步分为单工、半双工和全双工三种。信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工；信息能够同时双向传送则称为全双工。\n\n串口形容一下就是一条车道，而并口就是有8个车道同一时刻能传送8位（一个字节）数据。但是并不是说并口快，由于8位通道之间的互相干扰（串扰），传输时速度就受到了限制，传输容易出错。串口没有互相干扰。并口同时发送的数据量大，但要比串口慢。串口硬盘就是这样被人们重视的。\n\n采用并行传输方式的总线被成为并行总线，并行通讯通常可以一次传送8bit、16bit、32bit甚至更高的位数，相应地就需要8根、16根、32根信号线，同时也需要加入更多的信号地线。比如传统的PATA线路有40根线，其中有16根信号线和7根信号地线，其他为各种控制线，一次可以传送2Byte的数据。并行通讯中，数据信号中无法携带时钟信息（需要时钟信息，是为了确保一次发送的为一组相关数据，当始终跳转一次的时候，再发送下一租数据，如果缺少始终信息，而多组数据的传输有快有慢的话，则所有数据会串扰，通讯毫无意义。而串行通讯则没有这样的问题，一个个位发送，最终只需按照协议整合数据即可，当然也有部分穿行通信协议利用时钟来实现附加的操作），为了保证各对信号线上的信号时序一致，并行设备需要严格同步时钟信号，或者采用额外的时钟信号线。\n\n\n通过串行通讯与并行通讯的对比，可以看出：串行通讯很简单，但是相对速度低，抗干扰能力强（可以用在长距离通讯），成本低；并行通讯比较复杂，但是相对速度高，成本高（需要更多的线），抗干扰能力弱（传输距离短）。\n\n### 同步通信和异步通信\n\n异步通信就是发送方在任意时刻都可以发送数据，前提是接收端已经做好了接受数据的准备（如果没有做好接受准备，数据肯定发送失败），也正是因为发送方的不确定性，所以接收方要时时刻刻的准备好接受数据，同时由于每次发送数据时间间隔的不确定性，所以，在每次发送数据时都要使用明确的界定符来标示数据（字符）的开始和结束位置，可以想象这种通信方式效率很低。虽然异步通信效率低，但是对设备的要求不高，通信设备简单。异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，**字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。**\n\n同步通信和异步通信相反，就是主机在进行通信前要先建立同步，即要使用相同的时钟频率，发送方的发送频率和接受方的接受频率要同步。\n\n除了时间频率的不同外，异步通信和同步通信之间的区别还是发送数据的表示形式，异步通信一般发送单位是字符，同步通信发送单位是比特流（数据帧），但是这不是绝对的，异步通信有时也使用帧来通信。同步通讯进行数据传输时，发送和接收双方要保持完全的同步，因此，要求接收和发送设备必须使用同一时钟。优点是可以实现高速度、大容量的数据传送；缺点是要求发生时钟和接收时钟保持严格同步，同时硬件复杂。可以这样说，不管是异步通信还是同步通信都需要进行同步，只是异步通信通过传送字符内的起始位来进行同步，而同步通信采用共用外部时钟来进行同步。所以，可以说前者是自同步，后者是外同步。事实上目前大多是采用异步通讯，极少数是采用同步通讯的。\n\n### 单工，全双工和半双工\n\n- 如果在通信过程的任意时刻，信息只能由一方A传到另一方B，则称为单工。\n- 如果在任意时刻，信息既可由A传到B，又能由B传A，但只能由一个方向上的传输存在（即不能同时传输）,称为半双工传输。\n- 如果在任意时刻，线路上存在A到B和B到A的双向信号传输，则称为全双工。\n\n\n\n\n### 串口通信 （见详细文章）\n\n串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。曾经PC之间进行串口通信可以说是标配，很多老式电脑上面可以看到DB25的接头，但后来逐渐被DB9取代，早期鼠标打印机都通过串口进行数据传输的，但现在逐渐被USB和网络所取代，DB9的串口接头在PC和笔记本上面也较少能够看到了。做嵌入式开发可以看到有个DB9的串口标准接口，串口对于开发人员输入输出调试等有着至关重要的作用。串行接口按电气标准及协议来分包括RS-232-C、RS-422、RS485等，现在串口一般在工业嵌入式领域使用。\n\n在使用串口通信时最重要的参数：波特率，数据位，停止位，奇偶校验位。\n\n同步通信和异步通信：异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。\n\n#### RS-232-C\n\n传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座（DB25），后来使用简化为9芯D型插座（DB9），现在应用中25芯插头座已很少采用。目前一般可以见到的串口接头都为DB9的232接口，\n\n- RS-232串口通信最远距离是50英尺，约为15m\n- RS-232可做到双向传输，全双工通讯，最高传输速率20kbps\n- RS-232C上传送的数字量采用负逻辑，且与地对称：逻辑1：-3 ～-15V  逻辑0：+3～+15V （）\n\n#### RS-485\n\n232串口在实际使用已经用处不大，但基于232发展出来的485等串口设备仍然被广泛使用，RS-485（EIA-485标准）是RS-422的改进，因为它增加了设备的个数，从10个增加到32个，同时定义了在最大设备个数情况下的电气特性，以保证足够的信号电压。有了多个设备的能力，你可以使用一个单个RS-485口建立设备网络。\n\n因为都是串口通信，所以本质两者是相差无几的，但耗材少，抗干扰强等特点让RS485在目前的工业领域仍然被广泛使用，这边主要列举出不同：\n\n- 从接线上，RS232是三线制，RS485是两线制\n- 从传输距离上，RS232只能传输15米，RS485最远可以传输1200米\n- 从速率上，RS232是全双工传输，RS485是半双工传输\n- 从协议层上，RS232只支持点对点通讯(1:1)，RS485支持总线形式通讯（1:N）\n\n\n\n\n### SPI\n\nSPI是串行外设接口（Serial Peripheral Interface）的缩写。SPI，是一种高速的，**全双工**，**同步**的通信总线，并且在芯片的管脚上只占用**四根线**，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，如今越来越多的芯片集成了这种通信协议，比如AT91RM9200，stm32f103等。\n:\n\n\n\n\n\n\n### IIC\n\nIIC 即Inter-Integrated Circuit(集成电路总线），这种总线类型是由飞利浦半导体公司在八十年代初设计出来的一种简单、双向、二线制、同步串行总线，主要是用来连接整体电路(ICS) ，IIC是一种多向控制总线，也就是说多个芯片可以连接到同一总线结构下，同时每个芯片都可以作为实时数据传输的控制源。这种方式简化了信号传输总线接口，如今越来越多的芯片集成了这种通信协议，比如stm32f103，EFM32等。\n\n\n\n\n### \n\n\n***\n\nTo be continued...\n\n\n> 参考链接：\n> http://blog.csdn.net/wind19/article/details/7433249\n> http://baike.baidu.com/view/185322.htm\n> http://www.cnblogs.com/mylinux/p/4078576.html\n> http://baike.baidu.com/view/716175.htm\n> https://www.zhihu.com/question/29033993\n> http://www.cnblogs.com/general001/articles/2344079.html\n> http://blog.csdn.net/weiqifa0/article/details/8845281\n> http://www.cnblogs.com/jason-lu/articles/3171870.html\n","source":"_posts/2016/2016-10-18-计算机中的通信简介.md","raw":"---\nlayout: \"post\"\ntitle: \"计算机中的通信简介\"\ndate: \"2016-10-18 2:00\"\n---\n\n计算机从最初发展到现在已经有半个多世纪的历史，众所周知其实计算机就是一堆电路的组成，传统最为通用的计算功能仅仅是控制高低电平，输入输出（0和1）。而计算机中的CPU和其他设备如内存，硬盘，主板的其他电路连接过程中，控制的过程就是通过相关的通信协议，让一堆的高低电平输入输出最终可以转化为我们我们工作需要的内容，而赋予这些0,1实际意义的就是通信协议。计算机中有着众多的通信协议，有些协议已经逐渐被淘汰，而另外一些经过这么多年的发展仍然在各行各业经久不衰，一些更新更稳定更满足这个时代需求的协议也正在被越来越多的智能设备移动设备所采纳。本文仅仅是简要的叙述计算机嵌入式中最常用的一些协议。\n\n这边如果对码元，波特率等还不是恨清除的可以参考**传输速率**这篇文章。\n\n*在了解通信协议和传输前，得先弄明白：总线和协议，串行传输和并行传输，同步通信和异步通信，全双工和半双工等基本概念，至于具体的通信方式和协议，这边仅作简述，有单独文章进行具体阐述。*\n\n### 总线和协议  \n\n在展开讲解之前，先来区分两个概念：总线和协议。\n\n**总线**是一组信号线的集合，它定义了各引线的信号、电机、机械特性，使计算机内部各组成部分之间以及不同的计算机之间建立信号联系，进行信息传送和通信，按照作用范围简单来分可以分为内部总线和外部总线。内部总线：就是计算机内部功能模板之间进行通信的总线，它是构成完整的计算机系统的内部信息枢纽，但按功能仍要分为数据总线DB，地址总线AB，控制总线CB，电源总线PB。外部总线是计算机与计算机之间或计算机与其他智能设备之间进行通信的连接。但随着嵌入式不断的发展，现在在两者的区分已经不是那么严格，USB的传输可以认作是外部串行传输方式，而传统所认为是内部穿行传输方式的IIC现在也被一些外接的传感器所使用，因此在嵌入式领域已经无需再纠结是内部总线还是外部总线，毕竟为了满足需求很多原有的协议已经进行的改进使得传输距离更远，抗干扰性更强了，也有更多曾经的内部总线被在外部所使用了。\n\n通信协议是指双方实体完成通信或服务所必须遵循的规则和约定。协议定义了数据单元使用的格式，信息单元应该包含的信息与含义，连接方式，信息发送和接收的时序，从而确保在通信过程中数据顺利地传送到确定的地方。\n\n*因为总线的种类实在太多，各种总线的衍生品层出不穷，这边就不详细列举，以下仅仅将目前嵌入式/微机上面最为常见的通信方式列举出来。*\n\n\n<!-- more -->\n\n\n### 串行总线和并行总线\n\n采用串行传输方式的总线被成为串行总线，一条信息的各位数据被逐位按顺序传送的通讯方式称为串行通讯。串行通讯的特点是：数据位传送，传按位顺序进行，最少只需一根传输线即可完成，成本低但送速度慢。串行通讯的距离可以从几米到几千米。 根据信息的传送方向，串行通讯可以进一步分为单工、半双工和全双工三种。信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工；信息能够同时双向传送则称为全双工。\n\n串口形容一下就是一条车道，而并口就是有8个车道同一时刻能传送8位（一个字节）数据。但是并不是说并口快，由于8位通道之间的互相干扰（串扰），传输时速度就受到了限制，传输容易出错。串口没有互相干扰。并口同时发送的数据量大，但要比串口慢。串口硬盘就是这样被人们重视的。\n\n采用并行传输方式的总线被成为并行总线，并行通讯通常可以一次传送8bit、16bit、32bit甚至更高的位数，相应地就需要8根、16根、32根信号线，同时也需要加入更多的信号地线。比如传统的PATA线路有40根线，其中有16根信号线和7根信号地线，其他为各种控制线，一次可以传送2Byte的数据。并行通讯中，数据信号中无法携带时钟信息（需要时钟信息，是为了确保一次发送的为一组相关数据，当始终跳转一次的时候，再发送下一租数据，如果缺少始终信息，而多组数据的传输有快有慢的话，则所有数据会串扰，通讯毫无意义。而串行通讯则没有这样的问题，一个个位发送，最终只需按照协议整合数据即可，当然也有部分穿行通信协议利用时钟来实现附加的操作），为了保证各对信号线上的信号时序一致，并行设备需要严格同步时钟信号，或者采用额外的时钟信号线。\n\n\n通过串行通讯与并行通讯的对比，可以看出：串行通讯很简单，但是相对速度低，抗干扰能力强（可以用在长距离通讯），成本低；并行通讯比较复杂，但是相对速度高，成本高（需要更多的线），抗干扰能力弱（传输距离短）。\n\n### 同步通信和异步通信\n\n异步通信就是发送方在任意时刻都可以发送数据，前提是接收端已经做好了接受数据的准备（如果没有做好接受准备，数据肯定发送失败），也正是因为发送方的不确定性，所以接收方要时时刻刻的准备好接受数据，同时由于每次发送数据时间间隔的不确定性，所以，在每次发送数据时都要使用明确的界定符来标示数据（字符）的开始和结束位置，可以想象这种通信方式效率很低。虽然异步通信效率低，但是对设备的要求不高，通信设备简单。异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，**字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。**\n\n同步通信和异步通信相反，就是主机在进行通信前要先建立同步，即要使用相同的时钟频率，发送方的发送频率和接受方的接受频率要同步。\n\n除了时间频率的不同外，异步通信和同步通信之间的区别还是发送数据的表示形式，异步通信一般发送单位是字符，同步通信发送单位是比特流（数据帧），但是这不是绝对的，异步通信有时也使用帧来通信。同步通讯进行数据传输时，发送和接收双方要保持完全的同步，因此，要求接收和发送设备必须使用同一时钟。优点是可以实现高速度、大容量的数据传送；缺点是要求发生时钟和接收时钟保持严格同步，同时硬件复杂。可以这样说，不管是异步通信还是同步通信都需要进行同步，只是异步通信通过传送字符内的起始位来进行同步，而同步通信采用共用外部时钟来进行同步。所以，可以说前者是自同步，后者是外同步。事实上目前大多是采用异步通讯，极少数是采用同步通讯的。\n\n### 单工，全双工和半双工\n\n- 如果在通信过程的任意时刻，信息只能由一方A传到另一方B，则称为单工。\n- 如果在任意时刻，信息既可由A传到B，又能由B传A，但只能由一个方向上的传输存在（即不能同时传输）,称为半双工传输。\n- 如果在任意时刻，线路上存在A到B和B到A的双向信号传输，则称为全双工。\n\n\n\n\n### 串口通信 （见详细文章）\n\n串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。曾经PC之间进行串口通信可以说是标配，很多老式电脑上面可以看到DB25的接头，但后来逐渐被DB9取代，早期鼠标打印机都通过串口进行数据传输的，但现在逐渐被USB和网络所取代，DB9的串口接头在PC和笔记本上面也较少能够看到了。做嵌入式开发可以看到有个DB9的串口标准接口，串口对于开发人员输入输出调试等有着至关重要的作用。串行接口按电气标准及协议来分包括RS-232-C、RS-422、RS485等，现在串口一般在工业嵌入式领域使用。\n\n在使用串口通信时最重要的参数：波特率，数据位，停止位，奇偶校验位。\n\n同步通信和异步通信：异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。\n\n#### RS-232-C\n\n传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座（DB25），后来使用简化为9芯D型插座（DB9），现在应用中25芯插头座已很少采用。目前一般可以见到的串口接头都为DB9的232接口，\n\n- RS-232串口通信最远距离是50英尺，约为15m\n- RS-232可做到双向传输，全双工通讯，最高传输速率20kbps\n- RS-232C上传送的数字量采用负逻辑，且与地对称：逻辑1：-3 ～-15V  逻辑0：+3～+15V （）\n\n#### RS-485\n\n232串口在实际使用已经用处不大，但基于232发展出来的485等串口设备仍然被广泛使用，RS-485（EIA-485标准）是RS-422的改进，因为它增加了设备的个数，从10个增加到32个，同时定义了在最大设备个数情况下的电气特性，以保证足够的信号电压。有了多个设备的能力，你可以使用一个单个RS-485口建立设备网络。\n\n因为都是串口通信，所以本质两者是相差无几的，但耗材少，抗干扰强等特点让RS485在目前的工业领域仍然被广泛使用，这边主要列举出不同：\n\n- 从接线上，RS232是三线制，RS485是两线制\n- 从传输距离上，RS232只能传输15米，RS485最远可以传输1200米\n- 从速率上，RS232是全双工传输，RS485是半双工传输\n- 从协议层上，RS232只支持点对点通讯(1:1)，RS485支持总线形式通讯（1:N）\n\n\n\n\n### SPI\n\nSPI是串行外设接口（Serial Peripheral Interface）的缩写。SPI，是一种高速的，**全双工**，**同步**的通信总线，并且在芯片的管脚上只占用**四根线**，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，如今越来越多的芯片集成了这种通信协议，比如AT91RM9200，stm32f103等。\n:\n\n\n\n\n\n\n### IIC\n\nIIC 即Inter-Integrated Circuit(集成电路总线），这种总线类型是由飞利浦半导体公司在八十年代初设计出来的一种简单、双向、二线制、同步串行总线，主要是用来连接整体电路(ICS) ，IIC是一种多向控制总线，也就是说多个芯片可以连接到同一总线结构下，同时每个芯片都可以作为实时数据传输的控制源。这种方式简化了信号传输总线接口，如今越来越多的芯片集成了这种通信协议，比如stm32f103，EFM32等。\n\n\n\n\n### \n\n\n***\n\nTo be continued...\n\n\n> 参考链接：\n> http://blog.csdn.net/wind19/article/details/7433249\n> http://baike.baidu.com/view/185322.htm\n> http://www.cnblogs.com/mylinux/p/4078576.html\n> http://baike.baidu.com/view/716175.htm\n> https://www.zhihu.com/question/29033993\n> http://www.cnblogs.com/general001/articles/2344079.html\n> http://blog.csdn.net/weiqifa0/article/details/8845281\n> http://www.cnblogs.com/jason-lu/articles/3171870.html\n","slug":"2016/2016-10-18-计算机中的通信简介","published":1,"updated":"2016-12-16T01:49:16.430Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aic002xmumuf7cdudl0","content":"<p>计算机从最初发展到现在已经有半个多世纪的历史，众所周知其实计算机就是一堆电路的组成，传统最为通用的计算功能仅仅是控制高低电平，输入输出（0和1）。而计算机中的CPU和其他设备如内存，硬盘，主板的其他电路连接过程中，控制的过程就是通过相关的通信协议，让一堆的高低电平输入输出最终可以转化为我们我们工作需要的内容，而赋予这些0,1实际意义的就是通信协议。计算机中有着众多的通信协议，有些协议已经逐渐被淘汰，而另外一些经过这么多年的发展仍然在各行各业经久不衰，一些更新更稳定更满足这个时代需求的协议也正在被越来越多的智能设备移动设备所采纳。本文仅仅是简要的叙述计算机嵌入式中最常用的一些协议。</p>\n<p>这边如果对码元，波特率等还不是恨清除的可以参考<strong>传输速率</strong>这篇文章。</p>\n<p><em>在了解通信协议和传输前，得先弄明白：总线和协议，串行传输和并行传输，同步通信和异步通信，全双工和半双工等基本概念，至于具体的通信方式和协议，这边仅作简述，有单独文章进行具体阐述。</em></p>\n<h3 id=\"总线和协议\"><a href=\"#总线和协议\" class=\"headerlink\" title=\"总线和协议\"></a>总线和协议</h3><p>在展开讲解之前，先来区分两个概念：总线和协议。</p>\n<p><strong>总线</strong>是一组信号线的集合，它定义了各引线的信号、电机、机械特性，使计算机内部各组成部分之间以及不同的计算机之间建立信号联系，进行信息传送和通信，按照作用范围简单来分可以分为内部总线和外部总线。内部总线：就是计算机内部功能模板之间进行通信的总线，它是构成完整的计算机系统的内部信息枢纽，但按功能仍要分为数据总线DB，地址总线AB，控制总线CB，电源总线PB。外部总线是计算机与计算机之间或计算机与其他智能设备之间进行通信的连接。但随着嵌入式不断的发展，现在在两者的区分已经不是那么严格，USB的传输可以认作是外部串行传输方式，而传统所认为是内部穿行传输方式的IIC现在也被一些外接的传感器所使用，因此在嵌入式领域已经无需再纠结是内部总线还是外部总线，毕竟为了满足需求很多原有的协议已经进行的改进使得传输距离更远，抗干扰性更强了，也有更多曾经的内部总线被在外部所使用了。</p>\n<p>通信协议是指双方实体完成通信或服务所必须遵循的规则和约定。协议定义了数据单元使用的格式，信息单元应该包含的信息与含义，连接方式，信息发送和接收的时序，从而确保在通信过程中数据顺利地传送到确定的地方。</p>\n<p><em>因为总线的种类实在太多，各种总线的衍生品层出不穷，这边就不详细列举，以下仅仅将目前嵌入式/微机上面最为常见的通信方式列举出来。</em></p>\n<a id=\"more\"></a>\n<h3 id=\"串行总线和并行总线\"><a href=\"#串行总线和并行总线\" class=\"headerlink\" title=\"串行总线和并行总线\"></a>串行总线和并行总线</h3><p>采用串行传输方式的总线被成为串行总线，一条信息的各位数据被逐位按顺序传送的通讯方式称为串行通讯。串行通讯的特点是：数据位传送，传按位顺序进行，最少只需一根传输线即可完成，成本低但送速度慢。串行通讯的距离可以从几米到几千米。 根据信息的传送方向，串行通讯可以进一步分为单工、半双工和全双工三种。信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工；信息能够同时双向传送则称为全双工。</p>\n<p>串口形容一下就是一条车道，而并口就是有8个车道同一时刻能传送8位（一个字节）数据。但是并不是说并口快，由于8位通道之间的互相干扰（串扰），传输时速度就受到了限制，传输容易出错。串口没有互相干扰。并口同时发送的数据量大，但要比串口慢。串口硬盘就是这样被人们重视的。</p>\n<p>采用并行传输方式的总线被成为并行总线，并行通讯通常可以一次传送8bit、16bit、32bit甚至更高的位数，相应地就需要8根、16根、32根信号线，同时也需要加入更多的信号地线。比如传统的PATA线路有40根线，其中有16根信号线和7根信号地线，其他为各种控制线，一次可以传送2Byte的数据。并行通讯中，数据信号中无法携带时钟信息（需要时钟信息，是为了确保一次发送的为一组相关数据，当始终跳转一次的时候，再发送下一租数据，如果缺少始终信息，而多组数据的传输有快有慢的话，则所有数据会串扰，通讯毫无意义。而串行通讯则没有这样的问题，一个个位发送，最终只需按照协议整合数据即可，当然也有部分穿行通信协议利用时钟来实现附加的操作），为了保证各对信号线上的信号时序一致，并行设备需要严格同步时钟信号，或者采用额外的时钟信号线。</p>\n<p>通过串行通讯与并行通讯的对比，可以看出：串行通讯很简单，但是相对速度低，抗干扰能力强（可以用在长距离通讯），成本低；并行通讯比较复杂，但是相对速度高，成本高（需要更多的线），抗干扰能力弱（传输距离短）。</p>\n<h3 id=\"同步通信和异步通信\"><a href=\"#同步通信和异步通信\" class=\"headerlink\" title=\"同步通信和异步通信\"></a>同步通信和异步通信</h3><p>异步通信就是发送方在任意时刻都可以发送数据，前提是接收端已经做好了接受数据的准备（如果没有做好接受准备，数据肯定发送失败），也正是因为发送方的不确定性，所以接收方要时时刻刻的准备好接受数据，同时由于每次发送数据时间间隔的不确定性，所以，在每次发送数据时都要使用明确的界定符来标示数据（字符）的开始和结束位置，可以想象这种通信方式效率很低。虽然异步通信效率低，但是对设备的要求不高，通信设备简单。异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，<strong>字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</strong></p>\n<p>同步通信和异步通信相反，就是主机在进行通信前要先建立同步，即要使用相同的时钟频率，发送方的发送频率和接受方的接受频率要同步。</p>\n<p>除了时间频率的不同外，异步通信和同步通信之间的区别还是发送数据的表示形式，异步通信一般发送单位是字符，同步通信发送单位是比特流（数据帧），但是这不是绝对的，异步通信有时也使用帧来通信。同步通讯进行数据传输时，发送和接收双方要保持完全的同步，因此，要求接收和发送设备必须使用同一时钟。优点是可以实现高速度、大容量的数据传送；缺点是要求发生时钟和接收时钟保持严格同步，同时硬件复杂。可以这样说，不管是异步通信还是同步通信都需要进行同步，只是异步通信通过传送字符内的起始位来进行同步，而同步通信采用共用外部时钟来进行同步。所以，可以说前者是自同步，后者是外同步。事实上目前大多是采用异步通讯，极少数是采用同步通讯的。</p>\n<h3 id=\"单工，全双工和半双工\"><a href=\"#单工，全双工和半双工\" class=\"headerlink\" title=\"单工，全双工和半双工\"></a>单工，全双工和半双工</h3><ul>\n<li>如果在通信过程的任意时刻，信息只能由一方A传到另一方B，则称为单工。</li>\n<li>如果在任意时刻，信息既可由A传到B，又能由B传A，但只能由一个方向上的传输存在（即不能同时传输）,称为半双工传输。</li>\n<li>如果在任意时刻，线路上存在A到B和B到A的双向信号传输，则称为全双工。</li>\n</ul>\n<h3 id=\"串口通信-（见详细文章）\"><a href=\"#串口通信-（见详细文章）\" class=\"headerlink\" title=\"串口通信 （见详细文章）\"></a>串口通信 （见详细文章）</h3><p>串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。曾经PC之间进行串口通信可以说是标配，很多老式电脑上面可以看到DB25的接头，但后来逐渐被DB9取代，早期鼠标打印机都通过串口进行数据传输的，但现在逐渐被USB和网络所取代，DB9的串口接头在PC和笔记本上面也较少能够看到了。做嵌入式开发可以看到有个DB9的串口标准接口，串口对于开发人员输入输出调试等有着至关重要的作用。串行接口按电气标准及协议来分包括RS-232-C、RS-422、RS485等，现在串口一般在工业嵌入式领域使用。</p>\n<p>在使用串口通信时最重要的参数：波特率，数据位，停止位，奇偶校验位。</p>\n<p>同步通信和异步通信：异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</p>\n<h4 id=\"RS-232-C\"><a href=\"#RS-232-C\" class=\"headerlink\" title=\"RS-232-C\"></a>RS-232-C</h4><p>传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座（DB25），后来使用简化为9芯D型插座（DB9），现在应用中25芯插头座已很少采用。目前一般可以见到的串口接头都为DB9的232接口，</p>\n<ul>\n<li>RS-232串口通信最远距离是50英尺，约为15m</li>\n<li>RS-232可做到双向传输，全双工通讯，最高传输速率20kbps</li>\n<li>RS-232C上传送的数字量采用负逻辑，且与地对称：逻辑1：-3 ～-15V  逻辑0：+3～+15V （）</li>\n</ul>\n<h4 id=\"RS-485\"><a href=\"#RS-485\" class=\"headerlink\" title=\"RS-485\"></a>RS-485</h4><p>232串口在实际使用已经用处不大，但基于232发展出来的485等串口设备仍然被广泛使用，RS-485（EIA-485标准）是RS-422的改进，因为它增加了设备的个数，从10个增加到32个，同时定义了在最大设备个数情况下的电气特性，以保证足够的信号电压。有了多个设备的能力，你可以使用一个单个RS-485口建立设备网络。</p>\n<p>因为都是串口通信，所以本质两者是相差无几的，但耗材少，抗干扰强等特点让RS485在目前的工业领域仍然被广泛使用，这边主要列举出不同：</p>\n<ul>\n<li>从接线上，RS232是三线制，RS485是两线制</li>\n<li>从传输距离上，RS232只能传输15米，RS485最远可以传输1200米</li>\n<li>从速率上，RS232是全双工传输，RS485是半双工传输</li>\n<li>从协议层上，RS232只支持点对点通讯(1:1)，RS485支持总线形式通讯（1:N）</li>\n</ul>\n<h3 id=\"SPI\"><a href=\"#SPI\" class=\"headerlink\" title=\"SPI\"></a>SPI</h3><p>SPI是串行外设接口（Serial Peripheral Interface）的缩写。SPI，是一种高速的，<strong>全双工</strong>，<strong>同步</strong>的通信总线，并且在芯片的管脚上只占用<strong>四根线</strong>，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，如今越来越多的芯片集成了这种通信协议，比如AT91RM9200，stm32f103等。<br>:</p>\n<h3 id=\"IIC\"><a href=\"#IIC\" class=\"headerlink\" title=\"IIC\"></a>IIC</h3><p>IIC 即Inter-Integrated Circuit(集成电路总线），这种总线类型是由飞利浦半导体公司在八十年代初设计出来的一种简单、双向、二线制、同步串行总线，主要是用来连接整体电路(ICS) ，IIC是一种多向控制总线，也就是说多个芯片可以连接到同一总线结构下，同时每个芯片都可以作为实时数据传输的控制源。这种方式简化了信号传输总线接口，如今越来越多的芯片集成了这种通信协议，比如stm32f103，EFM32等。</p>\n<p>### </p>\n<hr>\n<p>To be continued…</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/wind19/article/details/7433249\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/wind19/article/details/7433249</a><br><a href=\"http://baike.baidu.com/view/185322.htm\" target=\"_blank\" rel=\"external\">http://baike.baidu.com/view/185322.htm</a><br><a href=\"http://www.cnblogs.com/mylinux/p/4078576.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/mylinux/p/4078576.html</a><br><a href=\"http://baike.baidu.com/view/716175.htm\" target=\"_blank\" rel=\"external\">http://baike.baidu.com/view/716175.htm</a><br><a href=\"https://www.zhihu.com/question/29033993\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/29033993</a><br><a href=\"http://www.cnblogs.com/general001/articles/2344079.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/general001/articles/2344079.html</a><br><a href=\"http://blog.csdn.net/weiqifa0/article/details/8845281\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/weiqifa0/article/details/8845281</a><br><a href=\"http://www.cnblogs.com/jason-lu/articles/3171870.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/jason-lu/articles/3171870.html</a></p>\n</blockquote>\n","excerpt":"<p>计算机从最初发展到现在已经有半个多世纪的历史，众所周知其实计算机就是一堆电路的组成，传统最为通用的计算功能仅仅是控制高低电平，输入输出（0和1）。而计算机中的CPU和其他设备如内存，硬盘，主板的其他电路连接过程中，控制的过程就是通过相关的通信协议，让一堆的高低电平输入输出最终可以转化为我们我们工作需要的内容，而赋予这些0,1实际意义的就是通信协议。计算机中有着众多的通信协议，有些协议已经逐渐被淘汰，而另外一些经过这么多年的发展仍然在各行各业经久不衰，一些更新更稳定更满足这个时代需求的协议也正在被越来越多的智能设备移动设备所采纳。本文仅仅是简要的叙述计算机嵌入式中最常用的一些协议。</p>\n<p>这边如果对码元，波特率等还不是恨清除的可以参考<strong>传输速率</strong>这篇文章。</p>\n<p><em>在了解通信协议和传输前，得先弄明白：总线和协议，串行传输和并行传输，同步通信和异步通信，全双工和半双工等基本概念，至于具体的通信方式和协议，这边仅作简述，有单独文章进行具体阐述。</em></p>\n<h3 id=\"总线和协议\"><a href=\"#总线和协议\" class=\"headerlink\" title=\"总线和协议\"></a>总线和协议</h3><p>在展开讲解之前，先来区分两个概念：总线和协议。</p>\n<p><strong>总线</strong>是一组信号线的集合，它定义了各引线的信号、电机、机械特性，使计算机内部各组成部分之间以及不同的计算机之间建立信号联系，进行信息传送和通信，按照作用范围简单来分可以分为内部总线和外部总线。内部总线：就是计算机内部功能模板之间进行通信的总线，它是构成完整的计算机系统的内部信息枢纽，但按功能仍要分为数据总线DB，地址总线AB，控制总线CB，电源总线PB。外部总线是计算机与计算机之间或计算机与其他智能设备之间进行通信的连接。但随着嵌入式不断的发展，现在在两者的区分已经不是那么严格，USB的传输可以认作是外部串行传输方式，而传统所认为是内部穿行传输方式的IIC现在也被一些外接的传感器所使用，因此在嵌入式领域已经无需再纠结是内部总线还是外部总线，毕竟为了满足需求很多原有的协议已经进行的改进使得传输距离更远，抗干扰性更强了，也有更多曾经的内部总线被在外部所使用了。</p>\n<p>通信协议是指双方实体完成通信或服务所必须遵循的规则和约定。协议定义了数据单元使用的格式，信息单元应该包含的信息与含义，连接方式，信息发送和接收的时序，从而确保在通信过程中数据顺利地传送到确定的地方。</p>\n<p><em>因为总线的种类实在太多，各种总线的衍生品层出不穷，这边就不详细列举，以下仅仅将目前嵌入式/微机上面最为常见的通信方式列举出来。</em></p>","more":"<h3 id=\"串行总线和并行总线\"><a href=\"#串行总线和并行总线\" class=\"headerlink\" title=\"串行总线和并行总线\"></a>串行总线和并行总线</h3><p>采用串行传输方式的总线被成为串行总线，一条信息的各位数据被逐位按顺序传送的通讯方式称为串行通讯。串行通讯的特点是：数据位传送，传按位顺序进行，最少只需一根传输线即可完成，成本低但送速度慢。串行通讯的距离可以从几米到几千米。 根据信息的传送方向，串行通讯可以进一步分为单工、半双工和全双工三种。信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工；信息能够同时双向传送则称为全双工。</p>\n<p>串口形容一下就是一条车道，而并口就是有8个车道同一时刻能传送8位（一个字节）数据。但是并不是说并口快，由于8位通道之间的互相干扰（串扰），传输时速度就受到了限制，传输容易出错。串口没有互相干扰。并口同时发送的数据量大，但要比串口慢。串口硬盘就是这样被人们重视的。</p>\n<p>采用并行传输方式的总线被成为并行总线，并行通讯通常可以一次传送8bit、16bit、32bit甚至更高的位数，相应地就需要8根、16根、32根信号线，同时也需要加入更多的信号地线。比如传统的PATA线路有40根线，其中有16根信号线和7根信号地线，其他为各种控制线，一次可以传送2Byte的数据。并行通讯中，数据信号中无法携带时钟信息（需要时钟信息，是为了确保一次发送的为一组相关数据，当始终跳转一次的时候，再发送下一租数据，如果缺少始终信息，而多组数据的传输有快有慢的话，则所有数据会串扰，通讯毫无意义。而串行通讯则没有这样的问题，一个个位发送，最终只需按照协议整合数据即可，当然也有部分穿行通信协议利用时钟来实现附加的操作），为了保证各对信号线上的信号时序一致，并行设备需要严格同步时钟信号，或者采用额外的时钟信号线。</p>\n<p>通过串行通讯与并行通讯的对比，可以看出：串行通讯很简单，但是相对速度低，抗干扰能力强（可以用在长距离通讯），成本低；并行通讯比较复杂，但是相对速度高，成本高（需要更多的线），抗干扰能力弱（传输距离短）。</p>\n<h3 id=\"同步通信和异步通信\"><a href=\"#同步通信和异步通信\" class=\"headerlink\" title=\"同步通信和异步通信\"></a>同步通信和异步通信</h3><p>异步通信就是发送方在任意时刻都可以发送数据，前提是接收端已经做好了接受数据的准备（如果没有做好接受准备，数据肯定发送失败），也正是因为发送方的不确定性，所以接收方要时时刻刻的准备好接受数据，同时由于每次发送数据时间间隔的不确定性，所以，在每次发送数据时都要使用明确的界定符来标示数据（字符）的开始和结束位置，可以想象这种通信方式效率很低。虽然异步通信效率低，但是对设备的要求不高，通信设备简单。异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，<strong>字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</strong></p>\n<p>同步通信和异步通信相反，就是主机在进行通信前要先建立同步，即要使用相同的时钟频率，发送方的发送频率和接受方的接受频率要同步。</p>\n<p>除了时间频率的不同外，异步通信和同步通信之间的区别还是发送数据的表示形式，异步通信一般发送单位是字符，同步通信发送单位是比特流（数据帧），但是这不是绝对的，异步通信有时也使用帧来通信。同步通讯进行数据传输时，发送和接收双方要保持完全的同步，因此，要求接收和发送设备必须使用同一时钟。优点是可以实现高速度、大容量的数据传送；缺点是要求发生时钟和接收时钟保持严格同步，同时硬件复杂。可以这样说，不管是异步通信还是同步通信都需要进行同步，只是异步通信通过传送字符内的起始位来进行同步，而同步通信采用共用外部时钟来进行同步。所以，可以说前者是自同步，后者是外同步。事实上目前大多是采用异步通讯，极少数是采用同步通讯的。</p>\n<h3 id=\"单工，全双工和半双工\"><a href=\"#单工，全双工和半双工\" class=\"headerlink\" title=\"单工，全双工和半双工\"></a>单工，全双工和半双工</h3><ul>\n<li>如果在通信过程的任意时刻，信息只能由一方A传到另一方B，则称为单工。</li>\n<li>如果在任意时刻，信息既可由A传到B，又能由B传A，但只能由一个方向上的传输存在（即不能同时传输）,称为半双工传输。</li>\n<li>如果在任意时刻，线路上存在A到B和B到A的双向信号传输，则称为全双工。</li>\n</ul>\n<h3 id=\"串口通信-（见详细文章）\"><a href=\"#串口通信-（见详细文章）\" class=\"headerlink\" title=\"串口通信 （见详细文章）\"></a>串口通信 （见详细文章）</h3><p>串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。曾经PC之间进行串口通信可以说是标配，很多老式电脑上面可以看到DB25的接头，但后来逐渐被DB9取代，早期鼠标打印机都通过串口进行数据传输的，但现在逐渐被USB和网络所取代，DB9的串口接头在PC和笔记本上面也较少能够看到了。做嵌入式开发可以看到有个DB9的串口标准接口，串口对于开发人员输入输出调试等有着至关重要的作用。串行接口按电气标准及协议来分包括RS-232-C、RS-422、RS485等，现在串口一般在工业嵌入式领域使用。</p>\n<p>在使用串口通信时最重要的参数：波特率，数据位，停止位，奇偶校验位。</p>\n<p>同步通信和异步通信：异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</p>\n<h4 id=\"RS-232-C\"><a href=\"#RS-232-C\" class=\"headerlink\" title=\"RS-232-C\"></a>RS-232-C</h4><p>传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座（DB25），后来使用简化为9芯D型插座（DB9），现在应用中25芯插头座已很少采用。目前一般可以见到的串口接头都为DB9的232接口，</p>\n<ul>\n<li>RS-232串口通信最远距离是50英尺，约为15m</li>\n<li>RS-232可做到双向传输，全双工通讯，最高传输速率20kbps</li>\n<li>RS-232C上传送的数字量采用负逻辑，且与地对称：逻辑1：-3 ～-15V  逻辑0：+3～+15V （）</li>\n</ul>\n<h4 id=\"RS-485\"><a href=\"#RS-485\" class=\"headerlink\" title=\"RS-485\"></a>RS-485</h4><p>232串口在实际使用已经用处不大，但基于232发展出来的485等串口设备仍然被广泛使用，RS-485（EIA-485标准）是RS-422的改进，因为它增加了设备的个数，从10个增加到32个，同时定义了在最大设备个数情况下的电气特性，以保证足够的信号电压。有了多个设备的能力，你可以使用一个单个RS-485口建立设备网络。</p>\n<p>因为都是串口通信，所以本质两者是相差无几的，但耗材少，抗干扰强等特点让RS485在目前的工业领域仍然被广泛使用，这边主要列举出不同：</p>\n<ul>\n<li>从接线上，RS232是三线制，RS485是两线制</li>\n<li>从传输距离上，RS232只能传输15米，RS485最远可以传输1200米</li>\n<li>从速率上，RS232是全双工传输，RS485是半双工传输</li>\n<li>从协议层上，RS232只支持点对点通讯(1:1)，RS485支持总线形式通讯（1:N）</li>\n</ul>\n<h3 id=\"SPI\"><a href=\"#SPI\" class=\"headerlink\" title=\"SPI\"></a>SPI</h3><p>SPI是串行外设接口（Serial Peripheral Interface）的缩写。SPI，是一种高速的，<strong>全双工</strong>，<strong>同步</strong>的通信总线，并且在芯片的管脚上只占用<strong>四根线</strong>，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，如今越来越多的芯片集成了这种通信协议，比如AT91RM9200，stm32f103等。<br>:</p>\n<h3 id=\"IIC\"><a href=\"#IIC\" class=\"headerlink\" title=\"IIC\"></a>IIC</h3><p>IIC 即Inter-Integrated Circuit(集成电路总线），这种总线类型是由飞利浦半导体公司在八十年代初设计出来的一种简单、双向、二线制、同步串行总线，主要是用来连接整体电路(ICS) ，IIC是一种多向控制总线，也就是说多个芯片可以连接到同一总线结构下，同时每个芯片都可以作为实时数据传输的控制源。这种方式简化了信号传输总线接口，如今越来越多的芯片集成了这种通信协议，比如stm32f103，EFM32等。</p>\n<p>### </p>\n<hr>\n<p>To be continued…</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/wind19/article/details/7433249\">http://blog.csdn.net/wind19/article/details/7433249</a><br><a href=\"http://baike.baidu.com/view/185322.htm\">http://baike.baidu.com/view/185322.htm</a><br><a href=\"http://www.cnblogs.com/mylinux/p/4078576.html\">http://www.cnblogs.com/mylinux/p/4078576.html</a><br><a href=\"http://baike.baidu.com/view/716175.htm\">http://baike.baidu.com/view/716175.htm</a><br><a href=\"https://www.zhihu.com/question/29033993\">https://www.zhihu.com/question/29033993</a><br><a href=\"http://www.cnblogs.com/general001/articles/2344079.html\">http://www.cnblogs.com/general001/articles/2344079.html</a><br><a href=\"http://blog.csdn.net/weiqifa0/article/details/8845281\">http://blog.csdn.net/weiqifa0/article/details/8845281</a><br><a href=\"http://www.cnblogs.com/jason-lu/articles/3171870.html\">http://www.cnblogs.com/jason-lu/articles/3171870.html</a></p>\n</blockquote>"},{"layout":"post","title":"IIC通信详解","date":"2016-10-20T13:59:00.000Z","_content":"\n我们在使用单片机的过程中，IIC通信可以说是最被广泛使用和采纳的一个协议，这边\n\n\n<!-- more -->\n\n\n> 参考链接：\n> http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html\n","source":"_posts/2016/2016-10-20-iic通信详解.md","raw":"---\nlayout: \"post\"\ntitle: \"IIC通信详解\"\ndate: \"2016-10-20 21:59\"\n---\n\n我们在使用单片机的过程中，IIC通信可以说是最被广泛使用和采纳的一个协议，这边\n\n\n<!-- more -->\n\n\n> 参考链接：\n> http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html\n","slug":"2016/2016-10-20-iic通信详解","published":1,"updated":"2016-12-16T01:49:27.991Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aid002ymumu11s5pbx9","content":"<p>我们在使用单片机的过程中，IIC通信可以说是最被广泛使用和采纳的一个协议，这边</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>参考链接：<br><a href=\"http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html\" target=\"_blank\" rel=\"external\">http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html</a></p>\n</blockquote>\n","excerpt":"<p>我们在使用单片机的过程中，IIC通信可以说是最被广泛使用和采纳的一个协议，这边</p>","more":"<blockquote>\n<p>参考链接：<br><a href=\"http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html\">http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html</a></p>\n</blockquote>"},{"layout":"post","title":"串口RS485通信详解","date":"2016-10-19T06:20:00.000Z","_content":"\n**注意：串口发送数据是按位逐个发送的，且在传输字节的过程中是从字节的低位开始发送的。串口的一些内容不再逐一介绍说明，可以参加之前的usb转串口及RS232通信等文章**\n\n### 特性介绍\n\n485（一般称作 RS485/EIA-485）是隶属于 OSI 模型物理层的电气特性规定为 2 线，半双工，多点通信的标准。它的电气特性和 RS-232 大不一样。用缆线两端的电压差值来表示传递信号。值得注意的是：RS485 仅仅规定了接受端和发送端的电气特性，它没有规定或推荐任何数据协议。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/1.jpg)\n\nRS485接口可以只使用两根线进行通讯（其他串口通讯至少需要三根线，一根为地线作为参考电平），通过差分电平（利用两个信号的差值来判断信息，使用差分信号来传输的，也就是一根线传同相信号，一根线传反相，这样差值最大，抗干扰能力强。）来确定信号是0还是1，也正因为这个原因，所以RS485每次有且仅有一根线能够传输数据，另外一根线作为比对信号，因此RS485是半双工的通讯方式。主要特点如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/2.jpg)\n\n- 接口电平低，不易损坏芯片。 RS485 的电气特性：逻辑“ 1”以两线间的电压差为+(2~6)V\n表示；逻辑“ 0”以两线间的电压差为-(2~6)V 表示。接口信号电平比 RS232 降低了，\n不易损坏接口电路的芯片，且该电平与 TTL 电平兼容，可方便与 TTL 电路连接。\n- 传输速率高。 10 米时， RS485 的数据最高传输速率可达 35Mbps，在 1200m 时，传输\n速度可达 100Kbps。\n- 抗干扰能力强。 RS485 接口是采用平衡驱动器和差分接收器的组合，抗共模干扰能力\n增强，即抗噪声干扰性好。 传输距离远，支持节点多。 RS485 总线最长可以传输 1200m\n以上（速率≤100Kbps）\n- 一般最大支持 32 个节点，如果使用特制的 485 芯片，可以达到 128 个或者 256 个节点，\n最大的可以支持到 400 个节点。\n\n<!-- more -->\n\n\n### 类比RS232\n\n实际上232串口在实际使用已经用处不大，但基于232发展出来的485等串口设备仍然被广泛使用，RS-485（EIA-485标准）是RS-422的改进，因为它增加了设备的个数，从10个增加到32个，同时定义了在最大设备个数情况下的电气特性，以保证足够的信号电压。有了多个设备的能力，你可以使用一个单个RS-485口建立设备网络。\n\n因为都是采用串口通信协议，所以软件端几乎可以直接使用，且RS485具备耗材少，抗干扰强等特点，在目前的工业领域仍然被广泛使用，这边主要列举出不同：\n\n- 从接线上，RS232是三线制，RS485是两线制\n- 从传输距离上，RS232只能传输15米，RS485最远可以传输1200米\n- 从速率上，RS232是全双工传输，RS485是半双工传输\n- 从协议层上，RS232只支持点对点通讯(1:1)，RS485支持总线形式通讯（1:N）\n\n\nRS232的接线：\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/3.jpg))\n\nRS485的接线\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/4.jpg)\n\n\n\n\n### 原理图\n\n\n\n\n### 参考案例\n\n\n\n\n> 参考链接：\n> http://www.cnblogs.com/jason-lu/articles/3171870.html\n> http://book.51cto.com/art/201308/408900.htm\n> http://blog.csdn.net/sdwuyulunbi/article/details/6632382\n> http://blog.csdn.net/skyflying2012/article/details/49274313\n> http://blog.csdn.net/gszhy/article/details/8594433\n> http://blog.csdn.net/bytxl/article/details/49147915\n","source":"_posts/2016/2016-10-19-串口RS485通信详解.md","raw":"---\nlayout: \"post\"\ntitle: \"串口RS485通信详解\"\ndate: \"2016-10-19 14:20\"\n---\n\n**注意：串口发送数据是按位逐个发送的，且在传输字节的过程中是从字节的低位开始发送的。串口的一些内容不再逐一介绍说明，可以参加之前的usb转串口及RS232通信等文章**\n\n### 特性介绍\n\n485（一般称作 RS485/EIA-485）是隶属于 OSI 模型物理层的电气特性规定为 2 线，半双工，多点通信的标准。它的电气特性和 RS-232 大不一样。用缆线两端的电压差值来表示传递信号。值得注意的是：RS485 仅仅规定了接受端和发送端的电气特性，它没有规定或推荐任何数据协议。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/1.jpg)\n\nRS485接口可以只使用两根线进行通讯（其他串口通讯至少需要三根线，一根为地线作为参考电平），通过差分电平（利用两个信号的差值来判断信息，使用差分信号来传输的，也就是一根线传同相信号，一根线传反相，这样差值最大，抗干扰能力强。）来确定信号是0还是1，也正因为这个原因，所以RS485每次有且仅有一根线能够传输数据，另外一根线作为比对信号，因此RS485是半双工的通讯方式。主要特点如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/2.jpg)\n\n- 接口电平低，不易损坏芯片。 RS485 的电气特性：逻辑“ 1”以两线间的电压差为+(2~6)V\n表示；逻辑“ 0”以两线间的电压差为-(2~6)V 表示。接口信号电平比 RS232 降低了，\n不易损坏接口电路的芯片，且该电平与 TTL 电平兼容，可方便与 TTL 电路连接。\n- 传输速率高。 10 米时， RS485 的数据最高传输速率可达 35Mbps，在 1200m 时，传输\n速度可达 100Kbps。\n- 抗干扰能力强。 RS485 接口是采用平衡驱动器和差分接收器的组合，抗共模干扰能力\n增强，即抗噪声干扰性好。 传输距离远，支持节点多。 RS485 总线最长可以传输 1200m\n以上（速率≤100Kbps）\n- 一般最大支持 32 个节点，如果使用特制的 485 芯片，可以达到 128 个或者 256 个节点，\n最大的可以支持到 400 个节点。\n\n<!-- more -->\n\n\n### 类比RS232\n\n实际上232串口在实际使用已经用处不大，但基于232发展出来的485等串口设备仍然被广泛使用，RS-485（EIA-485标准）是RS-422的改进，因为它增加了设备的个数，从10个增加到32个，同时定义了在最大设备个数情况下的电气特性，以保证足够的信号电压。有了多个设备的能力，你可以使用一个单个RS-485口建立设备网络。\n\n因为都是采用串口通信协议，所以软件端几乎可以直接使用，且RS485具备耗材少，抗干扰强等特点，在目前的工业领域仍然被广泛使用，这边主要列举出不同：\n\n- 从接线上，RS232是三线制，RS485是两线制\n- 从传输距离上，RS232只能传输15米，RS485最远可以传输1200米\n- 从速率上，RS232是全双工传输，RS485是半双工传输\n- 从协议层上，RS232只支持点对点通讯(1:1)，RS485支持总线形式通讯（1:N）\n\n\nRS232的接线：\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/3.jpg))\n\nRS485的接线\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/4.jpg)\n\n\n\n\n### 原理图\n\n\n\n\n### 参考案例\n\n\n\n\n> 参考链接：\n> http://www.cnblogs.com/jason-lu/articles/3171870.html\n> http://book.51cto.com/art/201308/408900.htm\n> http://blog.csdn.net/sdwuyulunbi/article/details/6632382\n> http://blog.csdn.net/skyflying2012/article/details/49274313\n> http://blog.csdn.net/gszhy/article/details/8594433\n> http://blog.csdn.net/bytxl/article/details/49147915\n","slug":"2016/2016-10-19-串口RS485通信详解","published":1,"updated":"2016-12-16T01:49:25.115Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aif002zmumupelw15dk","content":"<p><strong>注意：串口发送数据是按位逐个发送的，且在传输字节的过程中是从字节的低位开始发送的。串口的一些内容不再逐一介绍说明，可以参加之前的usb转串口及RS232通信等文章</strong></p>\n<h3 id=\"特性介绍\"><a href=\"#特性介绍\" class=\"headerlink\" title=\"特性介绍\"></a>特性介绍</h3><p>485（一般称作 RS485/EIA-485）是隶属于 OSI 模型物理层的电气特性规定为 2 线，半双工，多点通信的标准。它的电气特性和 RS-232 大不一样。用缆线两端的电压差值来表示传递信号。值得注意的是：RS485 仅仅规定了接受端和发送端的电气特性，它没有规定或推荐任何数据协议。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/1.jpg\" alt=\"\"></p>\n<p>RS485接口可以只使用两根线进行通讯（其他串口通讯至少需要三根线，一根为地线作为参考电平），通过差分电平（利用两个信号的差值来判断信息，使用差分信号来传输的，也就是一根线传同相信号，一根线传反相，这样差值最大，抗干扰能力强。）来确定信号是0还是1，也正因为这个原因，所以RS485每次有且仅有一根线能够传输数据，另外一根线作为比对信号，因此RS485是半双工的通讯方式。主要特点如下：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/2.jpg\" alt=\"\"></p>\n<ul>\n<li>接口电平低，不易损坏芯片。 RS485 的电气特性：逻辑“ 1”以两线间的电压差为+(2~6)V<br>表示；逻辑“ 0”以两线间的电压差为-(2~6)V 表示。接口信号电平比 RS232 降低了，<br>不易损坏接口电路的芯片，且该电平与 TTL 电平兼容，可方便与 TTL 电路连接。</li>\n<li>传输速率高。 10 米时， RS485 的数据最高传输速率可达 35Mbps，在 1200m 时，传输<br>速度可达 100Kbps。</li>\n<li>抗干扰能力强。 RS485 接口是采用平衡驱动器和差分接收器的组合，抗共模干扰能力<br>增强，即抗噪声干扰性好。 传输距离远，支持节点多。 RS485 总线最长可以传输 1200m<br>以上（速率≤100Kbps）</li>\n<li>一般最大支持 32 个节点，如果使用特制的 485 芯片，可以达到 128 个或者 256 个节点，<br>最大的可以支持到 400 个节点。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"类比RS232\"><a href=\"#类比RS232\" class=\"headerlink\" title=\"类比RS232\"></a>类比RS232</h3><p>实际上232串口在实际使用已经用处不大，但基于232发展出来的485等串口设备仍然被广泛使用，RS-485（EIA-485标准）是RS-422的改进，因为它增加了设备的个数，从10个增加到32个，同时定义了在最大设备个数情况下的电气特性，以保证足够的信号电压。有了多个设备的能力，你可以使用一个单个RS-485口建立设备网络。</p>\n<p>因为都是采用串口通信协议，所以软件端几乎可以直接使用，且RS485具备耗材少，抗干扰强等特点，在目前的工业领域仍然被广泛使用，这边主要列举出不同：</p>\n<ul>\n<li>从接线上，RS232是三线制，RS485是两线制</li>\n<li>从传输距离上，RS232只能传输15米，RS485最远可以传输1200米</li>\n<li>从速率上，RS232是全双工传输，RS485是半双工传输</li>\n<li>从协议层上，RS232只支持点对点通讯(1:1)，RS485支持总线形式通讯（1:N）</li>\n</ul>\n<p>RS232的接线：<br><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/3.jpg\" alt=\"\">)</p>\n<p>RS485的接线<br><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/4.jpg\" alt=\"\"></p>\n<h3 id=\"原理图\"><a href=\"#原理图\" class=\"headerlink\" title=\"原理图\"></a>原理图</h3><h3 id=\"参考案例\"><a href=\"#参考案例\" class=\"headerlink\" title=\"参考案例\"></a>参考案例</h3><blockquote>\n<p>参考链接：<br><a href=\"http://www.cnblogs.com/jason-lu/articles/3171870.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/jason-lu/articles/3171870.html</a><br><a href=\"http://book.51cto.com/art/201308/408900.htm\" target=\"_blank\" rel=\"external\">http://book.51cto.com/art/201308/408900.htm</a><br><a href=\"http://blog.csdn.net/sdwuyulunbi/article/details/6632382\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/sdwuyulunbi/article/details/6632382</a><br><a href=\"http://blog.csdn.net/skyflying2012/article/details/49274313\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/skyflying2012/article/details/49274313</a><br><a href=\"http://blog.csdn.net/gszhy/article/details/8594433\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/gszhy/article/details/8594433</a><br><a href=\"http://blog.csdn.net/bytxl/article/details/49147915\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/bytxl/article/details/49147915</a></p>\n</blockquote>\n","excerpt":"<p><strong>注意：串口发送数据是按位逐个发送的，且在传输字节的过程中是从字节的低位开始发送的。串口的一些内容不再逐一介绍说明，可以参加之前的usb转串口及RS232通信等文章</strong></p>\n<h3 id=\"特性介绍\"><a href=\"#特性介绍\" class=\"headerlink\" title=\"特性介绍\"></a>特性介绍</h3><p>485（一般称作 RS485/EIA-485）是隶属于 OSI 模型物理层的电气特性规定为 2 线，半双工，多点通信的标准。它的电气特性和 RS-232 大不一样。用缆线两端的电压差值来表示传递信号。值得注意的是：RS485 仅仅规定了接受端和发送端的电气特性，它没有规定或推荐任何数据协议。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/1.jpg\" alt=\"\"></p>\n<p>RS485接口可以只使用两根线进行通讯（其他串口通讯至少需要三根线，一根为地线作为参考电平），通过差分电平（利用两个信号的差值来判断信息，使用差分信号来传输的，也就是一根线传同相信号，一根线传反相，这样差值最大，抗干扰能力强。）来确定信号是0还是1，也正因为这个原因，所以RS485每次有且仅有一根线能够传输数据，另外一根线作为比对信号，因此RS485是半双工的通讯方式。主要特点如下：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/2.jpg\" alt=\"\"></p>\n<ul>\n<li>接口电平低，不易损坏芯片。 RS485 的电气特性：逻辑“ 1”以两线间的电压差为+(2~6)V<br>表示；逻辑“ 0”以两线间的电压差为-(2~6)V 表示。接口信号电平比 RS232 降低了，<br>不易损坏接口电路的芯片，且该电平与 TTL 电平兼容，可方便与 TTL 电路连接。</li>\n<li>传输速率高。 10 米时， RS485 的数据最高传输速率可达 35Mbps，在 1200m 时，传输<br>速度可达 100Kbps。</li>\n<li>抗干扰能力强。 RS485 接口是采用平衡驱动器和差分接收器的组合，抗共模干扰能力<br>增强，即抗噪声干扰性好。 传输距离远，支持节点多。 RS485 总线最长可以传输 1200m<br>以上（速率≤100Kbps）</li>\n<li>一般最大支持 32 个节点，如果使用特制的 485 芯片，可以达到 128 个或者 256 个节点，<br>最大的可以支持到 400 个节点。</li>\n</ul>","more":"<h3 id=\"类比RS232\"><a href=\"#类比RS232\" class=\"headerlink\" title=\"类比RS232\"></a>类比RS232</h3><p>实际上232串口在实际使用已经用处不大，但基于232发展出来的485等串口设备仍然被广泛使用，RS-485（EIA-485标准）是RS-422的改进，因为它增加了设备的个数，从10个增加到32个，同时定义了在最大设备个数情况下的电气特性，以保证足够的信号电压。有了多个设备的能力，你可以使用一个单个RS-485口建立设备网络。</p>\n<p>因为都是采用串口通信协议，所以软件端几乎可以直接使用，且RS485具备耗材少，抗干扰强等特点，在目前的工业领域仍然被广泛使用，这边主要列举出不同：</p>\n<ul>\n<li>从接线上，RS232是三线制，RS485是两线制</li>\n<li>从传输距离上，RS232只能传输15米，RS485最远可以传输1200米</li>\n<li>从速率上，RS232是全双工传输，RS485是半双工传输</li>\n<li>从协议层上，RS232只支持点对点通讯(1:1)，RS485支持总线形式通讯（1:N）</li>\n</ul>\n<p>RS232的接线：<br><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/3.jpg\" alt=\"\">)</p>\n<p>RS485的接线<br><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/4.jpg\" alt=\"\"></p>\n<h3 id=\"原理图\"><a href=\"#原理图\" class=\"headerlink\" title=\"原理图\"></a>原理图</h3><h3 id=\"参考案例\"><a href=\"#参考案例\" class=\"headerlink\" title=\"参考案例\"></a>参考案例</h3><blockquote>\n<p>参考链接：<br><a href=\"http://www.cnblogs.com/jason-lu/articles/3171870.html\">http://www.cnblogs.com/jason-lu/articles/3171870.html</a><br><a href=\"http://book.51cto.com/art/201308/408900.htm\">http://book.51cto.com/art/201308/408900.htm</a><br><a href=\"http://blog.csdn.net/sdwuyulunbi/article/details/6632382\">http://blog.csdn.net/sdwuyulunbi/article/details/6632382</a><br><a href=\"http://blog.csdn.net/skyflying2012/article/details/49274313\">http://blog.csdn.net/skyflying2012/article/details/49274313</a><br><a href=\"http://blog.csdn.net/gszhy/article/details/8594433\">http://blog.csdn.net/gszhy/article/details/8594433</a><br><a href=\"http://blog.csdn.net/bytxl/article/details/49147915\">http://blog.csdn.net/bytxl/article/details/49147915</a></p>\n</blockquote>"},{"layout":"post","title":"串口RS232通信详解","date":"2016-10-19T06:20:00.000Z","_content":"\n串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。曾经PC之间进行串口通信可以说是标配，很多老式电脑上面可以看到DB25的接头，但后来逐渐被DB9取代，早期鼠标打印机都通过串口进行数据传输的，但现在逐渐被USB和网络所取代，DB9的串口接头在PC和笔记本上面也较少能够看到了。做嵌入式开发可以看到有个DB9的串口标准接口，串口对于开发人员输入输出调试等有着至关重要的作用。串行接口按电气标准及协议来分包括RS-232-C、RS-422、RS485等，现在串口一般在工业嵌入式领域使用。\n\n波特率：单片机或计算机在串口通信时的速率。指的是信号被调制以后在单位时间内的变化，即单位时间内载波参数变化的次数，如每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为240Bd，比特率为10位*240个/秒=2400bps。（有单独文章详解）\n\n数据位：数据位为5-8位，它紧跟在起始位之后，是被传送字符的有效数据位。传送时先传送字符的低位，后传送字符的高位。数据位究竟是几位，可由硬件或软件来设定。当然，一般8位为一个字节，通常都喜欢设置为8位数据位传输。\n\n停止位：停止位为1位、1.5位或2位，可有软件设定。它一定是逻辑“1”电平，标志着传送一个字符的结束。\n\n奇偶校验位：奇偶校验位仅占一位，用于进行奇校验或偶校验，也可以不设奇偶位。\n\n同步通信和异步通信：异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。\n\n注意：**串口发送数据是按位逐个发送的，且在传输字节的过程中是从字节的低位开始发送的。**\n\n<!-- more -->\n\n\n### 串口通讯—全双工和半双工方式\n\n#### 全双工方式(full duplex)：\n\n当数据的发送和接收分流，分别由两根不同的传输线传送时，通信双方都能在同一时刻进行发送和接收操作，这样的传送方式就是全双工制。在全双工方式下，通信系统的每一端都设置了发送器和接收器，因此，能控制数据同时在两个方向上传送。全双工方式无需进行方向的切换，因此，没有切换操作所产生的时间延迟，这对那些不能有时间延误的交互式应用(例如远程监测和控制系统)十分有利。这种方式要求通讯双方均有发送器和接收器，同时，需要2根数据线传送数据信号。(可能还需要控制线和状态线，以及地线)。比如，计算机主机用串行接口连接显示终端，而显示终端带有键盘。这样，一方面键盘上输入的字符送到主机内存;另一方面，主机内存的信息可以送到屏幕显示。通常，往键盘上打入1个字符以后，先不显示，计算机主机收到字符后，立即回送到终端，然后终端再把这个字符显示出来。这样，前一个字符的回送过程和后一个字符的输入过程是同时进行的，即工作于全双工方式。\n\n#### 半双工方式(half duplex):\n\n若使用同一根传输线既作接收又作发送，虽然数据可以在两个方向上传送，但通信双方不能同时收发数据，这样的传送方式就是半双工制。采用半双工方式时，通信系统每一端的发送器和接收器，通过收/发开关转接到通信线上，进行方向的切换，因此，会产生时间延迟。收/发开关实际上是由软件控制的电子开关。当计算机主机用串行接口连接显示终端时，在半双工方式中，输入过程和输出过程使用同一通路。有些计算机和显示终端之间采用半双工方式工作，这时，从键盘打入的字符在发送到主机的同时就被送到终端上显示出来，而不是用回送的办法，所以避免了接收过程和发送过程同时进行的情况。\n\n\n目前多数终端和串行接口都为半双工方式提供了换向能力，也为全双工方式提供了两条独立的引脚。在实际使用时，一般并不需要通信双方同时既发送又接收，像打印机这类的单向传送设备，半双工甚至单工就能胜任，也无需倒向。\n\n### 连接方式\n\n首先需要明白两个概念，就是DTE和DCE。DTE是指数据终端设备，典型的DTE就是计算机和单片机。DCE是指数据通信设备，典型的DCE就是MODEM。RS232串口标准中的RXD和TXD都是站在DTE立场上的，而不是DCE。明白了这一点，再讲下面的接线方法，就很好理解了。\n\n单片机与计算机进行串口通信时，单片机的RXD接计算机的TXD，单片机的TXD接计算机的RXD。主要是在使用串口时，TXD和RXD都是成对的，因此值得注意的是如果都是标准串口链接方式，往往不能直接连接，必须要错开链接，而这常常有两种方式，一种是让其中一个端口的RXD和TXD对调（故意错开），然后导线直通；另外一种是两个端口都采用标准端口，但导线部分RXD和TXD对调（交叉线）。\n\n### 同步和异步\n\n同步通信和异步通信相反，就是主机在进行通信前要先建立同步，即要使用相同的时钟频率，发送方的发送频率和接受方的接受频率要同步。\n\n异步通信就是发送方在任意时刻都可以发送数据，前提是接收端已经做好了接受数据的准备（如果没有做好接受准备，数据肯定发送失败），也正是因为发送方的不确定性，所以接收方要时时刻刻的准备好接受数据，同时由于每次发送数据时间间隔的不确定性，所以，在每次发送数据时都要使用明确的界定符来标示数据（字符）的开始和结束位置，可以想象这种通信方式效率很低。虽然异步通信效率低，但是对设备的要求不高，通信设备简单。异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，**字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。**\n\n即便串口拥有同步功能，一般也是作为uart（通用异步收发传输器）使用，在UART上追加同步方式的序列信号变换电路的产品，被称为USART(Universal Synchronous Asynchronous Receiver Transmitter)。事实上目前一般我们所说的串口通信就是指通用异步收发，极少采用同步通讯的方式。\n\n\n\n### 硬件接口以及连线\n\n传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座（DB25），后来使用简化为9芯D型插座（DB9），现在应用中25芯插头座已很少采用。目前一般可以见到的串口接头都为DB9的232接口。\n\nRXD接TXD，TXD接RXD，无论是单片机和单片机相连还是计算机和单片机相连都是如此，发射部分TXD永远同RXD链接配对。具体连接见下图：\n- 使用串口直通线。设计电路时，单片机的RXD连接电路板DB9的TXD，单片机的TXD连接电路板DB9的RXD，具体实现可在232电平转换芯片处反接。\n- 使用串口交叉线。设计电路时，因为串口线已做交叉，单片机的RXD连接电路板DB9的RXD，单片机的TXD连接电路板DB9的TXD，均直连即可。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/5.jpg)\n\n除非专门说明，否则所有引脚线序都是指串口外侧的线序，RS232串口的端口示意图如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/1.jpg)\n\n如果是作为RS-232C接口，则各引脚定义如表所示。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/2.jpg)\n\n值得注意的是：**公头和母头的RS232口在所有引脚的定义上面都是一致的，因此在购买选链接线的时候会分很多种：公对公23交叉，公对公直通，母对母直通，母对母23交叉，公对母23交叉，公对母直通。如果不能确定是什么线，万用表测量串口线一端的引脚2与另一端的引脚2是否短接，是则是直连串口线，否则是交叉串口线。**\n\n\n各引脚的电气特性为：在TxD和RxD上，逻辑“1”为-3V~-15V； 逻辑“0”为+3V~+15V。在RTS、CTS、DSR、DTR和DCD等控制线上，信号有效为+3V~+15V；信号无效为-3V~-15V。对于数据信号，逻辑“1”为低于-3V，逻辑“0”为高于+3V；对于控制信号，接通ON为低于-3V；断开OFF为高于+3V；-3V~+3V、低于-15V、高于+15V都表示电压无意义。\n\n**串口异步传输在空闲状态时都必须是高电平。**\n\n\n### 特征简述\n\n- RS-232串口通信最远距离是50英尺，约为15m，可见232的距离传输并不是很远，由于正负逻辑电平的差量有限，232的抗干扰能力较弱。\n- RS-232可做到双向传输，全双工通讯，最高传输速率20kbps（传统情况下232的传输速度有限一般就是在19200以下）\n- RS-232C上传送的数字量采用负逻辑，且与地对称：逻辑1：-3 ～-15V  逻辑0：+3～+15V （使用过程中尤其需要注意232的电平，不能直接将单片机同RS-232C口中RX，TX直连，中间需要有相应的转换芯片才可）\n\n\n### 原理图\n\n既然要详细介绍RS232的使用和通讯，这边肯定要附上常见的硬件设计电路和原理图的。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/72.png)\n\n### 参考案例\n\n串口因为作为最常用的一个功能，有关串口的协议一般已经被迁入到了目前市面上几乎所有主流的芯片中了，目前绝大多数芯片本身自带串口相关功能，用户无需按照协议来模拟出高低电平和时间周期来发送码元，相关功能已经作为芯片自带功能嵌入到了相关寄存器中，用户仅仅需要根据参考文档，完成usart相关寄存器的配置和调用，即可实现串口的发送和接收了。\n\n\n#### IO口模拟uart实现\n\nIO口模拟uart能够帮助我们更加深入了理解uart的相关协议，知道整个uart通信过程中，是如何工作，对一切细节特性都可以了如指掌，对于我们深入的研究学习串口通信还是比较有帮助的，且IO模拟出来的通信协议一般都更具兼容性，可以很方便的进行不同芯片的移植，而无需关注芯片本身寄存器和底层结构。\n\n众所周知数字电路实现的最主要功能就是输入输出，高低电平。所谓的协议虽然复杂但都是可以通过输入输出和高低电频给模拟出来的。下面主要以stm32芯片为例，使用IO口模拟出串口通讯，这边只附上主要程序片段，详细工程见链接。\n\n首先，必须要知道串口通讯时数据是怎样传输的？这里以异步传输字符为例子，如下图所示：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/6.jpg)\n\n注意：\n- 串口异步传输在空闲状态时都必须是高电平\n- 起始位是低电平，发完后有一个等待时间\n- 中间数据位个数以及是否有校验位需要和接收端保持一致，发完后有一个等待时间\n- 停止位为高电平\n- 每次发完后的等待时间由波特率所决定，停止位之后需要有一定的空闲时间，这个时间是超过等待时间的。\n\n以下为模拟串口接收发送的主要代码，**仅仅是一个粗稿，实验使用，具体的工程项目存在较大的缺陷，还要进一步完善。**：\n\n```\n/* IO口设置，这边不详细写出，IO配置成LED灯的模式即可 */\n\n***以下为模拟uart的TX口发送数据***\n\n/*主要的打印字符串函数*/\nvoid my_printf(char * str, ...)\n{\n\twhile (*str != '\\0')\n\t{\n\t\tUART_SendData((u8)*str++);\n\t}\n}\n\n/*串口发送每个数据包*/\nvoid UART_SendData(u8 data)\n{\n\tTX_LOW();\n\tUART_DELAY();\n\n\t//传输字节的过程中是从字节的低位开始发送的。\n    for (u8 i = 0; i < 8; i++)\n\t{\n\t\tif (data & 0x01)\n\t\t{\n\t\t\tTX_HIGH();\n\t\t}\n\t\telse \n\t\t{\n\t\t\tTX_LOW();\n\t\t}\n\t\tdata >>= 1;\n\t\t\n\t\tUART_DELAY();\n\t}\n\t\n\tTX_HIGH();\n\t\n\t// 值得注意的是在发送完毕后\n\tUART_DELAY();\n\tUART_DELAY();\n}\n\n/*使用systick定时器精准制定波特率115200*/\n#define\tUART_DELAY()\tdelay_com()\n\nvoid delay_com(void)\n{\t\t\n\tu32 temp;\t    \t \n\tSysTick->LOAD =  SystemCoreClock / 8 / 115200; //时间加载\t  \t\t \n\tSysTick->VAL = 0x00;        //清空计数器\n\tSysTick->CTRL |= SysTick_CTRL_ENABLE_Msk ;          //开始倒数\t \n\tdo\n\t{\n\t\ttemp = SysTick->CTRL;\n\t}while(temp & 0x01 && !(temp&(1<<16)));//等待时间到达   \n\tSysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;       //关闭计数器\n\tSysTick->VAL = 0X00;       //清空计数器\t \n}\n\n***以下为模拟uart的RX接收数据***\n\n这边内容较多，不做详细的累述，仅大致提供下思路，详细内容可以参见代码。\n\n\n/* 串口完整接收一个字节的数据 */\nu8 UART_GetByte(void)\n{\n\tu8 Data = 0;\n\n\tfor (u8 i = 0; i < USART_DATA_LEN; i++)\n\t{\n\t\tUART_DELAY();\n\t\tData |= RX1_READ()<<i;\t\n\t}\n\treturn Data;\n}\n\n/* 终端捕捉信号 */\nvoid EXTI15_10_IRQHandler(void) /* bit & add */\n{\n\t/* about key2 bit*/\n    if(EXTI_GetITStatus(RX1_EXTI_LINE) != RESET)\n    {\n\t\t/* 每次有数据接受时，开启定时器用来计量数据采集的时间 */\n\t\tTIM3->CNT = 0;\n\t\tTIM_Cmd(TIMER_NUM[TIMER3], ENABLE); //使能定时器3\n\n\t\tTIM3_Init_Ctrl(ENABLE);\n\n\t\tg_TimeOut = 0;\n\t\t\n\t\tg_byStore[point++] = UART_GetByte();\n\n        /* 清除中断挂起标志位，否则会被认为中断没有被处理而循环再次进入中断 */\n      \tEXTI_ClearITPendingBit(RX1_EXTI_LINE);\n    } \n}\n\n**这边的难点在于如何判断数据发送完毕**\n- 设置RX口为外部终端触发，当接收到第一个下降沿时，进入中断函数\n- 中断函数逐一执行接收数据的采集和捕捉\n- 我们通过采用一个定时器来每次收到外部中断时，完成一次计时，当计时超过一次数据接收的时间，则认为接收完毕\n\n```\n\n\n 一般字符传输都采用：1位起始位，8位数据位，1位停止位，没有校验位 的形式传输，其他形式的这里不讲。**串口异步传输在空闲状态时都必须是高电平**。第一位传输的是起始位，**起始位会将原来空闲时的高电平拉成低电平**，起始位用来来标识数据开始传输，提示接收方准备开始接收数据；当接收方第一次检测到一个下降沿时，就表示接收到了起始位。起始位后就是8位的数据位，接收方在接收每一位数据的时候会采集几十次，如果结果都是低电平，则接收到的数据位0，如果结果都是高电平，则接受到的数据位是1。1位停止位会将电平拉成高电平，为接收下一个数据做准备。\n\n\n\n#### 芯片自带uart实现\n\n既然IO口也能够模拟出uart通信功能，为何众多芯片厂商还要费尽心思的将uart做入芯片里面呢？就我个人理解而言，IO虽然可以模拟出通信协议，但毕竟是IO口的操作，在能耗，速度还有计算资源占用上面都会是一个很大的开销。尤其对功耗而言，将这些做入芯片内部，可以最完美的匹配这些协议，降低能耗，另外虽然牺牲了一定的移植性，但模拟这些通讯协议可以减少代码复杂度，降低程序员编写代码的门槛，无需彻底的理解弄清这些协议，即可完成相关功能，这现在也被大家广泛接受，毕竟如：IIC，SPI等通信协议书完全用IO模拟写起来并不是太简单。这边主要以stm32中自带的串口驱动为例，本事例不具备普遍应用性。\n\n```\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n> 参考链接：\n> http://www.cnblogs.com/jason-lu/articles/3171870.html\n> http://book.51cto.com/art/201308/408900.htm\n> http://blog.csdn.net/sdwuyulunbi/article/details/6632382\n> http://blog.csdn.net/skyflying2012/article/details/49274313\n> http://blog.csdn.net/gszhy/article/details/8594433\n> http://blog.csdn.net/bytxl/article/details/49147915\n> http://www.baike.com/wiki/51+IO%E5%8F%A3%E6%A8%A1%E6%8B%9F%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AFC%E6%BA%90%E7%A8%8B%E5%BA%8F\n> http://ziye334.blog.163.com/blog/static/224306191201452833850647\n","source":"_posts/2016/2016-10-19-串口RS232通信详解.md","raw":"---\nlayout: \"post\"\ntitle: \"串口RS232通信详解\"\ndate: \"2016-10-19 14:20\"\n---\n\n串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。曾经PC之间进行串口通信可以说是标配，很多老式电脑上面可以看到DB25的接头，但后来逐渐被DB9取代，早期鼠标打印机都通过串口进行数据传输的，但现在逐渐被USB和网络所取代，DB9的串口接头在PC和笔记本上面也较少能够看到了。做嵌入式开发可以看到有个DB9的串口标准接口，串口对于开发人员输入输出调试等有着至关重要的作用。串行接口按电气标准及协议来分包括RS-232-C、RS-422、RS485等，现在串口一般在工业嵌入式领域使用。\n\n波特率：单片机或计算机在串口通信时的速率。指的是信号被调制以后在单位时间内的变化，即单位时间内载波参数变化的次数，如每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为240Bd，比特率为10位*240个/秒=2400bps。（有单独文章详解）\n\n数据位：数据位为5-8位，它紧跟在起始位之后，是被传送字符的有效数据位。传送时先传送字符的低位，后传送字符的高位。数据位究竟是几位，可由硬件或软件来设定。当然，一般8位为一个字节，通常都喜欢设置为8位数据位传输。\n\n停止位：停止位为1位、1.5位或2位，可有软件设定。它一定是逻辑“1”电平，标志着传送一个字符的结束。\n\n奇偶校验位：奇偶校验位仅占一位，用于进行奇校验或偶校验，也可以不设奇偶位。\n\n同步通信和异步通信：异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。\n\n注意：**串口发送数据是按位逐个发送的，且在传输字节的过程中是从字节的低位开始发送的。**\n\n<!-- more -->\n\n\n### 串口通讯—全双工和半双工方式\n\n#### 全双工方式(full duplex)：\n\n当数据的发送和接收分流，分别由两根不同的传输线传送时，通信双方都能在同一时刻进行发送和接收操作，这样的传送方式就是全双工制。在全双工方式下，通信系统的每一端都设置了发送器和接收器，因此，能控制数据同时在两个方向上传送。全双工方式无需进行方向的切换，因此，没有切换操作所产生的时间延迟，这对那些不能有时间延误的交互式应用(例如远程监测和控制系统)十分有利。这种方式要求通讯双方均有发送器和接收器，同时，需要2根数据线传送数据信号。(可能还需要控制线和状态线，以及地线)。比如，计算机主机用串行接口连接显示终端，而显示终端带有键盘。这样，一方面键盘上输入的字符送到主机内存;另一方面，主机内存的信息可以送到屏幕显示。通常，往键盘上打入1个字符以后，先不显示，计算机主机收到字符后，立即回送到终端，然后终端再把这个字符显示出来。这样，前一个字符的回送过程和后一个字符的输入过程是同时进行的，即工作于全双工方式。\n\n#### 半双工方式(half duplex):\n\n若使用同一根传输线既作接收又作发送，虽然数据可以在两个方向上传送，但通信双方不能同时收发数据，这样的传送方式就是半双工制。采用半双工方式时，通信系统每一端的发送器和接收器，通过收/发开关转接到通信线上，进行方向的切换，因此，会产生时间延迟。收/发开关实际上是由软件控制的电子开关。当计算机主机用串行接口连接显示终端时，在半双工方式中，输入过程和输出过程使用同一通路。有些计算机和显示终端之间采用半双工方式工作，这时，从键盘打入的字符在发送到主机的同时就被送到终端上显示出来，而不是用回送的办法，所以避免了接收过程和发送过程同时进行的情况。\n\n\n目前多数终端和串行接口都为半双工方式提供了换向能力，也为全双工方式提供了两条独立的引脚。在实际使用时，一般并不需要通信双方同时既发送又接收，像打印机这类的单向传送设备，半双工甚至单工就能胜任，也无需倒向。\n\n### 连接方式\n\n首先需要明白两个概念，就是DTE和DCE。DTE是指数据终端设备，典型的DTE就是计算机和单片机。DCE是指数据通信设备，典型的DCE就是MODEM。RS232串口标准中的RXD和TXD都是站在DTE立场上的，而不是DCE。明白了这一点，再讲下面的接线方法，就很好理解了。\n\n单片机与计算机进行串口通信时，单片机的RXD接计算机的TXD，单片机的TXD接计算机的RXD。主要是在使用串口时，TXD和RXD都是成对的，因此值得注意的是如果都是标准串口链接方式，往往不能直接连接，必须要错开链接，而这常常有两种方式，一种是让其中一个端口的RXD和TXD对调（故意错开），然后导线直通；另外一种是两个端口都采用标准端口，但导线部分RXD和TXD对调（交叉线）。\n\n### 同步和异步\n\n同步通信和异步通信相反，就是主机在进行通信前要先建立同步，即要使用相同的时钟频率，发送方的发送频率和接受方的接受频率要同步。\n\n异步通信就是发送方在任意时刻都可以发送数据，前提是接收端已经做好了接受数据的准备（如果没有做好接受准备，数据肯定发送失败），也正是因为发送方的不确定性，所以接收方要时时刻刻的准备好接受数据，同时由于每次发送数据时间间隔的不确定性，所以，在每次发送数据时都要使用明确的界定符来标示数据（字符）的开始和结束位置，可以想象这种通信方式效率很低。虽然异步通信效率低，但是对设备的要求不高，通信设备简单。异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，**字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。**\n\n即便串口拥有同步功能，一般也是作为uart（通用异步收发传输器）使用，在UART上追加同步方式的序列信号变换电路的产品，被称为USART(Universal Synchronous Asynchronous Receiver Transmitter)。事实上目前一般我们所说的串口通信就是指通用异步收发，极少采用同步通讯的方式。\n\n\n\n### 硬件接口以及连线\n\n传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座（DB25），后来使用简化为9芯D型插座（DB9），现在应用中25芯插头座已很少采用。目前一般可以见到的串口接头都为DB9的232接口。\n\nRXD接TXD，TXD接RXD，无论是单片机和单片机相连还是计算机和单片机相连都是如此，发射部分TXD永远同RXD链接配对。具体连接见下图：\n- 使用串口直通线。设计电路时，单片机的RXD连接电路板DB9的TXD，单片机的TXD连接电路板DB9的RXD，具体实现可在232电平转换芯片处反接。\n- 使用串口交叉线。设计电路时，因为串口线已做交叉，单片机的RXD连接电路板DB9的RXD，单片机的TXD连接电路板DB9的TXD，均直连即可。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/5.jpg)\n\n除非专门说明，否则所有引脚线序都是指串口外侧的线序，RS232串口的端口示意图如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/1.jpg)\n\n如果是作为RS-232C接口，则各引脚定义如表所示。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/2.jpg)\n\n值得注意的是：**公头和母头的RS232口在所有引脚的定义上面都是一致的，因此在购买选链接线的时候会分很多种：公对公23交叉，公对公直通，母对母直通，母对母23交叉，公对母23交叉，公对母直通。如果不能确定是什么线，万用表测量串口线一端的引脚2与另一端的引脚2是否短接，是则是直连串口线，否则是交叉串口线。**\n\n\n各引脚的电气特性为：在TxD和RxD上，逻辑“1”为-3V~-15V； 逻辑“0”为+3V~+15V。在RTS、CTS、DSR、DTR和DCD等控制线上，信号有效为+3V~+15V；信号无效为-3V~-15V。对于数据信号，逻辑“1”为低于-3V，逻辑“0”为高于+3V；对于控制信号，接通ON为低于-3V；断开OFF为高于+3V；-3V~+3V、低于-15V、高于+15V都表示电压无意义。\n\n**串口异步传输在空闲状态时都必须是高电平。**\n\n\n### 特征简述\n\n- RS-232串口通信最远距离是50英尺，约为15m，可见232的距离传输并不是很远，由于正负逻辑电平的差量有限，232的抗干扰能力较弱。\n- RS-232可做到双向传输，全双工通讯，最高传输速率20kbps（传统情况下232的传输速度有限一般就是在19200以下）\n- RS-232C上传送的数字量采用负逻辑，且与地对称：逻辑1：-3 ～-15V  逻辑0：+3～+15V （使用过程中尤其需要注意232的电平，不能直接将单片机同RS-232C口中RX，TX直连，中间需要有相应的转换芯片才可）\n\n\n### 原理图\n\n既然要详细介绍RS232的使用和通讯，这边肯定要附上常见的硬件设计电路和原理图的。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/72.png)\n\n### 参考案例\n\n串口因为作为最常用的一个功能，有关串口的协议一般已经被迁入到了目前市面上几乎所有主流的芯片中了，目前绝大多数芯片本身自带串口相关功能，用户无需按照协议来模拟出高低电平和时间周期来发送码元，相关功能已经作为芯片自带功能嵌入到了相关寄存器中，用户仅仅需要根据参考文档，完成usart相关寄存器的配置和调用，即可实现串口的发送和接收了。\n\n\n#### IO口模拟uart实现\n\nIO口模拟uart能够帮助我们更加深入了理解uart的相关协议，知道整个uart通信过程中，是如何工作，对一切细节特性都可以了如指掌，对于我们深入的研究学习串口通信还是比较有帮助的，且IO模拟出来的通信协议一般都更具兼容性，可以很方便的进行不同芯片的移植，而无需关注芯片本身寄存器和底层结构。\n\n众所周知数字电路实现的最主要功能就是输入输出，高低电平。所谓的协议虽然复杂但都是可以通过输入输出和高低电频给模拟出来的。下面主要以stm32芯片为例，使用IO口模拟出串口通讯，这边只附上主要程序片段，详细工程见链接。\n\n首先，必须要知道串口通讯时数据是怎样传输的？这里以异步传输字符为例子，如下图所示：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/6.jpg)\n\n注意：\n- 串口异步传输在空闲状态时都必须是高电平\n- 起始位是低电平，发完后有一个等待时间\n- 中间数据位个数以及是否有校验位需要和接收端保持一致，发完后有一个等待时间\n- 停止位为高电平\n- 每次发完后的等待时间由波特率所决定，停止位之后需要有一定的空闲时间，这个时间是超过等待时间的。\n\n以下为模拟串口接收发送的主要代码，**仅仅是一个粗稿，实验使用，具体的工程项目存在较大的缺陷，还要进一步完善。**：\n\n```\n/* IO口设置，这边不详细写出，IO配置成LED灯的模式即可 */\n\n***以下为模拟uart的TX口发送数据***\n\n/*主要的打印字符串函数*/\nvoid my_printf(char * str, ...)\n{\n\twhile (*str != '\\0')\n\t{\n\t\tUART_SendData((u8)*str++);\n\t}\n}\n\n/*串口发送每个数据包*/\nvoid UART_SendData(u8 data)\n{\n\tTX_LOW();\n\tUART_DELAY();\n\n\t//传输字节的过程中是从字节的低位开始发送的。\n    for (u8 i = 0; i < 8; i++)\n\t{\n\t\tif (data & 0x01)\n\t\t{\n\t\t\tTX_HIGH();\n\t\t}\n\t\telse \n\t\t{\n\t\t\tTX_LOW();\n\t\t}\n\t\tdata >>= 1;\n\t\t\n\t\tUART_DELAY();\n\t}\n\t\n\tTX_HIGH();\n\t\n\t// 值得注意的是在发送完毕后\n\tUART_DELAY();\n\tUART_DELAY();\n}\n\n/*使用systick定时器精准制定波特率115200*/\n#define\tUART_DELAY()\tdelay_com()\n\nvoid delay_com(void)\n{\t\t\n\tu32 temp;\t    \t \n\tSysTick->LOAD =  SystemCoreClock / 8 / 115200; //时间加载\t  \t\t \n\tSysTick->VAL = 0x00;        //清空计数器\n\tSysTick->CTRL |= SysTick_CTRL_ENABLE_Msk ;          //开始倒数\t \n\tdo\n\t{\n\t\ttemp = SysTick->CTRL;\n\t}while(temp & 0x01 && !(temp&(1<<16)));//等待时间到达   \n\tSysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;       //关闭计数器\n\tSysTick->VAL = 0X00;       //清空计数器\t \n}\n\n***以下为模拟uart的RX接收数据***\n\n这边内容较多，不做详细的累述，仅大致提供下思路，详细内容可以参见代码。\n\n\n/* 串口完整接收一个字节的数据 */\nu8 UART_GetByte(void)\n{\n\tu8 Data = 0;\n\n\tfor (u8 i = 0; i < USART_DATA_LEN; i++)\n\t{\n\t\tUART_DELAY();\n\t\tData |= RX1_READ()<<i;\t\n\t}\n\treturn Data;\n}\n\n/* 终端捕捉信号 */\nvoid EXTI15_10_IRQHandler(void) /* bit & add */\n{\n\t/* about key2 bit*/\n    if(EXTI_GetITStatus(RX1_EXTI_LINE) != RESET)\n    {\n\t\t/* 每次有数据接受时，开启定时器用来计量数据采集的时间 */\n\t\tTIM3->CNT = 0;\n\t\tTIM_Cmd(TIMER_NUM[TIMER3], ENABLE); //使能定时器3\n\n\t\tTIM3_Init_Ctrl(ENABLE);\n\n\t\tg_TimeOut = 0;\n\t\t\n\t\tg_byStore[point++] = UART_GetByte();\n\n        /* 清除中断挂起标志位，否则会被认为中断没有被处理而循环再次进入中断 */\n      \tEXTI_ClearITPendingBit(RX1_EXTI_LINE);\n    } \n}\n\n**这边的难点在于如何判断数据发送完毕**\n- 设置RX口为外部终端触发，当接收到第一个下降沿时，进入中断函数\n- 中断函数逐一执行接收数据的采集和捕捉\n- 我们通过采用一个定时器来每次收到外部中断时，完成一次计时，当计时超过一次数据接收的时间，则认为接收完毕\n\n```\n\n\n 一般字符传输都采用：1位起始位，8位数据位，1位停止位，没有校验位 的形式传输，其他形式的这里不讲。**串口异步传输在空闲状态时都必须是高电平**。第一位传输的是起始位，**起始位会将原来空闲时的高电平拉成低电平**，起始位用来来标识数据开始传输，提示接收方准备开始接收数据；当接收方第一次检测到一个下降沿时，就表示接收到了起始位。起始位后就是8位的数据位，接收方在接收每一位数据的时候会采集几十次，如果结果都是低电平，则接收到的数据位0，如果结果都是高电平，则接受到的数据位是1。1位停止位会将电平拉成高电平，为接收下一个数据做准备。\n\n\n\n#### 芯片自带uart实现\n\n既然IO口也能够模拟出uart通信功能，为何众多芯片厂商还要费尽心思的将uart做入芯片里面呢？就我个人理解而言，IO虽然可以模拟出通信协议，但毕竟是IO口的操作，在能耗，速度还有计算资源占用上面都会是一个很大的开销。尤其对功耗而言，将这些做入芯片内部，可以最完美的匹配这些协议，降低能耗，另外虽然牺牲了一定的移植性，但模拟这些通讯协议可以减少代码复杂度，降低程序员编写代码的门槛，无需彻底的理解弄清这些协议，即可完成相关功能，这现在也被大家广泛接受，毕竟如：IIC，SPI等通信协议书完全用IO模拟写起来并不是太简单。这边主要以stm32中自带的串口驱动为例，本事例不具备普遍应用性。\n\n```\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n> 参考链接：\n> http://www.cnblogs.com/jason-lu/articles/3171870.html\n> http://book.51cto.com/art/201308/408900.htm\n> http://blog.csdn.net/sdwuyulunbi/article/details/6632382\n> http://blog.csdn.net/skyflying2012/article/details/49274313\n> http://blog.csdn.net/gszhy/article/details/8594433\n> http://blog.csdn.net/bytxl/article/details/49147915\n> http://www.baike.com/wiki/51+IO%E5%8F%A3%E6%A8%A1%E6%8B%9F%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AFC%E6%BA%90%E7%A8%8B%E5%BA%8F\n> http://ziye334.blog.163.com/blog/static/224306191201452833850647\n","slug":"2016/2016-10-19-串口RS232通信详解","published":1,"updated":"2016-12-16T01:49:21.823Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aig0030mumuqiu9phq9","content":"<p>串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。曾经PC之间进行串口通信可以说是标配，很多老式电脑上面可以看到DB25的接头，但后来逐渐被DB9取代，早期鼠标打印机都通过串口进行数据传输的，但现在逐渐被USB和网络所取代，DB9的串口接头在PC和笔记本上面也较少能够看到了。做嵌入式开发可以看到有个DB9的串口标准接口，串口对于开发人员输入输出调试等有着至关重要的作用。串行接口按电气标准及协议来分包括RS-232-C、RS-422、RS485等，现在串口一般在工业嵌入式领域使用。</p>\n<p>波特率：单片机或计算机在串口通信时的速率。指的是信号被调制以后在单位时间内的变化，即单位时间内载波参数变化的次数，如每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为240Bd，比特率为10位*240个/秒=2400bps。（有单独文章详解）</p>\n<p>数据位：数据位为5-8位，它紧跟在起始位之后，是被传送字符的有效数据位。传送时先传送字符的低位，后传送字符的高位。数据位究竟是几位，可由硬件或软件来设定。当然，一般8位为一个字节，通常都喜欢设置为8位数据位传输。</p>\n<p>停止位：停止位为1位、1.5位或2位，可有软件设定。它一定是逻辑“1”电平，标志着传送一个字符的结束。</p>\n<p>奇偶校验位：奇偶校验位仅占一位，用于进行奇校验或偶校验，也可以不设奇偶位。</p>\n<p>同步通信和异步通信：异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</p>\n<p>注意：<strong>串口发送数据是按位逐个发送的，且在传输字节的过程中是从字节的低位开始发送的。</strong></p>\n<a id=\"more\"></a>\n<h3 id=\"串口通讯—全双工和半双工方式\"><a href=\"#串口通讯—全双工和半双工方式\" class=\"headerlink\" title=\"串口通讯—全双工和半双工方式\"></a>串口通讯—全双工和半双工方式</h3><h4 id=\"全双工方式-full-duplex-：\"><a href=\"#全双工方式-full-duplex-：\" class=\"headerlink\" title=\"全双工方式(full duplex)：\"></a>全双工方式(full duplex)：</h4><p>当数据的发送和接收分流，分别由两根不同的传输线传送时，通信双方都能在同一时刻进行发送和接收操作，这样的传送方式就是全双工制。在全双工方式下，通信系统的每一端都设置了发送器和接收器，因此，能控制数据同时在两个方向上传送。全双工方式无需进行方向的切换，因此，没有切换操作所产生的时间延迟，这对那些不能有时间延误的交互式应用(例如远程监测和控制系统)十分有利。这种方式要求通讯双方均有发送器和接收器，同时，需要2根数据线传送数据信号。(可能还需要控制线和状态线，以及地线)。比如，计算机主机用串行接口连接显示终端，而显示终端带有键盘。这样，一方面键盘上输入的字符送到主机内存;另一方面，主机内存的信息可以送到屏幕显示。通常，往键盘上打入1个字符以后，先不显示，计算机主机收到字符后，立即回送到终端，然后终端再把这个字符显示出来。这样，前一个字符的回送过程和后一个字符的输入过程是同时进行的，即工作于全双工方式。</p>\n<h4 id=\"半双工方式-half-duplex\"><a href=\"#半双工方式-half-duplex\" class=\"headerlink\" title=\"半双工方式(half duplex):\"></a>半双工方式(half duplex):</h4><p>若使用同一根传输线既作接收又作发送，虽然数据可以在两个方向上传送，但通信双方不能同时收发数据，这样的传送方式就是半双工制。采用半双工方式时，通信系统每一端的发送器和接收器，通过收/发开关转接到通信线上，进行方向的切换，因此，会产生时间延迟。收/发开关实际上是由软件控制的电子开关。当计算机主机用串行接口连接显示终端时，在半双工方式中，输入过程和输出过程使用同一通路。有些计算机和显示终端之间采用半双工方式工作，这时，从键盘打入的字符在发送到主机的同时就被送到终端上显示出来，而不是用回送的办法，所以避免了接收过程和发送过程同时进行的情况。</p>\n<p>目前多数终端和串行接口都为半双工方式提供了换向能力，也为全双工方式提供了两条独立的引脚。在实际使用时，一般并不需要通信双方同时既发送又接收，像打印机这类的单向传送设备，半双工甚至单工就能胜任，也无需倒向。</p>\n<h3 id=\"连接方式\"><a href=\"#连接方式\" class=\"headerlink\" title=\"连接方式\"></a>连接方式</h3><p>首先需要明白两个概念，就是DTE和DCE。DTE是指数据终端设备，典型的DTE就是计算机和单片机。DCE是指数据通信设备，典型的DCE就是MODEM。RS232串口标准中的RXD和TXD都是站在DTE立场上的，而不是DCE。明白了这一点，再讲下面的接线方法，就很好理解了。</p>\n<p>单片机与计算机进行串口通信时，单片机的RXD接计算机的TXD，单片机的TXD接计算机的RXD。主要是在使用串口时，TXD和RXD都是成对的，因此值得注意的是如果都是标准串口链接方式，往往不能直接连接，必须要错开链接，而这常常有两种方式，一种是让其中一个端口的RXD和TXD对调（故意错开），然后导线直通；另外一种是两个端口都采用标准端口，但导线部分RXD和TXD对调（交叉线）。</p>\n<h3 id=\"同步和异步\"><a href=\"#同步和异步\" class=\"headerlink\" title=\"同步和异步\"></a>同步和异步</h3><p>同步通信和异步通信相反，就是主机在进行通信前要先建立同步，即要使用相同的时钟频率，发送方的发送频率和接受方的接受频率要同步。</p>\n<p>异步通信就是发送方在任意时刻都可以发送数据，前提是接收端已经做好了接受数据的准备（如果没有做好接受准备，数据肯定发送失败），也正是因为发送方的不确定性，所以接收方要时时刻刻的准备好接受数据，同时由于每次发送数据时间间隔的不确定性，所以，在每次发送数据时都要使用明确的界定符来标示数据（字符）的开始和结束位置，可以想象这种通信方式效率很低。虽然异步通信效率低，但是对设备的要求不高，通信设备简单。异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，<strong>字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</strong></p>\n<p>即便串口拥有同步功能，一般也是作为uart（通用异步收发传输器）使用，在UART上追加同步方式的序列信号变换电路的产品，被称为USART(Universal Synchronous Asynchronous Receiver Transmitter)。事实上目前一般我们所说的串口通信就是指通用异步收发，极少采用同步通讯的方式。</p>\n<h3 id=\"硬件接口以及连线\"><a href=\"#硬件接口以及连线\" class=\"headerlink\" title=\"硬件接口以及连线\"></a>硬件接口以及连线</h3><p>传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座（DB25），后来使用简化为9芯D型插座（DB9），现在应用中25芯插头座已很少采用。目前一般可以见到的串口接头都为DB9的232接口。</p>\n<p>RXD接TXD，TXD接RXD，无论是单片机和单片机相连还是计算机和单片机相连都是如此，发射部分TXD永远同RXD链接配对。具体连接见下图：</p>\n<ul>\n<li>使用串口直通线。设计电路时，单片机的RXD连接电路板DB9的TXD，单片机的TXD连接电路板DB9的RXD，具体实现可在232电平转换芯片处反接。</li>\n<li>使用串口交叉线。设计电路时，因为串口线已做交叉，单片机的RXD连接电路板DB9的RXD，单片机的TXD连接电路板DB9的TXD，均直连即可。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/5.jpg\" alt=\"\"></p>\n<p>除非专门说明，否则所有引脚线序都是指串口外侧的线序，RS232串口的端口示意图如下：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/1.jpg\" alt=\"\"></p>\n<p>如果是作为RS-232C接口，则各引脚定义如表所示。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/2.jpg\" alt=\"\"></p>\n<p>值得注意的是：<strong>公头和母头的RS232口在所有引脚的定义上面都是一致的，因此在购买选链接线的时候会分很多种：公对公23交叉，公对公直通，母对母直通，母对母23交叉，公对母23交叉，公对母直通。如果不能确定是什么线，万用表测量串口线一端的引脚2与另一端的引脚2是否短接，是则是直连串口线，否则是交叉串口线。</strong></p>\n<p>各引脚的电气特性为：在TxD和RxD上，逻辑“1”为-3V~-15V； 逻辑“0”为+3V~+15V。在RTS、CTS、DSR、DTR和DCD等控制线上，信号有效为+3V~+15V；信号无效为-3V~-15V。对于数据信号，逻辑“1”为低于-3V，逻辑“0”为高于+3V；对于控制信号，接通ON为低于-3V；断开OFF为高于+3V；-3V~+3V、低于-15V、高于+15V都表示电压无意义。</p>\n<p><strong>串口异步传输在空闲状态时都必须是高电平。</strong></p>\n<h3 id=\"特征简述\"><a href=\"#特征简述\" class=\"headerlink\" title=\"特征简述\"></a>特征简述</h3><ul>\n<li>RS-232串口通信最远距离是50英尺，约为15m，可见232的距离传输并不是很远，由于正负逻辑电平的差量有限，232的抗干扰能力较弱。</li>\n<li>RS-232可做到双向传输，全双工通讯，最高传输速率20kbps（传统情况下232的传输速度有限一般就是在19200以下）</li>\n<li>RS-232C上传送的数字量采用负逻辑，且与地对称：逻辑1：-3 ～-15V  逻辑0：+3～+15V （使用过程中尤其需要注意232的电平，不能直接将单片机同RS-232C口中RX，TX直连，中间需要有相应的转换芯片才可）</li>\n</ul>\n<h3 id=\"原理图\"><a href=\"#原理图\" class=\"headerlink\" title=\"原理图\"></a>原理图</h3><p>既然要详细介绍RS232的使用和通讯，这边肯定要附上常见的硬件设计电路和原理图的。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/72.png\" alt=\"\"></p>\n<h3 id=\"参考案例\"><a href=\"#参考案例\" class=\"headerlink\" title=\"参考案例\"></a>参考案例</h3><p>串口因为作为最常用的一个功能，有关串口的协议一般已经被迁入到了目前市面上几乎所有主流的芯片中了，目前绝大多数芯片本身自带串口相关功能，用户无需按照协议来模拟出高低电平和时间周期来发送码元，相关功能已经作为芯片自带功能嵌入到了相关寄存器中，用户仅仅需要根据参考文档，完成usart相关寄存器的配置和调用，即可实现串口的发送和接收了。</p>\n<h4 id=\"IO口模拟uart实现\"><a href=\"#IO口模拟uart实现\" class=\"headerlink\" title=\"IO口模拟uart实现\"></a>IO口模拟uart实现</h4><p>IO口模拟uart能够帮助我们更加深入了理解uart的相关协议，知道整个uart通信过程中，是如何工作，对一切细节特性都可以了如指掌，对于我们深入的研究学习串口通信还是比较有帮助的，且IO模拟出来的通信协议一般都更具兼容性，可以很方便的进行不同芯片的移植，而无需关注芯片本身寄存器和底层结构。</p>\n<p>众所周知数字电路实现的最主要功能就是输入输出，高低电平。所谓的协议虽然复杂但都是可以通过输入输出和高低电频给模拟出来的。下面主要以stm32芯片为例，使用IO口模拟出串口通讯，这边只附上主要程序片段，详细工程见链接。</p>\n<p>首先，必须要知道串口通讯时数据是怎样传输的？这里以异步传输字符为例子，如下图所示：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/6.jpg\" alt=\"\"></p>\n<p>注意：</p>\n<ul>\n<li>串口异步传输在空闲状态时都必须是高电平</li>\n<li>起始位是低电平，发完后有一个等待时间</li>\n<li>中间数据位个数以及是否有校验位需要和接收端保持一致，发完后有一个等待时间</li>\n<li>停止位为高电平</li>\n<li>每次发完后的等待时间由波特率所决定，停止位之后需要有一定的空闲时间，这个时间是超过等待时间的。</li>\n</ul>\n<p>以下为模拟串口接收发送的主要代码，<strong>仅仅是一个粗稿，实验使用，具体的工程项目存在较大的缺陷，还要进一步完善。</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* IO口设置，这边不详细写出，IO配置成LED灯的模式即可 */</div><div class=\"line\"></div><div class=\"line\">***以下为模拟uart的TX口发送数据***</div><div class=\"line\"></div><div class=\"line\">/*主要的打印字符串函数*/</div><div class=\"line\">void my_printf(char * str, ...)</div><div class=\"line\">&#123;</div><div class=\"line\">\twhile (*str != &apos;\\0&apos;)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tUART_SendData((u8)*str++);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/*串口发送每个数据包*/</div><div class=\"line\">void UART_SendData(u8 data)</div><div class=\"line\">&#123;</div><div class=\"line\">\tTX_LOW();</div><div class=\"line\">\tUART_DELAY();</div><div class=\"line\"></div><div class=\"line\">\t//传输字节的过程中是从字节的低位开始发送的。</div><div class=\"line\">    for (u8 i = 0; i &lt; 8; i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tif (data &amp; 0x01)</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tTX_HIGH();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\telse </div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tTX_LOW();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tdata &gt;&gt;= 1;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tUART_DELAY();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tTX_HIGH();</div><div class=\"line\">\t</div><div class=\"line\">\t// 值得注意的是在发送完毕后</div><div class=\"line\">\tUART_DELAY();</div><div class=\"line\">\tUART_DELAY();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/*使用systick定时器精准制定波特率115200*/</div><div class=\"line\">#define\tUART_DELAY()\tdelay_com()</div><div class=\"line\"></div><div class=\"line\">void delay_com(void)</div><div class=\"line\">&#123;\t\t</div><div class=\"line\">\tu32 temp;\t    \t </div><div class=\"line\">\tSysTick-&gt;LOAD =  SystemCoreClock / 8 / 115200; //时间加载\t  \t\t </div><div class=\"line\">\tSysTick-&gt;VAL = 0x00;        //清空计数器</div><div class=\"line\">\tSysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk ;          //开始倒数\t </div><div class=\"line\">\tdo</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\ttemp = SysTick-&gt;CTRL;</div><div class=\"line\">\t&#125;while(temp &amp; 0x01 &amp;&amp; !(temp&amp;(1&lt;&lt;16)));//等待时间到达   </div><div class=\"line\">\tSysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;       //关闭计数器</div><div class=\"line\">\tSysTick-&gt;VAL = 0X00;       //清空计数器\t </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">***以下为模拟uart的RX接收数据***</div><div class=\"line\"></div><div class=\"line\">这边内容较多，不做详细的累述，仅大致提供下思路，详细内容可以参见代码。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/* 串口完整接收一个字节的数据 */</div><div class=\"line\">u8 UART_GetByte(void)</div><div class=\"line\">&#123;</div><div class=\"line\">\tu8 Data = 0;</div><div class=\"line\"></div><div class=\"line\">\tfor (u8 i = 0; i &lt; USART_DATA_LEN; i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tUART_DELAY();</div><div class=\"line\">\t\tData |= RX1_READ()&lt;&lt;i;\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn Data;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/* 终端捕捉信号 */</div><div class=\"line\">void EXTI15_10_IRQHandler(void) /* bit &amp; add */</div><div class=\"line\">&#123;</div><div class=\"line\">\t/* about key2 bit*/</div><div class=\"line\">    if(EXTI_GetITStatus(RX1_EXTI_LINE) != RESET)</div><div class=\"line\">    &#123;</div><div class=\"line\">\t\t/* 每次有数据接受时，开启定时器用来计量数据采集的时间 */</div><div class=\"line\">\t\tTIM3-&gt;CNT = 0;</div><div class=\"line\">\t\tTIM_Cmd(TIMER_NUM[TIMER3], ENABLE); //使能定时器3</div><div class=\"line\"></div><div class=\"line\">\t\tTIM3_Init_Ctrl(ENABLE);</div><div class=\"line\"></div><div class=\"line\">\t\tg_TimeOut = 0;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tg_byStore[point++] = UART_GetByte();</div><div class=\"line\"></div><div class=\"line\">        /* 清除中断挂起标志位，否则会被认为中断没有被处理而循环再次进入中断 */</div><div class=\"line\">      \tEXTI_ClearITPendingBit(RX1_EXTI_LINE);</div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">**这边的难点在于如何判断数据发送完毕**</div><div class=\"line\">- 设置RX口为外部终端触发，当接收到第一个下降沿时，进入中断函数</div><div class=\"line\">- 中断函数逐一执行接收数据的采集和捕捉</div><div class=\"line\">- 我们通过采用一个定时器来每次收到外部中断时，完成一次计时，当计时超过一次数据接收的时间，则认为接收完毕</div></pre></td></tr></table></figure>\n<p> 一般字符传输都采用：1位起始位，8位数据位，1位停止位，没有校验位 的形式传输，其他形式的这里不讲。<strong>串口异步传输在空闲状态时都必须是高电平</strong>。第一位传输的是起始位，<strong>起始位会将原来空闲时的高电平拉成低电平</strong>，起始位用来来标识数据开始传输，提示接收方准备开始接收数据；当接收方第一次检测到一个下降沿时，就表示接收到了起始位。起始位后就是8位的数据位，接收方在接收每一位数据的时候会采集几十次，如果结果都是低电平，则接收到的数据位0，如果结果都是高电平，则接受到的数据位是1。1位停止位会将电平拉成高电平，为接收下一个数据做准备。</p>\n<h4 id=\"芯片自带uart实现\"><a href=\"#芯片自带uart实现\" class=\"headerlink\" title=\"芯片自带uart实现\"></a>芯片自带uart实现</h4><p>既然IO口也能够模拟出uart通信功能，为何众多芯片厂商还要费尽心思的将uart做入芯片里面呢？就我个人理解而言，IO虽然可以模拟出通信协议，但毕竟是IO口的操作，在能耗，速度还有计算资源占用上面都会是一个很大的开销。尤其对功耗而言，将这些做入芯片内部，可以最完美的匹配这些协议，降低能耗，另外虽然牺牲了一定的移植性，但模拟这些通讯协议可以减少代码复杂度，降低程序员编写代码的门槛，无需彻底的理解弄清这些协议，即可完成相关功能，这现在也被大家广泛接受，毕竟如：IIC，SPI等通信协议书完全用IO模拟写起来并不是太简单。这边主要以stm32中自带的串口驱动为例，本事例不具备普遍应用性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.cnblogs.com/jason-lu/articles/3171870.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/jason-lu/articles/3171870.html</a><br><a href=\"http://book.51cto.com/art/201308/408900.htm\" target=\"_blank\" rel=\"external\">http://book.51cto.com/art/201308/408900.htm</a><br><a href=\"http://blog.csdn.net/sdwuyulunbi/article/details/6632382\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/sdwuyulunbi/article/details/6632382</a><br><a href=\"http://blog.csdn.net/skyflying2012/article/details/49274313\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/skyflying2012/article/details/49274313</a><br><a href=\"http://blog.csdn.net/gszhy/article/details/8594433\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/gszhy/article/details/8594433</a><br><a href=\"http://blog.csdn.net/bytxl/article/details/49147915\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/bytxl/article/details/49147915</a><br><a href=\"http://www.baike.com/wiki/51+IO%E5%8F%A3%E6%A8%A1%E6%8B%9F%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AFC%E6%BA%90%E7%A8%8B%E5%BA%8F\" target=\"_blank\" rel=\"external\">http://www.baike.com/wiki/51+IO%E5%8F%A3%E6%A8%A1%E6%8B%9F%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AFC%E6%BA%90%E7%A8%8B%E5%BA%8F</a><br><a href=\"http://ziye334.blog.163.com/blog/static/224306191201452833850647\" target=\"_blank\" rel=\"external\">http://ziye334.blog.163.com/blog/static/224306191201452833850647</a></p>\n</blockquote>\n","excerpt":"<p>串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。曾经PC之间进行串口通信可以说是标配，很多老式电脑上面可以看到DB25的接头，但后来逐渐被DB9取代，早期鼠标打印机都通过串口进行数据传输的，但现在逐渐被USB和网络所取代，DB9的串口接头在PC和笔记本上面也较少能够看到了。做嵌入式开发可以看到有个DB9的串口标准接口，串口对于开发人员输入输出调试等有着至关重要的作用。串行接口按电气标准及协议来分包括RS-232-C、RS-422、RS485等，现在串口一般在工业嵌入式领域使用。</p>\n<p>波特率：单片机或计算机在串口通信时的速率。指的是信号被调制以后在单位时间内的变化，即单位时间内载波参数变化的次数，如每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为240Bd，比特率为10位*240个/秒=2400bps。（有单独文章详解）</p>\n<p>数据位：数据位为5-8位，它紧跟在起始位之后，是被传送字符的有效数据位。传送时先传送字符的低位，后传送字符的高位。数据位究竟是几位，可由硬件或软件来设定。当然，一般8位为一个字节，通常都喜欢设置为8位数据位传输。</p>\n<p>停止位：停止位为1位、1.5位或2位，可有软件设定。它一定是逻辑“1”电平，标志着传送一个字符的结束。</p>\n<p>奇偶校验位：奇偶校验位仅占一位，用于进行奇校验或偶校验，也可以不设奇偶位。</p>\n<p>同步通信和异步通信：异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</p>\n<p>注意：<strong>串口发送数据是按位逐个发送的，且在传输字节的过程中是从字节的低位开始发送的。</strong></p>","more":"<h3 id=\"串口通讯—全双工和半双工方式\"><a href=\"#串口通讯—全双工和半双工方式\" class=\"headerlink\" title=\"串口通讯—全双工和半双工方式\"></a>串口通讯—全双工和半双工方式</h3><h4 id=\"全双工方式-full-duplex-：\"><a href=\"#全双工方式-full-duplex-：\" class=\"headerlink\" title=\"全双工方式(full duplex)：\"></a>全双工方式(full duplex)：</h4><p>当数据的发送和接收分流，分别由两根不同的传输线传送时，通信双方都能在同一时刻进行发送和接收操作，这样的传送方式就是全双工制。在全双工方式下，通信系统的每一端都设置了发送器和接收器，因此，能控制数据同时在两个方向上传送。全双工方式无需进行方向的切换，因此，没有切换操作所产生的时间延迟，这对那些不能有时间延误的交互式应用(例如远程监测和控制系统)十分有利。这种方式要求通讯双方均有发送器和接收器，同时，需要2根数据线传送数据信号。(可能还需要控制线和状态线，以及地线)。比如，计算机主机用串行接口连接显示终端，而显示终端带有键盘。这样，一方面键盘上输入的字符送到主机内存;另一方面，主机内存的信息可以送到屏幕显示。通常，往键盘上打入1个字符以后，先不显示，计算机主机收到字符后，立即回送到终端，然后终端再把这个字符显示出来。这样，前一个字符的回送过程和后一个字符的输入过程是同时进行的，即工作于全双工方式。</p>\n<h4 id=\"半双工方式-half-duplex\"><a href=\"#半双工方式-half-duplex\" class=\"headerlink\" title=\"半双工方式(half duplex):\"></a>半双工方式(half duplex):</h4><p>若使用同一根传输线既作接收又作发送，虽然数据可以在两个方向上传送，但通信双方不能同时收发数据，这样的传送方式就是半双工制。采用半双工方式时，通信系统每一端的发送器和接收器，通过收/发开关转接到通信线上，进行方向的切换，因此，会产生时间延迟。收/发开关实际上是由软件控制的电子开关。当计算机主机用串行接口连接显示终端时，在半双工方式中，输入过程和输出过程使用同一通路。有些计算机和显示终端之间采用半双工方式工作，这时，从键盘打入的字符在发送到主机的同时就被送到终端上显示出来，而不是用回送的办法，所以避免了接收过程和发送过程同时进行的情况。</p>\n<p>目前多数终端和串行接口都为半双工方式提供了换向能力，也为全双工方式提供了两条独立的引脚。在实际使用时，一般并不需要通信双方同时既发送又接收，像打印机这类的单向传送设备，半双工甚至单工就能胜任，也无需倒向。</p>\n<h3 id=\"连接方式\"><a href=\"#连接方式\" class=\"headerlink\" title=\"连接方式\"></a>连接方式</h3><p>首先需要明白两个概念，就是DTE和DCE。DTE是指数据终端设备，典型的DTE就是计算机和单片机。DCE是指数据通信设备，典型的DCE就是MODEM。RS232串口标准中的RXD和TXD都是站在DTE立场上的，而不是DCE。明白了这一点，再讲下面的接线方法，就很好理解了。</p>\n<p>单片机与计算机进行串口通信时，单片机的RXD接计算机的TXD，单片机的TXD接计算机的RXD。主要是在使用串口时，TXD和RXD都是成对的，因此值得注意的是如果都是标准串口链接方式，往往不能直接连接，必须要错开链接，而这常常有两种方式，一种是让其中一个端口的RXD和TXD对调（故意错开），然后导线直通；另外一种是两个端口都采用标准端口，但导线部分RXD和TXD对调（交叉线）。</p>\n<h3 id=\"同步和异步\"><a href=\"#同步和异步\" class=\"headerlink\" title=\"同步和异步\"></a>同步和异步</h3><p>同步通信和异步通信相反，就是主机在进行通信前要先建立同步，即要使用相同的时钟频率，发送方的发送频率和接受方的接受频率要同步。</p>\n<p>异步通信就是发送方在任意时刻都可以发送数据，前提是接收端已经做好了接受数据的准备（如果没有做好接受准备，数据肯定发送失败），也正是因为发送方的不确定性，所以接收方要时时刻刻的准备好接受数据，同时由于每次发送数据时间间隔的不确定性，所以，在每次发送数据时都要使用明确的界定符来标示数据（字符）的开始和结束位置，可以想象这种通信方式效率很低。虽然异步通信效率低，但是对设备的要求不高，通信设备简单。异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，<strong>字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</strong></p>\n<p>即便串口拥有同步功能，一般也是作为uart（通用异步收发传输器）使用，在UART上追加同步方式的序列信号变换电路的产品，被称为USART(Universal Synchronous Asynchronous Receiver Transmitter)。事实上目前一般我们所说的串口通信就是指通用异步收发，极少采用同步通讯的方式。</p>\n<h3 id=\"硬件接口以及连线\"><a href=\"#硬件接口以及连线\" class=\"headerlink\" title=\"硬件接口以及连线\"></a>硬件接口以及连线</h3><p>传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座（DB25），后来使用简化为9芯D型插座（DB9），现在应用中25芯插头座已很少采用。目前一般可以见到的串口接头都为DB9的232接口。</p>\n<p>RXD接TXD，TXD接RXD，无论是单片机和单片机相连还是计算机和单片机相连都是如此，发射部分TXD永远同RXD链接配对。具体连接见下图：</p>\n<ul>\n<li>使用串口直通线。设计电路时，单片机的RXD连接电路板DB9的TXD，单片机的TXD连接电路板DB9的RXD，具体实现可在232电平转换芯片处反接。</li>\n<li>使用串口交叉线。设计电路时，因为串口线已做交叉，单片机的RXD连接电路板DB9的RXD，单片机的TXD连接电路板DB9的TXD，均直连即可。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/5.jpg\" alt=\"\"></p>\n<p>除非专门说明，否则所有引脚线序都是指串口外侧的线序，RS232串口的端口示意图如下：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/1.jpg\" alt=\"\"></p>\n<p>如果是作为RS-232C接口，则各引脚定义如表所示。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/2.jpg\" alt=\"\"></p>\n<p>值得注意的是：<strong>公头和母头的RS232口在所有引脚的定义上面都是一致的，因此在购买选链接线的时候会分很多种：公对公23交叉，公对公直通，母对母直通，母对母23交叉，公对母23交叉，公对母直通。如果不能确定是什么线，万用表测量串口线一端的引脚2与另一端的引脚2是否短接，是则是直连串口线，否则是交叉串口线。</strong></p>\n<p>各引脚的电气特性为：在TxD和RxD上，逻辑“1”为-3V~-15V； 逻辑“0”为+3V~+15V。在RTS、CTS、DSR、DTR和DCD等控制线上，信号有效为+3V~+15V；信号无效为-3V~-15V。对于数据信号，逻辑“1”为低于-3V，逻辑“0”为高于+3V；对于控制信号，接通ON为低于-3V；断开OFF为高于+3V；-3V~+3V、低于-15V、高于+15V都表示电压无意义。</p>\n<p><strong>串口异步传输在空闲状态时都必须是高电平。</strong></p>\n<h3 id=\"特征简述\"><a href=\"#特征简述\" class=\"headerlink\" title=\"特征简述\"></a>特征简述</h3><ul>\n<li>RS-232串口通信最远距离是50英尺，约为15m，可见232的距离传输并不是很远，由于正负逻辑电平的差量有限，232的抗干扰能力较弱。</li>\n<li>RS-232可做到双向传输，全双工通讯，最高传输速率20kbps（传统情况下232的传输速度有限一般就是在19200以下）</li>\n<li>RS-232C上传送的数字量采用负逻辑，且与地对称：逻辑1：-3 ～-15V  逻辑0：+3～+15V （使用过程中尤其需要注意232的电平，不能直接将单片机同RS-232C口中RX，TX直连，中间需要有相应的转换芯片才可）</li>\n</ul>\n<h3 id=\"原理图\"><a href=\"#原理图\" class=\"headerlink\" title=\"原理图\"></a>原理图</h3><p>既然要详细介绍RS232的使用和通讯，这边肯定要附上常见的硬件设计电路和原理图的。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/72.png\" alt=\"\"></p>\n<h3 id=\"参考案例\"><a href=\"#参考案例\" class=\"headerlink\" title=\"参考案例\"></a>参考案例</h3><p>串口因为作为最常用的一个功能，有关串口的协议一般已经被迁入到了目前市面上几乎所有主流的芯片中了，目前绝大多数芯片本身自带串口相关功能，用户无需按照协议来模拟出高低电平和时间周期来发送码元，相关功能已经作为芯片自带功能嵌入到了相关寄存器中，用户仅仅需要根据参考文档，完成usart相关寄存器的配置和调用，即可实现串口的发送和接收了。</p>\n<h4 id=\"IO口模拟uart实现\"><a href=\"#IO口模拟uart实现\" class=\"headerlink\" title=\"IO口模拟uart实现\"></a>IO口模拟uart实现</h4><p>IO口模拟uart能够帮助我们更加深入了理解uart的相关协议，知道整个uart通信过程中，是如何工作，对一切细节特性都可以了如指掌，对于我们深入的研究学习串口通信还是比较有帮助的，且IO模拟出来的通信协议一般都更具兼容性，可以很方便的进行不同芯片的移植，而无需关注芯片本身寄存器和底层结构。</p>\n<p>众所周知数字电路实现的最主要功能就是输入输出，高低电平。所谓的协议虽然复杂但都是可以通过输入输出和高低电频给模拟出来的。下面主要以stm32芯片为例，使用IO口模拟出串口通讯，这边只附上主要程序片段，详细工程见链接。</p>\n<p>首先，必须要知道串口通讯时数据是怎样传输的？这里以异步传输字符为例子，如下图所示：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/6.jpg\" alt=\"\"></p>\n<p>注意：</p>\n<ul>\n<li>串口异步传输在空闲状态时都必须是高电平</li>\n<li>起始位是低电平，发完后有一个等待时间</li>\n<li>中间数据位个数以及是否有校验位需要和接收端保持一致，发完后有一个等待时间</li>\n<li>停止位为高电平</li>\n<li>每次发完后的等待时间由波特率所决定，停止位之后需要有一定的空闲时间，这个时间是超过等待时间的。</li>\n</ul>\n<p>以下为模拟串口接收发送的主要代码，<strong>仅仅是一个粗稿，实验使用，具体的工程项目存在较大的缺陷，还要进一步完善。</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* IO口设置，这边不详细写出，IO配置成LED灯的模式即可 */</div><div class=\"line\"></div><div class=\"line\">***以下为模拟uart的TX口发送数据***</div><div class=\"line\"></div><div class=\"line\">/*主要的打印字符串函数*/</div><div class=\"line\">void my_printf(char * str, ...)</div><div class=\"line\">&#123;</div><div class=\"line\">\twhile (*str != &apos;\\0&apos;)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tUART_SendData((u8)*str++);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/*串口发送每个数据包*/</div><div class=\"line\">void UART_SendData(u8 data)</div><div class=\"line\">&#123;</div><div class=\"line\">\tTX_LOW();</div><div class=\"line\">\tUART_DELAY();</div><div class=\"line\"></div><div class=\"line\">\t//传输字节的过程中是从字节的低位开始发送的。</div><div class=\"line\">    for (u8 i = 0; i &lt; 8; i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tif (data &amp; 0x01)</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tTX_HIGH();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\telse </div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tTX_LOW();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tdata &gt;&gt;= 1;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tUART_DELAY();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tTX_HIGH();</div><div class=\"line\">\t</div><div class=\"line\">\t// 值得注意的是在发送完毕后</div><div class=\"line\">\tUART_DELAY();</div><div class=\"line\">\tUART_DELAY();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/*使用systick定时器精准制定波特率115200*/</div><div class=\"line\">#define\tUART_DELAY()\tdelay_com()</div><div class=\"line\"></div><div class=\"line\">void delay_com(void)</div><div class=\"line\">&#123;\t\t</div><div class=\"line\">\tu32 temp;\t    \t </div><div class=\"line\">\tSysTick-&gt;LOAD =  SystemCoreClock / 8 / 115200; //时间加载\t  \t\t </div><div class=\"line\">\tSysTick-&gt;VAL = 0x00;        //清空计数器</div><div class=\"line\">\tSysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk ;          //开始倒数\t </div><div class=\"line\">\tdo</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\ttemp = SysTick-&gt;CTRL;</div><div class=\"line\">\t&#125;while(temp &amp; 0x01 &amp;&amp; !(temp&amp;(1&lt;&lt;16)));//等待时间到达   </div><div class=\"line\">\tSysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;       //关闭计数器</div><div class=\"line\">\tSysTick-&gt;VAL = 0X00;       //清空计数器\t </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">***以下为模拟uart的RX接收数据***</div><div class=\"line\"></div><div class=\"line\">这边内容较多，不做详细的累述，仅大致提供下思路，详细内容可以参见代码。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/* 串口完整接收一个字节的数据 */</div><div class=\"line\">u8 UART_GetByte(void)</div><div class=\"line\">&#123;</div><div class=\"line\">\tu8 Data = 0;</div><div class=\"line\"></div><div class=\"line\">\tfor (u8 i = 0; i &lt; USART_DATA_LEN; i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tUART_DELAY();</div><div class=\"line\">\t\tData |= RX1_READ()&lt;&lt;i;\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn Data;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/* 终端捕捉信号 */</div><div class=\"line\">void EXTI15_10_IRQHandler(void) /* bit &amp; add */</div><div class=\"line\">&#123;</div><div class=\"line\">\t/* about key2 bit*/</div><div class=\"line\">    if(EXTI_GetITStatus(RX1_EXTI_LINE) != RESET)</div><div class=\"line\">    &#123;</div><div class=\"line\">\t\t/* 每次有数据接受时，开启定时器用来计量数据采集的时间 */</div><div class=\"line\">\t\tTIM3-&gt;CNT = 0;</div><div class=\"line\">\t\tTIM_Cmd(TIMER_NUM[TIMER3], ENABLE); //使能定时器3</div><div class=\"line\"></div><div class=\"line\">\t\tTIM3_Init_Ctrl(ENABLE);</div><div class=\"line\"></div><div class=\"line\">\t\tg_TimeOut = 0;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tg_byStore[point++] = UART_GetByte();</div><div class=\"line\"></div><div class=\"line\">        /* 清除中断挂起标志位，否则会被认为中断没有被处理而循环再次进入中断 */</div><div class=\"line\">      \tEXTI_ClearITPendingBit(RX1_EXTI_LINE);</div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">**这边的难点在于如何判断数据发送完毕**</div><div class=\"line\">- 设置RX口为外部终端触发，当接收到第一个下降沿时，进入中断函数</div><div class=\"line\">- 中断函数逐一执行接收数据的采集和捕捉</div><div class=\"line\">- 我们通过采用一个定时器来每次收到外部中断时，完成一次计时，当计时超过一次数据接收的时间，则认为接收完毕</div></pre></td></tr></table></figure>\n<p> 一般字符传输都采用：1位起始位，8位数据位，1位停止位，没有校验位 的形式传输，其他形式的这里不讲。<strong>串口异步传输在空闲状态时都必须是高电平</strong>。第一位传输的是起始位，<strong>起始位会将原来空闲时的高电平拉成低电平</strong>，起始位用来来标识数据开始传输，提示接收方准备开始接收数据；当接收方第一次检测到一个下降沿时，就表示接收到了起始位。起始位后就是8位的数据位，接收方在接收每一位数据的时候会采集几十次，如果结果都是低电平，则接收到的数据位0，如果结果都是高电平，则接受到的数据位是1。1位停止位会将电平拉成高电平，为接收下一个数据做准备。</p>\n<h4 id=\"芯片自带uart实现\"><a href=\"#芯片自带uart实现\" class=\"headerlink\" title=\"芯片自带uart实现\"></a>芯片自带uart实现</h4><p>既然IO口也能够模拟出uart通信功能，为何众多芯片厂商还要费尽心思的将uart做入芯片里面呢？就我个人理解而言，IO虽然可以模拟出通信协议，但毕竟是IO口的操作，在能耗，速度还有计算资源占用上面都会是一个很大的开销。尤其对功耗而言，将这些做入芯片内部，可以最完美的匹配这些协议，降低能耗，另外虽然牺牲了一定的移植性，但模拟这些通讯协议可以减少代码复杂度，降低程序员编写代码的门槛，无需彻底的理解弄清这些协议，即可完成相关功能，这现在也被大家广泛接受，毕竟如：IIC，SPI等通信协议书完全用IO模拟写起来并不是太简单。这边主要以stm32中自带的串口驱动为例，本事例不具备普遍应用性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.cnblogs.com/jason-lu/articles/3171870.html\">http://www.cnblogs.com/jason-lu/articles/3171870.html</a><br><a href=\"http://book.51cto.com/art/201308/408900.htm\">http://book.51cto.com/art/201308/408900.htm</a><br><a href=\"http://blog.csdn.net/sdwuyulunbi/article/details/6632382\">http://blog.csdn.net/sdwuyulunbi/article/details/6632382</a><br><a href=\"http://blog.csdn.net/skyflying2012/article/details/49274313\">http://blog.csdn.net/skyflying2012/article/details/49274313</a><br><a href=\"http://blog.csdn.net/gszhy/article/details/8594433\">http://blog.csdn.net/gszhy/article/details/8594433</a><br><a href=\"http://blog.csdn.net/bytxl/article/details/49147915\">http://blog.csdn.net/bytxl/article/details/49147915</a><br><a href=\"http://www.baike.com/wiki/51+IO%E5%8F%A3%E6%A8%A1%E6%8B%9F%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AFC%E6%BA%90%E7%A8%8B%E5%BA%8F\">http://www.baike.com/wiki/51+IO%E5%8F%A3%E6%A8%A1%E6%8B%9F%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AFC%E6%BA%90%E7%A8%8B%E5%BA%8F</a><br><a href=\"http://ziye334.blog.163.com/blog/static/224306191201452833850647\">http://ziye334.blog.163.com/blog/static/224306191201452833850647</a></p>\n</blockquote>"},{"layout":"post","title":"linux免密码命令","date":"2016-10-24T03:12:00.000Z","_content":"\n在使用ubuntu的过程中，部分命令必须要具备root权限才可以执行，然后root权限需要输入密码，很多常用的命令如:reboot等，甚至需要每次输入密码，部分用户也许会很不满意。另外当如果在写脚本时也会出现这种问题，脚本中可能会包含一些sudo指令，但用户不想每次都输入密码。这边介绍几种方法以供参考。\n\n<!-- more -->\n\n\n### 写入配置文件\n\n将免密码文件写入到 /etc/sudoers 配置文件中，书写格式如下：\n\n```\n假设你的用户名是user，host是host则可以将以下命令加入到 /etc/sudoers 中:\n\nuser host = (root) NOPASSWD: /sbin/shutdown\nuser host = (root) NOPASSWD: /sbin/reboot\nuser host = (root) NOPASSWD: /home/user/program/startup.sh (注意：startup.up需要设定为可执行)\n\n可以看到通过以上方法写入到sudoers中可以让程序或者脚本中即便需要root权限，也可以免密码自动执行。\n\n```\n\n\n\n\n\n> 参考链接：\n> http://askubuntu.com/questions/159007/how-do-i-run-specific-sudo-commands-without-a-password\n> \n","source":"_posts/2016/2016-10-24-linux免密码命令.md","raw":"---\nlayout: \"post\"\ntitle: \"linux免密码命令\"\ndate: \"2016-10-24 11:12\"\n---\n\n在使用ubuntu的过程中，部分命令必须要具备root权限才可以执行，然后root权限需要输入密码，很多常用的命令如:reboot等，甚至需要每次输入密码，部分用户也许会很不满意。另外当如果在写脚本时也会出现这种问题，脚本中可能会包含一些sudo指令，但用户不想每次都输入密码。这边介绍几种方法以供参考。\n\n<!-- more -->\n\n\n### 写入配置文件\n\n将免密码文件写入到 /etc/sudoers 配置文件中，书写格式如下：\n\n```\n假设你的用户名是user，host是host则可以将以下命令加入到 /etc/sudoers 中:\n\nuser host = (root) NOPASSWD: /sbin/shutdown\nuser host = (root) NOPASSWD: /sbin/reboot\nuser host = (root) NOPASSWD: /home/user/program/startup.sh (注意：startup.up需要设定为可执行)\n\n可以看到通过以上方法写入到sudoers中可以让程序或者脚本中即便需要root权限，也可以免密码自动执行。\n\n```\n\n\n\n\n\n> 参考链接：\n> http://askubuntu.com/questions/159007/how-do-i-run-specific-sudo-commands-without-a-password\n> \n","slug":"2016/2016-10-24-linux免密码命令","published":1,"updated":"2016-12-16T01:49:39.955Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aii0031mumuic4fu9td","content":"<p>在使用ubuntu的过程中，部分命令必须要具备root权限才可以执行，然后root权限需要输入密码，很多常用的命令如:reboot等，甚至需要每次输入密码，部分用户也许会很不满意。另外当如果在写脚本时也会出现这种问题，脚本中可能会包含一些sudo指令，但用户不想每次都输入密码。这边介绍几种方法以供参考。</p>\n<a id=\"more\"></a>\n<h3 id=\"写入配置文件\"><a href=\"#写入配置文件\" class=\"headerlink\" title=\"写入配置文件\"></a>写入配置文件</h3><p>将免密码文件写入到 /etc/sudoers 配置文件中，书写格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">假设你的用户名是user，host是host则可以将以下命令加入到 /etc/sudoers 中:</div><div class=\"line\"></div><div class=\"line\">user host = (root) NOPASSWD: /sbin/shutdown</div><div class=\"line\">user host = (root) NOPASSWD: /sbin/reboot</div><div class=\"line\">user host = (root) NOPASSWD: /home/user/program/startup.sh (注意：startup.up需要设定为可执行)</div><div class=\"line\"></div><div class=\"line\">可以看到通过以上方法写入到sudoers中可以让程序或者脚本中即便需要root权限，也可以免密码自动执行。</div></pre></td></tr></table></figure>\n<blockquote>\n<p>参考链接：<br><a href=\"http://askubuntu.com/questions/159007/how-do-i-run-specific-sudo-commands-without-a-password\" target=\"_blank\" rel=\"external\">http://askubuntu.com/questions/159007/how-do-i-run-specific-sudo-commands-without-a-password</a></p>\n</blockquote>\n","excerpt":"<p>在使用ubuntu的过程中，部分命令必须要具备root权限才可以执行，然后root权限需要输入密码，很多常用的命令如:reboot等，甚至需要每次输入密码，部分用户也许会很不满意。另外当如果在写脚本时也会出现这种问题，脚本中可能会包含一些sudo指令，但用户不想每次都输入密码。这边介绍几种方法以供参考。</p>","more":"<h3 id=\"写入配置文件\"><a href=\"#写入配置文件\" class=\"headerlink\" title=\"写入配置文件\"></a>写入配置文件</h3><p>将免密码文件写入到 /etc/sudoers 配置文件中，书写格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">假设你的用户名是user，host是host则可以将以下命令加入到 /etc/sudoers 中:</div><div class=\"line\"></div><div class=\"line\">user host = (root) NOPASSWD: /sbin/shutdown</div><div class=\"line\">user host = (root) NOPASSWD: /sbin/reboot</div><div class=\"line\">user host = (root) NOPASSWD: /home/user/program/startup.sh (注意：startup.up需要设定为可执行)</div><div class=\"line\"></div><div class=\"line\">可以看到通过以上方法写入到sudoers中可以让程序或者脚本中即便需要root权限，也可以免密码自动执行。</div></pre></td></tr></table></figure>\n<blockquote>\n<p>参考链接：<br><a href=\"http://askubuntu.com/questions/159007/how-do-i-run-specific-sudo-commands-without-a-password\">http://askubuntu.com/questions/159007/how-do-i-run-specific-sudo-commands-without-a-password</a></p>\n</blockquote>"},{"layout":"post","title":"linux分区问题","date":"2016-10-28T00:46:00.000Z","_content":"\n\n分区功能是个使用系统时候的必备功能，但却不特别常用，所以每次使用时难免会因为不记得指令或者错误使用指令而导致一些没必要的错误发生，建议如果不是经常分区，对步骤不是记得太清楚的话，在分区前还是搜索一下详细步骤，免得出了问题仍然不自知。笔者之所以写这篇文章就是潜意识中觉得分区步骤简单，然后出了问题，还不知道问题出在哪儿。\n\n\n### 简述分区步骤：\n\n- df:可以查看下当前系统**挂载了的分区**，如下图所示\n\n```\nFilesystem     1K-blocks     Used Available Use% Mounted on\nudev             4044748        0   4044748   0% /dev\ntmpfs             812844     9744    803100   2% /run\n/dev/sda2       47930248 11323396  34149048  25% /\ntmpfs            4064220   349608   3714612   9% /dev/shm\ntmpfs               5120        4      5116   1% /run/lock\ntmpfs            4064220        0   4064220   0% /sys/fs/cgroup\n/dev/sda1         497696     3668    494028   1% /boot/efi\n/dev/sda3       95990540 70935460  20155908  78% /home\ntmpfs             812844       12    812832   1% /run/user/1000\n/dev/sda5      142794248 34011608 101506060  26% /home/demon/Space\n```\n\n<!-- more -->\n\n\n- 也可以使用sudo fdisk -l 看当前系统存在的分区信息\n- 下面开始分区，使用sudo fdisk /dev/sda，这边要对sda设备进行分区，主要看你要对哪块盘进行分区，如果有第二块盘，则是sdb。执行完这个指令后，会有帮助提示，跟着提示走，会很简单。\n- 这边我们新建分区，输入：n，选择分区码，起始扇区，结尾扇区。最后输入w写入分区表。这边出现警告：\n\n```\nThe partition table has been altered.\nCalling ioctl() to re-read partition table.\nRe-reading the partition table failed.: Device or resource busy\n\nThe kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8).\n```\n\n起初一直在纠结这个问题，后来通过网上查看发现仅仅是个警告，并非错误，而虽然完成但事实上这边没有格式化，值得注意的是，fdisk虽然选择了分区类型，但并没有格式化分区，而这边的分区类型仅仅是将分区类型的内容写入了MBR中，真正格式化还得手动执行。\n\n- 使用sudo fdisk -l 已经可以查看到分区列表了\n\n```\nDevice         Start        End    Sectors   Size Type\n/dev/sda1       2048     999423     997376   487M EFI System\n/dev/sda2     999424   98656255   97656832  46.6G Linux filesystem\n/dev/sda3   98656256  293967871  195311616  93.1G Linux filesystem\n/dev/sda4  293967872  309592063   15624192   7.5G Linux swap\n/dev/sda5  309592064  600000000  290407937 138.5G Linux filesystem\n/dev/sda6  600000512 1953525134 1353524623 645.4G Linux filesystem\n```\n\n- 下面真正格式化分区，格式化分区需要选择格式化类型，上面通过fdisk已经选定了分区为linux filesystem了，这边就要将其格式化为其对应的文件系统。sudo mkfs.ext4 /dev/sda6，再看分区sudo fdisk -l。\n\n```\nDevice         Start        End    Sectors   Size Type\n/dev/sda1       2048     999423     997376   487M EFI System\n/dev/sda2     999424   98656255   97656832  46.6G Linux filesystem\n/dev/sda3   98656256  293967871  195311616  93.1G Linux filesystem\n/dev/sda4  293967872  309592063   15624192   7.5G Linux swap\n/dev/sda5  309592064  600000000  290407937 138.5G Linux filesystem\n/dev/sda6  600000512 1953525134 1353524623 645.4G Linux filesystem\n```\n\n- 最后一步就是挂载分区了，使用sudo mount /dev/sda6 ~/Extern 将sda6新分出来的分区挂载到当前用户目录下的Extern分区中即可。\n- df再次查看可以发现，分区已经被挂载成功了。\n","source":"_posts/2016/2016-10-28-linux分区问题.md","raw":"---\nlayout: \"post\"\ntitle: \"linux分区问题\"\ndate: \"2016-10-28 08:46\"\n---\n\n\n分区功能是个使用系统时候的必备功能，但却不特别常用，所以每次使用时难免会因为不记得指令或者错误使用指令而导致一些没必要的错误发生，建议如果不是经常分区，对步骤不是记得太清楚的话，在分区前还是搜索一下详细步骤，免得出了问题仍然不自知。笔者之所以写这篇文章就是潜意识中觉得分区步骤简单，然后出了问题，还不知道问题出在哪儿。\n\n\n### 简述分区步骤：\n\n- df:可以查看下当前系统**挂载了的分区**，如下图所示\n\n```\nFilesystem     1K-blocks     Used Available Use% Mounted on\nudev             4044748        0   4044748   0% /dev\ntmpfs             812844     9744    803100   2% /run\n/dev/sda2       47930248 11323396  34149048  25% /\ntmpfs            4064220   349608   3714612   9% /dev/shm\ntmpfs               5120        4      5116   1% /run/lock\ntmpfs            4064220        0   4064220   0% /sys/fs/cgroup\n/dev/sda1         497696     3668    494028   1% /boot/efi\n/dev/sda3       95990540 70935460  20155908  78% /home\ntmpfs             812844       12    812832   1% /run/user/1000\n/dev/sda5      142794248 34011608 101506060  26% /home/demon/Space\n```\n\n<!-- more -->\n\n\n- 也可以使用sudo fdisk -l 看当前系统存在的分区信息\n- 下面开始分区，使用sudo fdisk /dev/sda，这边要对sda设备进行分区，主要看你要对哪块盘进行分区，如果有第二块盘，则是sdb。执行完这个指令后，会有帮助提示，跟着提示走，会很简单。\n- 这边我们新建分区，输入：n，选择分区码，起始扇区，结尾扇区。最后输入w写入分区表。这边出现警告：\n\n```\nThe partition table has been altered.\nCalling ioctl() to re-read partition table.\nRe-reading the partition table failed.: Device or resource busy\n\nThe kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8).\n```\n\n起初一直在纠结这个问题，后来通过网上查看发现仅仅是个警告，并非错误，而虽然完成但事实上这边没有格式化，值得注意的是，fdisk虽然选择了分区类型，但并没有格式化分区，而这边的分区类型仅仅是将分区类型的内容写入了MBR中，真正格式化还得手动执行。\n\n- 使用sudo fdisk -l 已经可以查看到分区列表了\n\n```\nDevice         Start        End    Sectors   Size Type\n/dev/sda1       2048     999423     997376   487M EFI System\n/dev/sda2     999424   98656255   97656832  46.6G Linux filesystem\n/dev/sda3   98656256  293967871  195311616  93.1G Linux filesystem\n/dev/sda4  293967872  309592063   15624192   7.5G Linux swap\n/dev/sda5  309592064  600000000  290407937 138.5G Linux filesystem\n/dev/sda6  600000512 1953525134 1353524623 645.4G Linux filesystem\n```\n\n- 下面真正格式化分区，格式化分区需要选择格式化类型，上面通过fdisk已经选定了分区为linux filesystem了，这边就要将其格式化为其对应的文件系统。sudo mkfs.ext4 /dev/sda6，再看分区sudo fdisk -l。\n\n```\nDevice         Start        End    Sectors   Size Type\n/dev/sda1       2048     999423     997376   487M EFI System\n/dev/sda2     999424   98656255   97656832  46.6G Linux filesystem\n/dev/sda3   98656256  293967871  195311616  93.1G Linux filesystem\n/dev/sda4  293967872  309592063   15624192   7.5G Linux swap\n/dev/sda5  309592064  600000000  290407937 138.5G Linux filesystem\n/dev/sda6  600000512 1953525134 1353524623 645.4G Linux filesystem\n```\n\n- 最后一步就是挂载分区了，使用sudo mount /dev/sda6 ~/Extern 将sda6新分出来的分区挂载到当前用户目录下的Extern分区中即可。\n- df再次查看可以发现，分区已经被挂载成功了。\n","slug":"2016/2016-10-28-linux分区问题","published":1,"updated":"2016-12-16T01:49:52.443Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aij0032mumui7pl91vo","content":"<p>分区功能是个使用系统时候的必备功能，但却不特别常用，所以每次使用时难免会因为不记得指令或者错误使用指令而导致一些没必要的错误发生，建议如果不是经常分区，对步骤不是记得太清楚的话，在分区前还是搜索一下详细步骤，免得出了问题仍然不自知。笔者之所以写这篇文章就是潜意识中觉得分区步骤简单，然后出了问题，还不知道问题出在哪儿。</p>\n<h3 id=\"简述分区步骤：\"><a href=\"#简述分区步骤：\" class=\"headerlink\" title=\"简述分区步骤：\"></a>简述分区步骤：</h3><ul>\n<li>df:可以查看下当前系统<strong>挂载了的分区</strong>，如下图所示</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Filesystem     1K-blocks     Used Available Use% Mounted on</div><div class=\"line\">udev             4044748        0   4044748   0% /dev</div><div class=\"line\">tmpfs             812844     9744    803100   2% /run</div><div class=\"line\">/dev/sda2       47930248 11323396  34149048  25% /</div><div class=\"line\">tmpfs            4064220   349608   3714612   9% /dev/shm</div><div class=\"line\">tmpfs               5120        4      5116   1% /run/lock</div><div class=\"line\">tmpfs            4064220        0   4064220   0% /sys/fs/cgroup</div><div class=\"line\">/dev/sda1         497696     3668    494028   1% /boot/efi</div><div class=\"line\">/dev/sda3       95990540 70935460  20155908  78% /home</div><div class=\"line\">tmpfs             812844       12    812832   1% /run/user/1000</div><div class=\"line\">/dev/sda5      142794248 34011608 101506060  26% /home/demon/Space</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<ul>\n<li>也可以使用sudo fdisk -l 看当前系统存在的分区信息</li>\n<li>下面开始分区，使用sudo fdisk /dev/sda，这边要对sda设备进行分区，主要看你要对哪块盘进行分区，如果有第二块盘，则是sdb。执行完这个指令后，会有帮助提示，跟着提示走，会很简单。</li>\n<li>这边我们新建分区，输入：n，选择分区码，起始扇区，结尾扇区。最后输入w写入分区表。这边出现警告：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">The partition table has been altered.</div><div class=\"line\">Calling ioctl() to re-read partition table.</div><div class=\"line\">Re-reading the partition table failed.: Device or resource busy</div><div class=\"line\"></div><div class=\"line\">The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8).</div></pre></td></tr></table></figure>\n<p>起初一直在纠结这个问题，后来通过网上查看发现仅仅是个警告，并非错误，而虽然完成但事实上这边没有格式化，值得注意的是，fdisk虽然选择了分区类型，但并没有格式化分区，而这边的分区类型仅仅是将分区类型的内容写入了MBR中，真正格式化还得手动执行。</p>\n<ul>\n<li>使用sudo fdisk -l 已经可以查看到分区列表了</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Device         Start        End    Sectors   Size Type</div><div class=\"line\">/dev/sda1       2048     999423     997376   487M EFI System</div><div class=\"line\">/dev/sda2     999424   98656255   97656832  46.6G Linux filesystem</div><div class=\"line\">/dev/sda3   98656256  293967871  195311616  93.1G Linux filesystem</div><div class=\"line\">/dev/sda4  293967872  309592063   15624192   7.5G Linux swap</div><div class=\"line\">/dev/sda5  309592064  600000000  290407937 138.5G Linux filesystem</div><div class=\"line\">/dev/sda6  600000512 1953525134 1353524623 645.4G Linux filesystem</div></pre></td></tr></table></figure>\n<ul>\n<li>下面真正格式化分区，格式化分区需要选择格式化类型，上面通过fdisk已经选定了分区为linux filesystem了，这边就要将其格式化为其对应的文件系统。sudo mkfs.ext4 /dev/sda6，再看分区sudo fdisk -l。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Device         Start        End    Sectors   Size Type</div><div class=\"line\">/dev/sda1       2048     999423     997376   487M EFI System</div><div class=\"line\">/dev/sda2     999424   98656255   97656832  46.6G Linux filesystem</div><div class=\"line\">/dev/sda3   98656256  293967871  195311616  93.1G Linux filesystem</div><div class=\"line\">/dev/sda4  293967872  309592063   15624192   7.5G Linux swap</div><div class=\"line\">/dev/sda5  309592064  600000000  290407937 138.5G Linux filesystem</div><div class=\"line\">/dev/sda6  600000512 1953525134 1353524623 645.4G Linux filesystem</div></pre></td></tr></table></figure>\n<ul>\n<li>最后一步就是挂载分区了，使用sudo mount /dev/sda6 ~/Extern 将sda6新分出来的分区挂载到当前用户目录下的Extern分区中即可。</li>\n<li>df再次查看可以发现，分区已经被挂载成功了。</li>\n</ul>\n","excerpt":"<p>分区功能是个使用系统时候的必备功能，但却不特别常用，所以每次使用时难免会因为不记得指令或者错误使用指令而导致一些没必要的错误发生，建议如果不是经常分区，对步骤不是记得太清楚的话，在分区前还是搜索一下详细步骤，免得出了问题仍然不自知。笔者之所以写这篇文章就是潜意识中觉得分区步骤简单，然后出了问题，还不知道问题出在哪儿。</p>\n<h3 id=\"简述分区步骤：\"><a href=\"#简述分区步骤：\" class=\"headerlink\" title=\"简述分区步骤：\"></a>简述分区步骤：</h3><ul>\n<li>df:可以查看下当前系统<strong>挂载了的分区</strong>，如下图所示</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Filesystem     1K-blocks     Used Available Use% Mounted on</div><div class=\"line\">udev             4044748        0   4044748   0% /dev</div><div class=\"line\">tmpfs             812844     9744    803100   2% /run</div><div class=\"line\">/dev/sda2       47930248 11323396  34149048  25% /</div><div class=\"line\">tmpfs            4064220   349608   3714612   9% /dev/shm</div><div class=\"line\">tmpfs               5120        4      5116   1% /run/lock</div><div class=\"line\">tmpfs            4064220        0   4064220   0% /sys/fs/cgroup</div><div class=\"line\">/dev/sda1         497696     3668    494028   1% /boot/efi</div><div class=\"line\">/dev/sda3       95990540 70935460  20155908  78% /home</div><div class=\"line\">tmpfs             812844       12    812832   1% /run/user/1000</div><div class=\"line\">/dev/sda5      142794248 34011608 101506060  26% /home/demon/Space</div></pre></td></tr></table></figure>","more":"<ul>\n<li>也可以使用sudo fdisk -l 看当前系统存在的分区信息</li>\n<li>下面开始分区，使用sudo fdisk /dev/sda，这边要对sda设备进行分区，主要看你要对哪块盘进行分区，如果有第二块盘，则是sdb。执行完这个指令后，会有帮助提示，跟着提示走，会很简单。</li>\n<li>这边我们新建分区，输入：n，选择分区码，起始扇区，结尾扇区。最后输入w写入分区表。这边出现警告：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">The partition table has been altered.</div><div class=\"line\">Calling ioctl() to re-read partition table.</div><div class=\"line\">Re-reading the partition table failed.: Device or resource busy</div><div class=\"line\"></div><div class=\"line\">The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8).</div></pre></td></tr></table></figure>\n<p>起初一直在纠结这个问题，后来通过网上查看发现仅仅是个警告，并非错误，而虽然完成但事实上这边没有格式化，值得注意的是，fdisk虽然选择了分区类型，但并没有格式化分区，而这边的分区类型仅仅是将分区类型的内容写入了MBR中，真正格式化还得手动执行。</p>\n<ul>\n<li>使用sudo fdisk -l 已经可以查看到分区列表了</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Device         Start        End    Sectors   Size Type</div><div class=\"line\">/dev/sda1       2048     999423     997376   487M EFI System</div><div class=\"line\">/dev/sda2     999424   98656255   97656832  46.6G Linux filesystem</div><div class=\"line\">/dev/sda3   98656256  293967871  195311616  93.1G Linux filesystem</div><div class=\"line\">/dev/sda4  293967872  309592063   15624192   7.5G Linux swap</div><div class=\"line\">/dev/sda5  309592064  600000000  290407937 138.5G Linux filesystem</div><div class=\"line\">/dev/sda6  600000512 1953525134 1353524623 645.4G Linux filesystem</div></pre></td></tr></table></figure>\n<ul>\n<li>下面真正格式化分区，格式化分区需要选择格式化类型，上面通过fdisk已经选定了分区为linux filesystem了，这边就要将其格式化为其对应的文件系统。sudo mkfs.ext4 /dev/sda6，再看分区sudo fdisk -l。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Device         Start        End    Sectors   Size Type</div><div class=\"line\">/dev/sda1       2048     999423     997376   487M EFI System</div><div class=\"line\">/dev/sda2     999424   98656255   97656832  46.6G Linux filesystem</div><div class=\"line\">/dev/sda3   98656256  293967871  195311616  93.1G Linux filesystem</div><div class=\"line\">/dev/sda4  293967872  309592063   15624192   7.5G Linux swap</div><div class=\"line\">/dev/sda5  309592064  600000000  290407937 138.5G Linux filesystem</div><div class=\"line\">/dev/sda6  600000512 1953525134 1353524623 645.4G Linux filesystem</div></pre></td></tr></table></figure>\n<ul>\n<li>最后一步就是挂载分区了，使用sudo mount /dev/sda6 ~/Extern 将sda6新分出来的分区挂载到当前用户目录下的Extern分区中即可。</li>\n<li>df再次查看可以发现，分区已经被挂载成功了。</li>\n</ul>"},{"layout":"post","title":"（转）机器人工程师学习计划","date":"2016-09-28T10:50:00.000Z","_content":"\n*本文是转载的一篇知乎专栏上的文章，写的相当好。可惜当年上学的时候无人指点，浪费了太多的光影。*\n\n```\n作者：YY硕\n链接：https://zhuanlan.zhihu.com/p/22266788\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n### 前言\n\n很多朋友私信问我对机器人和人工智能感兴趣，该怎么展开学习。最近稍微有点空，我写写我的看法。\n\n两年前，我在知乎回答如何定义「机器人」？ - YY硕的回答中试图给机器人做出一个比较仔细的定义，我觉得机器人和人工智能最大的区别在于是否要和物理世界进行交互。今年初在另一篇知乎回答里对机器人或人工智能的研究会帮助我们更好的了解人类自己吗？ - YY硕的回答我说到传感器是和物理世界交互的基础。后来，我又在知乎回答有哪些与控制、机器人等相关的 quotes？ - YY硕的回答中提到莫拉维克悖论（Moravec's paradox），谈到了机器人学里公认的难题是在物理世界中实现类人的活动能力。\n\n把之前的回答再翻出来是为了支持以下观点：机器人学的核心问题是做好和物理世界的交互。现在主流的机器人学分支里，处理与物理世界的交互的学科分为三类：传感器和处理算法（激光雷达，多目视觉，融合算法）；多刚体系统动力学控制（工业机器人动力学控制和接触力控制）；机器人自主移动（locomotion不知道该怎么翻译，轮式、足式、飞行等移动机器人的研究）。我建议对机器人学有兴趣的同学着重在这几个问题上面。\n\n另外，根据世界第一的机器人教育机构卡耐基梅隆大学的机器人学博士的课程分类方式（http://www.ri.cmu.edu/education/COSAug2016.pdf），机器人学有四个核心领域：\n\n感知。视觉传感器、图像传感器、触觉和力传感器、惯导等。\n认知。人工智能、知识表达、规划、任务调度、机器学习等。\n行为。运动学、动力学、控制、manipulation和locomotion等。\n数学基础。最优估计、微分几何、计算几何、运筹学等。\n结合卡耐基梅隆大学的核心课程要求，我觉得我定义的机器人学核心问题算是基本没跑偏的。本文后面谈到的机器人项目都是以上述观点和课程要求为基础。\n\n一些可能有争议性的观点：\n\n1. 机器人学是富人的活动。虽然工业越来越发达，但好的开发板和电机还是非常贵。如果要下定决心学习机器人学并且做出实物，你必须找到做实物出来的资金。要么是自己花钱，要么就得找学校的机器人社团，或者找什么愿意资助年轻人学习的贵人。另外现在没有任何一本完整的书可以教你怎么造一个四旋翼空中机器人或者大狗机器人，你需要参考十几本不同的教科书，这些书不管中文版还是英文版都很贵。\n\n2. 机器人学是屠龙之术。这话是Ninebot创始人说的。虽然最近几年，平衡车、扫地机器人、多旋翼飞行器让机器人学开始进入人们的生活，但是可行的商业应用还是很少，而且已有的机器人和理论都还很难解决好与物理世界交互这件事情。所以一定要确保自己在机器人学这个道路上同时练好了能去其他行当吃饭的技能，比如编程、机械设计和硬件设计。也要做好心理准备，接受自己有可能在学会屠龙之术以后几年都造不出对社会有用的东西的事实。\n\n3. 基于上述所说的观点，如果是已经工作之后才想要学习机器人的话，可能已经太迟了，因为很可能兴趣战胜不了客观限制因素。如果作为兴趣去学习，只能学到做巡线小车和舵机机械臂什么的，可能也满足不了中二病的创造欲。\n\n个人认为机器人学是一个艰苦的道路，想要成为一个独挡一面的机器人工程师需要多年理论和实践的同步训练。理论学习和动手实践的过程还要互相排好时间表，在做某个实践项目的同时去学习最相关理论往往可以达到事半功倍的效果，但是同时那些不太相关的理论会看起来非常枯燥，因此如何妥善安排自己的实践项目也是很重要的事情。\n\n这篇文章里我计划介绍一个电子工程、机械工程和计算机专业学生从大学一年级到研究生二年级的机器人学习计划，基本是我对自己过去学习方式的一个总结。按照这个方法来学习，能够成为一个能力全面，但是稍微偏软件一点的机器人工程师。这个六年的学习计划，估算下来，全年中每天在上课和完成课程要求之外要投入学习时间6-8个小时，这些时间一方面用于阅读课程知识的英文教材，一方面用于阅读其他学科的教材，一方面用于实践项目。\n\n机器人工程师在大型项目里的定位类似于飞机系统里的总体设计师。和机械工程师、硬件工程师、软件工程师、算法工程师、控制工程师比起来，机器人工程师参与某个具体技术的时间较少，但是能够听得懂所有工程师说的话，能够作为不同模块间的协调人，带领整个团队去攻坚。当然如果机器人工程师能够在一个领域达到那个领域的工程师的优秀水平，肯定更好。\n\n由于时间仓促，再加上个人水平有限，文章中如有纰漏和错误，恭请读者指出，谢谢。如果同学还有什么想知道的内容和教材，也欢迎留言交流。\n\n<!-- more -->\n\n\n### 大一\n\n刚上大一，你的机器人生涯开始了。先看看学校的校园网能不能翻墙，不能的话自己去买个一年一百多块钱的VPN，先确保自己能上Google，不要心疼VPN的钱，这能让你在之后的职业生涯里节省上万块钱。然后去注册一个gmail账号，再注册stackoverflow账号，再注册github的账号，再注册CSDN账号，注册完登录上去逛逛，暂时先不要问为什么。\n\n英语水平一定程度上会是机器人工程师水平的限制因素，英语是同学们在大学最该努力学的一门课，而且不止要把它当成课，要当成一种技能，当成生活的一部分。当你开始努力学习一些高级的机器人知识以后，有可能会非常难以找到中文的参考资料，这个时候如果啃不下英文的资料，进步速度和眼界就会受到很大影响。因此大一的时候要多看看红宝书，看看美剧。\n\n不管是什么专业背景的同学，大学一年级一定要上好的课是微积分和线性代数。线性代数的重要性需要特别强调。一般来说，优秀的工程师和科学家在职业生涯中要学至少五次线性代数，大一学一遍、学凸优化的时候学一遍、学线性系统的时候学一遍、学机器学习的时候学一遍……如果在第一遍学的时候就看到对的书，刷到对的题，那么以后的学习会轻松很多。\n\n网上有很多对于如何学好线性代数的讨论，比如知乎问题如何理解线性代数？ - 数学学习。Matrix67大神的文章随记：我们需要怎样的数学教育？也很有启发。我个人对学习线性代数的建议是两本书，一本叫做《Linear Algebra Done Right》，另一本叫做《Linear Algebra Done Wrong》（https://www.math.brown.edu/~treil/papers/LADW/book.pdf），我比较喜欢的是Done Wrong这本书，第一它是免费的，第二只需要读前6章两百页就够了，第三它页边距很大，打印出来有很多空白做练习题。另外一个较好的教材是麻省理工公开课：线性代数。不论如何，学线性代数一定要用国外的教材，千万不要用国内的教材。啃英文书很累，但是考虑到之后还要啃更多的英文书，线性代数已经算是很入门的了，一定要啃下来，同时还要刷足够多的课后题。\n\n学完线性代数以后，一个自然而然的问题就是怎么能用计算机自己去计算矩阵的乘法、向量的乘法、向量的内积。因此引入了编程的学习。\n\n不管同学的专业是什么，一定要在大学一年级尽早开始学编程。至于用哪种语言开始学习编程，我推荐Python，比较好的教材是麻省理工学院公开课：计算机科学及编程导论，比较好的Python开发学习环境是Anacoda (http://www.continuum.io/downloads)。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。\n\n对任何人来说，Python是一把瑞士军刀，你可以用他干很多东西，比如自动回复邮件、自动收集信息。但是真要去造机器人，合适的工具并不是瑞士军刀，而是C/C++这样简单粗暴的锤子和螺丝刀般的工具。在学习Python学到一定程度的时候（比如你听说有一种叫做cython的东西），最好开始学习C，而且要强迫自己练习用C的一维数组和指针来实现矩阵的加法、乘法、求逆等操作。之所以有高级的Python或者Java（不要问我Java哪里高级了）这些语言以后我们还需要去学C，是因为机器人上常用的不是完整的电脑，而是计算量有局限的嵌入式系统，嵌入式系统开发基本只能用C或者更低级的语言。\n\n学习C我个人入门用的是清华大学出版的《C++语言程序设计》。虽然这个书标题是C++，但其实没什么太大问题。不过国内的C语言教材都有个巨大的问题是不引导学生去用Linux。近年来更好的一个教材是http://songjinshan.com/akabook/zh/index.html，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。\n\nIT行业的程序员都会争论高级语言和低级语言哪个好，Linux和Windows哪个好，而对于机器人工程师来说，从现在到可预见的未来里，C是最好的语言，Linux是最好的操作系统，这都毋庸置疑。甚至对于Linux的发行版该选哪个，我们都是很少有质疑的：Ubuntu（The leading OS for PC, tablet, phone and cloud）。原因是机器人操作系统ROS`（ROS.org | Powering the world's robots）`是基于Ubuntu开发的，因此在Ubuntu上运行最稳定。注意Ubuntu出了一个中文版叫做Kylin，个人感觉比较坑，建议大家不要装中文版。Ubuntu 作为一个开源操作系统，总是在快速迭代，2016年8月比较稳定的版本是14.04和16.04，建议同学安装14.04。\n\n当你把C学得差不多，开始要学写包含多个头文件的程序时，一定要同时学习makefile的知识。这时候要上网去搜“Makefile详解”（Makefile详解（超级好）_mingw吧）这篇文章看。\n\n我自己在大学一年级的时候还学习了HTML和Javascript，到大一结束的时候已经能够熟练用Javascript手写一些动态页面。我个人觉得HTML和Javascript也是机器人工程师必备的技术，而不只是软件工程师的玩具。这是因为web技术实际上已经渗透到了编程的方方面面，比如json开始是Javascript里的一种object定义的方式，但现在已经成为了一种很标准的数据交互、参数配置的格式。另外AJAX能够帮助初学者理解一定的网络技术原理，而网络技术也是机器人工程师必备的技能。再者，制作GUI（图形用户界面）是常规debug的办法，而近年来一个流行的趋势是用webkit嵌入程序用HTML和Javascript作为图形界面的后端，而在机器人操作系统ROS`（ROS.org | Powering the world's robots）`里，通过rosbridge可以非常方便地把机器人程序的数据传递到websocket上，这句话看不懂没关系，反正你知道学学HTML和Javascript很重要就是了。更重要的是，HTML文档背后的DOM (Document Object Model)深刻地体现了面向对象的思想。大学中的面向对象程序设计一般都讲C++，在我看来应该讲HTML和Javascript。这一点不细说了，如果同学们去学习HTML和Javascript，自然会体会到。学习HTML和Javascript比较好的资料是http://www.w3schools.com/，把网站左侧的“Learn HTML”、“Learn CSS”、“Learn Javascript”和“Learn JQuery”学完就行，别的部分还有很多花哨的技术，没有必要去学了。为了培养自己对Javascript的兴趣，可以上three.js / examples跪着看看热闹。\n\n以上介绍的这些知识点、书和资料应该在大一期间就全部看完，然后利用大一的暑假好好巩固这些知识。比如开始用HTML和Javascript做一个自己的个人主页，刷一刷编程的题目，学用Python的奇技淫巧（比方说做一个自己的个人主页）。另外还可以抽时间学学数学知识，比如开始看看代数和离散数学。我大一的时候看到了两篇文章，认识到了数学的重要性，一个是MIT的CV大牛林达华写的[转]MIT牛人解说数学体系，另一个是前Goolge研究员吴军博士写的《数学之美》（数学之美 (豆瓣)）。当时林达华还在MIT读博士，而《数学之美》还没有成书。两篇文章看完以后我感觉自己整个人对数学的认识上了一个新的层次，此后一直在注意提高自己的数学水平，几年下来觉得收益很大。在之后的介绍里我还会多次强调需要学的数学知识和对应的教材。\n\n### 大二\n\n上大二的时候，你已经会了基本的编程知识和基本的数学知识。大二这一年应该投入在嵌入式系统的学习中，同时继续拓展自己多方面的能力。学校的机器人社团，比如做Robocon，RoboMasters的团队应该在招新了，赶快去加入，有了学长学姐的指导以及同辈朋友的鞭策，应该会进步的快一点。\n\n大二应该掌握的技能：Solidworks画基本的机械图，基本的数字电路知识、数模转换，51单片机、AVR单片机、STM32单片机原理，UART、SPI、I2C、CAN等协议的原理和数据收发，STM32开发板的使用，电机转动和驱动的原理，PID的原理，调试四轮机器人底盘的移动，基本的传感器如陀螺仪、码盘、红外线、超声波的原理和读取方式，网络知识如配置IP配置路由器等，微电子焊接，金工技术。我在知乎回答如果程序员每天都浅尝辄止地学一些不同的新技术，长久以往，人会变成什么样子呢？ - YY硕的回答里谈过机器人工程师需要的技能数量是IT行业全栈工程师技能数量的三倍以上，这些技能的基础都应该在大二开始积累。\n\n如果同学们的专业是机械工程相关，那么大二的时候要深入学习solidworks做图，买机械加工手册学习各种机械的奇技淫巧。你的专业知识还不足以让你进行缜密的受力分析，不过你可以尽量多做一些机械结构出来感受它们的乐趣。\n\n如果同学们的专业是硬件、电路相关，那么大二的时候要深入学习Altium Designer做图、制板、焊板。你要从现在开始，就给自己积累一个工作记录，可以就是简单的txt文件，记录你做过所有板子的bug、解决方案、学到的原理图、PCB layout的注意事项等等。积累很多年以后，你的这个工作记录会值很多钱。\n\n学习这些技能的最好的方式，就是参加自己学校机器人社团的训练和方案设计。一般来说，学校的机器人社团招新之后会有训练和测试，让新人分组去做机器人，这个过程中如果愿意努力学，提高得会很快。如果你所在的大学是机器人比赛强校，比如西安交通大学，电子科技大学，哈尔滨工业大学，华中科技大学，东北大学等等（排名不分先后，没有提到你们学校名字的话我表示抱歉），那么你很幸运，你们学校的机器人社团有很好的积淀，有很多资源可以帮助你学习。基本上只要天天泡实验室，保证自己每天只睡6-7个小时（但还是要多去跑步、游泳保持身体健康），勤于向学长学姐请教，那么一定会提高得很快。\n\n大二阶段特别要强调的是对动手能力的培养，包括机械材料的加工、电路焊接、制作导线和接头、连接路由器、配置网络、做网线等等。机械加工的工具有螺丝刀、锯、钻、锤子、车床、铣床、钻床，进阶选手可以学一下氧焊，这个比较危险，我没尝试过；电路焊接的工具有焊机、焊锡、洗板水、松香、吸锡器；制作导线的工具有剪子、剥线钳、夹头钳、网线钳各种钳；网络配置就是连连路由器插插网线，但是Linux系统下配置网络有时会非常麻烦，一定要多积累这方面的知识，因为将来你造的机器人多半会顶着一个无线路由器跑来跑去，甚至有的机器人上各个模块自己就能组起一个小局域网。这些技能的熟练掌握需要你花很多时间去做真正能用的机器人来练手。\n\n对于该选择造一个怎么样的“真正能用的机器人”练手，最好的选择肯定是机器人比赛中的机器人。如果参加Robocon，你会跟着学长学姐们学着造有人那么高的巨大机械；如果参加RoboMasters，你会学着造比汽车还要灵活的机器人以及快速发弹的机构。其他一些小型的比赛比如飞思卡尔智能车，也是很好的训练，因为飞思卡尔智能车已经发展得很成熟，参加这个比赛的参赛资料就够学一阵子的，学完以后能够获得比较多的机器人技能。\n\n如果没有太多学校机器人社团的资源，同学们还有一些小型的比赛比如挑战杯、大创比赛等等可以选择，以三五个人的小团队参与这些比赛。如果同学所在的学校连这些比赛都不组织大家参与，那就只好自己花钱了。国内开源机器人社区有很多资源可以利用来学习，比如自己买Arduino STEM educational Robot kits Building Platform的各种开发套件做简单的机器人。Arduino的开发环境可能有些人不喜欢，因为它对硬件做了一级封装，如果更希望接触到单片机的本质，可以自己买STM32开发板学习。俗话说，没有什么嵌入式系统是一块STM32实现不了的，如果有，就用两块。STM32是ARM Cortex‑M家族中最为广泛应用的一款单片机，在网上也有很多的教材和开发板可供选择。在国内著名的电子论坛STM32/8 分论坛帖子清单 (amoBBS 阿莫电子论坛)上，有很多参考资料，有问题也可以在这里和大家讨论学习。\n\n如果你很想参加机器人比赛，身边也恰好有一些志同道合的小伙伴，但是学校不支持。没关系，来找我，我尽量通过大疆的关系说服你们学校支持你们参加RoboMasters。\n\n虽然你是以机器人比赛为主线在探索机器人技术，但是要时刻记得，机器人比赛给你的理论方面的训练很差，还会让你养成一些坏习惯，比如凡事都希望用一些糙猛快的办法来解决。由于通常整个团队都没有太多的项目管理经验，到比赛前一段时间才会加紧功夫去做机器人，很多时候就会用“山寨”的办法去处理机器人的故障。比如说某个承重结构用久了会弯，为了赶比赛的进度，就拿锤子敲直了、再加一条辅助的结构在旁边继续用，而没有细致地去做建模、受力分析，思考是什么原因导致承重结构会变形。再比如说调PID参数就是生调乱改，而没有基于机器人的动力学模型去估测参数的大概范围。\n\n大二的暑假，有可能你跟着学校的机器人队参加了一些机器人比赛。这是一个反思总结的好时机，为什么机器人队取得了这样那样的成绩？整个团队怎样才能更有效率？明年如何继续招新？暑假要把时间花在技术积累上面，这个时候可以回头思考思考之前准备比赛时用糙猛快的办法解决的问题如何能够细致地去解决。\n\n如果大二的暑假没有参加机器人比赛，可以做一个舵机机器人，比如6条腿的蜘蛛，比如码垛机器人。舵机是机器人工程师的好朋友，一定要好好掌握。\n\n另外你其他方面的能力也不能落下。大二结束的时候，你的Linux应该用的很熟练了，除了makefile，你也用起了cmake。你也应该开始理解Github存在的意义，因为你已经上去读了很多别人的代码，你也把自己的一些课程设计和小项目放在了Github上面。另外大二基本上了本专业一些比较难的基础课程，比如自动控制原理、机器学习、概率统计、材料和力学等课程，同学们会看到这些课程里又用到了线性代数和微积分的知识，以及建模的知识。这时候可以把大一的物理、线性代数和微积分再翻出来看看。\n\n同学的学校应该给大二到大三的学生有开设面向对象的程序设计，一般用Java或C++教授。在面向对象的程序课里面，一定要积累3000行左右的代码的开发经验。经典的面向对象程序设计的练习通常是写游戏，比如俄罗斯方块，吃豆人等等，一定要自己能够做到完全手写一个完整的项目出来。\n\n另外你可以开始学习Matlab当中的神器Simulink了。在大二这一年的学习中，你可能在不少课程里多多少少用到了Matlab。假设你已经在我的推荐下喜欢上了Python，你可能会觉得Matlab的计算工具没有比Python强多少；假设你自己在别人的推荐下喜欢上了mathematica（Mathematica 到底有多厉害？ - Wolfram Mathematica），你可能会觉得和Mathematica这种神一样的语言比起来，Matlab弱爆了。但是要注意的是，Matlab最强大的工具是Simulink，通过它你几乎可以仿真一切的物理系统和控制系统。我建议同学可以通过Simulink实现一个倒立摆，然后理解Matlab的强大之处。对此我强烈推荐一个很好的教材（http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（Control of an Inverted Pendulum on a Cart）的文章。阅读并实现了这两篇文章里的内容，同学应该会对倒立摆有了比较深刻的认识。倒立摆是机器人学中一个非常重要的模型，因为火箭、导弹、双足机器人、四足机器人，基本都是倒立摆的变形。你自己实现出来的simulink模型一定要存好，以后可能还会再拿出来仔细看。\n\n如果你按照我之前说的方法探索了一些HTML和Javascript的技术，那么JQuery，bootstrap，AngularJS你已经多多少少知道是怎么回事了。web后端的技术，比如PHP和MySQL，也可以了解一下，LAMP要学会怎么配置。如果有同学找你帮忙写小网站，尽量去帮个忙，帮别人做网站是提高自己系统编程能力的好练习。在做网站的过程中你可能还会顺便学一学如何用Photoshop和Illustrator让网站显得更漂亮。这些技能有最好，没空学也没关系。\n\n### 大三\n\n大三开始的时候，你可以在学校的机器人队里担任重要角色了，或者能够带领一个小团队参加小型的机器人比赛。你在系里甚至院里都小有名气了，可能有的人叫你大神，有的人觉得你技术还不错。但是一定要记得你现在的水平放到别的地方应该不算什么。每年我都往大疆的RoboMasters夏令营招进100个和你现在的水平相当的同学。\n\n大三一定要培养出自己一个人独立造出一个完整机器人的能力，比如一个Robocon水平的机器人，或者一个RoboMasters的战车，或者一个四旋翼飞行器。\n\nRobocon水平的机器人，涉及大量的机械设计，单片机开发，电机驱动的开发，码盘和超声波等传感器的读取，底盘运动学的计算，PID调试，任务调度逻辑的调试，舵机控制。RoboMasters的战车的机械部分简单一些，但是还需要进行云台的控制、发弹系统的控制、功率控制等方面的知识，另外你也可以不搞这些部分，学习学习视觉识别和自动打击，那么就要开始研究OpenCV（OpenCV | OpenCV）了。\n\n四旋翼飞行器的机械部分最简单，但是算法比较复杂。对于大三学生来说，从零开始一步到位写一个稳定的飞控比较困难，因为飞控里面有很多细小的知识点要注意。目前我没有发现什么比较好的书籍推荐，已有的一些关于四旋翼系统的书要么太浅（上来就教你焊电路），要么太深（上来就教你state estimation），听说 @Liu Top的exbot小组在写一个教材，我是非常期待的。学习四旋翼飞行器有下面几个步骤：\n\n第一步：自己调一个小四轴飞起来\n现在开源社区的人言必pixhawk，其实我觉得从学习的角度来说，pixhawk太贵，而且不适合学习，我比较推荐的是 首页-第七实验室 这家淘宝店卖的STM32F405飞控，买回来以后自己再随便买个机架（比如大疆F450）、接收机和遥控，就能按照飞控板附带的学习资料、调试软件飞起来。\n\n第二步：看硬件图、读代码\nchiplab7的飞控板附带一大堆学习资料，对加速度计、陀螺和磁感计都有很仔细的解释，硬件链路图也很详细。chiplab7淘宝掌柜的又很认真负责，我学用的时候，发现代码有bug和看不懂的地方，都可以直接找掌柜问。\n\n看完代码以后，对一个飞控系统的基本模块：姿态解算、控制解算、混控输出、遥控器处理、嵌入式处理就很明白了。然而这里面有很多技术是需要另外学习的。除了基本的嵌入式编程以外，还有要把大二大三学的信号处理方面的知识再捡起来看看。因为飞行器在空中有振动，会让加速度计产生噪声，为了把这些噪声去除掉，需要对加速度计给出的信号做低通滤波处理，如何选择滤波器的参数呢？如果滤波滤得太狠，延迟就会比较大，对控制的表现会有影响；如果滤波滤得不够，可能会有一些低频的噪声偶尔会出现，导致加速度计的观测不能用。另外最重要的是要理解姿态解算和控制解算这两块知识。chiplab7的飞控板的代码采用的是最简单的互补滤波算法做为姿态解算模块，然后控制解算是对欧拉角的三个角度做闭环PID控制，基本都是基础的基础了。\n\n第三步：小修小改加深理解\nchiplab7的飞控是靠气压计定高的，飞行效果非常奔放。这时候可以淘宝买个20块钱的超声波模块，然后自己写个高度环去稳定飞控的定高表现。\n\n我觉得这个过程至关重要，因为高度控制相对来说是个比较直观理解PID控制的方式，而且chiplab7的飞控加高度控制非常好加。工作量不大，因为改善效果很显著，所以可以让人很有成就感，加深继续学习的乐趣。\n\n第四步：理解核心的数学和控制知识\n这一部分大三是肯定来不及学的，但是我还是在这里列出来，因为这些知识你之后都需要慢慢学，我也会在之后不断重复提到这些知识点。\n姿态解算和控制解算涉及的知识有：\n1. 刚体姿态的表示、运动学方程和动力学方程。主要是对牛顿-欧拉方程的认识和理解、刚体姿态的欧拉角表示法、姿态与角速度的关系等等。\n这部分说复杂不复杂，说简单也不简单，我同样是没有找到一本完整的书全都介绍过的，是学了好几个不同的书和论文以后搞明白的。现在看起来是从维基百科入手比较靠谱。\n2. 自动控制原理。讲PID的书和文章就多了去了，没有太多复杂的书。\n3. 线性估计基本原理。其实就是互补滤波：Reading a IMU Without Kalman: The Complementary Filter 。拿这个关键词百度各种搜就会了。\n第五步：重头开始造轮子\n知乎著名网友vczh曾经说过，学习要抱着勇于造轮子的心态才能进步。所以在熟悉了别人飞控基础上，可以自己重头造一个飞控的轮子。可以自己从芯片开始重新画一个飞控板，读读STM32的芯片手册、读读各种传感器的芯片手册，自己手画一个飞控的原理图、做PCB layout、制板自己焊元件，全套花不了1000块钱，能够加深很多对硬件的理解。这一部分如果大三没空，也可以不搞了。\n\n制造整个机器人的过程中要特别重视文档的积累。在你大三末期，你可能随着学校的机器人队备战比赛，你可能主力负责一台机器人。你应该自己列一个excel表格，把机器人用了几颗螺丝，几根导线，每个零件的规格是什么，都列出来。这个表格一方面可以用来帮助团队管理机器人的物料，一方面也是你自己的经验技术积累，将来你做的其他机器人可能多多少少都是Robocon、RoboMasters机器人的变形。\n\n另一个积累是建一个自己的buglist，buglist包括什么呢，可以像冷大这样：做控制、机器人等算法工程师是怎样一种体验？ - 冷哲的回答，就简单把一些自己的发生过的问题和最后的解决办法罗列下来。比如说“杜邦线接插位不稳固容易脱开，接好后应该用电工胶布再裹一圈”，“外发给淘宝加工的机械图纸，要特别注意和加工商沟通有没有漏掉一些细节，如沉头螺丝孔，关键的倒角”等等。你也可以帮其他机器人的问题也做这样的记录。buglist可以就是一个简单的文本文件，如果你一直往里面积累自己工作中的记录，等你将来工作了，这个文件可能会值很多钱。\n\n大三的时候学校应该会开设软件工程的课程。不管你是不是这个专业，上不上这门课，都应该主动去听一听，甚至跟着课程的设计作业一起做一做。软件工程我觉得是机器人工程师必须具备的意识，因为一个机器人系统里涉及大量的硬件系统和软件功能，软件的部分往往还会涉及不同的语言、不同的编译环境、不同的开发工具链。几个人合作的话，大家的专业背景、编程习惯都不相同，这就导致不同的代码和模块之间的协议沟通非常复杂，必须尽早用UML和其他软件工程的工具帮助团队理解和互相沟通。\n\n大三的时候学校应该还会开设操作系统原理和嵌入式系统原理的课程，而大二的时候讲过计算机组成原理（所谓的微机原理）。从大三开始同学需要开始体会实时操作系统和非实时操作系统的区别、原理以及使用时需要注意的地方。这是一个比较杂的知识点，我目前没有找到很好的教材去介绍。在STM32上，有freeRTOS，uCOS，Vxworks这么几种实时操作系统；Linux是一种非实时操作系统，但是可以通过打补丁变成实时操作系统。这些操作系统的细节在机器人开发中都会多多少少被涉及到，同学们可以随时上Google和CSDN去查大神们的介绍。\n\n另外特别重要的一点是机器人系统里的嵌入式平台都有烧坏的可能性，有可能在某个嵌入式Linux平台上面辛辛苦苦写了一个多月代码，这个平台突然烧坏了，代码也就丢了。因此你的机器人如果有嵌入式Linux系统在里面，一定要尽早顶起来路由器，代码定时提交SVN或者git。\n\n大三的暑假你可能会作为学校机器人队的主力去参赛了。备战比赛和参赛是一件磨练心性的事情。我在学生时代体会过和胜利擦肩而过的痛苦，体会过没机会再来一年的遗憾；也在负责大疆RoboMasters比赛的过程中被那些痛苦和遗憾的学生当做发泄的对象，非常有感触。我觉得参加机器人比赛，很努力，然后失败了，是一件让人快速成长的事情。同学如果有机会，一定应该参加至少一届机器人比赛。\n\n大三的暑假你也可以选择来参加大疆的RoboMasters夏令营，关于夏令营大家可以看这个知乎问答了解更多：参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新。每年我们都在全国范围内寻找有一定技术基础的学生，让他们一起分组做一个自动机器人的挑战。这个夏令营，作为组织负责人，不谦虚地说，我觉得应该是全世界范围内最好的技术类夏令营。\n\n大三的暑假有一件很重要的事情就是思考自己大四应该干什么。一般来说，你现在的能力保本校研究生肯定没有问题，当然你也可以选择考其他学校的研究生或者出国留学。虽然说你现在能力已经很全面了，但是你还需要2-3年的时间全面提升自己更多的能力，才能迈向卓越之路。不管是出国还是保研，最重要的目的是给自己争取到未来2-3年能够在一个优秀的环境中安心提升自己，有比较好的学习资源，能够参与到一些不错的项目中去。可能其他有些行当，出国留学始终是比在国内待着更好的选择，但是机器人行业并不是这样。我们国家这两年在机器人方面提高也很快，而且我们国家现在比较有钱。就像我开始说的那样，机器人是富人的活动，现在你在国内也能找到一些很有钱的实验室可以造比较牛逼的机器人。另外国外很多比较强的机器人公司也都在做比较敏感的军方项目，去找实习可能比较受限制。\n\n出国去学机器人学方面的知识你有很多不错的选择，比如世界第一的机器人研究院卡耐基梅隆大学，或者麻省理工学院的CSAIL实验室。北美传统计算机四大名校（麻省理工学院，卡耐基梅隆大学，斯坦福大学，加州大学伯克利分校）里，除了斯坦福大学热火朝天在搞人工智能以外，其他几个学校的机器人研究都很不错。除了四大名校，你还有很多其他的选择，就像我开始说的那样，机器人是富人的活动，如果想接触到最好的机器人资源，你要选择有钱的实验室，而不是有名的实验室。\n\n另外你还需要在大三的尾巴上选定自己将来的细分研究方向，而且开始往这个方向深挖，也就是我在文章开始提到的感知、认知、行为几个方向。当然同时你也不能放松其他方面的知识，尤其是数学基础。我在大三的暑假专门找数学系的同学给我开了个数学小讲座，学习了一点抽象代数的知识，对我后来学习密码学帮助很大。同时我也读了一些拓扑方面的教材（有一本很神奇的书叫做Topopogy Without Tears http://www.topologywithouttears.net/），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。\n\n大三阶段的机器人工程师该学什么基础数学是众说纷纭的，在我看来，你要基本掌握“群是什么”，能够用代数的眼光去证明\"det(AB) = det(A)det(B)\"，还要能理解“用一张纸就可以变出克莱因瓶”（当然是在四维空间里）。另外，你这个时候也要能够意识到自己需要再学一遍线性代数。\n\n### 大四\n\n大四开始了，你可以开始深挖自己的研究方向，同时也要开始学一些高级一点的通用技术和理论，这时候你和一般的机械、电子、计算机学生就不太一样了，你虽然也在狂编程，但也在狂学习物理和数学。通用技术包括ROS，simulink，gazebo和Vrep等工具。通用理论包括，再学一遍线性代数，学学凸优化、数值计算、旋转表示法等方面的知识。这些知识你在大四仅仅只能开一个头，因为你的大四要实习、毕业、考研、毕设，你会非常地忙。有些人会在大四进实验室和老师发论文，我个人觉得发论文这件事没必要操之过急。你的整个大学期间应该用在广泛涉猎各种各样的知识上面，而不是深入某一个细小的研究问题。\n\n大四可以开始读一些著名入门书籍，我把这些书不分先后地列出来，你没有必要全部去读，而且每本书先读前几章就够了，能读多少尽量读多少。\n\n1. 概率机器人学，https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623\n\n2. 凸优化，https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf\n\n3. 线性系统理论，https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579\n\n4. Multiple View Geometry in Computer Vision，Multiple View Geometry in Computer Vision\n\n5. 线性估计，https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642\n\n6. 《机器学习》，周志华老师的书。\n\n7. An Invitation to 3-D Vision，https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf\n\n8. Modern Control Systems，https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580\n\n9. Rigid Body Dynamics，http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。\n\n10. Feedback Systems: An Introduction for Scientists and Engineers，FBSwiki\n\n就像我开始说的那样，这些书，大部分特别贵，还好有一些业界良心的作者放出了他们书的电子版。当然你也可以去一些名字都不能说的网站去找影印版。\n\n在读上面这些书的时候，matlab，python都要放在手边，然后把书里面的知识尽量实践出来。很多教科书里都会在章节后面的习题里放一些写明是用matlab做的习题，要尽量多做一些这样的题。\n\n你可能早就听说了ROS的大名，但是最好不要在大四之前去碰它。因为ROS用了很多操作系统和网络的底层技术。我在知乎回答高手可以谈谈ROS机器人操作平台开发的一些经验吗？ - YY硕的回答里有简单的介绍。ROS的设计目标是把机器人的控制和传感器处理的软件和它的硬件隔离开，用上ROS以后，你可以方便地用到很多能直接跑的软件代码。但是ROS从入门到精通需要至少一年以上的时间，你必须不断地用，不断地尝试新的代码和硬件，才能对它熟悉起来。\n\nROS的可视化工具Rviz里面对于机器人旋转的表示用的是四元数，而在你之前研究四旋翼飞行器时，里面的代码表示旋转用的是欧拉角，做姿态解算用的可能是四元数。这个时候要开始有意识地去学习旋转表示法之间的区别和联系。\n\n要重视大四期间的实习和毕业设计。很多大四的学生毕业设计都会非常颓地做一下，我觉得是不好的。要把做毕业设计的过程看做一个正式的项目。这个项目除了做好技术方面的工作，也要做好展示方面的工作。中国工程师的一大特点是，不会表达自己，可能做的东西水平很高，但是做出PPT就会犯字体花哨不正式、一页上面字太多，图文没有联系等表达上的问题。通过PPT介绍、展示自己的成果在工程师的职业生涯的任何一个阶段都非常重要，它甚至也一定程度上限制了机器人工程师能够达到的高度。只有能够把自己的成果清晰地表达给自己的团队，才能获得其他人的反馈、通过沟通提高团队的整体凝聚力和知识水平，这样自己在团队能够获得更多的认可，有助于团队整体工作效率的提高。我每年去参加几次学术会议，都在会议上感觉到一些中国的科研人员走到国际上以后，演讲能力很差就会导致他们的科研成果不受重视。当然其他国家的科研人员也是这样。\n\n为了写出美观的技术报告和毕业论文，你可以开始学习Latex。Latex作为国际国内第一写作神器，学习资料在网上有很多。Latex的学习和使用同样也是需要不断地熟能生巧，多写多练就熟悉了。写毕业论文有个问题是怎么做出精美的矢量图，我推荐Draw Freely | Inkscape，一个比Illustrator更轻量化、但是有些功能反而更强大的免费软件。\n\n对于那些想申请出国留学的同学，你要做一个自己个人的成果展示，用网页的形式呈现比较好。把自己Github链接（如果你按我说的，大学第一天就申请Github账号，现在已经是一个三年的老油条了）、做过的机器人视频、写过的技术报告和文章（最好是英文的）放在上面。\n\n关于毕业设计的选题，我推荐这么几个：\n\n1. 手写双目视觉里程计。涉及到图像处理、特征匹配、位置解算、空间变换等等。\n\n2. 手写四旋翼飞行器基于GPS的轨迹规划。涉及到深挖四旋翼飞行器的运动原理、IMU原理、轨迹生成和优化等。\n\n3. 造一个被推了也不会倒的双足舵机机器人。涉及到舵机控制、倒立摆建模、动力学分析、PID控制、IMU原理等。\n\n4. 深度学习训练一个小车追人跑。涉及到深度学习工具包使用、数据集采集、数据集分析、小车控制等。\n\n5. 机械臂给人端茶倒水。这个相对来说土豪一点，因为能直接拿来用的机械臂都很贵，这个要看实验室有没有条件了。涉及到多自由度机械臂原理的学习、工具包的使用、轨迹规划等等。\n\n这几个项目要做好，都要持续投入三个月以上的时间以及一定的资金，每一个都是理论多于实践。当然同学们自己也可以自己选择自己的毕业设计题目，但是最好还是选做出来能跑能飞的东西，同时避免选择需要花大量时间去拧螺丝、焊板子的题目，尽量买现成的电机、开发板、3D打印结构，大四要多给自己留时间去看书和写代码。\n\n大四到研究生之前的暑假，最好去一些比较不错的机器人公司实习一下，比如说大疆。当然你也可以继续做机器人比赛，比如RoboMasters和大疆的飞行器比赛。\n\n### 研究生一年级\n\n研究生的时候，你的目标比较清晰了，就是做一种机器人至少两年时间，并从中发掘出可以发表论文的知识点。上面我给出的书单里面，你要开始精读里面的几本。\n\n如果做机器人视觉定位、传感器融合方面的研究，1、4、5、7四本书一定要精读。\n\n如果做控制系统的研究，3、8、9、10一定要精读。\n\n如果做规划算法的研究，那么还要读其他偏CS一些的书，比如讲A* search，random forest，图论方面知识的教材。由于我在这方面造诣不深，就不托大了。\n\n如果学习随机系统的控制和最优控制，除了1、2、3，还要读一本神书Stochastic models estimation and control（https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）。\n\n如果研究机器人视觉定位，几种常用的定位算法：PTAM（Parallel Tracking and Mapping for Small AR Workspaces (PTAM)），ROS的标配VO（viso2_ros - ROS Wiki），SVO（GitHub - uzh-rpg/rpg_svo: Semi-direct Visual Odometry），LSD-SLAM（http://vision.in.tum.de/research/vslam/lsdslam）ORB-SLAM（GitHub - raulmur/ORB_SLAM2: Real-Time SLAM for Monocular, Stereo and RGB-D Cameras, with Loop Detection and Relocalization Capabilities），都必须自己学习之后全部跑一遍。只会用OpenCV的函数和这些工具包并不能说明你会视觉定位，必须要能自己手写出一个能用的才算。国内有一个很厉害的SLAM专家叫高翔，他的博客要关注一下：机器人 - 标签。由于SLAM这两年很火，研究的人很多，所以网上可以参考的资料也很多，比如https://github.com/hcdth011/ROS-Hydro-SLAM，就在ROS上实现了几种定位算法的对比。\n\n我现在非常不建议同学们选择从四旋翼飞行器的动力学控制里找问题作为研究课题。因为四旋翼飞行器的特点已经被研究透了。目前国际上对多旋翼飞行器的研究主要集中在造一些奇葩形状的飞行器，以及给多旋翼飞行器上安装一个机械臂去做力控制，这样做就对多旋翼飞行器控制的动力学造成了一些影响。因此需要同学对动力学和多自由度机械臂控制有比较深的认识。\n\n自动导航和驾驶是这两年的热点，一方面汽车的自动化是大势所趋，另一方面多旋翼飞行器异军突起，产生了很多对自动飞行的需求。除了机器人视觉定位算法以外，同学还需要学习其他的传感器，以及这些传感器与视觉定位算法怎么融合。这里面有很多坑，比如计算量的问题，怎么保证融合算法不崩，怎么处理传感器的延时等等，都需要同学结合自己的项目去踩，坑踩得多了才能成长。如果大家想找一个多旋翼飞行器平台研究自动导航，我推荐大疆的M100，我已经在知乎回答RoboMasters2015夏令营是怎样的？ - YY硕的回答里吹过一波M100，前面说过的今年夏令营的知乎回答参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新里也有人帮我吹了一波。\n\n一些大学里学过的知识点，是必须结合研究生期间的项目的需求弄得很清楚的，比如三大变换（傅里叶变换，拉普拉斯变换，Z变换），旋转表示法（欧拉角、四元数、旋转矩阵），数值计算怎么防止矩阵出现数值问题等等。除了自己的项目，还需要把凸优化、卡尔曼滤波还有多自由度机械臂的控制学习一下。这三个领域的知识，是任何一种机器人都会用的到比较难的知识。\n\n凸优化和凸优化的各种变形是非常重要的知识，因为各行各业里的研究问题，多半是会建立一个优化问题去解决的。上面提到的《Convex Optimization》https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf，也是一本神书，同学们一定要认真读一读。Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient descend，barrier method等等。另外现在主流的SLAM算法，后端都是通过一种叫做g2o的优化算法来出效果的。而且g2o能够整合bundle adjustment 和structure-from-motion这两大计算机视觉里的关键问题，可以说是一种很好的计算思想了，非常有必要学习一下g2o。\n\n卡尔曼滤波在上面书单里的1和3都有提到，同时在神书Stochastic models estimation and control（https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。\n\n多自由度的机械臂的难点在于机械臂的运动学正反解、运动学控制和动力学控制，基本是一个建模分析和数值算法实现的问题。如果你所在的学校没有一个财力雄厚的机器人实验室的话，你基本上没有机会接触到多自由度的机械臂。这时候之前学到的Simulink和就要学的Gazebo就派上用场了，你可以用Simscape里面的刚体搭一个多自由度机械臂，然后通过Simulink仿真去学习机械臂的控制；也可以用Gazebo的URDF语言写一个机械臂，然后通过Gazebo和ROS的接口去控制机械臂；也可以用ROS里面的著名工具包MoveIt! Motion Planning Framework，不过MoveIt的问题是，他只能仿真运动学，而不能仿真动力学。工业领域对多自由度的机械臂控制通常用一个叫做D-H表示法的建模工具（Denavit），这个东西我并不太会。我只会向同学们推荐我导师的著作《A mathematical introduction to robotic manipulation》（http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf）。\n\n有一个非常神奇的事实：《A mathematical introduction to robotic manipulation》这本机械臂控制领域的著名教材的第二章和计算机视觉领域的著名教材《An Invitation to 3-D Vision》的第二章基本是一样的，都在讲旋转表示法。这是因为所有的旋转表示法都可以归纳为一种优雅的李群结构：SO(3)群。而计算机视觉和机械臂控制都涉及到理解刚体的旋转，事实上用计算系统去观测和控制所有的刚体构成的系统，理解旋转都是很关键的问题。旋转表示法应该作为研究生阶段的一个重要学习的知识点。\n\n李群和李代数是刚体旋转表示背后的数学理论，如果想要深挖一些，可以看这篇文章An elementary introduction to groups and representations的前50页（http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf）。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。\n\n研究生阶段还要培养的一个能力是借助各种工具仿真机器人系统的能力。显然地，很多机器人系统真的造出来的话造价昂贵，需要在实际制造之前写一个比较真实的仿真系统出来测试算法。我觉得做仿真系统的能力直接衡量了机器人工程师的技术水平。当你开始要搭一个仿真系统的时候，第一步是通过欧拉方程和牛顿方程确定刚体的运动特点，甚至要自己写刚体二阶微分方程；第二步是确定刚体之间的互联关系，设计不同类型的关节，如果有软性连接需要加入弹簧阻尼模型；第三步是确定被仿真的刚体系统会不会和外界产生碰撞或者其他形式的力，如果有的话，需要设计合适的接触力和摩擦力仿真的模型。多旋翼飞行器的仿真是很简单的，不需要考虑什么接触力。但是多自由度机械臂基本都需要仿真接触力，不和物理世界去交互的机械臂只有很小的实用意义。而能够自行运动locomotion系统，比如双足、多足机器人，则涉及到更多的接触力，多到接触力都会影响仿真系统的数值稳定性。搭建一个仿真系统需要很强的系统建模能力和数值分析的能力，虽然Simulink、Gazebo、Vrep提供了不同程度的工具简化你的工作，但是要让仿真系统能够稳定运行，必须要能深入其中的细节。有些看起来很高大上的仿真工具，比如Nvida的PhysX，在仿真的时候是忽略掉科里奥利力的，如果不理解仿真的本质，可能就会忽略这一个重要的缺陷。\n\n### 研究生二年级\n\n你的学习计划接近尾声。现在你已经进入了一个很好的状态：看到一个机器人，能够很果断地分析出它用了什么传感器、执行器、计算平台大概是什么量级，他的执行机构能够承受多少力量。看到一个新的算法，能够大约判断清楚它的执行流程，在什么环节做了优化。看到一个新的没学过的知识，能够分析出它和你以前学过的什么知识有联系，你还需要再学什么才能弄明白这个知识点。\n\n研究生二年级要深化第一年学到的那些技术和知识，要做到完整地读过四五本书，五十篇以上的论文。你已经积累了几万行代码的经验，也能熟练地谈论谁家的电机回差小，谁家的电机线性程度好。\n\n你这个时候可以去写作一些论文，也可以开始学习一些更高级的技术和工具，比如用FPGA和GPU优化算法、魔改Linux内核、玩玩液压系统、了解更多机器学习的知识比如强化学习等等。你也可以从计算机图形学或者计算力学里面找到一些帮助你更好进行机器人仿真和系统分析的工具。由于你懂很多机器人方面的知识，你可以给学校的机器人队做指导，或者带队参加一些比较有挑战性的机器人比赛。\n\n写到这里，我就不可能给出很多不同领域的指导了，因为随着学习的进一步深化，我自己熟悉的领域也在收缩。我只能对几个领域给出我的意见。\n\n对视觉定位和传感器融合来说，SLAM急需新的突破，目前通过几何约束去实现loop closure看起来已经走入了死路，没法有更多的发展了，下一步可行的方向是与深度学习进行结合。具体的一些介绍可以阅读行业中大牛的一篇文章http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie Shen的工作。\n\n对于多自由度机械手和机器人的locomotion来说，这里面还有非常多可以探索的研究问题。我前面提过接触力和摩擦力很难仿真，大神告诉我现在没有任何一种工具和理论能把接触力和摩擦力正确仿真出来，因此如何在机器人系统里妥善处理对这些力的控制，就是很难的问题了。现在业界的一个前沿发展方向，也是利用机器学习技术来帮助机器人学会处理这些外力，不过人类目前最优秀的多自由度机器人系统，Berkeley的Brett机器人，叠几块积木就要用十分钟（New ‘deep learning’ technique enables robot mastery of skills via trial and error），显然还有很多提升的空间。这方面的问题同学可以关注知乎大神@戴泓楷@周佳骥。\n\n最后我想再强调一遍表达能力的重要性。你可以从自己带的课程和机器人队入手，把自己这几年来学过的知识做成PPT讲给学生们听，然后让他们给你反馈。多做这样的练习，提升自己做演讲的能力，这将来会让你受益匪浅。\n\n研究生二年级之后，你可以准备进机器人公司工作了，也可以根据你自己感兴趣的研究方向申请博士接着努力。由于你已经掌握了广博的知识和技能，你的职业生涯将会大有作为。\n\n结束语\n\n我从2008年展开自己的机器人生涯。那一年波士顿动力刚刚发布他们的大狗机器人，Python还是很小众的语言，Ubuntu 8.04还很不稳定，Chrome还没有多少人知道。在之后的几年中我目击了深度神经网络的复兴，看到波士顿动力的机器人日渐强大，经历了ROS的起源和繁荣，帮助了大疆的崛起，深深为这个产业的未来感到激动。我希望这篇文章能够帮助更多的年轻人进入机器人学的海洋，为未来机器人学的继续发展贡献力量。\n","source":"_posts/2016/2016-09-28-（转）机器人工程师学习计划.md","raw":"---\nlayout: \"post\"\ntitle: \"（转）机器人工程师学习计划\"\ndate: \"2016-09-28 18:50\"\n---\n\n*本文是转载的一篇知乎专栏上的文章，写的相当好。可惜当年上学的时候无人指点，浪费了太多的光影。*\n\n```\n作者：YY硕\n链接：https://zhuanlan.zhihu.com/p/22266788\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n### 前言\n\n很多朋友私信问我对机器人和人工智能感兴趣，该怎么展开学习。最近稍微有点空，我写写我的看法。\n\n两年前，我在知乎回答如何定义「机器人」？ - YY硕的回答中试图给机器人做出一个比较仔细的定义，我觉得机器人和人工智能最大的区别在于是否要和物理世界进行交互。今年初在另一篇知乎回答里对机器人或人工智能的研究会帮助我们更好的了解人类自己吗？ - YY硕的回答我说到传感器是和物理世界交互的基础。后来，我又在知乎回答有哪些与控制、机器人等相关的 quotes？ - YY硕的回答中提到莫拉维克悖论（Moravec's paradox），谈到了机器人学里公认的难题是在物理世界中实现类人的活动能力。\n\n把之前的回答再翻出来是为了支持以下观点：机器人学的核心问题是做好和物理世界的交互。现在主流的机器人学分支里，处理与物理世界的交互的学科分为三类：传感器和处理算法（激光雷达，多目视觉，融合算法）；多刚体系统动力学控制（工业机器人动力学控制和接触力控制）；机器人自主移动（locomotion不知道该怎么翻译，轮式、足式、飞行等移动机器人的研究）。我建议对机器人学有兴趣的同学着重在这几个问题上面。\n\n另外，根据世界第一的机器人教育机构卡耐基梅隆大学的机器人学博士的课程分类方式（http://www.ri.cmu.edu/education/COSAug2016.pdf），机器人学有四个核心领域：\n\n感知。视觉传感器、图像传感器、触觉和力传感器、惯导等。\n认知。人工智能、知识表达、规划、任务调度、机器学习等。\n行为。运动学、动力学、控制、manipulation和locomotion等。\n数学基础。最优估计、微分几何、计算几何、运筹学等。\n结合卡耐基梅隆大学的核心课程要求，我觉得我定义的机器人学核心问题算是基本没跑偏的。本文后面谈到的机器人项目都是以上述观点和课程要求为基础。\n\n一些可能有争议性的观点：\n\n1. 机器人学是富人的活动。虽然工业越来越发达，但好的开发板和电机还是非常贵。如果要下定决心学习机器人学并且做出实物，你必须找到做实物出来的资金。要么是自己花钱，要么就得找学校的机器人社团，或者找什么愿意资助年轻人学习的贵人。另外现在没有任何一本完整的书可以教你怎么造一个四旋翼空中机器人或者大狗机器人，你需要参考十几本不同的教科书，这些书不管中文版还是英文版都很贵。\n\n2. 机器人学是屠龙之术。这话是Ninebot创始人说的。虽然最近几年，平衡车、扫地机器人、多旋翼飞行器让机器人学开始进入人们的生活，但是可行的商业应用还是很少，而且已有的机器人和理论都还很难解决好与物理世界交互这件事情。所以一定要确保自己在机器人学这个道路上同时练好了能去其他行当吃饭的技能，比如编程、机械设计和硬件设计。也要做好心理准备，接受自己有可能在学会屠龙之术以后几年都造不出对社会有用的东西的事实。\n\n3. 基于上述所说的观点，如果是已经工作之后才想要学习机器人的话，可能已经太迟了，因为很可能兴趣战胜不了客观限制因素。如果作为兴趣去学习，只能学到做巡线小车和舵机机械臂什么的，可能也满足不了中二病的创造欲。\n\n个人认为机器人学是一个艰苦的道路，想要成为一个独挡一面的机器人工程师需要多年理论和实践的同步训练。理论学习和动手实践的过程还要互相排好时间表，在做某个实践项目的同时去学习最相关理论往往可以达到事半功倍的效果，但是同时那些不太相关的理论会看起来非常枯燥，因此如何妥善安排自己的实践项目也是很重要的事情。\n\n这篇文章里我计划介绍一个电子工程、机械工程和计算机专业学生从大学一年级到研究生二年级的机器人学习计划，基本是我对自己过去学习方式的一个总结。按照这个方法来学习，能够成为一个能力全面，但是稍微偏软件一点的机器人工程师。这个六年的学习计划，估算下来，全年中每天在上课和完成课程要求之外要投入学习时间6-8个小时，这些时间一方面用于阅读课程知识的英文教材，一方面用于阅读其他学科的教材，一方面用于实践项目。\n\n机器人工程师在大型项目里的定位类似于飞机系统里的总体设计师。和机械工程师、硬件工程师、软件工程师、算法工程师、控制工程师比起来，机器人工程师参与某个具体技术的时间较少，但是能够听得懂所有工程师说的话，能够作为不同模块间的协调人，带领整个团队去攻坚。当然如果机器人工程师能够在一个领域达到那个领域的工程师的优秀水平，肯定更好。\n\n由于时间仓促，再加上个人水平有限，文章中如有纰漏和错误，恭请读者指出，谢谢。如果同学还有什么想知道的内容和教材，也欢迎留言交流。\n\n<!-- more -->\n\n\n### 大一\n\n刚上大一，你的机器人生涯开始了。先看看学校的校园网能不能翻墙，不能的话自己去买个一年一百多块钱的VPN，先确保自己能上Google，不要心疼VPN的钱，这能让你在之后的职业生涯里节省上万块钱。然后去注册一个gmail账号，再注册stackoverflow账号，再注册github的账号，再注册CSDN账号，注册完登录上去逛逛，暂时先不要问为什么。\n\n英语水平一定程度上会是机器人工程师水平的限制因素，英语是同学们在大学最该努力学的一门课，而且不止要把它当成课，要当成一种技能，当成生活的一部分。当你开始努力学习一些高级的机器人知识以后，有可能会非常难以找到中文的参考资料，这个时候如果啃不下英文的资料，进步速度和眼界就会受到很大影响。因此大一的时候要多看看红宝书，看看美剧。\n\n不管是什么专业背景的同学，大学一年级一定要上好的课是微积分和线性代数。线性代数的重要性需要特别强调。一般来说，优秀的工程师和科学家在职业生涯中要学至少五次线性代数，大一学一遍、学凸优化的时候学一遍、学线性系统的时候学一遍、学机器学习的时候学一遍……如果在第一遍学的时候就看到对的书，刷到对的题，那么以后的学习会轻松很多。\n\n网上有很多对于如何学好线性代数的讨论，比如知乎问题如何理解线性代数？ - 数学学习。Matrix67大神的文章随记：我们需要怎样的数学教育？也很有启发。我个人对学习线性代数的建议是两本书，一本叫做《Linear Algebra Done Right》，另一本叫做《Linear Algebra Done Wrong》（https://www.math.brown.edu/~treil/papers/LADW/book.pdf），我比较喜欢的是Done Wrong这本书，第一它是免费的，第二只需要读前6章两百页就够了，第三它页边距很大，打印出来有很多空白做练习题。另外一个较好的教材是麻省理工公开课：线性代数。不论如何，学线性代数一定要用国外的教材，千万不要用国内的教材。啃英文书很累，但是考虑到之后还要啃更多的英文书，线性代数已经算是很入门的了，一定要啃下来，同时还要刷足够多的课后题。\n\n学完线性代数以后，一个自然而然的问题就是怎么能用计算机自己去计算矩阵的乘法、向量的乘法、向量的内积。因此引入了编程的学习。\n\n不管同学的专业是什么，一定要在大学一年级尽早开始学编程。至于用哪种语言开始学习编程，我推荐Python，比较好的教材是麻省理工学院公开课：计算机科学及编程导论，比较好的Python开发学习环境是Anacoda (http://www.continuum.io/downloads)。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。\n\n对任何人来说，Python是一把瑞士军刀，你可以用他干很多东西，比如自动回复邮件、自动收集信息。但是真要去造机器人，合适的工具并不是瑞士军刀，而是C/C++这样简单粗暴的锤子和螺丝刀般的工具。在学习Python学到一定程度的时候（比如你听说有一种叫做cython的东西），最好开始学习C，而且要强迫自己练习用C的一维数组和指针来实现矩阵的加法、乘法、求逆等操作。之所以有高级的Python或者Java（不要问我Java哪里高级了）这些语言以后我们还需要去学C，是因为机器人上常用的不是完整的电脑，而是计算量有局限的嵌入式系统，嵌入式系统开发基本只能用C或者更低级的语言。\n\n学习C我个人入门用的是清华大学出版的《C++语言程序设计》。虽然这个书标题是C++，但其实没什么太大问题。不过国内的C语言教材都有个巨大的问题是不引导学生去用Linux。近年来更好的一个教材是http://songjinshan.com/akabook/zh/index.html，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。\n\nIT行业的程序员都会争论高级语言和低级语言哪个好，Linux和Windows哪个好，而对于机器人工程师来说，从现在到可预见的未来里，C是最好的语言，Linux是最好的操作系统，这都毋庸置疑。甚至对于Linux的发行版该选哪个，我们都是很少有质疑的：Ubuntu（The leading OS for PC, tablet, phone and cloud）。原因是机器人操作系统ROS`（ROS.org | Powering the world's robots）`是基于Ubuntu开发的，因此在Ubuntu上运行最稳定。注意Ubuntu出了一个中文版叫做Kylin，个人感觉比较坑，建议大家不要装中文版。Ubuntu 作为一个开源操作系统，总是在快速迭代，2016年8月比较稳定的版本是14.04和16.04，建议同学安装14.04。\n\n当你把C学得差不多，开始要学写包含多个头文件的程序时，一定要同时学习makefile的知识。这时候要上网去搜“Makefile详解”（Makefile详解（超级好）_mingw吧）这篇文章看。\n\n我自己在大学一年级的时候还学习了HTML和Javascript，到大一结束的时候已经能够熟练用Javascript手写一些动态页面。我个人觉得HTML和Javascript也是机器人工程师必备的技术，而不只是软件工程师的玩具。这是因为web技术实际上已经渗透到了编程的方方面面，比如json开始是Javascript里的一种object定义的方式，但现在已经成为了一种很标准的数据交互、参数配置的格式。另外AJAX能够帮助初学者理解一定的网络技术原理，而网络技术也是机器人工程师必备的技能。再者，制作GUI（图形用户界面）是常规debug的办法，而近年来一个流行的趋势是用webkit嵌入程序用HTML和Javascript作为图形界面的后端，而在机器人操作系统ROS`（ROS.org | Powering the world's robots）`里，通过rosbridge可以非常方便地把机器人程序的数据传递到websocket上，这句话看不懂没关系，反正你知道学学HTML和Javascript很重要就是了。更重要的是，HTML文档背后的DOM (Document Object Model)深刻地体现了面向对象的思想。大学中的面向对象程序设计一般都讲C++，在我看来应该讲HTML和Javascript。这一点不细说了，如果同学们去学习HTML和Javascript，自然会体会到。学习HTML和Javascript比较好的资料是http://www.w3schools.com/，把网站左侧的“Learn HTML”、“Learn CSS”、“Learn Javascript”和“Learn JQuery”学完就行，别的部分还有很多花哨的技术，没有必要去学了。为了培养自己对Javascript的兴趣，可以上three.js / examples跪着看看热闹。\n\n以上介绍的这些知识点、书和资料应该在大一期间就全部看完，然后利用大一的暑假好好巩固这些知识。比如开始用HTML和Javascript做一个自己的个人主页，刷一刷编程的题目，学用Python的奇技淫巧（比方说做一个自己的个人主页）。另外还可以抽时间学学数学知识，比如开始看看代数和离散数学。我大一的时候看到了两篇文章，认识到了数学的重要性，一个是MIT的CV大牛林达华写的[转]MIT牛人解说数学体系，另一个是前Goolge研究员吴军博士写的《数学之美》（数学之美 (豆瓣)）。当时林达华还在MIT读博士，而《数学之美》还没有成书。两篇文章看完以后我感觉自己整个人对数学的认识上了一个新的层次，此后一直在注意提高自己的数学水平，几年下来觉得收益很大。在之后的介绍里我还会多次强调需要学的数学知识和对应的教材。\n\n### 大二\n\n上大二的时候，你已经会了基本的编程知识和基本的数学知识。大二这一年应该投入在嵌入式系统的学习中，同时继续拓展自己多方面的能力。学校的机器人社团，比如做Robocon，RoboMasters的团队应该在招新了，赶快去加入，有了学长学姐的指导以及同辈朋友的鞭策，应该会进步的快一点。\n\n大二应该掌握的技能：Solidworks画基本的机械图，基本的数字电路知识、数模转换，51单片机、AVR单片机、STM32单片机原理，UART、SPI、I2C、CAN等协议的原理和数据收发，STM32开发板的使用，电机转动和驱动的原理，PID的原理，调试四轮机器人底盘的移动，基本的传感器如陀螺仪、码盘、红外线、超声波的原理和读取方式，网络知识如配置IP配置路由器等，微电子焊接，金工技术。我在知乎回答如果程序员每天都浅尝辄止地学一些不同的新技术，长久以往，人会变成什么样子呢？ - YY硕的回答里谈过机器人工程师需要的技能数量是IT行业全栈工程师技能数量的三倍以上，这些技能的基础都应该在大二开始积累。\n\n如果同学们的专业是机械工程相关，那么大二的时候要深入学习solidworks做图，买机械加工手册学习各种机械的奇技淫巧。你的专业知识还不足以让你进行缜密的受力分析，不过你可以尽量多做一些机械结构出来感受它们的乐趣。\n\n如果同学们的专业是硬件、电路相关，那么大二的时候要深入学习Altium Designer做图、制板、焊板。你要从现在开始，就给自己积累一个工作记录，可以就是简单的txt文件，记录你做过所有板子的bug、解决方案、学到的原理图、PCB layout的注意事项等等。积累很多年以后，你的这个工作记录会值很多钱。\n\n学习这些技能的最好的方式，就是参加自己学校机器人社团的训练和方案设计。一般来说，学校的机器人社团招新之后会有训练和测试，让新人分组去做机器人，这个过程中如果愿意努力学，提高得会很快。如果你所在的大学是机器人比赛强校，比如西安交通大学，电子科技大学，哈尔滨工业大学，华中科技大学，东北大学等等（排名不分先后，没有提到你们学校名字的话我表示抱歉），那么你很幸运，你们学校的机器人社团有很好的积淀，有很多资源可以帮助你学习。基本上只要天天泡实验室，保证自己每天只睡6-7个小时（但还是要多去跑步、游泳保持身体健康），勤于向学长学姐请教，那么一定会提高得很快。\n\n大二阶段特别要强调的是对动手能力的培养，包括机械材料的加工、电路焊接、制作导线和接头、连接路由器、配置网络、做网线等等。机械加工的工具有螺丝刀、锯、钻、锤子、车床、铣床、钻床，进阶选手可以学一下氧焊，这个比较危险，我没尝试过；电路焊接的工具有焊机、焊锡、洗板水、松香、吸锡器；制作导线的工具有剪子、剥线钳、夹头钳、网线钳各种钳；网络配置就是连连路由器插插网线，但是Linux系统下配置网络有时会非常麻烦，一定要多积累这方面的知识，因为将来你造的机器人多半会顶着一个无线路由器跑来跑去，甚至有的机器人上各个模块自己就能组起一个小局域网。这些技能的熟练掌握需要你花很多时间去做真正能用的机器人来练手。\n\n对于该选择造一个怎么样的“真正能用的机器人”练手，最好的选择肯定是机器人比赛中的机器人。如果参加Robocon，你会跟着学长学姐们学着造有人那么高的巨大机械；如果参加RoboMasters，你会学着造比汽车还要灵活的机器人以及快速发弹的机构。其他一些小型的比赛比如飞思卡尔智能车，也是很好的训练，因为飞思卡尔智能车已经发展得很成熟，参加这个比赛的参赛资料就够学一阵子的，学完以后能够获得比较多的机器人技能。\n\n如果没有太多学校机器人社团的资源，同学们还有一些小型的比赛比如挑战杯、大创比赛等等可以选择，以三五个人的小团队参与这些比赛。如果同学所在的学校连这些比赛都不组织大家参与，那就只好自己花钱了。国内开源机器人社区有很多资源可以利用来学习，比如自己买Arduino STEM educational Robot kits Building Platform的各种开发套件做简单的机器人。Arduino的开发环境可能有些人不喜欢，因为它对硬件做了一级封装，如果更希望接触到单片机的本质，可以自己买STM32开发板学习。俗话说，没有什么嵌入式系统是一块STM32实现不了的，如果有，就用两块。STM32是ARM Cortex‑M家族中最为广泛应用的一款单片机，在网上也有很多的教材和开发板可供选择。在国内著名的电子论坛STM32/8 分论坛帖子清单 (amoBBS 阿莫电子论坛)上，有很多参考资料，有问题也可以在这里和大家讨论学习。\n\n如果你很想参加机器人比赛，身边也恰好有一些志同道合的小伙伴，但是学校不支持。没关系，来找我，我尽量通过大疆的关系说服你们学校支持你们参加RoboMasters。\n\n虽然你是以机器人比赛为主线在探索机器人技术，但是要时刻记得，机器人比赛给你的理论方面的训练很差，还会让你养成一些坏习惯，比如凡事都希望用一些糙猛快的办法来解决。由于通常整个团队都没有太多的项目管理经验，到比赛前一段时间才会加紧功夫去做机器人，很多时候就会用“山寨”的办法去处理机器人的故障。比如说某个承重结构用久了会弯，为了赶比赛的进度，就拿锤子敲直了、再加一条辅助的结构在旁边继续用，而没有细致地去做建模、受力分析，思考是什么原因导致承重结构会变形。再比如说调PID参数就是生调乱改，而没有基于机器人的动力学模型去估测参数的大概范围。\n\n大二的暑假，有可能你跟着学校的机器人队参加了一些机器人比赛。这是一个反思总结的好时机，为什么机器人队取得了这样那样的成绩？整个团队怎样才能更有效率？明年如何继续招新？暑假要把时间花在技术积累上面，这个时候可以回头思考思考之前准备比赛时用糙猛快的办法解决的问题如何能够细致地去解决。\n\n如果大二的暑假没有参加机器人比赛，可以做一个舵机机器人，比如6条腿的蜘蛛，比如码垛机器人。舵机是机器人工程师的好朋友，一定要好好掌握。\n\n另外你其他方面的能力也不能落下。大二结束的时候，你的Linux应该用的很熟练了，除了makefile，你也用起了cmake。你也应该开始理解Github存在的意义，因为你已经上去读了很多别人的代码，你也把自己的一些课程设计和小项目放在了Github上面。另外大二基本上了本专业一些比较难的基础课程，比如自动控制原理、机器学习、概率统计、材料和力学等课程，同学们会看到这些课程里又用到了线性代数和微积分的知识，以及建模的知识。这时候可以把大一的物理、线性代数和微积分再翻出来看看。\n\n同学的学校应该给大二到大三的学生有开设面向对象的程序设计，一般用Java或C++教授。在面向对象的程序课里面，一定要积累3000行左右的代码的开发经验。经典的面向对象程序设计的练习通常是写游戏，比如俄罗斯方块，吃豆人等等，一定要自己能够做到完全手写一个完整的项目出来。\n\n另外你可以开始学习Matlab当中的神器Simulink了。在大二这一年的学习中，你可能在不少课程里多多少少用到了Matlab。假设你已经在我的推荐下喜欢上了Python，你可能会觉得Matlab的计算工具没有比Python强多少；假设你自己在别人的推荐下喜欢上了mathematica（Mathematica 到底有多厉害？ - Wolfram Mathematica），你可能会觉得和Mathematica这种神一样的语言比起来，Matlab弱爆了。但是要注意的是，Matlab最强大的工具是Simulink，通过它你几乎可以仿真一切的物理系统和控制系统。我建议同学可以通过Simulink实现一个倒立摆，然后理解Matlab的强大之处。对此我强烈推荐一个很好的教材（http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（Control of an Inverted Pendulum on a Cart）的文章。阅读并实现了这两篇文章里的内容，同学应该会对倒立摆有了比较深刻的认识。倒立摆是机器人学中一个非常重要的模型，因为火箭、导弹、双足机器人、四足机器人，基本都是倒立摆的变形。你自己实现出来的simulink模型一定要存好，以后可能还会再拿出来仔细看。\n\n如果你按照我之前说的方法探索了一些HTML和Javascript的技术，那么JQuery，bootstrap，AngularJS你已经多多少少知道是怎么回事了。web后端的技术，比如PHP和MySQL，也可以了解一下，LAMP要学会怎么配置。如果有同学找你帮忙写小网站，尽量去帮个忙，帮别人做网站是提高自己系统编程能力的好练习。在做网站的过程中你可能还会顺便学一学如何用Photoshop和Illustrator让网站显得更漂亮。这些技能有最好，没空学也没关系。\n\n### 大三\n\n大三开始的时候，你可以在学校的机器人队里担任重要角色了，或者能够带领一个小团队参加小型的机器人比赛。你在系里甚至院里都小有名气了，可能有的人叫你大神，有的人觉得你技术还不错。但是一定要记得你现在的水平放到别的地方应该不算什么。每年我都往大疆的RoboMasters夏令营招进100个和你现在的水平相当的同学。\n\n大三一定要培养出自己一个人独立造出一个完整机器人的能力，比如一个Robocon水平的机器人，或者一个RoboMasters的战车，或者一个四旋翼飞行器。\n\nRobocon水平的机器人，涉及大量的机械设计，单片机开发，电机驱动的开发，码盘和超声波等传感器的读取，底盘运动学的计算，PID调试，任务调度逻辑的调试，舵机控制。RoboMasters的战车的机械部分简单一些，但是还需要进行云台的控制、发弹系统的控制、功率控制等方面的知识，另外你也可以不搞这些部分，学习学习视觉识别和自动打击，那么就要开始研究OpenCV（OpenCV | OpenCV）了。\n\n四旋翼飞行器的机械部分最简单，但是算法比较复杂。对于大三学生来说，从零开始一步到位写一个稳定的飞控比较困难，因为飞控里面有很多细小的知识点要注意。目前我没有发现什么比较好的书籍推荐，已有的一些关于四旋翼系统的书要么太浅（上来就教你焊电路），要么太深（上来就教你state estimation），听说 @Liu Top的exbot小组在写一个教材，我是非常期待的。学习四旋翼飞行器有下面几个步骤：\n\n第一步：自己调一个小四轴飞起来\n现在开源社区的人言必pixhawk，其实我觉得从学习的角度来说，pixhawk太贵，而且不适合学习，我比较推荐的是 首页-第七实验室 这家淘宝店卖的STM32F405飞控，买回来以后自己再随便买个机架（比如大疆F450）、接收机和遥控，就能按照飞控板附带的学习资料、调试软件飞起来。\n\n第二步：看硬件图、读代码\nchiplab7的飞控板附带一大堆学习资料，对加速度计、陀螺和磁感计都有很仔细的解释，硬件链路图也很详细。chiplab7淘宝掌柜的又很认真负责，我学用的时候，发现代码有bug和看不懂的地方，都可以直接找掌柜问。\n\n看完代码以后，对一个飞控系统的基本模块：姿态解算、控制解算、混控输出、遥控器处理、嵌入式处理就很明白了。然而这里面有很多技术是需要另外学习的。除了基本的嵌入式编程以外，还有要把大二大三学的信号处理方面的知识再捡起来看看。因为飞行器在空中有振动，会让加速度计产生噪声，为了把这些噪声去除掉，需要对加速度计给出的信号做低通滤波处理，如何选择滤波器的参数呢？如果滤波滤得太狠，延迟就会比较大，对控制的表现会有影响；如果滤波滤得不够，可能会有一些低频的噪声偶尔会出现，导致加速度计的观测不能用。另外最重要的是要理解姿态解算和控制解算这两块知识。chiplab7的飞控板的代码采用的是最简单的互补滤波算法做为姿态解算模块，然后控制解算是对欧拉角的三个角度做闭环PID控制，基本都是基础的基础了。\n\n第三步：小修小改加深理解\nchiplab7的飞控是靠气压计定高的，飞行效果非常奔放。这时候可以淘宝买个20块钱的超声波模块，然后自己写个高度环去稳定飞控的定高表现。\n\n我觉得这个过程至关重要，因为高度控制相对来说是个比较直观理解PID控制的方式，而且chiplab7的飞控加高度控制非常好加。工作量不大，因为改善效果很显著，所以可以让人很有成就感，加深继续学习的乐趣。\n\n第四步：理解核心的数学和控制知识\n这一部分大三是肯定来不及学的，但是我还是在这里列出来，因为这些知识你之后都需要慢慢学，我也会在之后不断重复提到这些知识点。\n姿态解算和控制解算涉及的知识有：\n1. 刚体姿态的表示、运动学方程和动力学方程。主要是对牛顿-欧拉方程的认识和理解、刚体姿态的欧拉角表示法、姿态与角速度的关系等等。\n这部分说复杂不复杂，说简单也不简单，我同样是没有找到一本完整的书全都介绍过的，是学了好几个不同的书和论文以后搞明白的。现在看起来是从维基百科入手比较靠谱。\n2. 自动控制原理。讲PID的书和文章就多了去了，没有太多复杂的书。\n3. 线性估计基本原理。其实就是互补滤波：Reading a IMU Without Kalman: The Complementary Filter 。拿这个关键词百度各种搜就会了。\n第五步：重头开始造轮子\n知乎著名网友vczh曾经说过，学习要抱着勇于造轮子的心态才能进步。所以在熟悉了别人飞控基础上，可以自己重头造一个飞控的轮子。可以自己从芯片开始重新画一个飞控板，读读STM32的芯片手册、读读各种传感器的芯片手册，自己手画一个飞控的原理图、做PCB layout、制板自己焊元件，全套花不了1000块钱，能够加深很多对硬件的理解。这一部分如果大三没空，也可以不搞了。\n\n制造整个机器人的过程中要特别重视文档的积累。在你大三末期，你可能随着学校的机器人队备战比赛，你可能主力负责一台机器人。你应该自己列一个excel表格，把机器人用了几颗螺丝，几根导线，每个零件的规格是什么，都列出来。这个表格一方面可以用来帮助团队管理机器人的物料，一方面也是你自己的经验技术积累，将来你做的其他机器人可能多多少少都是Robocon、RoboMasters机器人的变形。\n\n另一个积累是建一个自己的buglist，buglist包括什么呢，可以像冷大这样：做控制、机器人等算法工程师是怎样一种体验？ - 冷哲的回答，就简单把一些自己的发生过的问题和最后的解决办法罗列下来。比如说“杜邦线接插位不稳固容易脱开，接好后应该用电工胶布再裹一圈”，“外发给淘宝加工的机械图纸，要特别注意和加工商沟通有没有漏掉一些细节，如沉头螺丝孔，关键的倒角”等等。你也可以帮其他机器人的问题也做这样的记录。buglist可以就是一个简单的文本文件，如果你一直往里面积累自己工作中的记录，等你将来工作了，这个文件可能会值很多钱。\n\n大三的时候学校应该会开设软件工程的课程。不管你是不是这个专业，上不上这门课，都应该主动去听一听，甚至跟着课程的设计作业一起做一做。软件工程我觉得是机器人工程师必须具备的意识，因为一个机器人系统里涉及大量的硬件系统和软件功能，软件的部分往往还会涉及不同的语言、不同的编译环境、不同的开发工具链。几个人合作的话，大家的专业背景、编程习惯都不相同，这就导致不同的代码和模块之间的协议沟通非常复杂，必须尽早用UML和其他软件工程的工具帮助团队理解和互相沟通。\n\n大三的时候学校应该还会开设操作系统原理和嵌入式系统原理的课程，而大二的时候讲过计算机组成原理（所谓的微机原理）。从大三开始同学需要开始体会实时操作系统和非实时操作系统的区别、原理以及使用时需要注意的地方。这是一个比较杂的知识点，我目前没有找到很好的教材去介绍。在STM32上，有freeRTOS，uCOS，Vxworks这么几种实时操作系统；Linux是一种非实时操作系统，但是可以通过打补丁变成实时操作系统。这些操作系统的细节在机器人开发中都会多多少少被涉及到，同学们可以随时上Google和CSDN去查大神们的介绍。\n\n另外特别重要的一点是机器人系统里的嵌入式平台都有烧坏的可能性，有可能在某个嵌入式Linux平台上面辛辛苦苦写了一个多月代码，这个平台突然烧坏了，代码也就丢了。因此你的机器人如果有嵌入式Linux系统在里面，一定要尽早顶起来路由器，代码定时提交SVN或者git。\n\n大三的暑假你可能会作为学校机器人队的主力去参赛了。备战比赛和参赛是一件磨练心性的事情。我在学生时代体会过和胜利擦肩而过的痛苦，体会过没机会再来一年的遗憾；也在负责大疆RoboMasters比赛的过程中被那些痛苦和遗憾的学生当做发泄的对象，非常有感触。我觉得参加机器人比赛，很努力，然后失败了，是一件让人快速成长的事情。同学如果有机会，一定应该参加至少一届机器人比赛。\n\n大三的暑假你也可以选择来参加大疆的RoboMasters夏令营，关于夏令营大家可以看这个知乎问答了解更多：参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新。每年我们都在全国范围内寻找有一定技术基础的学生，让他们一起分组做一个自动机器人的挑战。这个夏令营，作为组织负责人，不谦虚地说，我觉得应该是全世界范围内最好的技术类夏令营。\n\n大三的暑假有一件很重要的事情就是思考自己大四应该干什么。一般来说，你现在的能力保本校研究生肯定没有问题，当然你也可以选择考其他学校的研究生或者出国留学。虽然说你现在能力已经很全面了，但是你还需要2-3年的时间全面提升自己更多的能力，才能迈向卓越之路。不管是出国还是保研，最重要的目的是给自己争取到未来2-3年能够在一个优秀的环境中安心提升自己，有比较好的学习资源，能够参与到一些不错的项目中去。可能其他有些行当，出国留学始终是比在国内待着更好的选择，但是机器人行业并不是这样。我们国家这两年在机器人方面提高也很快，而且我们国家现在比较有钱。就像我开始说的那样，机器人是富人的活动，现在你在国内也能找到一些很有钱的实验室可以造比较牛逼的机器人。另外国外很多比较强的机器人公司也都在做比较敏感的军方项目，去找实习可能比较受限制。\n\n出国去学机器人学方面的知识你有很多不错的选择，比如世界第一的机器人研究院卡耐基梅隆大学，或者麻省理工学院的CSAIL实验室。北美传统计算机四大名校（麻省理工学院，卡耐基梅隆大学，斯坦福大学，加州大学伯克利分校）里，除了斯坦福大学热火朝天在搞人工智能以外，其他几个学校的机器人研究都很不错。除了四大名校，你还有很多其他的选择，就像我开始说的那样，机器人是富人的活动，如果想接触到最好的机器人资源，你要选择有钱的实验室，而不是有名的实验室。\n\n另外你还需要在大三的尾巴上选定自己将来的细分研究方向，而且开始往这个方向深挖，也就是我在文章开始提到的感知、认知、行为几个方向。当然同时你也不能放松其他方面的知识，尤其是数学基础。我在大三的暑假专门找数学系的同学给我开了个数学小讲座，学习了一点抽象代数的知识，对我后来学习密码学帮助很大。同时我也读了一些拓扑方面的教材（有一本很神奇的书叫做Topopogy Without Tears http://www.topologywithouttears.net/），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。\n\n大三阶段的机器人工程师该学什么基础数学是众说纷纭的，在我看来，你要基本掌握“群是什么”，能够用代数的眼光去证明\"det(AB) = det(A)det(B)\"，还要能理解“用一张纸就可以变出克莱因瓶”（当然是在四维空间里）。另外，你这个时候也要能够意识到自己需要再学一遍线性代数。\n\n### 大四\n\n大四开始了，你可以开始深挖自己的研究方向，同时也要开始学一些高级一点的通用技术和理论，这时候你和一般的机械、电子、计算机学生就不太一样了，你虽然也在狂编程，但也在狂学习物理和数学。通用技术包括ROS，simulink，gazebo和Vrep等工具。通用理论包括，再学一遍线性代数，学学凸优化、数值计算、旋转表示法等方面的知识。这些知识你在大四仅仅只能开一个头，因为你的大四要实习、毕业、考研、毕设，你会非常地忙。有些人会在大四进实验室和老师发论文，我个人觉得发论文这件事没必要操之过急。你的整个大学期间应该用在广泛涉猎各种各样的知识上面，而不是深入某一个细小的研究问题。\n\n大四可以开始读一些著名入门书籍，我把这些书不分先后地列出来，你没有必要全部去读，而且每本书先读前几章就够了，能读多少尽量读多少。\n\n1. 概率机器人学，https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623\n\n2. 凸优化，https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf\n\n3. 线性系统理论，https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579\n\n4. Multiple View Geometry in Computer Vision，Multiple View Geometry in Computer Vision\n\n5. 线性估计，https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642\n\n6. 《机器学习》，周志华老师的书。\n\n7. An Invitation to 3-D Vision，https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf\n\n8. Modern Control Systems，https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580\n\n9. Rigid Body Dynamics，http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。\n\n10. Feedback Systems: An Introduction for Scientists and Engineers，FBSwiki\n\n就像我开始说的那样，这些书，大部分特别贵，还好有一些业界良心的作者放出了他们书的电子版。当然你也可以去一些名字都不能说的网站去找影印版。\n\n在读上面这些书的时候，matlab，python都要放在手边，然后把书里面的知识尽量实践出来。很多教科书里都会在章节后面的习题里放一些写明是用matlab做的习题，要尽量多做一些这样的题。\n\n你可能早就听说了ROS的大名，但是最好不要在大四之前去碰它。因为ROS用了很多操作系统和网络的底层技术。我在知乎回答高手可以谈谈ROS机器人操作平台开发的一些经验吗？ - YY硕的回答里有简单的介绍。ROS的设计目标是把机器人的控制和传感器处理的软件和它的硬件隔离开，用上ROS以后，你可以方便地用到很多能直接跑的软件代码。但是ROS从入门到精通需要至少一年以上的时间，你必须不断地用，不断地尝试新的代码和硬件，才能对它熟悉起来。\n\nROS的可视化工具Rviz里面对于机器人旋转的表示用的是四元数，而在你之前研究四旋翼飞行器时，里面的代码表示旋转用的是欧拉角，做姿态解算用的可能是四元数。这个时候要开始有意识地去学习旋转表示法之间的区别和联系。\n\n要重视大四期间的实习和毕业设计。很多大四的学生毕业设计都会非常颓地做一下，我觉得是不好的。要把做毕业设计的过程看做一个正式的项目。这个项目除了做好技术方面的工作，也要做好展示方面的工作。中国工程师的一大特点是，不会表达自己，可能做的东西水平很高，但是做出PPT就会犯字体花哨不正式、一页上面字太多，图文没有联系等表达上的问题。通过PPT介绍、展示自己的成果在工程师的职业生涯的任何一个阶段都非常重要，它甚至也一定程度上限制了机器人工程师能够达到的高度。只有能够把自己的成果清晰地表达给自己的团队，才能获得其他人的反馈、通过沟通提高团队的整体凝聚力和知识水平，这样自己在团队能够获得更多的认可，有助于团队整体工作效率的提高。我每年去参加几次学术会议，都在会议上感觉到一些中国的科研人员走到国际上以后，演讲能力很差就会导致他们的科研成果不受重视。当然其他国家的科研人员也是这样。\n\n为了写出美观的技术报告和毕业论文，你可以开始学习Latex。Latex作为国际国内第一写作神器，学习资料在网上有很多。Latex的学习和使用同样也是需要不断地熟能生巧，多写多练就熟悉了。写毕业论文有个问题是怎么做出精美的矢量图，我推荐Draw Freely | Inkscape，一个比Illustrator更轻量化、但是有些功能反而更强大的免费软件。\n\n对于那些想申请出国留学的同学，你要做一个自己个人的成果展示，用网页的形式呈现比较好。把自己Github链接（如果你按我说的，大学第一天就申请Github账号，现在已经是一个三年的老油条了）、做过的机器人视频、写过的技术报告和文章（最好是英文的）放在上面。\n\n关于毕业设计的选题，我推荐这么几个：\n\n1. 手写双目视觉里程计。涉及到图像处理、特征匹配、位置解算、空间变换等等。\n\n2. 手写四旋翼飞行器基于GPS的轨迹规划。涉及到深挖四旋翼飞行器的运动原理、IMU原理、轨迹生成和优化等。\n\n3. 造一个被推了也不会倒的双足舵机机器人。涉及到舵机控制、倒立摆建模、动力学分析、PID控制、IMU原理等。\n\n4. 深度学习训练一个小车追人跑。涉及到深度学习工具包使用、数据集采集、数据集分析、小车控制等。\n\n5. 机械臂给人端茶倒水。这个相对来说土豪一点，因为能直接拿来用的机械臂都很贵，这个要看实验室有没有条件了。涉及到多自由度机械臂原理的学习、工具包的使用、轨迹规划等等。\n\n这几个项目要做好，都要持续投入三个月以上的时间以及一定的资金，每一个都是理论多于实践。当然同学们自己也可以自己选择自己的毕业设计题目，但是最好还是选做出来能跑能飞的东西，同时避免选择需要花大量时间去拧螺丝、焊板子的题目，尽量买现成的电机、开发板、3D打印结构，大四要多给自己留时间去看书和写代码。\n\n大四到研究生之前的暑假，最好去一些比较不错的机器人公司实习一下，比如说大疆。当然你也可以继续做机器人比赛，比如RoboMasters和大疆的飞行器比赛。\n\n### 研究生一年级\n\n研究生的时候，你的目标比较清晰了，就是做一种机器人至少两年时间，并从中发掘出可以发表论文的知识点。上面我给出的书单里面，你要开始精读里面的几本。\n\n如果做机器人视觉定位、传感器融合方面的研究，1、4、5、7四本书一定要精读。\n\n如果做控制系统的研究，3、8、9、10一定要精读。\n\n如果做规划算法的研究，那么还要读其他偏CS一些的书，比如讲A* search，random forest，图论方面知识的教材。由于我在这方面造诣不深，就不托大了。\n\n如果学习随机系统的控制和最优控制，除了1、2、3，还要读一本神书Stochastic models estimation and control（https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）。\n\n如果研究机器人视觉定位，几种常用的定位算法：PTAM（Parallel Tracking and Mapping for Small AR Workspaces (PTAM)），ROS的标配VO（viso2_ros - ROS Wiki），SVO（GitHub - uzh-rpg/rpg_svo: Semi-direct Visual Odometry），LSD-SLAM（http://vision.in.tum.de/research/vslam/lsdslam）ORB-SLAM（GitHub - raulmur/ORB_SLAM2: Real-Time SLAM for Monocular, Stereo and RGB-D Cameras, with Loop Detection and Relocalization Capabilities），都必须自己学习之后全部跑一遍。只会用OpenCV的函数和这些工具包并不能说明你会视觉定位，必须要能自己手写出一个能用的才算。国内有一个很厉害的SLAM专家叫高翔，他的博客要关注一下：机器人 - 标签。由于SLAM这两年很火，研究的人很多，所以网上可以参考的资料也很多，比如https://github.com/hcdth011/ROS-Hydro-SLAM，就在ROS上实现了几种定位算法的对比。\n\n我现在非常不建议同学们选择从四旋翼飞行器的动力学控制里找问题作为研究课题。因为四旋翼飞行器的特点已经被研究透了。目前国际上对多旋翼飞行器的研究主要集中在造一些奇葩形状的飞行器，以及给多旋翼飞行器上安装一个机械臂去做力控制，这样做就对多旋翼飞行器控制的动力学造成了一些影响。因此需要同学对动力学和多自由度机械臂控制有比较深的认识。\n\n自动导航和驾驶是这两年的热点，一方面汽车的自动化是大势所趋，另一方面多旋翼飞行器异军突起，产生了很多对自动飞行的需求。除了机器人视觉定位算法以外，同学还需要学习其他的传感器，以及这些传感器与视觉定位算法怎么融合。这里面有很多坑，比如计算量的问题，怎么保证融合算法不崩，怎么处理传感器的延时等等，都需要同学结合自己的项目去踩，坑踩得多了才能成长。如果大家想找一个多旋翼飞行器平台研究自动导航，我推荐大疆的M100，我已经在知乎回答RoboMasters2015夏令营是怎样的？ - YY硕的回答里吹过一波M100，前面说过的今年夏令营的知乎回答参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新里也有人帮我吹了一波。\n\n一些大学里学过的知识点，是必须结合研究生期间的项目的需求弄得很清楚的，比如三大变换（傅里叶变换，拉普拉斯变换，Z变换），旋转表示法（欧拉角、四元数、旋转矩阵），数值计算怎么防止矩阵出现数值问题等等。除了自己的项目，还需要把凸优化、卡尔曼滤波还有多自由度机械臂的控制学习一下。这三个领域的知识，是任何一种机器人都会用的到比较难的知识。\n\n凸优化和凸优化的各种变形是非常重要的知识，因为各行各业里的研究问题，多半是会建立一个优化问题去解决的。上面提到的《Convex Optimization》https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf，也是一本神书，同学们一定要认真读一读。Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient descend，barrier method等等。另外现在主流的SLAM算法，后端都是通过一种叫做g2o的优化算法来出效果的。而且g2o能够整合bundle adjustment 和structure-from-motion这两大计算机视觉里的关键问题，可以说是一种很好的计算思想了，非常有必要学习一下g2o。\n\n卡尔曼滤波在上面书单里的1和3都有提到，同时在神书Stochastic models estimation and control（https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。\n\n多自由度的机械臂的难点在于机械臂的运动学正反解、运动学控制和动力学控制，基本是一个建模分析和数值算法实现的问题。如果你所在的学校没有一个财力雄厚的机器人实验室的话，你基本上没有机会接触到多自由度的机械臂。这时候之前学到的Simulink和就要学的Gazebo就派上用场了，你可以用Simscape里面的刚体搭一个多自由度机械臂，然后通过Simulink仿真去学习机械臂的控制；也可以用Gazebo的URDF语言写一个机械臂，然后通过Gazebo和ROS的接口去控制机械臂；也可以用ROS里面的著名工具包MoveIt! Motion Planning Framework，不过MoveIt的问题是，他只能仿真运动学，而不能仿真动力学。工业领域对多自由度的机械臂控制通常用一个叫做D-H表示法的建模工具（Denavit），这个东西我并不太会。我只会向同学们推荐我导师的著作《A mathematical introduction to robotic manipulation》（http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf）。\n\n有一个非常神奇的事实：《A mathematical introduction to robotic manipulation》这本机械臂控制领域的著名教材的第二章和计算机视觉领域的著名教材《An Invitation to 3-D Vision》的第二章基本是一样的，都在讲旋转表示法。这是因为所有的旋转表示法都可以归纳为一种优雅的李群结构：SO(3)群。而计算机视觉和机械臂控制都涉及到理解刚体的旋转，事实上用计算系统去观测和控制所有的刚体构成的系统，理解旋转都是很关键的问题。旋转表示法应该作为研究生阶段的一个重要学习的知识点。\n\n李群和李代数是刚体旋转表示背后的数学理论，如果想要深挖一些，可以看这篇文章An elementary introduction to groups and representations的前50页（http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf）。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。\n\n研究生阶段还要培养的一个能力是借助各种工具仿真机器人系统的能力。显然地，很多机器人系统真的造出来的话造价昂贵，需要在实际制造之前写一个比较真实的仿真系统出来测试算法。我觉得做仿真系统的能力直接衡量了机器人工程师的技术水平。当你开始要搭一个仿真系统的时候，第一步是通过欧拉方程和牛顿方程确定刚体的运动特点，甚至要自己写刚体二阶微分方程；第二步是确定刚体之间的互联关系，设计不同类型的关节，如果有软性连接需要加入弹簧阻尼模型；第三步是确定被仿真的刚体系统会不会和外界产生碰撞或者其他形式的力，如果有的话，需要设计合适的接触力和摩擦力仿真的模型。多旋翼飞行器的仿真是很简单的，不需要考虑什么接触力。但是多自由度机械臂基本都需要仿真接触力，不和物理世界去交互的机械臂只有很小的实用意义。而能够自行运动locomotion系统，比如双足、多足机器人，则涉及到更多的接触力，多到接触力都会影响仿真系统的数值稳定性。搭建一个仿真系统需要很强的系统建模能力和数值分析的能力，虽然Simulink、Gazebo、Vrep提供了不同程度的工具简化你的工作，但是要让仿真系统能够稳定运行，必须要能深入其中的细节。有些看起来很高大上的仿真工具，比如Nvida的PhysX，在仿真的时候是忽略掉科里奥利力的，如果不理解仿真的本质，可能就会忽略这一个重要的缺陷。\n\n### 研究生二年级\n\n你的学习计划接近尾声。现在你已经进入了一个很好的状态：看到一个机器人，能够很果断地分析出它用了什么传感器、执行器、计算平台大概是什么量级，他的执行机构能够承受多少力量。看到一个新的算法，能够大约判断清楚它的执行流程，在什么环节做了优化。看到一个新的没学过的知识，能够分析出它和你以前学过的什么知识有联系，你还需要再学什么才能弄明白这个知识点。\n\n研究生二年级要深化第一年学到的那些技术和知识，要做到完整地读过四五本书，五十篇以上的论文。你已经积累了几万行代码的经验，也能熟练地谈论谁家的电机回差小，谁家的电机线性程度好。\n\n你这个时候可以去写作一些论文，也可以开始学习一些更高级的技术和工具，比如用FPGA和GPU优化算法、魔改Linux内核、玩玩液压系统、了解更多机器学习的知识比如强化学习等等。你也可以从计算机图形学或者计算力学里面找到一些帮助你更好进行机器人仿真和系统分析的工具。由于你懂很多机器人方面的知识，你可以给学校的机器人队做指导，或者带队参加一些比较有挑战性的机器人比赛。\n\n写到这里，我就不可能给出很多不同领域的指导了，因为随着学习的进一步深化，我自己熟悉的领域也在收缩。我只能对几个领域给出我的意见。\n\n对视觉定位和传感器融合来说，SLAM急需新的突破，目前通过几何约束去实现loop closure看起来已经走入了死路，没法有更多的发展了，下一步可行的方向是与深度学习进行结合。具体的一些介绍可以阅读行业中大牛的一篇文章http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie Shen的工作。\n\n对于多自由度机械手和机器人的locomotion来说，这里面还有非常多可以探索的研究问题。我前面提过接触力和摩擦力很难仿真，大神告诉我现在没有任何一种工具和理论能把接触力和摩擦力正确仿真出来，因此如何在机器人系统里妥善处理对这些力的控制，就是很难的问题了。现在业界的一个前沿发展方向，也是利用机器学习技术来帮助机器人学会处理这些外力，不过人类目前最优秀的多自由度机器人系统，Berkeley的Brett机器人，叠几块积木就要用十分钟（New ‘deep learning’ technique enables robot mastery of skills via trial and error），显然还有很多提升的空间。这方面的问题同学可以关注知乎大神@戴泓楷@周佳骥。\n\n最后我想再强调一遍表达能力的重要性。你可以从自己带的课程和机器人队入手，把自己这几年来学过的知识做成PPT讲给学生们听，然后让他们给你反馈。多做这样的练习，提升自己做演讲的能力，这将来会让你受益匪浅。\n\n研究生二年级之后，你可以准备进机器人公司工作了，也可以根据你自己感兴趣的研究方向申请博士接着努力。由于你已经掌握了广博的知识和技能，你的职业生涯将会大有作为。\n\n结束语\n\n我从2008年展开自己的机器人生涯。那一年波士顿动力刚刚发布他们的大狗机器人，Python还是很小众的语言，Ubuntu 8.04还很不稳定，Chrome还没有多少人知道。在之后的几年中我目击了深度神经网络的复兴，看到波士顿动力的机器人日渐强大，经历了ROS的起源和繁荣，帮助了大疆的崛起，深深为这个产业的未来感到激动。我希望这篇文章能够帮助更多的年轻人进入机器人学的海洋，为未来机器人学的继续发展贡献力量。\n","slug":"2016/2016-09-28-（转）机器人工程师学习计划","published":1,"updated":"2017-01-05T00:32:09.455Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aik0033mumurwoq26q7","content":"<p><em>本文是转载的一篇知乎专栏上的文章，写的相当好。可惜当年上学的时候无人指点，浪费了太多的光影。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">作者：YY硕</div><div class=\"line\">链接：https://zhuanlan.zhihu.com/p/22266788</div><div class=\"line\">来源：知乎</div><div class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</div></pre></td></tr></table></figure>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>很多朋友私信问我对机器人和人工智能感兴趣，该怎么展开学习。最近稍微有点空，我写写我的看法。</p>\n<p>两年前，我在知乎回答如何定义「机器人」？ - YY硕的回答中试图给机器人做出一个比较仔细的定义，我觉得机器人和人工智能最大的区别在于是否要和物理世界进行交互。今年初在另一篇知乎回答里对机器人或人工智能的研究会帮助我们更好的了解人类自己吗？ - YY硕的回答我说到传感器是和物理世界交互的基础。后来，我又在知乎回答有哪些与控制、机器人等相关的 quotes？ - YY硕的回答中提到莫拉维克悖论（Moravec’s paradox），谈到了机器人学里公认的难题是在物理世界中实现类人的活动能力。</p>\n<p>把之前的回答再翻出来是为了支持以下观点：机器人学的核心问题是做好和物理世界的交互。现在主流的机器人学分支里，处理与物理世界的交互的学科分为三类：传感器和处理算法（激光雷达，多目视觉，融合算法）；多刚体系统动力学控制（工业机器人动力学控制和接触力控制）；机器人自主移动（locomotion不知道该怎么翻译，轮式、足式、飞行等移动机器人的研究）。我建议对机器人学有兴趣的同学着重在这几个问题上面。</p>\n<p>另外，根据世界第一的机器人教育机构卡耐基梅隆大学的机器人学博士的课程分类方式（<a href=\"http://www.ri.cmu.edu/education/COSAug2016.pdf），机器人学有四个核心领域：\" target=\"_blank\" rel=\"external\">http://www.ri.cmu.edu/education/COSAug2016.pdf），机器人学有四个核心领域：</a></p>\n<p>感知。视觉传感器、图像传感器、触觉和力传感器、惯导等。<br>认知。人工智能、知识表达、规划、任务调度、机器学习等。<br>行为。运动学、动力学、控制、manipulation和locomotion等。<br>数学基础。最优估计、微分几何、计算几何、运筹学等。<br>结合卡耐基梅隆大学的核心课程要求，我觉得我定义的机器人学核心问题算是基本没跑偏的。本文后面谈到的机器人项目都是以上述观点和课程要求为基础。</p>\n<p>一些可能有争议性的观点：</p>\n<ol>\n<li><p>机器人学是富人的活动。虽然工业越来越发达，但好的开发板和电机还是非常贵。如果要下定决心学习机器人学并且做出实物，你必须找到做实物出来的资金。要么是自己花钱，要么就得找学校的机器人社团，或者找什么愿意资助年轻人学习的贵人。另外现在没有任何一本完整的书可以教你怎么造一个四旋翼空中机器人或者大狗机器人，你需要参考十几本不同的教科书，这些书不管中文版还是英文版都很贵。</p>\n</li>\n<li><p>机器人学是屠龙之术。这话是Ninebot创始人说的。虽然最近几年，平衡车、扫地机器人、多旋翼飞行器让机器人学开始进入人们的生活，但是可行的商业应用还是很少，而且已有的机器人和理论都还很难解决好与物理世界交互这件事情。所以一定要确保自己在机器人学这个道路上同时练好了能去其他行当吃饭的技能，比如编程、机械设计和硬件设计。也要做好心理准备，接受自己有可能在学会屠龙之术以后几年都造不出对社会有用的东西的事实。</p>\n</li>\n<li><p>基于上述所说的观点，如果是已经工作之后才想要学习机器人的话，可能已经太迟了，因为很可能兴趣战胜不了客观限制因素。如果作为兴趣去学习，只能学到做巡线小车和舵机机械臂什么的，可能也满足不了中二病的创造欲。</p>\n</li>\n</ol>\n<p>个人认为机器人学是一个艰苦的道路，想要成为一个独挡一面的机器人工程师需要多年理论和实践的同步训练。理论学习和动手实践的过程还要互相排好时间表，在做某个实践项目的同时去学习最相关理论往往可以达到事半功倍的效果，但是同时那些不太相关的理论会看起来非常枯燥，因此如何妥善安排自己的实践项目也是很重要的事情。</p>\n<p>这篇文章里我计划介绍一个电子工程、机械工程和计算机专业学生从大学一年级到研究生二年级的机器人学习计划，基本是我对自己过去学习方式的一个总结。按照这个方法来学习，能够成为一个能力全面，但是稍微偏软件一点的机器人工程师。这个六年的学习计划，估算下来，全年中每天在上课和完成课程要求之外要投入学习时间6-8个小时，这些时间一方面用于阅读课程知识的英文教材，一方面用于阅读其他学科的教材，一方面用于实践项目。</p>\n<p>机器人工程师在大型项目里的定位类似于飞机系统里的总体设计师。和机械工程师、硬件工程师、软件工程师、算法工程师、控制工程师比起来，机器人工程师参与某个具体技术的时间较少，但是能够听得懂所有工程师说的话，能够作为不同模块间的协调人，带领整个团队去攻坚。当然如果机器人工程师能够在一个领域达到那个领域的工程师的优秀水平，肯定更好。</p>\n<p>由于时间仓促，再加上个人水平有限，文章中如有纰漏和错误，恭请读者指出，谢谢。如果同学还有什么想知道的内容和教材，也欢迎留言交流。</p>\n<a id=\"more\"></a>\n<h3 id=\"大一\"><a href=\"#大一\" class=\"headerlink\" title=\"大一\"></a>大一</h3><p>刚上大一，你的机器人生涯开始了。先看看学校的校园网能不能翻墙，不能的话自己去买个一年一百多块钱的VPN，先确保自己能上Google，不要心疼VPN的钱，这能让你在之后的职业生涯里节省上万块钱。然后去注册一个gmail账号，再注册stackoverflow账号，再注册github的账号，再注册CSDN账号，注册完登录上去逛逛，暂时先不要问为什么。</p>\n<p>英语水平一定程度上会是机器人工程师水平的限制因素，英语是同学们在大学最该努力学的一门课，而且不止要把它当成课，要当成一种技能，当成生活的一部分。当你开始努力学习一些高级的机器人知识以后，有可能会非常难以找到中文的参考资料，这个时候如果啃不下英文的资料，进步速度和眼界就会受到很大影响。因此大一的时候要多看看红宝书，看看美剧。</p>\n<p>不管是什么专业背景的同学，大学一年级一定要上好的课是微积分和线性代数。线性代数的重要性需要特别强调。一般来说，优秀的工程师和科学家在职业生涯中要学至少五次线性代数，大一学一遍、学凸优化的时候学一遍、学线性系统的时候学一遍、学机器学习的时候学一遍……如果在第一遍学的时候就看到对的书，刷到对的题，那么以后的学习会轻松很多。</p>\n<p>网上有很多对于如何学好线性代数的讨论，比如知乎问题如何理解线性代数？ - 数学学习。Matrix67大神的文章随记：我们需要怎样的数学教育？也很有启发。我个人对学习线性代数的建议是两本书，一本叫做《Linear Algebra Done Right》，另一本叫做《Linear Algebra Done Wrong》（<a href=\"https://www.math.brown.edu/~treil/papers/LADW/book.pdf），我比较喜欢的是Done\" target=\"_blank\" rel=\"external\">https://www.math.brown.edu/~treil/papers/LADW/book.pdf），我比较喜欢的是Done</a> Wrong这本书，第一它是免费的，第二只需要读前6章两百页就够了，第三它页边距很大，打印出来有很多空白做练习题。另外一个较好的教材是麻省理工公开课：线性代数。不论如何，学线性代数一定要用国外的教材，千万不要用国内的教材。啃英文书很累，但是考虑到之后还要啃更多的英文书，线性代数已经算是很入门的了，一定要啃下来，同时还要刷足够多的课后题。</p>\n<p>学完线性代数以后，一个自然而然的问题就是怎么能用计算机自己去计算矩阵的乘法、向量的乘法、向量的内积。因此引入了编程的学习。</p>\n<p>不管同学的专业是什么，一定要在大学一年级尽早开始学编程。至于用哪种语言开始学习编程，我推荐Python，比较好的教材是麻省理工学院公开课：计算机科学及编程导论，比较好的Python开发学习环境是Anacoda (<a href=\"http://www.continuum.io/downloads)。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。\" target=\"_blank\" rel=\"external\">http://www.continuum.io/downloads)。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。</a></p>\n<p>对任何人来说，Python是一把瑞士军刀，你可以用他干很多东西，比如自动回复邮件、自动收集信息。但是真要去造机器人，合适的工具并不是瑞士军刀，而是C/C++这样简单粗暴的锤子和螺丝刀般的工具。在学习Python学到一定程度的时候（比如你听说有一种叫做cython的东西），最好开始学习C，而且要强迫自己练习用C的一维数组和指针来实现矩阵的加法、乘法、求逆等操作。之所以有高级的Python或者Java（不要问我Java哪里高级了）这些语言以后我们还需要去学C，是因为机器人上常用的不是完整的电脑，而是计算量有局限的嵌入式系统，嵌入式系统开发基本只能用C或者更低级的语言。</p>\n<p>学习C我个人入门用的是清华大学出版的《C++语言程序设计》。虽然这个书标题是C++，但其实没什么太大问题。不过国内的C语言教材都有个巨大的问题是不引导学生去用Linux。近年来更好的一个教材是<a href=\"http://songjinshan.com/akabook/zh/index.html，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。\" target=\"_blank\" rel=\"external\">http://songjinshan.com/akabook/zh/index.html，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。</a></p>\n<p>IT行业的程序员都会争论高级语言和低级语言哪个好，Linux和Windows哪个好，而对于机器人工程师来说，从现在到可预见的未来里，C是最好的语言，Linux是最好的操作系统，这都毋庸置疑。甚至对于Linux的发行版该选哪个，我们都是很少有质疑的：Ubuntu（The leading OS for PC, tablet, phone and cloud）。原因是机器人操作系统ROS<code>（ROS.org | Powering the world&#39;s robots）</code>是基于Ubuntu开发的，因此在Ubuntu上运行最稳定。注意Ubuntu出了一个中文版叫做Kylin，个人感觉比较坑，建议大家不要装中文版。Ubuntu 作为一个开源操作系统，总是在快速迭代，2016年8月比较稳定的版本是14.04和16.04，建议同学安装14.04。</p>\n<p>当你把C学得差不多，开始要学写包含多个头文件的程序时，一定要同时学习makefile的知识。这时候要上网去搜“Makefile详解”（Makefile详解（超级好）_mingw吧）这篇文章看。</p>\n<p>我自己在大学一年级的时候还学习了HTML和Javascript，到大一结束的时候已经能够熟练用Javascript手写一些动态页面。我个人觉得HTML和Javascript也是机器人工程师必备的技术，而不只是软件工程师的玩具。这是因为web技术实际上已经渗透到了编程的方方面面，比如json开始是Javascript里的一种object定义的方式，但现在已经成为了一种很标准的数据交互、参数配置的格式。另外AJAX能够帮助初学者理解一定的网络技术原理，而网络技术也是机器人工程师必备的技能。再者，制作GUI（图形用户界面）是常规debug的办法，而近年来一个流行的趋势是用webkit嵌入程序用HTML和Javascript作为图形界面的后端，而在机器人操作系统ROS<code>（ROS.org | Powering the world&#39;s robots）</code>里，通过rosbridge可以非常方便地把机器人程序的数据传递到websocket上，这句话看不懂没关系，反正你知道学学HTML和Javascript很重要就是了。更重要的是，HTML文档背后的DOM (Document Object Model)深刻地体现了面向对象的思想。大学中的面向对象程序设计一般都讲C++，在我看来应该讲HTML和Javascript。这一点不细说了，如果同学们去学习HTML和Javascript，自然会体会到。学习HTML和Javascript比较好的资料是<a href=\"http://www.w3schools.com/，把网站左侧的“Learn\" target=\"_blank\" rel=\"external\">http://www.w3schools.com/，把网站左侧的“Learn</a> HTML”、“Learn CSS”、“Learn Javascript”和“Learn JQuery”学完就行，别的部分还有很多花哨的技术，没有必要去学了。为了培养自己对Javascript的兴趣，可以上three.js / examples跪着看看热闹。</p>\n<p>以上介绍的这些知识点、书和资料应该在大一期间就全部看完，然后利用大一的暑假好好巩固这些知识。比如开始用HTML和Javascript做一个自己的个人主页，刷一刷编程的题目，学用Python的奇技淫巧（比方说做一个自己的个人主页）。另外还可以抽时间学学数学知识，比如开始看看代数和离散数学。我大一的时候看到了两篇文章，认识到了数学的重要性，一个是MIT的CV大牛林达华写的[转]MIT牛人解说数学体系，另一个是前Goolge研究员吴军博士写的《数学之美》（数学之美 (豆瓣)）。当时林达华还在MIT读博士，而《数学之美》还没有成书。两篇文章看完以后我感觉自己整个人对数学的认识上了一个新的层次，此后一直在注意提高自己的数学水平，几年下来觉得收益很大。在之后的介绍里我还会多次强调需要学的数学知识和对应的教材。</p>\n<h3 id=\"大二\"><a href=\"#大二\" class=\"headerlink\" title=\"大二\"></a>大二</h3><p>上大二的时候，你已经会了基本的编程知识和基本的数学知识。大二这一年应该投入在嵌入式系统的学习中，同时继续拓展自己多方面的能力。学校的机器人社团，比如做Robocon，RoboMasters的团队应该在招新了，赶快去加入，有了学长学姐的指导以及同辈朋友的鞭策，应该会进步的快一点。</p>\n<p>大二应该掌握的技能：Solidworks画基本的机械图，基本的数字电路知识、数模转换，51单片机、AVR单片机、STM32单片机原理，UART、SPI、I2C、CAN等协议的原理和数据收发，STM32开发板的使用，电机转动和驱动的原理，PID的原理，调试四轮机器人底盘的移动，基本的传感器如陀螺仪、码盘、红外线、超声波的原理和读取方式，网络知识如配置IP配置路由器等，微电子焊接，金工技术。我在知乎回答如果程序员每天都浅尝辄止地学一些不同的新技术，长久以往，人会变成什么样子呢？ - YY硕的回答里谈过机器人工程师需要的技能数量是IT行业全栈工程师技能数量的三倍以上，这些技能的基础都应该在大二开始积累。</p>\n<p>如果同学们的专业是机械工程相关，那么大二的时候要深入学习solidworks做图，买机械加工手册学习各种机械的奇技淫巧。你的专业知识还不足以让你进行缜密的受力分析，不过你可以尽量多做一些机械结构出来感受它们的乐趣。</p>\n<p>如果同学们的专业是硬件、电路相关，那么大二的时候要深入学习Altium Designer做图、制板、焊板。你要从现在开始，就给自己积累一个工作记录，可以就是简单的txt文件，记录你做过所有板子的bug、解决方案、学到的原理图、PCB layout的注意事项等等。积累很多年以后，你的这个工作记录会值很多钱。</p>\n<p>学习这些技能的最好的方式，就是参加自己学校机器人社团的训练和方案设计。一般来说，学校的机器人社团招新之后会有训练和测试，让新人分组去做机器人，这个过程中如果愿意努力学，提高得会很快。如果你所在的大学是机器人比赛强校，比如西安交通大学，电子科技大学，哈尔滨工业大学，华中科技大学，东北大学等等（排名不分先后，没有提到你们学校名字的话我表示抱歉），那么你很幸运，你们学校的机器人社团有很好的积淀，有很多资源可以帮助你学习。基本上只要天天泡实验室，保证自己每天只睡6-7个小时（但还是要多去跑步、游泳保持身体健康），勤于向学长学姐请教，那么一定会提高得很快。</p>\n<p>大二阶段特别要强调的是对动手能力的培养，包括机械材料的加工、电路焊接、制作导线和接头、连接路由器、配置网络、做网线等等。机械加工的工具有螺丝刀、锯、钻、锤子、车床、铣床、钻床，进阶选手可以学一下氧焊，这个比较危险，我没尝试过；电路焊接的工具有焊机、焊锡、洗板水、松香、吸锡器；制作导线的工具有剪子、剥线钳、夹头钳、网线钳各种钳；网络配置就是连连路由器插插网线，但是Linux系统下配置网络有时会非常麻烦，一定要多积累这方面的知识，因为将来你造的机器人多半会顶着一个无线路由器跑来跑去，甚至有的机器人上各个模块自己就能组起一个小局域网。这些技能的熟练掌握需要你花很多时间去做真正能用的机器人来练手。</p>\n<p>对于该选择造一个怎么样的“真正能用的机器人”练手，最好的选择肯定是机器人比赛中的机器人。如果参加Robocon，你会跟着学长学姐们学着造有人那么高的巨大机械；如果参加RoboMasters，你会学着造比汽车还要灵活的机器人以及快速发弹的机构。其他一些小型的比赛比如飞思卡尔智能车，也是很好的训练，因为飞思卡尔智能车已经发展得很成熟，参加这个比赛的参赛资料就够学一阵子的，学完以后能够获得比较多的机器人技能。</p>\n<p>如果没有太多学校机器人社团的资源，同学们还有一些小型的比赛比如挑战杯、大创比赛等等可以选择，以三五个人的小团队参与这些比赛。如果同学所在的学校连这些比赛都不组织大家参与，那就只好自己花钱了。国内开源机器人社区有很多资源可以利用来学习，比如自己买Arduino STEM educational Robot kits Building Platform的各种开发套件做简单的机器人。Arduino的开发环境可能有些人不喜欢，因为它对硬件做了一级封装，如果更希望接触到单片机的本质，可以自己买STM32开发板学习。俗话说，没有什么嵌入式系统是一块STM32实现不了的，如果有，就用两块。STM32是ARM Cortex‑M家族中最为广泛应用的一款单片机，在网上也有很多的教材和开发板可供选择。在国内著名的电子论坛STM32/8 分论坛帖子清单 (amoBBS 阿莫电子论坛)上，有很多参考资料，有问题也可以在这里和大家讨论学习。</p>\n<p>如果你很想参加机器人比赛，身边也恰好有一些志同道合的小伙伴，但是学校不支持。没关系，来找我，我尽量通过大疆的关系说服你们学校支持你们参加RoboMasters。</p>\n<p>虽然你是以机器人比赛为主线在探索机器人技术，但是要时刻记得，机器人比赛给你的理论方面的训练很差，还会让你养成一些坏习惯，比如凡事都希望用一些糙猛快的办法来解决。由于通常整个团队都没有太多的项目管理经验，到比赛前一段时间才会加紧功夫去做机器人，很多时候就会用“山寨”的办法去处理机器人的故障。比如说某个承重结构用久了会弯，为了赶比赛的进度，就拿锤子敲直了、再加一条辅助的结构在旁边继续用，而没有细致地去做建模、受力分析，思考是什么原因导致承重结构会变形。再比如说调PID参数就是生调乱改，而没有基于机器人的动力学模型去估测参数的大概范围。</p>\n<p>大二的暑假，有可能你跟着学校的机器人队参加了一些机器人比赛。这是一个反思总结的好时机，为什么机器人队取得了这样那样的成绩？整个团队怎样才能更有效率？明年如何继续招新？暑假要把时间花在技术积累上面，这个时候可以回头思考思考之前准备比赛时用糙猛快的办法解决的问题如何能够细致地去解决。</p>\n<p>如果大二的暑假没有参加机器人比赛，可以做一个舵机机器人，比如6条腿的蜘蛛，比如码垛机器人。舵机是机器人工程师的好朋友，一定要好好掌握。</p>\n<p>另外你其他方面的能力也不能落下。大二结束的时候，你的Linux应该用的很熟练了，除了makefile，你也用起了cmake。你也应该开始理解Github存在的意义，因为你已经上去读了很多别人的代码，你也把自己的一些课程设计和小项目放在了Github上面。另外大二基本上了本专业一些比较难的基础课程，比如自动控制原理、机器学习、概率统计、材料和力学等课程，同学们会看到这些课程里又用到了线性代数和微积分的知识，以及建模的知识。这时候可以把大一的物理、线性代数和微积分再翻出来看看。</p>\n<p>同学的学校应该给大二到大三的学生有开设面向对象的程序设计，一般用Java或C++教授。在面向对象的程序课里面，一定要积累3000行左右的代码的开发经验。经典的面向对象程序设计的练习通常是写游戏，比如俄罗斯方块，吃豆人等等，一定要自己能够做到完全手写一个完整的项目出来。</p>\n<p>另外你可以开始学习Matlab当中的神器Simulink了。在大二这一年的学习中，你可能在不少课程里多多少少用到了Matlab。假设你已经在我的推荐下喜欢上了Python，你可能会觉得Matlab的计算工具没有比Python强多少；假设你自己在别人的推荐下喜欢上了mathematica（Mathematica 到底有多厉害？ - Wolfram Mathematica），你可能会觉得和Mathematica这种神一样的语言比起来，Matlab弱爆了。但是要注意的是，Matlab最强大的工具是Simulink，通过它你几乎可以仿真一切的物理系统和控制系统。我建议同学可以通过Simulink实现一个倒立摆，然后理解Matlab的强大之处。对此我强烈推荐一个很好的教材（<a href=\"http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（Control\" target=\"_blank\" rel=\"external\">http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（Control</a> of an Inverted Pendulum on a Cart）的文章。阅读并实现了这两篇文章里的内容，同学应该会对倒立摆有了比较深刻的认识。倒立摆是机器人学中一个非常重要的模型，因为火箭、导弹、双足机器人、四足机器人，基本都是倒立摆的变形。你自己实现出来的simulink模型一定要存好，以后可能还会再拿出来仔细看。</p>\n<p>如果你按照我之前说的方法探索了一些HTML和Javascript的技术，那么JQuery，bootstrap，AngularJS你已经多多少少知道是怎么回事了。web后端的技术，比如PHP和MySQL，也可以了解一下，LAMP要学会怎么配置。如果有同学找你帮忙写小网站，尽量去帮个忙，帮别人做网站是提高自己系统编程能力的好练习。在做网站的过程中你可能还会顺便学一学如何用Photoshop和Illustrator让网站显得更漂亮。这些技能有最好，没空学也没关系。</p>\n<h3 id=\"大三\"><a href=\"#大三\" class=\"headerlink\" title=\"大三\"></a>大三</h3><p>大三开始的时候，你可以在学校的机器人队里担任重要角色了，或者能够带领一个小团队参加小型的机器人比赛。你在系里甚至院里都小有名气了，可能有的人叫你大神，有的人觉得你技术还不错。但是一定要记得你现在的水平放到别的地方应该不算什么。每年我都往大疆的RoboMasters夏令营招进100个和你现在的水平相当的同学。</p>\n<p>大三一定要培养出自己一个人独立造出一个完整机器人的能力，比如一个Robocon水平的机器人，或者一个RoboMasters的战车，或者一个四旋翼飞行器。</p>\n<p>Robocon水平的机器人，涉及大量的机械设计，单片机开发，电机驱动的开发，码盘和超声波等传感器的读取，底盘运动学的计算，PID调试，任务调度逻辑的调试，舵机控制。RoboMasters的战车的机械部分简单一些，但是还需要进行云台的控制、发弹系统的控制、功率控制等方面的知识，另外你也可以不搞这些部分，学习学习视觉识别和自动打击，那么就要开始研究OpenCV（OpenCV | OpenCV）了。</p>\n<p>四旋翼飞行器的机械部分最简单，但是算法比较复杂。对于大三学生来说，从零开始一步到位写一个稳定的飞控比较困难，因为飞控里面有很多细小的知识点要注意。目前我没有发现什么比较好的书籍推荐，已有的一些关于四旋翼系统的书要么太浅（上来就教你焊电路），要么太深（上来就教你state estimation），听说 @Liu Top的exbot小组在写一个教材，我是非常期待的。学习四旋翼飞行器有下面几个步骤：</p>\n<p>第一步：自己调一个小四轴飞起来<br>现在开源社区的人言必pixhawk，其实我觉得从学习的角度来说，pixhawk太贵，而且不适合学习，我比较推荐的是 首页-第七实验室 这家淘宝店卖的STM32F405飞控，买回来以后自己再随便买个机架（比如大疆F450）、接收机和遥控，就能按照飞控板附带的学习资料、调试软件飞起来。</p>\n<p>第二步：看硬件图、读代码<br>chiplab7的飞控板附带一大堆学习资料，对加速度计、陀螺和磁感计都有很仔细的解释，硬件链路图也很详细。chiplab7淘宝掌柜的又很认真负责，我学用的时候，发现代码有bug和看不懂的地方，都可以直接找掌柜问。</p>\n<p>看完代码以后，对一个飞控系统的基本模块：姿态解算、控制解算、混控输出、遥控器处理、嵌入式处理就很明白了。然而这里面有很多技术是需要另外学习的。除了基本的嵌入式编程以外，还有要把大二大三学的信号处理方面的知识再捡起来看看。因为飞行器在空中有振动，会让加速度计产生噪声，为了把这些噪声去除掉，需要对加速度计给出的信号做低通滤波处理，如何选择滤波器的参数呢？如果滤波滤得太狠，延迟就会比较大，对控制的表现会有影响；如果滤波滤得不够，可能会有一些低频的噪声偶尔会出现，导致加速度计的观测不能用。另外最重要的是要理解姿态解算和控制解算这两块知识。chiplab7的飞控板的代码采用的是最简单的互补滤波算法做为姿态解算模块，然后控制解算是对欧拉角的三个角度做闭环PID控制，基本都是基础的基础了。</p>\n<p>第三步：小修小改加深理解<br>chiplab7的飞控是靠气压计定高的，飞行效果非常奔放。这时候可以淘宝买个20块钱的超声波模块，然后自己写个高度环去稳定飞控的定高表现。</p>\n<p>我觉得这个过程至关重要，因为高度控制相对来说是个比较直观理解PID控制的方式，而且chiplab7的飞控加高度控制非常好加。工作量不大，因为改善效果很显著，所以可以让人很有成就感，加深继续学习的乐趣。</p>\n<p>第四步：理解核心的数学和控制知识<br>这一部分大三是肯定来不及学的，但是我还是在这里列出来，因为这些知识你之后都需要慢慢学，我也会在之后不断重复提到这些知识点。<br>姿态解算和控制解算涉及的知识有：</p>\n<ol>\n<li>刚体姿态的表示、运动学方程和动力学方程。主要是对牛顿-欧拉方程的认识和理解、刚体姿态的欧拉角表示法、姿态与角速度的关系等等。<br>这部分说复杂不复杂，说简单也不简单，我同样是没有找到一本完整的书全都介绍过的，是学了好几个不同的书和论文以后搞明白的。现在看起来是从维基百科入手比较靠谱。</li>\n<li>自动控制原理。讲PID的书和文章就多了去了，没有太多复杂的书。</li>\n<li>线性估计基本原理。其实就是互补滤波：Reading a IMU Without Kalman: The Complementary Filter 。拿这个关键词百度各种搜就会了。<br>第五步：重头开始造轮子<br>知乎著名网友vczh曾经说过，学习要抱着勇于造轮子的心态才能进步。所以在熟悉了别人飞控基础上，可以自己重头造一个飞控的轮子。可以自己从芯片开始重新画一个飞控板，读读STM32的芯片手册、读读各种传感器的芯片手册，自己手画一个飞控的原理图、做PCB layout、制板自己焊元件，全套花不了1000块钱，能够加深很多对硬件的理解。这一部分如果大三没空，也可以不搞了。</li>\n</ol>\n<p>制造整个机器人的过程中要特别重视文档的积累。在你大三末期，你可能随着学校的机器人队备战比赛，你可能主力负责一台机器人。你应该自己列一个excel表格，把机器人用了几颗螺丝，几根导线，每个零件的规格是什么，都列出来。这个表格一方面可以用来帮助团队管理机器人的物料，一方面也是你自己的经验技术积累，将来你做的其他机器人可能多多少少都是Robocon、RoboMasters机器人的变形。</p>\n<p>另一个积累是建一个自己的buglist，buglist包括什么呢，可以像冷大这样：做控制、机器人等算法工程师是怎样一种体验？ - 冷哲的回答，就简单把一些自己的发生过的问题和最后的解决办法罗列下来。比如说“杜邦线接插位不稳固容易脱开，接好后应该用电工胶布再裹一圈”，“外发给淘宝加工的机械图纸，要特别注意和加工商沟通有没有漏掉一些细节，如沉头螺丝孔，关键的倒角”等等。你也可以帮其他机器人的问题也做这样的记录。buglist可以就是一个简单的文本文件，如果你一直往里面积累自己工作中的记录，等你将来工作了，这个文件可能会值很多钱。</p>\n<p>大三的时候学校应该会开设软件工程的课程。不管你是不是这个专业，上不上这门课，都应该主动去听一听，甚至跟着课程的设计作业一起做一做。软件工程我觉得是机器人工程师必须具备的意识，因为一个机器人系统里涉及大量的硬件系统和软件功能，软件的部分往往还会涉及不同的语言、不同的编译环境、不同的开发工具链。几个人合作的话，大家的专业背景、编程习惯都不相同，这就导致不同的代码和模块之间的协议沟通非常复杂，必须尽早用UML和其他软件工程的工具帮助团队理解和互相沟通。</p>\n<p>大三的时候学校应该还会开设操作系统原理和嵌入式系统原理的课程，而大二的时候讲过计算机组成原理（所谓的微机原理）。从大三开始同学需要开始体会实时操作系统和非实时操作系统的区别、原理以及使用时需要注意的地方。这是一个比较杂的知识点，我目前没有找到很好的教材去介绍。在STM32上，有freeRTOS，uCOS，Vxworks这么几种实时操作系统；Linux是一种非实时操作系统，但是可以通过打补丁变成实时操作系统。这些操作系统的细节在机器人开发中都会多多少少被涉及到，同学们可以随时上Google和CSDN去查大神们的介绍。</p>\n<p>另外特别重要的一点是机器人系统里的嵌入式平台都有烧坏的可能性，有可能在某个嵌入式Linux平台上面辛辛苦苦写了一个多月代码，这个平台突然烧坏了，代码也就丢了。因此你的机器人如果有嵌入式Linux系统在里面，一定要尽早顶起来路由器，代码定时提交SVN或者git。</p>\n<p>大三的暑假你可能会作为学校机器人队的主力去参赛了。备战比赛和参赛是一件磨练心性的事情。我在学生时代体会过和胜利擦肩而过的痛苦，体会过没机会再来一年的遗憾；也在负责大疆RoboMasters比赛的过程中被那些痛苦和遗憾的学生当做发泄的对象，非常有感触。我觉得参加机器人比赛，很努力，然后失败了，是一件让人快速成长的事情。同学如果有机会，一定应该参加至少一届机器人比赛。</p>\n<p>大三的暑假你也可以选择来参加大疆的RoboMasters夏令营，关于夏令营大家可以看这个知乎问答了解更多：参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新。每年我们都在全国范围内寻找有一定技术基础的学生，让他们一起分组做一个自动机器人的挑战。这个夏令营，作为组织负责人，不谦虚地说，我觉得应该是全世界范围内最好的技术类夏令营。</p>\n<p>大三的暑假有一件很重要的事情就是思考自己大四应该干什么。一般来说，你现在的能力保本校研究生肯定没有问题，当然你也可以选择考其他学校的研究生或者出国留学。虽然说你现在能力已经很全面了，但是你还需要2-3年的时间全面提升自己更多的能力，才能迈向卓越之路。不管是出国还是保研，最重要的目的是给自己争取到未来2-3年能够在一个优秀的环境中安心提升自己，有比较好的学习资源，能够参与到一些不错的项目中去。可能其他有些行当，出国留学始终是比在国内待着更好的选择，但是机器人行业并不是这样。我们国家这两年在机器人方面提高也很快，而且我们国家现在比较有钱。就像我开始说的那样，机器人是富人的活动，现在你在国内也能找到一些很有钱的实验室可以造比较牛逼的机器人。另外国外很多比较强的机器人公司也都在做比较敏感的军方项目，去找实习可能比较受限制。</p>\n<p>出国去学机器人学方面的知识你有很多不错的选择，比如世界第一的机器人研究院卡耐基梅隆大学，或者麻省理工学院的CSAIL实验室。北美传统计算机四大名校（麻省理工学院，卡耐基梅隆大学，斯坦福大学，加州大学伯克利分校）里，除了斯坦福大学热火朝天在搞人工智能以外，其他几个学校的机器人研究都很不错。除了四大名校，你还有很多其他的选择，就像我开始说的那样，机器人是富人的活动，如果想接触到最好的机器人资源，你要选择有钱的实验室，而不是有名的实验室。</p>\n<p>另外你还需要在大三的尾巴上选定自己将来的细分研究方向，而且开始往这个方向深挖，也就是我在文章开始提到的感知、认知、行为几个方向。当然同时你也不能放松其他方面的知识，尤其是数学基础。我在大三的暑假专门找数学系的同学给我开了个数学小讲座，学习了一点抽象代数的知识，对我后来学习密码学帮助很大。同时我也读了一些拓扑方面的教材（有一本很神奇的书叫做Topopogy Without Tears <a href=\"http://www.topologywithouttears.net/），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。\" target=\"_blank\" rel=\"external\">http://www.topologywithouttears.net/），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。</a></p>\n<p>大三阶段的机器人工程师该学什么基础数学是众说纷纭的，在我看来，你要基本掌握“群是什么”，能够用代数的眼光去证明”det(AB) = det(A)det(B)”，还要能理解“用一张纸就可以变出克莱因瓶”（当然是在四维空间里）。另外，你这个时候也要能够意识到自己需要再学一遍线性代数。</p>\n<h3 id=\"大四\"><a href=\"#大四\" class=\"headerlink\" title=\"大四\"></a>大四</h3><p>大四开始了，你可以开始深挖自己的研究方向，同时也要开始学一些高级一点的通用技术和理论，这时候你和一般的机械、电子、计算机学生就不太一样了，你虽然也在狂编程，但也在狂学习物理和数学。通用技术包括ROS，simulink，gazebo和Vrep等工具。通用理论包括，再学一遍线性代数，学学凸优化、数值计算、旋转表示法等方面的知识。这些知识你在大四仅仅只能开一个头，因为你的大四要实习、毕业、考研、毕设，你会非常地忙。有些人会在大四进实验室和老师发论文，我个人觉得发论文这件事没必要操之过急。你的整个大学期间应该用在广泛涉猎各种各样的知识上面，而不是深入某一个细小的研究问题。</p>\n<p>大四可以开始读一些著名入门书籍，我把这些书不分先后地列出来，你没有必要全部去读，而且每本书先读前几章就够了，能读多少尽量读多少。</p>\n<ol>\n<li><p>概率机器人学，<a href=\"https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623\" target=\"_blank\" rel=\"external\">https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623</a></p>\n</li>\n<li><p>凸优化，<a href=\"https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf\" target=\"_blank\" rel=\"external\">https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf</a></p>\n</li>\n<li><p>线性系统理论，<a href=\"https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579\" target=\"_blank\" rel=\"external\">https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579</a></p>\n</li>\n<li><p>Multiple View Geometry in Computer Vision，Multiple View Geometry in Computer Vision</p>\n</li>\n<li><p>线性估计，<a href=\"https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642\" target=\"_blank\" rel=\"external\">https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642</a></p>\n</li>\n<li><p>《机器学习》，周志华老师的书。</p>\n</li>\n<li><p>An Invitation to 3-D Vision，<a href=\"https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf\" target=\"_blank\" rel=\"external\">https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf</a></p>\n</li>\n<li><p>Modern Control Systems，<a href=\"https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580\" target=\"_blank\" rel=\"external\">https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580</a></p>\n</li>\n<li><p>Rigid Body Dynamics，<a href=\"http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。\" target=\"_blank\" rel=\"external\">http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。</a></p>\n</li>\n<li><p>Feedback Systems: An Introduction for Scientists and Engineers，FBSwiki</p>\n</li>\n</ol>\n<p>就像我开始说的那样，这些书，大部分特别贵，还好有一些业界良心的作者放出了他们书的电子版。当然你也可以去一些名字都不能说的网站去找影印版。</p>\n<p>在读上面这些书的时候，matlab，python都要放在手边，然后把书里面的知识尽量实践出来。很多教科书里都会在章节后面的习题里放一些写明是用matlab做的习题，要尽量多做一些这样的题。</p>\n<p>你可能早就听说了ROS的大名，但是最好不要在大四之前去碰它。因为ROS用了很多操作系统和网络的底层技术。我在知乎回答高手可以谈谈ROS机器人操作平台开发的一些经验吗？ - YY硕的回答里有简单的介绍。ROS的设计目标是把机器人的控制和传感器处理的软件和它的硬件隔离开，用上ROS以后，你可以方便地用到很多能直接跑的软件代码。但是ROS从入门到精通需要至少一年以上的时间，你必须不断地用，不断地尝试新的代码和硬件，才能对它熟悉起来。</p>\n<p>ROS的可视化工具Rviz里面对于机器人旋转的表示用的是四元数，而在你之前研究四旋翼飞行器时，里面的代码表示旋转用的是欧拉角，做姿态解算用的可能是四元数。这个时候要开始有意识地去学习旋转表示法之间的区别和联系。</p>\n<p>要重视大四期间的实习和毕业设计。很多大四的学生毕业设计都会非常颓地做一下，我觉得是不好的。要把做毕业设计的过程看做一个正式的项目。这个项目除了做好技术方面的工作，也要做好展示方面的工作。中国工程师的一大特点是，不会表达自己，可能做的东西水平很高，但是做出PPT就会犯字体花哨不正式、一页上面字太多，图文没有联系等表达上的问题。通过PPT介绍、展示自己的成果在工程师的职业生涯的任何一个阶段都非常重要，它甚至也一定程度上限制了机器人工程师能够达到的高度。只有能够把自己的成果清晰地表达给自己的团队，才能获得其他人的反馈、通过沟通提高团队的整体凝聚力和知识水平，这样自己在团队能够获得更多的认可，有助于团队整体工作效率的提高。我每年去参加几次学术会议，都在会议上感觉到一些中国的科研人员走到国际上以后，演讲能力很差就会导致他们的科研成果不受重视。当然其他国家的科研人员也是这样。</p>\n<p>为了写出美观的技术报告和毕业论文，你可以开始学习Latex。Latex作为国际国内第一写作神器，学习资料在网上有很多。Latex的学习和使用同样也是需要不断地熟能生巧，多写多练就熟悉了。写毕业论文有个问题是怎么做出精美的矢量图，我推荐Draw Freely | Inkscape，一个比Illustrator更轻量化、但是有些功能反而更强大的免费软件。</p>\n<p>对于那些想申请出国留学的同学，你要做一个自己个人的成果展示，用网页的形式呈现比较好。把自己Github链接（如果你按我说的，大学第一天就申请Github账号，现在已经是一个三年的老油条了）、做过的机器人视频、写过的技术报告和文章（最好是英文的）放在上面。</p>\n<p>关于毕业设计的选题，我推荐这么几个：</p>\n<ol>\n<li><p>手写双目视觉里程计。涉及到图像处理、特征匹配、位置解算、空间变换等等。</p>\n</li>\n<li><p>手写四旋翼飞行器基于GPS的轨迹规划。涉及到深挖四旋翼飞行器的运动原理、IMU原理、轨迹生成和优化等。</p>\n</li>\n<li><p>造一个被推了也不会倒的双足舵机机器人。涉及到舵机控制、倒立摆建模、动力学分析、PID控制、IMU原理等。</p>\n</li>\n<li><p>深度学习训练一个小车追人跑。涉及到深度学习工具包使用、数据集采集、数据集分析、小车控制等。</p>\n</li>\n<li><p>机械臂给人端茶倒水。这个相对来说土豪一点，因为能直接拿来用的机械臂都很贵，这个要看实验室有没有条件了。涉及到多自由度机械臂原理的学习、工具包的使用、轨迹规划等等。</p>\n</li>\n</ol>\n<p>这几个项目要做好，都要持续投入三个月以上的时间以及一定的资金，每一个都是理论多于实践。当然同学们自己也可以自己选择自己的毕业设计题目，但是最好还是选做出来能跑能飞的东西，同时避免选择需要花大量时间去拧螺丝、焊板子的题目，尽量买现成的电机、开发板、3D打印结构，大四要多给自己留时间去看书和写代码。</p>\n<p>大四到研究生之前的暑假，最好去一些比较不错的机器人公司实习一下，比如说大疆。当然你也可以继续做机器人比赛，比如RoboMasters和大疆的飞行器比赛。</p>\n<h3 id=\"研究生一年级\"><a href=\"#研究生一年级\" class=\"headerlink\" title=\"研究生一年级\"></a>研究生一年级</h3><p>研究生的时候，你的目标比较清晰了，就是做一种机器人至少两年时间，并从中发掘出可以发表论文的知识点。上面我给出的书单里面，你要开始精读里面的几本。</p>\n<p>如果做机器人视觉定位、传感器融合方面的研究，1、4、5、7四本书一定要精读。</p>\n<p>如果做控制系统的研究，3、8、9、10一定要精读。</p>\n<p>如果做规划算法的研究，那么还要读其他偏CS一些的书，比如讲A* search，random forest，图论方面知识的教材。由于我在这方面造诣不深，就不托大了。</p>\n<p>如果学习随机系统的控制和最优控制，除了1、2、3，还要读一本神书Stochastic models estimation and control（<a href=\"https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）。\" target=\"_blank\" rel=\"external\">https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）。</a></p>\n<p>如果研究机器人视觉定位，几种常用的定位算法：PTAM（Parallel Tracking and Mapping for Small AR Workspaces (PTAM)），ROS的标配VO（viso2_ros - ROS Wiki），SVO（GitHub - uzh-rpg/rpg_svo: Semi-direct Visual Odometry），LSD-SLAM（<a href=\"http://vision.in.tum.de/research/vslam/lsdslam）ORB-SLAM（GitHub\" target=\"_blank\" rel=\"external\">http://vision.in.tum.de/research/vslam/lsdslam）ORB-SLAM（GitHub</a> - raulmur/ORB_SLAM2: Real-Time SLAM for Monocular, Stereo and RGB-D Cameras, with Loop Detection and Relocalization Capabilities），都必须自己学习之后全部跑一遍。只会用OpenCV的函数和这些工具包并不能说明你会视觉定位，必须要能自己手写出一个能用的才算。国内有一个很厉害的SLAM专家叫高翔，他的博客要关注一下：机器人 - 标签。由于SLAM这两年很火，研究的人很多，所以网上可以参考的资料也很多，比如<a href=\"https://github.com/hcdth011/ROS-Hydro-SLAM，就在ROS上实现了几种定位算法的对比。\" target=\"_blank\" rel=\"external\">https://github.com/hcdth011/ROS-Hydro-SLAM，就在ROS上实现了几种定位算法的对比。</a></p>\n<p>我现在非常不建议同学们选择从四旋翼飞行器的动力学控制里找问题作为研究课题。因为四旋翼飞行器的特点已经被研究透了。目前国际上对多旋翼飞行器的研究主要集中在造一些奇葩形状的飞行器，以及给多旋翼飞行器上安装一个机械臂去做力控制，这样做就对多旋翼飞行器控制的动力学造成了一些影响。因此需要同学对动力学和多自由度机械臂控制有比较深的认识。</p>\n<p>自动导航和驾驶是这两年的热点，一方面汽车的自动化是大势所趋，另一方面多旋翼飞行器异军突起，产生了很多对自动飞行的需求。除了机器人视觉定位算法以外，同学还需要学习其他的传感器，以及这些传感器与视觉定位算法怎么融合。这里面有很多坑，比如计算量的问题，怎么保证融合算法不崩，怎么处理传感器的延时等等，都需要同学结合自己的项目去踩，坑踩得多了才能成长。如果大家想找一个多旋翼飞行器平台研究自动导航，我推荐大疆的M100，我已经在知乎回答RoboMasters2015夏令营是怎样的？ - YY硕的回答里吹过一波M100，前面说过的今年夏令营的知乎回答参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新里也有人帮我吹了一波。</p>\n<p>一些大学里学过的知识点，是必须结合研究生期间的项目的需求弄得很清楚的，比如三大变换（傅里叶变换，拉普拉斯变换，Z变换），旋转表示法（欧拉角、四元数、旋转矩阵），数值计算怎么防止矩阵出现数值问题等等。除了自己的项目，还需要把凸优化、卡尔曼滤波还有多自由度机械臂的控制学习一下。这三个领域的知识，是任何一种机器人都会用的到比较难的知识。</p>\n<p>凸优化和凸优化的各种变形是非常重要的知识，因为各行各业里的研究问题，多半是会建立一个优化问题去解决的。上面提到的《Convex Optimization》<a href=\"https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf，也是一本神书，同学们一定要认真读一读。Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient\" target=\"_blank\" rel=\"external\">https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf，也是一本神书，同学们一定要认真读一读。Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient</a> descend，barrier method等等。另外现在主流的SLAM算法，后端都是通过一种叫做g2o的优化算法来出效果的。而且g2o能够整合bundle adjustment 和structure-from-motion这两大计算机视觉里的关键问题，可以说是一种很好的计算思想了，非常有必要学习一下g2o。</p>\n<p>卡尔曼滤波在上面书单里的1和3都有提到，同时在神书Stochastic models estimation and control（<a href=\"https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。\" target=\"_blank\" rel=\"external\">https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。</a></p>\n<p>多自由度的机械臂的难点在于机械臂的运动学正反解、运动学控制和动力学控制，基本是一个建模分析和数值算法实现的问题。如果你所在的学校没有一个财力雄厚的机器人实验室的话，你基本上没有机会接触到多自由度的机械臂。这时候之前学到的Simulink和就要学的Gazebo就派上用场了，你可以用Simscape里面的刚体搭一个多自由度机械臂，然后通过Simulink仿真去学习机械臂的控制；也可以用Gazebo的URDF语言写一个机械臂，然后通过Gazebo和ROS的接口去控制机械臂；也可以用ROS里面的著名工具包MoveIt! Motion Planning Framework，不过MoveIt的问题是，他只能仿真运动学，而不能仿真动力学。工业领域对多自由度的机械臂控制通常用一个叫做D-H表示法的建模工具（Denavit），这个东西我并不太会。我只会向同学们推荐我导师的著作《A mathematical introduction to robotic manipulation》（<a href=\"http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf）。\" target=\"_blank\" rel=\"external\">http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf）。</a></p>\n<p>有一个非常神奇的事实：《A mathematical introduction to robotic manipulation》这本机械臂控制领域的著名教材的第二章和计算机视觉领域的著名教材《An Invitation to 3-D Vision》的第二章基本是一样的，都在讲旋转表示法。这是因为所有的旋转表示法都可以归纳为一种优雅的李群结构：SO(3)群。而计算机视觉和机械臂控制都涉及到理解刚体的旋转，事实上用计算系统去观测和控制所有的刚体构成的系统，理解旋转都是很关键的问题。旋转表示法应该作为研究生阶段的一个重要学习的知识点。</p>\n<p>李群和李代数是刚体旋转表示背后的数学理论，如果想要深挖一些，可以看这篇文章An elementary introduction to groups and representations的前50页（<a href=\"http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf）。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。\" target=\"_blank\" rel=\"external\">http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf）。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。</a></p>\n<p>研究生阶段还要培养的一个能力是借助各种工具仿真机器人系统的能力。显然地，很多机器人系统真的造出来的话造价昂贵，需要在实际制造之前写一个比较真实的仿真系统出来测试算法。我觉得做仿真系统的能力直接衡量了机器人工程师的技术水平。当你开始要搭一个仿真系统的时候，第一步是通过欧拉方程和牛顿方程确定刚体的运动特点，甚至要自己写刚体二阶微分方程；第二步是确定刚体之间的互联关系，设计不同类型的关节，如果有软性连接需要加入弹簧阻尼模型；第三步是确定被仿真的刚体系统会不会和外界产生碰撞或者其他形式的力，如果有的话，需要设计合适的接触力和摩擦力仿真的模型。多旋翼飞行器的仿真是很简单的，不需要考虑什么接触力。但是多自由度机械臂基本都需要仿真接触力，不和物理世界去交互的机械臂只有很小的实用意义。而能够自行运动locomotion系统，比如双足、多足机器人，则涉及到更多的接触力，多到接触力都会影响仿真系统的数值稳定性。搭建一个仿真系统需要很强的系统建模能力和数值分析的能力，虽然Simulink、Gazebo、Vrep提供了不同程度的工具简化你的工作，但是要让仿真系统能够稳定运行，必须要能深入其中的细节。有些看起来很高大上的仿真工具，比如Nvida的PhysX，在仿真的时候是忽略掉科里奥利力的，如果不理解仿真的本质，可能就会忽略这一个重要的缺陷。</p>\n<h3 id=\"研究生二年级\"><a href=\"#研究生二年级\" class=\"headerlink\" title=\"研究生二年级\"></a>研究生二年级</h3><p>你的学习计划接近尾声。现在你已经进入了一个很好的状态：看到一个机器人，能够很果断地分析出它用了什么传感器、执行器、计算平台大概是什么量级，他的执行机构能够承受多少力量。看到一个新的算法，能够大约判断清楚它的执行流程，在什么环节做了优化。看到一个新的没学过的知识，能够分析出它和你以前学过的什么知识有联系，你还需要再学什么才能弄明白这个知识点。</p>\n<p>研究生二年级要深化第一年学到的那些技术和知识，要做到完整地读过四五本书，五十篇以上的论文。你已经积累了几万行代码的经验，也能熟练地谈论谁家的电机回差小，谁家的电机线性程度好。</p>\n<p>你这个时候可以去写作一些论文，也可以开始学习一些更高级的技术和工具，比如用FPGA和GPU优化算法、魔改Linux内核、玩玩液压系统、了解更多机器学习的知识比如强化学习等等。你也可以从计算机图形学或者计算力学里面找到一些帮助你更好进行机器人仿真和系统分析的工具。由于你懂很多机器人方面的知识，你可以给学校的机器人队做指导，或者带队参加一些比较有挑战性的机器人比赛。</p>\n<p>写到这里，我就不可能给出很多不同领域的指导了，因为随着学习的进一步深化，我自己熟悉的领域也在收缩。我只能对几个领域给出我的意见。</p>\n<p>对视觉定位和传感器融合来说，SLAM急需新的突破，目前通过几何约束去实现loop closure看起来已经走入了死路，没法有更多的发展了，下一步可行的方向是与深度学习进行结合。具体的一些介绍可以阅读行业中大牛的一篇文章<a href=\"http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie\" target=\"_blank\" rel=\"external\">http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie</a> Shen的工作。</p>\n<p>对于多自由度机械手和机器人的locomotion来说，这里面还有非常多可以探索的研究问题。我前面提过接触力和摩擦力很难仿真，大神告诉我现在没有任何一种工具和理论能把接触力和摩擦力正确仿真出来，因此如何在机器人系统里妥善处理对这些力的控制，就是很难的问题了。现在业界的一个前沿发展方向，也是利用机器学习技术来帮助机器人学会处理这些外力，不过人类目前最优秀的多自由度机器人系统，Berkeley的Brett机器人，叠几块积木就要用十分钟（New ‘deep learning’ technique enables robot mastery of skills via trial and error），显然还有很多提升的空间。这方面的问题同学可以关注知乎大神@戴泓楷@周佳骥。</p>\n<p>最后我想再强调一遍表达能力的重要性。你可以从自己带的课程和机器人队入手，把自己这几年来学过的知识做成PPT讲给学生们听，然后让他们给你反馈。多做这样的练习，提升自己做演讲的能力，这将来会让你受益匪浅。</p>\n<p>研究生二年级之后，你可以准备进机器人公司工作了，也可以根据你自己感兴趣的研究方向申请博士接着努力。由于你已经掌握了广博的知识和技能，你的职业生涯将会大有作为。</p>\n<p>结束语</p>\n<p>我从2008年展开自己的机器人生涯。那一年波士顿动力刚刚发布他们的大狗机器人，Python还是很小众的语言，Ubuntu 8.04还很不稳定，Chrome还没有多少人知道。在之后的几年中我目击了深度神经网络的复兴，看到波士顿动力的机器人日渐强大，经历了ROS的起源和繁荣，帮助了大疆的崛起，深深为这个产业的未来感到激动。我希望这篇文章能够帮助更多的年轻人进入机器人学的海洋，为未来机器人学的继续发展贡献力量。</p>\n","excerpt":"<p><em>本文是转载的一篇知乎专栏上的文章，写的相当好。可惜当年上学的时候无人指点，浪费了太多的光影。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">作者：YY硕</div><div class=\"line\">链接：https://zhuanlan.zhihu.com/p/22266788</div><div class=\"line\">来源：知乎</div><div class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</div></pre></td></tr></table></figure>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>很多朋友私信问我对机器人和人工智能感兴趣，该怎么展开学习。最近稍微有点空，我写写我的看法。</p>\n<p>两年前，我在知乎回答如何定义「机器人」？ - YY硕的回答中试图给机器人做出一个比较仔细的定义，我觉得机器人和人工智能最大的区别在于是否要和物理世界进行交互。今年初在另一篇知乎回答里对机器人或人工智能的研究会帮助我们更好的了解人类自己吗？ - YY硕的回答我说到传感器是和物理世界交互的基础。后来，我又在知乎回答有哪些与控制、机器人等相关的 quotes？ - YY硕的回答中提到莫拉维克悖论（Moravec’s paradox），谈到了机器人学里公认的难题是在物理世界中实现类人的活动能力。</p>\n<p>把之前的回答再翻出来是为了支持以下观点：机器人学的核心问题是做好和物理世界的交互。现在主流的机器人学分支里，处理与物理世界的交互的学科分为三类：传感器和处理算法（激光雷达，多目视觉，融合算法）；多刚体系统动力学控制（工业机器人动力学控制和接触力控制）；机器人自主移动（locomotion不知道该怎么翻译，轮式、足式、飞行等移动机器人的研究）。我建议对机器人学有兴趣的同学着重在这几个问题上面。</p>\n<p>另外，根据世界第一的机器人教育机构卡耐基梅隆大学的机器人学博士的课程分类方式（<a href=\"http://www.ri.cmu.edu/education/COSAug2016.pdf），机器人学有四个核心领域：\">http://www.ri.cmu.edu/education/COSAug2016.pdf），机器人学有四个核心领域：</a></p>\n<p>感知。视觉传感器、图像传感器、触觉和力传感器、惯导等。<br>认知。人工智能、知识表达、规划、任务调度、机器学习等。<br>行为。运动学、动力学、控制、manipulation和locomotion等。<br>数学基础。最优估计、微分几何、计算几何、运筹学等。<br>结合卡耐基梅隆大学的核心课程要求，我觉得我定义的机器人学核心问题算是基本没跑偏的。本文后面谈到的机器人项目都是以上述观点和课程要求为基础。</p>\n<p>一些可能有争议性的观点：</p>\n<ol>\n<li><p>机器人学是富人的活动。虽然工业越来越发达，但好的开发板和电机还是非常贵。如果要下定决心学习机器人学并且做出实物，你必须找到做实物出来的资金。要么是自己花钱，要么就得找学校的机器人社团，或者找什么愿意资助年轻人学习的贵人。另外现在没有任何一本完整的书可以教你怎么造一个四旋翼空中机器人或者大狗机器人，你需要参考十几本不同的教科书，这些书不管中文版还是英文版都很贵。</p>\n</li>\n<li><p>机器人学是屠龙之术。这话是Ninebot创始人说的。虽然最近几年，平衡车、扫地机器人、多旋翼飞行器让机器人学开始进入人们的生活，但是可行的商业应用还是很少，而且已有的机器人和理论都还很难解决好与物理世界交互这件事情。所以一定要确保自己在机器人学这个道路上同时练好了能去其他行当吃饭的技能，比如编程、机械设计和硬件设计。也要做好心理准备，接受自己有可能在学会屠龙之术以后几年都造不出对社会有用的东西的事实。</p>\n</li>\n<li><p>基于上述所说的观点，如果是已经工作之后才想要学习机器人的话，可能已经太迟了，因为很可能兴趣战胜不了客观限制因素。如果作为兴趣去学习，只能学到做巡线小车和舵机机械臂什么的，可能也满足不了中二病的创造欲。</p>\n</li>\n</ol>\n<p>个人认为机器人学是一个艰苦的道路，想要成为一个独挡一面的机器人工程师需要多年理论和实践的同步训练。理论学习和动手实践的过程还要互相排好时间表，在做某个实践项目的同时去学习最相关理论往往可以达到事半功倍的效果，但是同时那些不太相关的理论会看起来非常枯燥，因此如何妥善安排自己的实践项目也是很重要的事情。</p>\n<p>这篇文章里我计划介绍一个电子工程、机械工程和计算机专业学生从大学一年级到研究生二年级的机器人学习计划，基本是我对自己过去学习方式的一个总结。按照这个方法来学习，能够成为一个能力全面，但是稍微偏软件一点的机器人工程师。这个六年的学习计划，估算下来，全年中每天在上课和完成课程要求之外要投入学习时间6-8个小时，这些时间一方面用于阅读课程知识的英文教材，一方面用于阅读其他学科的教材，一方面用于实践项目。</p>\n<p>机器人工程师在大型项目里的定位类似于飞机系统里的总体设计师。和机械工程师、硬件工程师、软件工程师、算法工程师、控制工程师比起来，机器人工程师参与某个具体技术的时间较少，但是能够听得懂所有工程师说的话，能够作为不同模块间的协调人，带领整个团队去攻坚。当然如果机器人工程师能够在一个领域达到那个领域的工程师的优秀水平，肯定更好。</p>\n<p>由于时间仓促，再加上个人水平有限，文章中如有纰漏和错误，恭请读者指出，谢谢。如果同学还有什么想知道的内容和教材，也欢迎留言交流。</p>","more":"<h3 id=\"大一\"><a href=\"#大一\" class=\"headerlink\" title=\"大一\"></a>大一</h3><p>刚上大一，你的机器人生涯开始了。先看看学校的校园网能不能翻墙，不能的话自己去买个一年一百多块钱的VPN，先确保自己能上Google，不要心疼VPN的钱，这能让你在之后的职业生涯里节省上万块钱。然后去注册一个gmail账号，再注册stackoverflow账号，再注册github的账号，再注册CSDN账号，注册完登录上去逛逛，暂时先不要问为什么。</p>\n<p>英语水平一定程度上会是机器人工程师水平的限制因素，英语是同学们在大学最该努力学的一门课，而且不止要把它当成课，要当成一种技能，当成生活的一部分。当你开始努力学习一些高级的机器人知识以后，有可能会非常难以找到中文的参考资料，这个时候如果啃不下英文的资料，进步速度和眼界就会受到很大影响。因此大一的时候要多看看红宝书，看看美剧。</p>\n<p>不管是什么专业背景的同学，大学一年级一定要上好的课是微积分和线性代数。线性代数的重要性需要特别强调。一般来说，优秀的工程师和科学家在职业生涯中要学至少五次线性代数，大一学一遍、学凸优化的时候学一遍、学线性系统的时候学一遍、学机器学习的时候学一遍……如果在第一遍学的时候就看到对的书，刷到对的题，那么以后的学习会轻松很多。</p>\n<p>网上有很多对于如何学好线性代数的讨论，比如知乎问题如何理解线性代数？ - 数学学习。Matrix67大神的文章随记：我们需要怎样的数学教育？也很有启发。我个人对学习线性代数的建议是两本书，一本叫做《Linear Algebra Done Right》，另一本叫做《Linear Algebra Done Wrong》（<a href=\"https://www.math.brown.edu/~treil/papers/LADW/book.pdf），我比较喜欢的是Done\">https://www.math.brown.edu/~treil/papers/LADW/book.pdf），我比较喜欢的是Done</a> Wrong这本书，第一它是免费的，第二只需要读前6章两百页就够了，第三它页边距很大，打印出来有很多空白做练习题。另外一个较好的教材是麻省理工公开课：线性代数。不论如何，学线性代数一定要用国外的教材，千万不要用国内的教材。啃英文书很累，但是考虑到之后还要啃更多的英文书，线性代数已经算是很入门的了，一定要啃下来，同时还要刷足够多的课后题。</p>\n<p>学完线性代数以后，一个自然而然的问题就是怎么能用计算机自己去计算矩阵的乘法、向量的乘法、向量的内积。因此引入了编程的学习。</p>\n<p>不管同学的专业是什么，一定要在大学一年级尽早开始学编程。至于用哪种语言开始学习编程，我推荐Python，比较好的教材是麻省理工学院公开课：计算机科学及编程导论，比较好的Python开发学习环境是Anacoda (<a href=\"http://www.continuum.io/downloads)。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。\">http://www.continuum.io/downloads)。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。</a></p>\n<p>对任何人来说，Python是一把瑞士军刀，你可以用他干很多东西，比如自动回复邮件、自动收集信息。但是真要去造机器人，合适的工具并不是瑞士军刀，而是C/C++这样简单粗暴的锤子和螺丝刀般的工具。在学习Python学到一定程度的时候（比如你听说有一种叫做cython的东西），最好开始学习C，而且要强迫自己练习用C的一维数组和指针来实现矩阵的加法、乘法、求逆等操作。之所以有高级的Python或者Java（不要问我Java哪里高级了）这些语言以后我们还需要去学C，是因为机器人上常用的不是完整的电脑，而是计算量有局限的嵌入式系统，嵌入式系统开发基本只能用C或者更低级的语言。</p>\n<p>学习C我个人入门用的是清华大学出版的《C++语言程序设计》。虽然这个书标题是C++，但其实没什么太大问题。不过国内的C语言教材都有个巨大的问题是不引导学生去用Linux。近年来更好的一个教材是<a href=\"http://songjinshan.com/akabook/zh/index.html，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。\">http://songjinshan.com/akabook/zh/index.html，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。</a></p>\n<p>IT行业的程序员都会争论高级语言和低级语言哪个好，Linux和Windows哪个好，而对于机器人工程师来说，从现在到可预见的未来里，C是最好的语言，Linux是最好的操作系统，这都毋庸置疑。甚至对于Linux的发行版该选哪个，我们都是很少有质疑的：Ubuntu（The leading OS for PC, tablet, phone and cloud）。原因是机器人操作系统ROS<code>（ROS.org | Powering the world&#39;s robots）</code>是基于Ubuntu开发的，因此在Ubuntu上运行最稳定。注意Ubuntu出了一个中文版叫做Kylin，个人感觉比较坑，建议大家不要装中文版。Ubuntu 作为一个开源操作系统，总是在快速迭代，2016年8月比较稳定的版本是14.04和16.04，建议同学安装14.04。</p>\n<p>当你把C学得差不多，开始要学写包含多个头文件的程序时，一定要同时学习makefile的知识。这时候要上网去搜“Makefile详解”（Makefile详解（超级好）_mingw吧）这篇文章看。</p>\n<p>我自己在大学一年级的时候还学习了HTML和Javascript，到大一结束的时候已经能够熟练用Javascript手写一些动态页面。我个人觉得HTML和Javascript也是机器人工程师必备的技术，而不只是软件工程师的玩具。这是因为web技术实际上已经渗透到了编程的方方面面，比如json开始是Javascript里的一种object定义的方式，但现在已经成为了一种很标准的数据交互、参数配置的格式。另外AJAX能够帮助初学者理解一定的网络技术原理，而网络技术也是机器人工程师必备的技能。再者，制作GUI（图形用户界面）是常规debug的办法，而近年来一个流行的趋势是用webkit嵌入程序用HTML和Javascript作为图形界面的后端，而在机器人操作系统ROS<code>（ROS.org | Powering the world&#39;s robots）</code>里，通过rosbridge可以非常方便地把机器人程序的数据传递到websocket上，这句话看不懂没关系，反正你知道学学HTML和Javascript很重要就是了。更重要的是，HTML文档背后的DOM (Document Object Model)深刻地体现了面向对象的思想。大学中的面向对象程序设计一般都讲C++，在我看来应该讲HTML和Javascript。这一点不细说了，如果同学们去学习HTML和Javascript，自然会体会到。学习HTML和Javascript比较好的资料是<a href=\"http://www.w3schools.com/，把网站左侧的“Learn\">http://www.w3schools.com/，把网站左侧的“Learn</a> HTML”、“Learn CSS”、“Learn Javascript”和“Learn JQuery”学完就行，别的部分还有很多花哨的技术，没有必要去学了。为了培养自己对Javascript的兴趣，可以上three.js / examples跪着看看热闹。</p>\n<p>以上介绍的这些知识点、书和资料应该在大一期间就全部看完，然后利用大一的暑假好好巩固这些知识。比如开始用HTML和Javascript做一个自己的个人主页，刷一刷编程的题目，学用Python的奇技淫巧（比方说做一个自己的个人主页）。另外还可以抽时间学学数学知识，比如开始看看代数和离散数学。我大一的时候看到了两篇文章，认识到了数学的重要性，一个是MIT的CV大牛林达华写的[转]MIT牛人解说数学体系，另一个是前Goolge研究员吴军博士写的《数学之美》（数学之美 (豆瓣)）。当时林达华还在MIT读博士，而《数学之美》还没有成书。两篇文章看完以后我感觉自己整个人对数学的认识上了一个新的层次，此后一直在注意提高自己的数学水平，几年下来觉得收益很大。在之后的介绍里我还会多次强调需要学的数学知识和对应的教材。</p>\n<h3 id=\"大二\"><a href=\"#大二\" class=\"headerlink\" title=\"大二\"></a>大二</h3><p>上大二的时候，你已经会了基本的编程知识和基本的数学知识。大二这一年应该投入在嵌入式系统的学习中，同时继续拓展自己多方面的能力。学校的机器人社团，比如做Robocon，RoboMasters的团队应该在招新了，赶快去加入，有了学长学姐的指导以及同辈朋友的鞭策，应该会进步的快一点。</p>\n<p>大二应该掌握的技能：Solidworks画基本的机械图，基本的数字电路知识、数模转换，51单片机、AVR单片机、STM32单片机原理，UART、SPI、I2C、CAN等协议的原理和数据收发，STM32开发板的使用，电机转动和驱动的原理，PID的原理，调试四轮机器人底盘的移动，基本的传感器如陀螺仪、码盘、红外线、超声波的原理和读取方式，网络知识如配置IP配置路由器等，微电子焊接，金工技术。我在知乎回答如果程序员每天都浅尝辄止地学一些不同的新技术，长久以往，人会变成什么样子呢？ - YY硕的回答里谈过机器人工程师需要的技能数量是IT行业全栈工程师技能数量的三倍以上，这些技能的基础都应该在大二开始积累。</p>\n<p>如果同学们的专业是机械工程相关，那么大二的时候要深入学习solidworks做图，买机械加工手册学习各种机械的奇技淫巧。你的专业知识还不足以让你进行缜密的受力分析，不过你可以尽量多做一些机械结构出来感受它们的乐趣。</p>\n<p>如果同学们的专业是硬件、电路相关，那么大二的时候要深入学习Altium Designer做图、制板、焊板。你要从现在开始，就给自己积累一个工作记录，可以就是简单的txt文件，记录你做过所有板子的bug、解决方案、学到的原理图、PCB layout的注意事项等等。积累很多年以后，你的这个工作记录会值很多钱。</p>\n<p>学习这些技能的最好的方式，就是参加自己学校机器人社团的训练和方案设计。一般来说，学校的机器人社团招新之后会有训练和测试，让新人分组去做机器人，这个过程中如果愿意努力学，提高得会很快。如果你所在的大学是机器人比赛强校，比如西安交通大学，电子科技大学，哈尔滨工业大学，华中科技大学，东北大学等等（排名不分先后，没有提到你们学校名字的话我表示抱歉），那么你很幸运，你们学校的机器人社团有很好的积淀，有很多资源可以帮助你学习。基本上只要天天泡实验室，保证自己每天只睡6-7个小时（但还是要多去跑步、游泳保持身体健康），勤于向学长学姐请教，那么一定会提高得很快。</p>\n<p>大二阶段特别要强调的是对动手能力的培养，包括机械材料的加工、电路焊接、制作导线和接头、连接路由器、配置网络、做网线等等。机械加工的工具有螺丝刀、锯、钻、锤子、车床、铣床、钻床，进阶选手可以学一下氧焊，这个比较危险，我没尝试过；电路焊接的工具有焊机、焊锡、洗板水、松香、吸锡器；制作导线的工具有剪子、剥线钳、夹头钳、网线钳各种钳；网络配置就是连连路由器插插网线，但是Linux系统下配置网络有时会非常麻烦，一定要多积累这方面的知识，因为将来你造的机器人多半会顶着一个无线路由器跑来跑去，甚至有的机器人上各个模块自己就能组起一个小局域网。这些技能的熟练掌握需要你花很多时间去做真正能用的机器人来练手。</p>\n<p>对于该选择造一个怎么样的“真正能用的机器人”练手，最好的选择肯定是机器人比赛中的机器人。如果参加Robocon，你会跟着学长学姐们学着造有人那么高的巨大机械；如果参加RoboMasters，你会学着造比汽车还要灵活的机器人以及快速发弹的机构。其他一些小型的比赛比如飞思卡尔智能车，也是很好的训练，因为飞思卡尔智能车已经发展得很成熟，参加这个比赛的参赛资料就够学一阵子的，学完以后能够获得比较多的机器人技能。</p>\n<p>如果没有太多学校机器人社团的资源，同学们还有一些小型的比赛比如挑战杯、大创比赛等等可以选择，以三五个人的小团队参与这些比赛。如果同学所在的学校连这些比赛都不组织大家参与，那就只好自己花钱了。国内开源机器人社区有很多资源可以利用来学习，比如自己买Arduino STEM educational Robot kits Building Platform的各种开发套件做简单的机器人。Arduino的开发环境可能有些人不喜欢，因为它对硬件做了一级封装，如果更希望接触到单片机的本质，可以自己买STM32开发板学习。俗话说，没有什么嵌入式系统是一块STM32实现不了的，如果有，就用两块。STM32是ARM Cortex‑M家族中最为广泛应用的一款单片机，在网上也有很多的教材和开发板可供选择。在国内著名的电子论坛STM32/8 分论坛帖子清单 (amoBBS 阿莫电子论坛)上，有很多参考资料，有问题也可以在这里和大家讨论学习。</p>\n<p>如果你很想参加机器人比赛，身边也恰好有一些志同道合的小伙伴，但是学校不支持。没关系，来找我，我尽量通过大疆的关系说服你们学校支持你们参加RoboMasters。</p>\n<p>虽然你是以机器人比赛为主线在探索机器人技术，但是要时刻记得，机器人比赛给你的理论方面的训练很差，还会让你养成一些坏习惯，比如凡事都希望用一些糙猛快的办法来解决。由于通常整个团队都没有太多的项目管理经验，到比赛前一段时间才会加紧功夫去做机器人，很多时候就会用“山寨”的办法去处理机器人的故障。比如说某个承重结构用久了会弯，为了赶比赛的进度，就拿锤子敲直了、再加一条辅助的结构在旁边继续用，而没有细致地去做建模、受力分析，思考是什么原因导致承重结构会变形。再比如说调PID参数就是生调乱改，而没有基于机器人的动力学模型去估测参数的大概范围。</p>\n<p>大二的暑假，有可能你跟着学校的机器人队参加了一些机器人比赛。这是一个反思总结的好时机，为什么机器人队取得了这样那样的成绩？整个团队怎样才能更有效率？明年如何继续招新？暑假要把时间花在技术积累上面，这个时候可以回头思考思考之前准备比赛时用糙猛快的办法解决的问题如何能够细致地去解决。</p>\n<p>如果大二的暑假没有参加机器人比赛，可以做一个舵机机器人，比如6条腿的蜘蛛，比如码垛机器人。舵机是机器人工程师的好朋友，一定要好好掌握。</p>\n<p>另外你其他方面的能力也不能落下。大二结束的时候，你的Linux应该用的很熟练了，除了makefile，你也用起了cmake。你也应该开始理解Github存在的意义，因为你已经上去读了很多别人的代码，你也把自己的一些课程设计和小项目放在了Github上面。另外大二基本上了本专业一些比较难的基础课程，比如自动控制原理、机器学习、概率统计、材料和力学等课程，同学们会看到这些课程里又用到了线性代数和微积分的知识，以及建模的知识。这时候可以把大一的物理、线性代数和微积分再翻出来看看。</p>\n<p>同学的学校应该给大二到大三的学生有开设面向对象的程序设计，一般用Java或C++教授。在面向对象的程序课里面，一定要积累3000行左右的代码的开发经验。经典的面向对象程序设计的练习通常是写游戏，比如俄罗斯方块，吃豆人等等，一定要自己能够做到完全手写一个完整的项目出来。</p>\n<p>另外你可以开始学习Matlab当中的神器Simulink了。在大二这一年的学习中，你可能在不少课程里多多少少用到了Matlab。假设你已经在我的推荐下喜欢上了Python，你可能会觉得Matlab的计算工具没有比Python强多少；假设你自己在别人的推荐下喜欢上了mathematica（Mathematica 到底有多厉害？ - Wolfram Mathematica），你可能会觉得和Mathematica这种神一样的语言比起来，Matlab弱爆了。但是要注意的是，Matlab最强大的工具是Simulink，通过它你几乎可以仿真一切的物理系统和控制系统。我建议同学可以通过Simulink实现一个倒立摆，然后理解Matlab的强大之处。对此我强烈推荐一个很好的教材（<a href=\"http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（Control\">http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（Control</a> of an Inverted Pendulum on a Cart）的文章。阅读并实现了这两篇文章里的内容，同学应该会对倒立摆有了比较深刻的认识。倒立摆是机器人学中一个非常重要的模型，因为火箭、导弹、双足机器人、四足机器人，基本都是倒立摆的变形。你自己实现出来的simulink模型一定要存好，以后可能还会再拿出来仔细看。</p>\n<p>如果你按照我之前说的方法探索了一些HTML和Javascript的技术，那么JQuery，bootstrap，AngularJS你已经多多少少知道是怎么回事了。web后端的技术，比如PHP和MySQL，也可以了解一下，LAMP要学会怎么配置。如果有同学找你帮忙写小网站，尽量去帮个忙，帮别人做网站是提高自己系统编程能力的好练习。在做网站的过程中你可能还会顺便学一学如何用Photoshop和Illustrator让网站显得更漂亮。这些技能有最好，没空学也没关系。</p>\n<h3 id=\"大三\"><a href=\"#大三\" class=\"headerlink\" title=\"大三\"></a>大三</h3><p>大三开始的时候，你可以在学校的机器人队里担任重要角色了，或者能够带领一个小团队参加小型的机器人比赛。你在系里甚至院里都小有名气了，可能有的人叫你大神，有的人觉得你技术还不错。但是一定要记得你现在的水平放到别的地方应该不算什么。每年我都往大疆的RoboMasters夏令营招进100个和你现在的水平相当的同学。</p>\n<p>大三一定要培养出自己一个人独立造出一个完整机器人的能力，比如一个Robocon水平的机器人，或者一个RoboMasters的战车，或者一个四旋翼飞行器。</p>\n<p>Robocon水平的机器人，涉及大量的机械设计，单片机开发，电机驱动的开发，码盘和超声波等传感器的读取，底盘运动学的计算，PID调试，任务调度逻辑的调试，舵机控制。RoboMasters的战车的机械部分简单一些，但是还需要进行云台的控制、发弹系统的控制、功率控制等方面的知识，另外你也可以不搞这些部分，学习学习视觉识别和自动打击，那么就要开始研究OpenCV（OpenCV | OpenCV）了。</p>\n<p>四旋翼飞行器的机械部分最简单，但是算法比较复杂。对于大三学生来说，从零开始一步到位写一个稳定的飞控比较困难，因为飞控里面有很多细小的知识点要注意。目前我没有发现什么比较好的书籍推荐，已有的一些关于四旋翼系统的书要么太浅（上来就教你焊电路），要么太深（上来就教你state estimation），听说 @Liu Top的exbot小组在写一个教材，我是非常期待的。学习四旋翼飞行器有下面几个步骤：</p>\n<p>第一步：自己调一个小四轴飞起来<br>现在开源社区的人言必pixhawk，其实我觉得从学习的角度来说，pixhawk太贵，而且不适合学习，我比较推荐的是 首页-第七实验室 这家淘宝店卖的STM32F405飞控，买回来以后自己再随便买个机架（比如大疆F450）、接收机和遥控，就能按照飞控板附带的学习资料、调试软件飞起来。</p>\n<p>第二步：看硬件图、读代码<br>chiplab7的飞控板附带一大堆学习资料，对加速度计、陀螺和磁感计都有很仔细的解释，硬件链路图也很详细。chiplab7淘宝掌柜的又很认真负责，我学用的时候，发现代码有bug和看不懂的地方，都可以直接找掌柜问。</p>\n<p>看完代码以后，对一个飞控系统的基本模块：姿态解算、控制解算、混控输出、遥控器处理、嵌入式处理就很明白了。然而这里面有很多技术是需要另外学习的。除了基本的嵌入式编程以外，还有要把大二大三学的信号处理方面的知识再捡起来看看。因为飞行器在空中有振动，会让加速度计产生噪声，为了把这些噪声去除掉，需要对加速度计给出的信号做低通滤波处理，如何选择滤波器的参数呢？如果滤波滤得太狠，延迟就会比较大，对控制的表现会有影响；如果滤波滤得不够，可能会有一些低频的噪声偶尔会出现，导致加速度计的观测不能用。另外最重要的是要理解姿态解算和控制解算这两块知识。chiplab7的飞控板的代码采用的是最简单的互补滤波算法做为姿态解算模块，然后控制解算是对欧拉角的三个角度做闭环PID控制，基本都是基础的基础了。</p>\n<p>第三步：小修小改加深理解<br>chiplab7的飞控是靠气压计定高的，飞行效果非常奔放。这时候可以淘宝买个20块钱的超声波模块，然后自己写个高度环去稳定飞控的定高表现。</p>\n<p>我觉得这个过程至关重要，因为高度控制相对来说是个比较直观理解PID控制的方式，而且chiplab7的飞控加高度控制非常好加。工作量不大，因为改善效果很显著，所以可以让人很有成就感，加深继续学习的乐趣。</p>\n<p>第四步：理解核心的数学和控制知识<br>这一部分大三是肯定来不及学的，但是我还是在这里列出来，因为这些知识你之后都需要慢慢学，我也会在之后不断重复提到这些知识点。<br>姿态解算和控制解算涉及的知识有：</p>\n<ol>\n<li>刚体姿态的表示、运动学方程和动力学方程。主要是对牛顿-欧拉方程的认识和理解、刚体姿态的欧拉角表示法、姿态与角速度的关系等等。<br>这部分说复杂不复杂，说简单也不简单，我同样是没有找到一本完整的书全都介绍过的，是学了好几个不同的书和论文以后搞明白的。现在看起来是从维基百科入手比较靠谱。</li>\n<li>自动控制原理。讲PID的书和文章就多了去了，没有太多复杂的书。</li>\n<li>线性估计基本原理。其实就是互补滤波：Reading a IMU Without Kalman: The Complementary Filter 。拿这个关键词百度各种搜就会了。<br>第五步：重头开始造轮子<br>知乎著名网友vczh曾经说过，学习要抱着勇于造轮子的心态才能进步。所以在熟悉了别人飞控基础上，可以自己重头造一个飞控的轮子。可以自己从芯片开始重新画一个飞控板，读读STM32的芯片手册、读读各种传感器的芯片手册，自己手画一个飞控的原理图、做PCB layout、制板自己焊元件，全套花不了1000块钱，能够加深很多对硬件的理解。这一部分如果大三没空，也可以不搞了。</li>\n</ol>\n<p>制造整个机器人的过程中要特别重视文档的积累。在你大三末期，你可能随着学校的机器人队备战比赛，你可能主力负责一台机器人。你应该自己列一个excel表格，把机器人用了几颗螺丝，几根导线，每个零件的规格是什么，都列出来。这个表格一方面可以用来帮助团队管理机器人的物料，一方面也是你自己的经验技术积累，将来你做的其他机器人可能多多少少都是Robocon、RoboMasters机器人的变形。</p>\n<p>另一个积累是建一个自己的buglist，buglist包括什么呢，可以像冷大这样：做控制、机器人等算法工程师是怎样一种体验？ - 冷哲的回答，就简单把一些自己的发生过的问题和最后的解决办法罗列下来。比如说“杜邦线接插位不稳固容易脱开，接好后应该用电工胶布再裹一圈”，“外发给淘宝加工的机械图纸，要特别注意和加工商沟通有没有漏掉一些细节，如沉头螺丝孔，关键的倒角”等等。你也可以帮其他机器人的问题也做这样的记录。buglist可以就是一个简单的文本文件，如果你一直往里面积累自己工作中的记录，等你将来工作了，这个文件可能会值很多钱。</p>\n<p>大三的时候学校应该会开设软件工程的课程。不管你是不是这个专业，上不上这门课，都应该主动去听一听，甚至跟着课程的设计作业一起做一做。软件工程我觉得是机器人工程师必须具备的意识，因为一个机器人系统里涉及大量的硬件系统和软件功能，软件的部分往往还会涉及不同的语言、不同的编译环境、不同的开发工具链。几个人合作的话，大家的专业背景、编程习惯都不相同，这就导致不同的代码和模块之间的协议沟通非常复杂，必须尽早用UML和其他软件工程的工具帮助团队理解和互相沟通。</p>\n<p>大三的时候学校应该还会开设操作系统原理和嵌入式系统原理的课程，而大二的时候讲过计算机组成原理（所谓的微机原理）。从大三开始同学需要开始体会实时操作系统和非实时操作系统的区别、原理以及使用时需要注意的地方。这是一个比较杂的知识点，我目前没有找到很好的教材去介绍。在STM32上，有freeRTOS，uCOS，Vxworks这么几种实时操作系统；Linux是一种非实时操作系统，但是可以通过打补丁变成实时操作系统。这些操作系统的细节在机器人开发中都会多多少少被涉及到，同学们可以随时上Google和CSDN去查大神们的介绍。</p>\n<p>另外特别重要的一点是机器人系统里的嵌入式平台都有烧坏的可能性，有可能在某个嵌入式Linux平台上面辛辛苦苦写了一个多月代码，这个平台突然烧坏了，代码也就丢了。因此你的机器人如果有嵌入式Linux系统在里面，一定要尽早顶起来路由器，代码定时提交SVN或者git。</p>\n<p>大三的暑假你可能会作为学校机器人队的主力去参赛了。备战比赛和参赛是一件磨练心性的事情。我在学生时代体会过和胜利擦肩而过的痛苦，体会过没机会再来一年的遗憾；也在负责大疆RoboMasters比赛的过程中被那些痛苦和遗憾的学生当做发泄的对象，非常有感触。我觉得参加机器人比赛，很努力，然后失败了，是一件让人快速成长的事情。同学如果有机会，一定应该参加至少一届机器人比赛。</p>\n<p>大三的暑假你也可以选择来参加大疆的RoboMasters夏令营，关于夏令营大家可以看这个知乎问答了解更多：参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新。每年我们都在全国范围内寻找有一定技术基础的学生，让他们一起分组做一个自动机器人的挑战。这个夏令营，作为组织负责人，不谦虚地说，我觉得应该是全世界范围内最好的技术类夏令营。</p>\n<p>大三的暑假有一件很重要的事情就是思考自己大四应该干什么。一般来说，你现在的能力保本校研究生肯定没有问题，当然你也可以选择考其他学校的研究生或者出国留学。虽然说你现在能力已经很全面了，但是你还需要2-3年的时间全面提升自己更多的能力，才能迈向卓越之路。不管是出国还是保研，最重要的目的是给自己争取到未来2-3年能够在一个优秀的环境中安心提升自己，有比较好的学习资源，能够参与到一些不错的项目中去。可能其他有些行当，出国留学始终是比在国内待着更好的选择，但是机器人行业并不是这样。我们国家这两年在机器人方面提高也很快，而且我们国家现在比较有钱。就像我开始说的那样，机器人是富人的活动，现在你在国内也能找到一些很有钱的实验室可以造比较牛逼的机器人。另外国外很多比较强的机器人公司也都在做比较敏感的军方项目，去找实习可能比较受限制。</p>\n<p>出国去学机器人学方面的知识你有很多不错的选择，比如世界第一的机器人研究院卡耐基梅隆大学，或者麻省理工学院的CSAIL实验室。北美传统计算机四大名校（麻省理工学院，卡耐基梅隆大学，斯坦福大学，加州大学伯克利分校）里，除了斯坦福大学热火朝天在搞人工智能以外，其他几个学校的机器人研究都很不错。除了四大名校，你还有很多其他的选择，就像我开始说的那样，机器人是富人的活动，如果想接触到最好的机器人资源，你要选择有钱的实验室，而不是有名的实验室。</p>\n<p>另外你还需要在大三的尾巴上选定自己将来的细分研究方向，而且开始往这个方向深挖，也就是我在文章开始提到的感知、认知、行为几个方向。当然同时你也不能放松其他方面的知识，尤其是数学基础。我在大三的暑假专门找数学系的同学给我开了个数学小讲座，学习了一点抽象代数的知识，对我后来学习密码学帮助很大。同时我也读了一些拓扑方面的教材（有一本很神奇的书叫做Topopogy Without Tears <a href=\"http://www.topologywithouttears.net/），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。\">http://www.topologywithouttears.net/），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。</a></p>\n<p>大三阶段的机器人工程师该学什么基础数学是众说纷纭的，在我看来，你要基本掌握“群是什么”，能够用代数的眼光去证明”det(AB) = det(A)det(B)”，还要能理解“用一张纸就可以变出克莱因瓶”（当然是在四维空间里）。另外，你这个时候也要能够意识到自己需要再学一遍线性代数。</p>\n<h3 id=\"大四\"><a href=\"#大四\" class=\"headerlink\" title=\"大四\"></a>大四</h3><p>大四开始了，你可以开始深挖自己的研究方向，同时也要开始学一些高级一点的通用技术和理论，这时候你和一般的机械、电子、计算机学生就不太一样了，你虽然也在狂编程，但也在狂学习物理和数学。通用技术包括ROS，simulink，gazebo和Vrep等工具。通用理论包括，再学一遍线性代数，学学凸优化、数值计算、旋转表示法等方面的知识。这些知识你在大四仅仅只能开一个头，因为你的大四要实习、毕业、考研、毕设，你会非常地忙。有些人会在大四进实验室和老师发论文，我个人觉得发论文这件事没必要操之过急。你的整个大学期间应该用在广泛涉猎各种各样的知识上面，而不是深入某一个细小的研究问题。</p>\n<p>大四可以开始读一些著名入门书籍，我把这些书不分先后地列出来，你没有必要全部去读，而且每本书先读前几章就够了，能读多少尽量读多少。</p>\n<ol>\n<li><p>概率机器人学，<a href=\"https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623\">https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623</a></p>\n</li>\n<li><p>凸优化，<a href=\"https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf\">https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf</a></p>\n</li>\n<li><p>线性系统理论，<a href=\"https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579\">https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579</a></p>\n</li>\n<li><p>Multiple View Geometry in Computer Vision，Multiple View Geometry in Computer Vision</p>\n</li>\n<li><p>线性估计，<a href=\"https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642\">https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642</a></p>\n</li>\n<li><p>《机器学习》，周志华老师的书。</p>\n</li>\n<li><p>An Invitation to 3-D Vision，<a href=\"https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf\">https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf</a></p>\n</li>\n<li><p>Modern Control Systems，<a href=\"https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580\">https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580</a></p>\n</li>\n<li><p>Rigid Body Dynamics，<a href=\"http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。\">http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。</a></p>\n</li>\n<li><p>Feedback Systems: An Introduction for Scientists and Engineers，FBSwiki</p>\n</li>\n</ol>\n<p>就像我开始说的那样，这些书，大部分特别贵，还好有一些业界良心的作者放出了他们书的电子版。当然你也可以去一些名字都不能说的网站去找影印版。</p>\n<p>在读上面这些书的时候，matlab，python都要放在手边，然后把书里面的知识尽量实践出来。很多教科书里都会在章节后面的习题里放一些写明是用matlab做的习题，要尽量多做一些这样的题。</p>\n<p>你可能早就听说了ROS的大名，但是最好不要在大四之前去碰它。因为ROS用了很多操作系统和网络的底层技术。我在知乎回答高手可以谈谈ROS机器人操作平台开发的一些经验吗？ - YY硕的回答里有简单的介绍。ROS的设计目标是把机器人的控制和传感器处理的软件和它的硬件隔离开，用上ROS以后，你可以方便地用到很多能直接跑的软件代码。但是ROS从入门到精通需要至少一年以上的时间，你必须不断地用，不断地尝试新的代码和硬件，才能对它熟悉起来。</p>\n<p>ROS的可视化工具Rviz里面对于机器人旋转的表示用的是四元数，而在你之前研究四旋翼飞行器时，里面的代码表示旋转用的是欧拉角，做姿态解算用的可能是四元数。这个时候要开始有意识地去学习旋转表示法之间的区别和联系。</p>\n<p>要重视大四期间的实习和毕业设计。很多大四的学生毕业设计都会非常颓地做一下，我觉得是不好的。要把做毕业设计的过程看做一个正式的项目。这个项目除了做好技术方面的工作，也要做好展示方面的工作。中国工程师的一大特点是，不会表达自己，可能做的东西水平很高，但是做出PPT就会犯字体花哨不正式、一页上面字太多，图文没有联系等表达上的问题。通过PPT介绍、展示自己的成果在工程师的职业生涯的任何一个阶段都非常重要，它甚至也一定程度上限制了机器人工程师能够达到的高度。只有能够把自己的成果清晰地表达给自己的团队，才能获得其他人的反馈、通过沟通提高团队的整体凝聚力和知识水平，这样自己在团队能够获得更多的认可，有助于团队整体工作效率的提高。我每年去参加几次学术会议，都在会议上感觉到一些中国的科研人员走到国际上以后，演讲能力很差就会导致他们的科研成果不受重视。当然其他国家的科研人员也是这样。</p>\n<p>为了写出美观的技术报告和毕业论文，你可以开始学习Latex。Latex作为国际国内第一写作神器，学习资料在网上有很多。Latex的学习和使用同样也是需要不断地熟能生巧，多写多练就熟悉了。写毕业论文有个问题是怎么做出精美的矢量图，我推荐Draw Freely | Inkscape，一个比Illustrator更轻量化、但是有些功能反而更强大的免费软件。</p>\n<p>对于那些想申请出国留学的同学，你要做一个自己个人的成果展示，用网页的形式呈现比较好。把自己Github链接（如果你按我说的，大学第一天就申请Github账号，现在已经是一个三年的老油条了）、做过的机器人视频、写过的技术报告和文章（最好是英文的）放在上面。</p>\n<p>关于毕业设计的选题，我推荐这么几个：</p>\n<ol>\n<li><p>手写双目视觉里程计。涉及到图像处理、特征匹配、位置解算、空间变换等等。</p>\n</li>\n<li><p>手写四旋翼飞行器基于GPS的轨迹规划。涉及到深挖四旋翼飞行器的运动原理、IMU原理、轨迹生成和优化等。</p>\n</li>\n<li><p>造一个被推了也不会倒的双足舵机机器人。涉及到舵机控制、倒立摆建模、动力学分析、PID控制、IMU原理等。</p>\n</li>\n<li><p>深度学习训练一个小车追人跑。涉及到深度学习工具包使用、数据集采集、数据集分析、小车控制等。</p>\n</li>\n<li><p>机械臂给人端茶倒水。这个相对来说土豪一点，因为能直接拿来用的机械臂都很贵，这个要看实验室有没有条件了。涉及到多自由度机械臂原理的学习、工具包的使用、轨迹规划等等。</p>\n</li>\n</ol>\n<p>这几个项目要做好，都要持续投入三个月以上的时间以及一定的资金，每一个都是理论多于实践。当然同学们自己也可以自己选择自己的毕业设计题目，但是最好还是选做出来能跑能飞的东西，同时避免选择需要花大量时间去拧螺丝、焊板子的题目，尽量买现成的电机、开发板、3D打印结构，大四要多给自己留时间去看书和写代码。</p>\n<p>大四到研究生之前的暑假，最好去一些比较不错的机器人公司实习一下，比如说大疆。当然你也可以继续做机器人比赛，比如RoboMasters和大疆的飞行器比赛。</p>\n<h3 id=\"研究生一年级\"><a href=\"#研究生一年级\" class=\"headerlink\" title=\"研究生一年级\"></a>研究生一年级</h3><p>研究生的时候，你的目标比较清晰了，就是做一种机器人至少两年时间，并从中发掘出可以发表论文的知识点。上面我给出的书单里面，你要开始精读里面的几本。</p>\n<p>如果做机器人视觉定位、传感器融合方面的研究，1、4、5、7四本书一定要精读。</p>\n<p>如果做控制系统的研究，3、8、9、10一定要精读。</p>\n<p>如果做规划算法的研究，那么还要读其他偏CS一些的书，比如讲A* search，random forest，图论方面知识的教材。由于我在这方面造诣不深，就不托大了。</p>\n<p>如果学习随机系统的控制和最优控制，除了1、2、3，还要读一本神书Stochastic models estimation and control（<a href=\"https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）。\">https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）。</a></p>\n<p>如果研究机器人视觉定位，几种常用的定位算法：PTAM（Parallel Tracking and Mapping for Small AR Workspaces (PTAM)），ROS的标配VO（viso2_ros - ROS Wiki），SVO（GitHub - uzh-rpg/rpg_svo: Semi-direct Visual Odometry），LSD-SLAM（<a href=\"http://vision.in.tum.de/research/vslam/lsdslam）ORB-SLAM（GitHub\">http://vision.in.tum.de/research/vslam/lsdslam）ORB-SLAM（GitHub</a> - raulmur/ORB_SLAM2: Real-Time SLAM for Monocular, Stereo and RGB-D Cameras, with Loop Detection and Relocalization Capabilities），都必须自己学习之后全部跑一遍。只会用OpenCV的函数和这些工具包并不能说明你会视觉定位，必须要能自己手写出一个能用的才算。国内有一个很厉害的SLAM专家叫高翔，他的博客要关注一下：机器人 - 标签。由于SLAM这两年很火，研究的人很多，所以网上可以参考的资料也很多，比如<a href=\"https://github.com/hcdth011/ROS-Hydro-SLAM，就在ROS上实现了几种定位算法的对比。\">https://github.com/hcdth011/ROS-Hydro-SLAM，就在ROS上实现了几种定位算法的对比。</a></p>\n<p>我现在非常不建议同学们选择从四旋翼飞行器的动力学控制里找问题作为研究课题。因为四旋翼飞行器的特点已经被研究透了。目前国际上对多旋翼飞行器的研究主要集中在造一些奇葩形状的飞行器，以及给多旋翼飞行器上安装一个机械臂去做力控制，这样做就对多旋翼飞行器控制的动力学造成了一些影响。因此需要同学对动力学和多自由度机械臂控制有比较深的认识。</p>\n<p>自动导航和驾驶是这两年的热点，一方面汽车的自动化是大势所趋，另一方面多旋翼飞行器异军突起，产生了很多对自动飞行的需求。除了机器人视觉定位算法以外，同学还需要学习其他的传感器，以及这些传感器与视觉定位算法怎么融合。这里面有很多坑，比如计算量的问题，怎么保证融合算法不崩，怎么处理传感器的延时等等，都需要同学结合自己的项目去踩，坑踩得多了才能成长。如果大家想找一个多旋翼飞行器平台研究自动导航，我推荐大疆的M100，我已经在知乎回答RoboMasters2015夏令营是怎样的？ - YY硕的回答里吹过一波M100，前面说过的今年夏令营的知乎回答参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新里也有人帮我吹了一波。</p>\n<p>一些大学里学过的知识点，是必须结合研究生期间的项目的需求弄得很清楚的，比如三大变换（傅里叶变换，拉普拉斯变换，Z变换），旋转表示法（欧拉角、四元数、旋转矩阵），数值计算怎么防止矩阵出现数值问题等等。除了自己的项目，还需要把凸优化、卡尔曼滤波还有多自由度机械臂的控制学习一下。这三个领域的知识，是任何一种机器人都会用的到比较难的知识。</p>\n<p>凸优化和凸优化的各种变形是非常重要的知识，因为各行各业里的研究问题，多半是会建立一个优化问题去解决的。上面提到的《Convex Optimization》<a href=\"https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf，也是一本神书，同学们一定要认真读一读。Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient\">https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf，也是一本神书，同学们一定要认真读一读。Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient</a> descend，barrier method等等。另外现在主流的SLAM算法，后端都是通过一种叫做g2o的优化算法来出效果的。而且g2o能够整合bundle adjustment 和structure-from-motion这两大计算机视觉里的关键问题，可以说是一种很好的计算思想了，非常有必要学习一下g2o。</p>\n<p>卡尔曼滤波在上面书单里的1和3都有提到，同时在神书Stochastic models estimation and control（<a href=\"https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。\">https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。</a></p>\n<p>多自由度的机械臂的难点在于机械臂的运动学正反解、运动学控制和动力学控制，基本是一个建模分析和数值算法实现的问题。如果你所在的学校没有一个财力雄厚的机器人实验室的话，你基本上没有机会接触到多自由度的机械臂。这时候之前学到的Simulink和就要学的Gazebo就派上用场了，你可以用Simscape里面的刚体搭一个多自由度机械臂，然后通过Simulink仿真去学习机械臂的控制；也可以用Gazebo的URDF语言写一个机械臂，然后通过Gazebo和ROS的接口去控制机械臂；也可以用ROS里面的著名工具包MoveIt! Motion Planning Framework，不过MoveIt的问题是，他只能仿真运动学，而不能仿真动力学。工业领域对多自由度的机械臂控制通常用一个叫做D-H表示法的建模工具（Denavit），这个东西我并不太会。我只会向同学们推荐我导师的著作《A mathematical introduction to robotic manipulation》（<a href=\"http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf）。\">http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf）。</a></p>\n<p>有一个非常神奇的事实：《A mathematical introduction to robotic manipulation》这本机械臂控制领域的著名教材的第二章和计算机视觉领域的著名教材《An Invitation to 3-D Vision》的第二章基本是一样的，都在讲旋转表示法。这是因为所有的旋转表示法都可以归纳为一种优雅的李群结构：SO(3)群。而计算机视觉和机械臂控制都涉及到理解刚体的旋转，事实上用计算系统去观测和控制所有的刚体构成的系统，理解旋转都是很关键的问题。旋转表示法应该作为研究生阶段的一个重要学习的知识点。</p>\n<p>李群和李代数是刚体旋转表示背后的数学理论，如果想要深挖一些，可以看这篇文章An elementary introduction to groups and representations的前50页（<a href=\"http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf）。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。\">http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf）。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。</a></p>\n<p>研究生阶段还要培养的一个能力是借助各种工具仿真机器人系统的能力。显然地，很多机器人系统真的造出来的话造价昂贵，需要在实际制造之前写一个比较真实的仿真系统出来测试算法。我觉得做仿真系统的能力直接衡量了机器人工程师的技术水平。当你开始要搭一个仿真系统的时候，第一步是通过欧拉方程和牛顿方程确定刚体的运动特点，甚至要自己写刚体二阶微分方程；第二步是确定刚体之间的互联关系，设计不同类型的关节，如果有软性连接需要加入弹簧阻尼模型；第三步是确定被仿真的刚体系统会不会和外界产生碰撞或者其他形式的力，如果有的话，需要设计合适的接触力和摩擦力仿真的模型。多旋翼飞行器的仿真是很简单的，不需要考虑什么接触力。但是多自由度机械臂基本都需要仿真接触力，不和物理世界去交互的机械臂只有很小的实用意义。而能够自行运动locomotion系统，比如双足、多足机器人，则涉及到更多的接触力，多到接触力都会影响仿真系统的数值稳定性。搭建一个仿真系统需要很强的系统建模能力和数值分析的能力，虽然Simulink、Gazebo、Vrep提供了不同程度的工具简化你的工作，但是要让仿真系统能够稳定运行，必须要能深入其中的细节。有些看起来很高大上的仿真工具，比如Nvida的PhysX，在仿真的时候是忽略掉科里奥利力的，如果不理解仿真的本质，可能就会忽略这一个重要的缺陷。</p>\n<h3 id=\"研究生二年级\"><a href=\"#研究生二年级\" class=\"headerlink\" title=\"研究生二年级\"></a>研究生二年级</h3><p>你的学习计划接近尾声。现在你已经进入了一个很好的状态：看到一个机器人，能够很果断地分析出它用了什么传感器、执行器、计算平台大概是什么量级，他的执行机构能够承受多少力量。看到一个新的算法，能够大约判断清楚它的执行流程，在什么环节做了优化。看到一个新的没学过的知识，能够分析出它和你以前学过的什么知识有联系，你还需要再学什么才能弄明白这个知识点。</p>\n<p>研究生二年级要深化第一年学到的那些技术和知识，要做到完整地读过四五本书，五十篇以上的论文。你已经积累了几万行代码的经验，也能熟练地谈论谁家的电机回差小，谁家的电机线性程度好。</p>\n<p>你这个时候可以去写作一些论文，也可以开始学习一些更高级的技术和工具，比如用FPGA和GPU优化算法、魔改Linux内核、玩玩液压系统、了解更多机器学习的知识比如强化学习等等。你也可以从计算机图形学或者计算力学里面找到一些帮助你更好进行机器人仿真和系统分析的工具。由于你懂很多机器人方面的知识，你可以给学校的机器人队做指导，或者带队参加一些比较有挑战性的机器人比赛。</p>\n<p>写到这里，我就不可能给出很多不同领域的指导了，因为随着学习的进一步深化，我自己熟悉的领域也在收缩。我只能对几个领域给出我的意见。</p>\n<p>对视觉定位和传感器融合来说，SLAM急需新的突破，目前通过几何约束去实现loop closure看起来已经走入了死路，没法有更多的发展了，下一步可行的方向是与深度学习进行结合。具体的一些介绍可以阅读行业中大牛的一篇文章<a href=\"http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie\">http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie</a> Shen的工作。</p>\n<p>对于多自由度机械手和机器人的locomotion来说，这里面还有非常多可以探索的研究问题。我前面提过接触力和摩擦力很难仿真，大神告诉我现在没有任何一种工具和理论能把接触力和摩擦力正确仿真出来，因此如何在机器人系统里妥善处理对这些力的控制，就是很难的问题了。现在业界的一个前沿发展方向，也是利用机器学习技术来帮助机器人学会处理这些外力，不过人类目前最优秀的多自由度机器人系统，Berkeley的Brett机器人，叠几块积木就要用十分钟（New ‘deep learning’ technique enables robot mastery of skills via trial and error），显然还有很多提升的空间。这方面的问题同学可以关注知乎大神@戴泓楷@周佳骥。</p>\n<p>最后我想再强调一遍表达能力的重要性。你可以从自己带的课程和机器人队入手，把自己这几年来学过的知识做成PPT讲给学生们听，然后让他们给你反馈。多做这样的练习，提升自己做演讲的能力，这将来会让你受益匪浅。</p>\n<p>研究生二年级之后，你可以准备进机器人公司工作了，也可以根据你自己感兴趣的研究方向申请博士接着努力。由于你已经掌握了广博的知识和技能，你的职业生涯将会大有作为。</p>\n<p>结束语</p>\n<p>我从2008年展开自己的机器人生涯。那一年波士顿动力刚刚发布他们的大狗机器人，Python还是很小众的语言，Ubuntu 8.04还很不稳定，Chrome还没有多少人知道。在之后的几年中我目击了深度神经网络的复兴，看到波士顿动力的机器人日渐强大，经历了ROS的起源和繁荣，帮助了大疆的崛起，深深为这个产业的未来感到激动。我希望这篇文章能够帮助更多的年轻人进入机器人学的海洋，为未来机器人学的继续发展贡献力量。</p>"},{"layout":"post","title":"Aria2详解","date":"2016-10-27T08:18:00.000Z","_content":"\nAria2应该来说是最流行的免费下载工具之一，因为它的轻量级以及支持各种协议而被广为使用。\n\n\n*这个东西折腾了很长时间，终于配好了，老实说仅仅是配置使用的话应该是相当简单的，但由于一开始参考了mac下配置的那篇文章，虽然更改了路径等内容，但每次启动aria2的时候总是经常启动不起来，或者启动后自动被kill了，反复往返，看了很多教程官方文档说明等，一直查不出问题所在，最后没办法，直接自己写配置文件，终于可以使用了。*\n\n\n### aria2配置\n\n根据man文档aria2的默认配置在$HOME/.aria2/aria2.conf中，你也可以在每次加载的过程中人为修改位置如：`aria2c --conf-path=/etc/.aria2/aria2.conf`。\n\n\n配置如下：\n\n```\n#保存路径，注意这边必须写完整路径\ndir=/home/demon/Downloads\n#允许rpc\nenable-rpc=true\n#允许所有来源, web界面跨域权限需要\nrpc-allow-origin-all=true\n##允许非外部访问\nrpc-listen-all=true\n#RPC端口, 仅当默认端口被占用时修改\nrpc-listen-port=6800\n#disable-ipv6=true\n#最大同时下载数(任务数), 路由建议值: 3\nmax-concurrent-downloads=10\n#断点续传\ncontinue=true\n#同服务器连接数\nmax-connection-per-server=10\n#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要\nmin-split-size=10M\n#单文件最大线程数, 路由建议值: 5\nsplit=10\n#下载速度限制\nmax-overall-download-limit=0\n#单文件速度限制\nmax-download-limit=0\n#上传速度限制\nmax-overall-upload-limit=0\n```\n\n<!-- more -->\n\n\n### aria2c命令\n\n基本使用\n\n- 下载一个文件（Download a file）：\n\n```\naria2c http://host/image.iso\n说明：1.10.0以后的版本默认对每个 host 使用 1 个连接，你可以使用 –max-connection-per-server 或者 -x 选项进行改变。\n```\n\n\n- 用每个 host 两个连接从一个 host 下载一个文件（To download a file using 2 connections from single host）：\n\n```\naria2c -x2 http://host/image.iso\n说明：想要停止下载，可以按Ctrl-C。想要恢复下载，可以在同一个文件夹中执行相同的下载命令。只要URI指向同一个文件，URIs是可以被改变的。\n```\n\n- 同时使用两个连接下载同一文件（Download a file using 2 connections）：\n\n```\naria2c -s2 http://host/image.iso http://mirror1/image.iso http://mirror2/image.iso\n\n说明：你可以指定URIs的数量多余 -s 选项设定的数。在这个例子中，前两个URL会被用于下载，而第三个URL作为备用（如果前面两个有个挂了，第三个顶上）。\n```\n\n- 同时从FTP和HTTP源下载一个文件（Download a file from HTTP and FTP servers）：\n\n```\naria2c http://host1/file.zip ftp://host2/file.zip\n```\n\n\n- 并行下载任意数目的URI, metalink, torrent（Parallel downloads of arbitrary number of URI, metalink, torrent）：\n\n```\naria2c -Z http://host/file1 file2.torrent file3.metalink\n说明：如果你只是下载 torrent 和 metalink 的文件，那么选项 -Z 将不是必须的。所以你可以使用以下这个命令同时下载bt文件。\naria2c file1.torrent file2.torrent\n```\n\n- 并发下载一个文件中的URI（Download files listed in a file concurrently）：\n\n```\naria2c -ifiles.txt -j5\n说明：选项 -j 用于指定同时下载的文件的数量。你可以在文件中指定本地的 torrent 和 metalink 文件。\n说明：你可以指定一些 选项 在下载文件（input list file）中。\n```\n\n- 在退出时保存错误/未完成的下载（Save error/unfinished downloads on exit）：\n\n```\naria2c -ifiles.txt --save-session=out.txt\n当你按下Ctrl-C或者 aria2 退出时，所有的错误（error）/未完成（unfinished）下载将会保存到 out.txt 文件中。注意通过 XML-RPC 方式(aria2.addTorrent and aria2.addMetalink)添加的下载不会被保存！你可以使用这个文件作为一个输入文件列表（input file list）来重新开始下载。\naria2c -iout.txt\n```\n### uget\n\nuget可以说相当于一个图形化界面的下载器，这个下载器的优点是可以调用curl和aria2等工具，在设置--插件中选择aria2即可，具体的使用类似迅雷等一些下载器类似。一单设置选择了aria2的话，uget就会自动运行aria2这个进程，其他程序就无法调用aria2的部分功能了。这个软件占用资源较小，如果使用的linux操作系统，简单易用，基本上不需要配置，重点推荐。\n\n### web软件\n\naria2c有几个比较出名的web软件可以选择：[webui-aria2](http://ziahamza.github.io/webui-aria2/)，[yaaw](https://binux.github.io/yaaw/)。\n\n注意在使用这些UI工具时，实际仍然是调用aria2s命令，因此需要实现开启aria2的守护进程：`aria2c -D`，然后在浏览器上面可以执行相关操作。\n\n我个人在使用这两个工具时，研究了很久但一直不能使用，疑似无法读取本地的配置文件，极少情况能够加载成功，进行下载。**待解决**\n\n\n***\n\n\n> 参考链接：\n> http://aria2c.com/usage.html\n> https://medium.com/@Justin___Smith/aria2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B-mac%E5%92%8Cwindows-b31d0f64bd4e#.n6bvy48ay\n> http://yalv.me/aria2/\n> https://zhuanlan.zhihu.com/p/20563721?columnSlug=ChanTalk\n> http://wenku.baidu.com/link?url=bKJCYvk24K--RuZ7DuCzg_0TADnrIMt7aT8fSjTcElI57nOenrWsmKVmWuuHD0SKOt-0OrbvltqOSzXX8Ryj0qEJzhCegBN65X1_dNAA727\n> http://www.cnblogs.com/RhinoC/p/aria2.html\n> https://aria2.github.io/\n> http://sydi.org/posts/linux/aria2c-usage-sample-cns.html\n> http://chanjh.com/post/software/0012\n","source":"_posts/2016/2016-10-27-aria2详解.md","raw":"---\nlayout: \"post\"\ntitle: \"Aria2详解\"\ndate: \"2016-10-27 16:18\"\n---\n\nAria2应该来说是最流行的免费下载工具之一，因为它的轻量级以及支持各种协议而被广为使用。\n\n\n*这个东西折腾了很长时间，终于配好了，老实说仅仅是配置使用的话应该是相当简单的，但由于一开始参考了mac下配置的那篇文章，虽然更改了路径等内容，但每次启动aria2的时候总是经常启动不起来，或者启动后自动被kill了，反复往返，看了很多教程官方文档说明等，一直查不出问题所在，最后没办法，直接自己写配置文件，终于可以使用了。*\n\n\n### aria2配置\n\n根据man文档aria2的默认配置在$HOME/.aria2/aria2.conf中，你也可以在每次加载的过程中人为修改位置如：`aria2c --conf-path=/etc/.aria2/aria2.conf`。\n\n\n配置如下：\n\n```\n#保存路径，注意这边必须写完整路径\ndir=/home/demon/Downloads\n#允许rpc\nenable-rpc=true\n#允许所有来源, web界面跨域权限需要\nrpc-allow-origin-all=true\n##允许非外部访问\nrpc-listen-all=true\n#RPC端口, 仅当默认端口被占用时修改\nrpc-listen-port=6800\n#disable-ipv6=true\n#最大同时下载数(任务数), 路由建议值: 3\nmax-concurrent-downloads=10\n#断点续传\ncontinue=true\n#同服务器连接数\nmax-connection-per-server=10\n#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要\nmin-split-size=10M\n#单文件最大线程数, 路由建议值: 5\nsplit=10\n#下载速度限制\nmax-overall-download-limit=0\n#单文件速度限制\nmax-download-limit=0\n#上传速度限制\nmax-overall-upload-limit=0\n```\n\n<!-- more -->\n\n\n### aria2c命令\n\n基本使用\n\n- 下载一个文件（Download a file）：\n\n```\naria2c http://host/image.iso\n说明：1.10.0以后的版本默认对每个 host 使用 1 个连接，你可以使用 –max-connection-per-server 或者 -x 选项进行改变。\n```\n\n\n- 用每个 host 两个连接从一个 host 下载一个文件（To download a file using 2 connections from single host）：\n\n```\naria2c -x2 http://host/image.iso\n说明：想要停止下载，可以按Ctrl-C。想要恢复下载，可以在同一个文件夹中执行相同的下载命令。只要URI指向同一个文件，URIs是可以被改变的。\n```\n\n- 同时使用两个连接下载同一文件（Download a file using 2 connections）：\n\n```\naria2c -s2 http://host/image.iso http://mirror1/image.iso http://mirror2/image.iso\n\n说明：你可以指定URIs的数量多余 -s 选项设定的数。在这个例子中，前两个URL会被用于下载，而第三个URL作为备用（如果前面两个有个挂了，第三个顶上）。\n```\n\n- 同时从FTP和HTTP源下载一个文件（Download a file from HTTP and FTP servers）：\n\n```\naria2c http://host1/file.zip ftp://host2/file.zip\n```\n\n\n- 并行下载任意数目的URI, metalink, torrent（Parallel downloads of arbitrary number of URI, metalink, torrent）：\n\n```\naria2c -Z http://host/file1 file2.torrent file3.metalink\n说明：如果你只是下载 torrent 和 metalink 的文件，那么选项 -Z 将不是必须的。所以你可以使用以下这个命令同时下载bt文件。\naria2c file1.torrent file2.torrent\n```\n\n- 并发下载一个文件中的URI（Download files listed in a file concurrently）：\n\n```\naria2c -ifiles.txt -j5\n说明：选项 -j 用于指定同时下载的文件的数量。你可以在文件中指定本地的 torrent 和 metalink 文件。\n说明：你可以指定一些 选项 在下载文件（input list file）中。\n```\n\n- 在退出时保存错误/未完成的下载（Save error/unfinished downloads on exit）：\n\n```\naria2c -ifiles.txt --save-session=out.txt\n当你按下Ctrl-C或者 aria2 退出时，所有的错误（error）/未完成（unfinished）下载将会保存到 out.txt 文件中。注意通过 XML-RPC 方式(aria2.addTorrent and aria2.addMetalink)添加的下载不会被保存！你可以使用这个文件作为一个输入文件列表（input file list）来重新开始下载。\naria2c -iout.txt\n```\n### uget\n\nuget可以说相当于一个图形化界面的下载器，这个下载器的优点是可以调用curl和aria2等工具，在设置--插件中选择aria2即可，具体的使用类似迅雷等一些下载器类似。一单设置选择了aria2的话，uget就会自动运行aria2这个进程，其他程序就无法调用aria2的部分功能了。这个软件占用资源较小，如果使用的linux操作系统，简单易用，基本上不需要配置，重点推荐。\n\n### web软件\n\naria2c有几个比较出名的web软件可以选择：[webui-aria2](http://ziahamza.github.io/webui-aria2/)，[yaaw](https://binux.github.io/yaaw/)。\n\n注意在使用这些UI工具时，实际仍然是调用aria2s命令，因此需要实现开启aria2的守护进程：`aria2c -D`，然后在浏览器上面可以执行相关操作。\n\n我个人在使用这两个工具时，研究了很久但一直不能使用，疑似无法读取本地的配置文件，极少情况能够加载成功，进行下载。**待解决**\n\n\n***\n\n\n> 参考链接：\n> http://aria2c.com/usage.html\n> https://medium.com/@Justin___Smith/aria2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B-mac%E5%92%8Cwindows-b31d0f64bd4e#.n6bvy48ay\n> http://yalv.me/aria2/\n> https://zhuanlan.zhihu.com/p/20563721?columnSlug=ChanTalk\n> http://wenku.baidu.com/link?url=bKJCYvk24K--RuZ7DuCzg_0TADnrIMt7aT8fSjTcElI57nOenrWsmKVmWuuHD0SKOt-0OrbvltqOSzXX8Ryj0qEJzhCegBN65X1_dNAA727\n> http://www.cnblogs.com/RhinoC/p/aria2.html\n> https://aria2.github.io/\n> http://sydi.org/posts/linux/aria2c-usage-sample-cns.html\n> http://chanjh.com/post/software/0012\n","slug":"2016/2016-10-27-aria2详解","published":1,"updated":"2017-01-12T02:47:02.051Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ail0034mumug74hd05c","content":"<p>Aria2应该来说是最流行的免费下载工具之一，因为它的轻量级以及支持各种协议而被广为使用。</p>\n<p><em>这个东西折腾了很长时间，终于配好了，老实说仅仅是配置使用的话应该是相当简单的，但由于一开始参考了mac下配置的那篇文章，虽然更改了路径等内容，但每次启动aria2的时候总是经常启动不起来，或者启动后自动被kill了，反复往返，看了很多教程官方文档说明等，一直查不出问题所在，最后没办法，直接自己写配置文件，终于可以使用了。</em></p>\n<h3 id=\"aria2配置\"><a href=\"#aria2配置\" class=\"headerlink\" title=\"aria2配置\"></a>aria2配置</h3><p>根据man文档aria2的默认配置在$HOME/.aria2/aria2.conf中，你也可以在每次加载的过程中人为修改位置如：<code>aria2c --conf-path=/etc/.aria2/aria2.conf</code>。</p>\n<p>配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">#保存路径，注意这边必须写完整路径</div><div class=\"line\">dir=/home/demon/Downloads</div><div class=\"line\">#允许rpc</div><div class=\"line\">enable-rpc=true</div><div class=\"line\">#允许所有来源, web界面跨域权限需要</div><div class=\"line\">rpc-allow-origin-all=true</div><div class=\"line\">##允许非外部访问</div><div class=\"line\">rpc-listen-all=true</div><div class=\"line\">#RPC端口, 仅当默认端口被占用时修改</div><div class=\"line\">rpc-listen-port=6800</div><div class=\"line\">#disable-ipv6=true</div><div class=\"line\">#最大同时下载数(任务数), 路由建议值: 3</div><div class=\"line\">max-concurrent-downloads=10</div><div class=\"line\">#断点续传</div><div class=\"line\">continue=true</div><div class=\"line\">#同服务器连接数</div><div class=\"line\">max-connection-per-server=10</div><div class=\"line\">#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要</div><div class=\"line\">min-split-size=10M</div><div class=\"line\">#单文件最大线程数, 路由建议值: 5</div><div class=\"line\">split=10</div><div class=\"line\">#下载速度限制</div><div class=\"line\">max-overall-download-limit=0</div><div class=\"line\">#单文件速度限制</div><div class=\"line\">max-download-limit=0</div><div class=\"line\">#上传速度限制</div><div class=\"line\">max-overall-upload-limit=0</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"aria2c命令\"><a href=\"#aria2c命令\" class=\"headerlink\" title=\"aria2c命令\"></a>aria2c命令</h3><p>基本使用</p>\n<ul>\n<li>下载一个文件（Download a file）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">aria2c http://host/image.iso</div><div class=\"line\">说明：1.10.0以后的版本默认对每个 host 使用 1 个连接，你可以使用 –max-connection-per-server 或者 -x 选项进行改变。</div></pre></td></tr></table></figure>\n<ul>\n<li>用每个 host 两个连接从一个 host 下载一个文件（To download a file using 2 connections from single host）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">aria2c -x2 http://host/image.iso</div><div class=\"line\">说明：想要停止下载，可以按Ctrl-C。想要恢复下载，可以在同一个文件夹中执行相同的下载命令。只要URI指向同一个文件，URIs是可以被改变的。</div></pre></td></tr></table></figure>\n<ul>\n<li>同时使用两个连接下载同一文件（Download a file using 2 connections）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">aria2c -s2 http://host/image.iso http://mirror1/image.iso http://mirror2/image.iso</div><div class=\"line\"></div><div class=\"line\">说明：你可以指定URIs的数量多余 -s 选项设定的数。在这个例子中，前两个URL会被用于下载，而第三个URL作为备用（如果前面两个有个挂了，第三个顶上）。</div></pre></td></tr></table></figure>\n<ul>\n<li>同时从FTP和HTTP源下载一个文件（Download a file from HTTP and FTP servers）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">aria2c http://host1/file.zip ftp://host2/file.zip</div></pre></td></tr></table></figure>\n<ul>\n<li>并行下载任意数目的URI, metalink, torrent（Parallel downloads of arbitrary number of URI, metalink, torrent）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">aria2c -Z http://host/file1 file2.torrent file3.metalink</div><div class=\"line\">说明：如果你只是下载 torrent 和 metalink 的文件，那么选项 -Z 将不是必须的。所以你可以使用以下这个命令同时下载bt文件。</div><div class=\"line\">aria2c file1.torrent file2.torrent</div></pre></td></tr></table></figure>\n<ul>\n<li>并发下载一个文件中的URI（Download files listed in a file concurrently）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">aria2c -ifiles.txt -j5</div><div class=\"line\">说明：选项 -j 用于指定同时下载的文件的数量。你可以在文件中指定本地的 torrent 和 metalink 文件。</div><div class=\"line\">说明：你可以指定一些 选项 在下载文件（input list file）中。</div></pre></td></tr></table></figure>\n<ul>\n<li>在退出时保存错误/未完成的下载（Save error/unfinished downloads on exit）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">aria2c -ifiles.txt --save-session=out.txt</div><div class=\"line\">当你按下Ctrl-C或者 aria2 退出时，所有的错误（error）/未完成（unfinished）下载将会保存到 out.txt 文件中。注意通过 XML-RPC 方式(aria2.addTorrent and aria2.addMetalink)添加的下载不会被保存！你可以使用这个文件作为一个输入文件列表（input file list）来重新开始下载。</div><div class=\"line\">aria2c -iout.txt</div></pre></td></tr></table></figure>\n<h3 id=\"uget\"><a href=\"#uget\" class=\"headerlink\" title=\"uget\"></a>uget</h3><p>uget可以说相当于一个图形化界面的下载器，这个下载器的优点是可以调用curl和aria2等工具，在设置–插件中选择aria2即可，具体的使用类似迅雷等一些下载器类似。一单设置选择了aria2的话，uget就会自动运行aria2这个进程，其他程序就无法调用aria2的部分功能了。这个软件占用资源较小，如果使用的linux操作系统，简单易用，基本上不需要配置，重点推荐。</p>\n<h3 id=\"web软件\"><a href=\"#web软件\" class=\"headerlink\" title=\"web软件\"></a>web软件</h3><p>aria2c有几个比较出名的web软件可以选择：<a href=\"http://ziahamza.github.io/webui-aria2/\" target=\"_blank\" rel=\"external\">webui-aria2</a>，<a href=\"https://binux.github.io/yaaw/\" target=\"_blank\" rel=\"external\">yaaw</a>。</p>\n<p>注意在使用这些UI工具时，实际仍然是调用aria2s命令，因此需要实现开启aria2的守护进程：<code>aria2c -D</code>，然后在浏览器上面可以执行相关操作。</p>\n<p>我个人在使用这两个工具时，研究了很久但一直不能使用，疑似无法读取本地的配置文件，极少情况能够加载成功，进行下载。<strong>待解决</strong></p>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://aria2c.com/usage.html\" target=\"_blank\" rel=\"external\">http://aria2c.com/usage.html</a><br><a href=\"https://medium.com/@Justin___Smith/aria2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B-mac%E5%92%8Cwindows-b31d0f64bd4e#.n6bvy48ay\" target=\"_blank\" rel=\"external\">https://medium.com/@Justin___Smith/aria2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B-mac%E5%92%8Cwindows-b31d0f64bd4e#.n6bvy48ay</a><br><a href=\"http://yalv.me/aria2/\" target=\"_blank\" rel=\"external\">http://yalv.me/aria2/</a><br><a href=\"https://zhuanlan.zhihu.com/p/20563721?columnSlug=ChanTalk\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/p/20563721?columnSlug=ChanTalk</a><br><a href=\"http://wenku.baidu.com/link?url=bKJCYvk24K--RuZ7DuCzg_0TADnrIMt7aT8fSjTcElI57nOenrWsmKVmWuuHD0SKOt-0OrbvltqOSzXX8Ryj0qEJzhCegBN65X1_dNAA727\" target=\"_blank\" rel=\"external\">http://wenku.baidu.com/link?url=bKJCYvk24K--RuZ7DuCzg_0TADnrIMt7aT8fSjTcElI57nOenrWsmKVmWuuHD0SKOt-0OrbvltqOSzXX8Ryj0qEJzhCegBN65X1_dNAA727</a><br><a href=\"http://www.cnblogs.com/RhinoC/p/aria2.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/RhinoC/p/aria2.html</a><br><a href=\"https://aria2.github.io/\" target=\"_blank\" rel=\"external\">https://aria2.github.io/</a><br><a href=\"http://sydi.org/posts/linux/aria2c-usage-sample-cns.html\" target=\"_blank\" rel=\"external\">http://sydi.org/posts/linux/aria2c-usage-sample-cns.html</a><br><a href=\"http://chanjh.com/post/software/0012\" target=\"_blank\" rel=\"external\">http://chanjh.com/post/software/0012</a></p>\n</blockquote>\n","excerpt":"<p>Aria2应该来说是最流行的免费下载工具之一，因为它的轻量级以及支持各种协议而被广为使用。</p>\n<p><em>这个东西折腾了很长时间，终于配好了，老实说仅仅是配置使用的话应该是相当简单的，但由于一开始参考了mac下配置的那篇文章，虽然更改了路径等内容，但每次启动aria2的时候总是经常启动不起来，或者启动后自动被kill了，反复往返，看了很多教程官方文档说明等，一直查不出问题所在，最后没办法，直接自己写配置文件，终于可以使用了。</em></p>\n<h3 id=\"aria2配置\"><a href=\"#aria2配置\" class=\"headerlink\" title=\"aria2配置\"></a>aria2配置</h3><p>根据man文档aria2的默认配置在$HOME/.aria2/aria2.conf中，你也可以在每次加载的过程中人为修改位置如：<code>aria2c --conf-path=/etc/.aria2/aria2.conf</code>。</p>\n<p>配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">#保存路径，注意这边必须写完整路径</div><div class=\"line\">dir=/home/demon/Downloads</div><div class=\"line\">#允许rpc</div><div class=\"line\">enable-rpc=true</div><div class=\"line\">#允许所有来源, web界面跨域权限需要</div><div class=\"line\">rpc-allow-origin-all=true</div><div class=\"line\">##允许非外部访问</div><div class=\"line\">rpc-listen-all=true</div><div class=\"line\">#RPC端口, 仅当默认端口被占用时修改</div><div class=\"line\">rpc-listen-port=6800</div><div class=\"line\">#disable-ipv6=true</div><div class=\"line\">#最大同时下载数(任务数), 路由建议值: 3</div><div class=\"line\">max-concurrent-downloads=10</div><div class=\"line\">#断点续传</div><div class=\"line\">continue=true</div><div class=\"line\">#同服务器连接数</div><div class=\"line\">max-connection-per-server=10</div><div class=\"line\">#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要</div><div class=\"line\">min-split-size=10M</div><div class=\"line\">#单文件最大线程数, 路由建议值: 5</div><div class=\"line\">split=10</div><div class=\"line\">#下载速度限制</div><div class=\"line\">max-overall-download-limit=0</div><div class=\"line\">#单文件速度限制</div><div class=\"line\">max-download-limit=0</div><div class=\"line\">#上传速度限制</div><div class=\"line\">max-overall-upload-limit=0</div></pre></td></tr></table></figure>","more":"<h3 id=\"aria2c命令\"><a href=\"#aria2c命令\" class=\"headerlink\" title=\"aria2c命令\"></a>aria2c命令</h3><p>基本使用</p>\n<ul>\n<li>下载一个文件（Download a file）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">aria2c http://host/image.iso</div><div class=\"line\">说明：1.10.0以后的版本默认对每个 host 使用 1 个连接，你可以使用 –max-connection-per-server 或者 -x 选项进行改变。</div></pre></td></tr></table></figure>\n<ul>\n<li>用每个 host 两个连接从一个 host 下载一个文件（To download a file using 2 connections from single host）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">aria2c -x2 http://host/image.iso</div><div class=\"line\">说明：想要停止下载，可以按Ctrl-C。想要恢复下载，可以在同一个文件夹中执行相同的下载命令。只要URI指向同一个文件，URIs是可以被改变的。</div></pre></td></tr></table></figure>\n<ul>\n<li>同时使用两个连接下载同一文件（Download a file using 2 connections）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">aria2c -s2 http://host/image.iso http://mirror1/image.iso http://mirror2/image.iso</div><div class=\"line\"></div><div class=\"line\">说明：你可以指定URIs的数量多余 -s 选项设定的数。在这个例子中，前两个URL会被用于下载，而第三个URL作为备用（如果前面两个有个挂了，第三个顶上）。</div></pre></td></tr></table></figure>\n<ul>\n<li>同时从FTP和HTTP源下载一个文件（Download a file from HTTP and FTP servers）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">aria2c http://host1/file.zip ftp://host2/file.zip</div></pre></td></tr></table></figure>\n<ul>\n<li>并行下载任意数目的URI, metalink, torrent（Parallel downloads of arbitrary number of URI, metalink, torrent）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">aria2c -Z http://host/file1 file2.torrent file3.metalink</div><div class=\"line\">说明：如果你只是下载 torrent 和 metalink 的文件，那么选项 -Z 将不是必须的。所以你可以使用以下这个命令同时下载bt文件。</div><div class=\"line\">aria2c file1.torrent file2.torrent</div></pre></td></tr></table></figure>\n<ul>\n<li>并发下载一个文件中的URI（Download files listed in a file concurrently）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">aria2c -ifiles.txt -j5</div><div class=\"line\">说明：选项 -j 用于指定同时下载的文件的数量。你可以在文件中指定本地的 torrent 和 metalink 文件。</div><div class=\"line\">说明：你可以指定一些 选项 在下载文件（input list file）中。</div></pre></td></tr></table></figure>\n<ul>\n<li>在退出时保存错误/未完成的下载（Save error/unfinished downloads on exit）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">aria2c -ifiles.txt --save-session=out.txt</div><div class=\"line\">当你按下Ctrl-C或者 aria2 退出时，所有的错误（error）/未完成（unfinished）下载将会保存到 out.txt 文件中。注意通过 XML-RPC 方式(aria2.addTorrent and aria2.addMetalink)添加的下载不会被保存！你可以使用这个文件作为一个输入文件列表（input file list）来重新开始下载。</div><div class=\"line\">aria2c -iout.txt</div></pre></td></tr></table></figure>\n<h3 id=\"uget\"><a href=\"#uget\" class=\"headerlink\" title=\"uget\"></a>uget</h3><p>uget可以说相当于一个图形化界面的下载器，这个下载器的优点是可以调用curl和aria2等工具，在设置–插件中选择aria2即可，具体的使用类似迅雷等一些下载器类似。一单设置选择了aria2的话，uget就会自动运行aria2这个进程，其他程序就无法调用aria2的部分功能了。这个软件占用资源较小，如果使用的linux操作系统，简单易用，基本上不需要配置，重点推荐。</p>\n<h3 id=\"web软件\"><a href=\"#web软件\" class=\"headerlink\" title=\"web软件\"></a>web软件</h3><p>aria2c有几个比较出名的web软件可以选择：<a href=\"http://ziahamza.github.io/webui-aria2/\">webui-aria2</a>，<a href=\"https://binux.github.io/yaaw/\">yaaw</a>。</p>\n<p>注意在使用这些UI工具时，实际仍然是调用aria2s命令，因此需要实现开启aria2的守护进程：<code>aria2c -D</code>，然后在浏览器上面可以执行相关操作。</p>\n<p>我个人在使用这两个工具时，研究了很久但一直不能使用，疑似无法读取本地的配置文件，极少情况能够加载成功，进行下载。<strong>待解决</strong></p>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://aria2c.com/usage.html\">http://aria2c.com/usage.html</a><br><a href=\"https://medium.com/@Justin___Smith/aria2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B-mac%E5%92%8Cwindows-b31d0f64bd4e#.n6bvy48ay\">https://medium.com/@Justin___Smith/aria2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B-mac%E5%92%8Cwindows-b31d0f64bd4e#.n6bvy48ay</a><br><a href=\"http://yalv.me/aria2/\">http://yalv.me/aria2/</a><br><a href=\"https://zhuanlan.zhihu.com/p/20563721?columnSlug=ChanTalk\">https://zhuanlan.zhihu.com/p/20563721?columnSlug=ChanTalk</a><br><a href=\"http://wenku.baidu.com/link?url=bKJCYvk24K--RuZ7DuCzg_0TADnrIMt7aT8fSjTcElI57nOenrWsmKVmWuuHD0SKOt-0OrbvltqOSzXX8Ryj0qEJzhCegBN65X1_dNAA727\">http://wenku.baidu.com/link?url=bKJCYvk24K--RuZ7DuCzg_0TADnrIMt7aT8fSjTcElI57nOenrWsmKVmWuuHD0SKOt-0OrbvltqOSzXX8Ryj0qEJzhCegBN65X1_dNAA727</a><br><a href=\"http://www.cnblogs.com/RhinoC/p/aria2.html\">http://www.cnblogs.com/RhinoC/p/aria2.html</a><br><a href=\"https://aria2.github.io/\">https://aria2.github.io/</a><br><a href=\"http://sydi.org/posts/linux/aria2c-usage-sample-cns.html\">http://sydi.org/posts/linux/aria2c-usage-sample-cns.html</a><br><a href=\"http://chanjh.com/post/software/0012\">http://chanjh.com/post/software/0012</a></p>\n</blockquote>"},{"layout":"post","title":"MSB 和 LSB","date":"2016-10-29T03:23:00.000Z","_content":"\n\nMSB 和 LSB 在计算机中的意思并不唯一确定，这边分为两种解释：\n- MSB ： Most Significant Bit，LSB ： Least Significant Bit\n- MSB ： Most Significant Byte，LSB ： Least Significant Byte\n\n但有一点可以确定的是：MS 往往代表是重要的，而 LS 则代表不重要的，比如 传递数据 1001 时，高位的数据单位是千，肯定比低位数据单位是个来的更加重要，所以往往丢失低位数据的影响要远远小于丢失高位数据。\n\n### 高低位\n\nMSB 可以代表 Most Significant Bit，LSB 则代表 Least Significant Bit 根据具体的场景来判别。在很多涉及到 SPI/IIC 通讯的芯片手册中，如：FM25W256 铁电或者 EEPROM 中，描述的 MSB/LSB 根据时序图往往可以判别代表的是高地位而不是字节。\n\n一般而言，采用 Data is written MSB first 的方式会更好些，如上面所叙述的那样， MSB 代表的是**重要位（Most Significant Bit**，先传递重要位，能够减少重要位被丢失的可能性，目前像 I2C，SPI等通讯协议都保留了设置先传递 MSB 还是先传递 LSB 的功能，但是绝大多数的厂家的芯片手册都会注明**Data is written MSB first**。\n\n但值得注意的是，uart 通讯中全部采用**Data is written LSB first**，即先传递低位数据，且芯片配置中是无法更改 uart 传递位的次序的，换言之，uart 是一种较古老的通讯协议，通讯中一定是从低位往高位传递数据。大家在使用时基本不需要考虑 MSB 和 LSB 的先写入顺序，因为已经固定死了，所有使用该设备的 232/485，上/下位机，都必须遵守这个规则。\n\n### 高低字节\n\nMSB 可以代表 Most Significant Byte，LSB 则代表 Least Significant Byte 根据具体的场景来判别。一般在串口通讯场景中， MSB 和 LSB 代表的是字节。\n\n数据寻址时，一般读取的都是低位字节的地址（即存储数据的可能占用多个地址，但低位地址代表了这个数据的存储地址）。C 中的数据类型都是从内存的低地址向高地址扩展，取址运算\"&\"都是取低地址。 所以就有高位地址和地位地址区别，一般来说数字大的就是高地址，数字小的是地址：比如 0x1000 相对于 0x1003 来说是低地址。数据低位和数据高位：比如 0x012345678 0x01 是数据高位（即使 Most Significant Byte，MSB 位），而 0x78 是数据低地址位（Least Significant Byte，LSB）。\n\n计算机中，究竟高字节先被存储还是低字节先被存储，以及传输过程中先发送高位字节还是低位字节这个往往取决于 CPU 的结构，是大端小端问题，可以参考具体文章。\n","source":"_posts/2016/2016-10-29-msb-和-lsb.md","raw":"---\nlayout: \"post\"\ntitle: \"MSB 和 LSB\"\ndate: \"2016-10-29 11:23\"\n---\n\n\nMSB 和 LSB 在计算机中的意思并不唯一确定，这边分为两种解释：\n- MSB ： Most Significant Bit，LSB ： Least Significant Bit\n- MSB ： Most Significant Byte，LSB ： Least Significant Byte\n\n但有一点可以确定的是：MS 往往代表是重要的，而 LS 则代表不重要的，比如 传递数据 1001 时，高位的数据单位是千，肯定比低位数据单位是个来的更加重要，所以往往丢失低位数据的影响要远远小于丢失高位数据。\n\n### 高低位\n\nMSB 可以代表 Most Significant Bit，LSB 则代表 Least Significant Bit 根据具体的场景来判别。在很多涉及到 SPI/IIC 通讯的芯片手册中，如：FM25W256 铁电或者 EEPROM 中，描述的 MSB/LSB 根据时序图往往可以判别代表的是高地位而不是字节。\n\n一般而言，采用 Data is written MSB first 的方式会更好些，如上面所叙述的那样， MSB 代表的是**重要位（Most Significant Bit**，先传递重要位，能够减少重要位被丢失的可能性，目前像 I2C，SPI等通讯协议都保留了设置先传递 MSB 还是先传递 LSB 的功能，但是绝大多数的厂家的芯片手册都会注明**Data is written MSB first**。\n\n但值得注意的是，uart 通讯中全部采用**Data is written LSB first**，即先传递低位数据，且芯片配置中是无法更改 uart 传递位的次序的，换言之，uart 是一种较古老的通讯协议，通讯中一定是从低位往高位传递数据。大家在使用时基本不需要考虑 MSB 和 LSB 的先写入顺序，因为已经固定死了，所有使用该设备的 232/485，上/下位机，都必须遵守这个规则。\n\n### 高低字节\n\nMSB 可以代表 Most Significant Byte，LSB 则代表 Least Significant Byte 根据具体的场景来判别。一般在串口通讯场景中， MSB 和 LSB 代表的是字节。\n\n数据寻址时，一般读取的都是低位字节的地址（即存储数据的可能占用多个地址，但低位地址代表了这个数据的存储地址）。C 中的数据类型都是从内存的低地址向高地址扩展，取址运算\"&\"都是取低地址。 所以就有高位地址和地位地址区别，一般来说数字大的就是高地址，数字小的是地址：比如 0x1000 相对于 0x1003 来说是低地址。数据低位和数据高位：比如 0x012345678 0x01 是数据高位（即使 Most Significant Byte，MSB 位），而 0x78 是数据低地址位（Least Significant Byte，LSB）。\n\n计算机中，究竟高字节先被存储还是低字节先被存储，以及传输过程中先发送高位字节还是低位字节这个往往取决于 CPU 的结构，是大端小端问题，可以参考具体文章。\n","slug":"2016/2016-10-29-msb-和-lsb","published":1,"updated":"2016-12-28T03:50:29.440Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aim0035mumuxzigivf4","content":"<p>MSB 和 LSB 在计算机中的意思并不唯一确定，这边分为两种解释：</p>\n<ul>\n<li>MSB ： Most Significant Bit，LSB ： Least Significant Bit</li>\n<li>MSB ： Most Significant Byte，LSB ： Least Significant Byte</li>\n</ul>\n<p>但有一点可以确定的是：MS 往往代表是重要的，而 LS 则代表不重要的，比如 传递数据 1001 时，高位的数据单位是千，肯定比低位数据单位是个来的更加重要，所以往往丢失低位数据的影响要远远小于丢失高位数据。</p>\n<h3 id=\"高低位\"><a href=\"#高低位\" class=\"headerlink\" title=\"高低位\"></a>高低位</h3><p>MSB 可以代表 Most Significant Bit，LSB 则代表 Least Significant Bit 根据具体的场景来判别。在很多涉及到 SPI/IIC 通讯的芯片手册中，如：FM25W256 铁电或者 EEPROM 中，描述的 MSB/LSB 根据时序图往往可以判别代表的是高地位而不是字节。</p>\n<p>一般而言，采用 Data is written MSB first 的方式会更好些，如上面所叙述的那样， MSB 代表的是<strong>重要位（Most Significant Bit</strong>，先传递重要位，能够减少重要位被丢失的可能性，目前像 I2C，SPI等通讯协议都保留了设置先传递 MSB 还是先传递 LSB 的功能，但是绝大多数的厂家的芯片手册都会注明<strong>Data is written MSB first</strong>。</p>\n<p>但值得注意的是，uart 通讯中全部采用<strong>Data is written LSB first</strong>，即先传递低位数据，且芯片配置中是无法更改 uart 传递位的次序的，换言之，uart 是一种较古老的通讯协议，通讯中一定是从低位往高位传递数据。大家在使用时基本不需要考虑 MSB 和 LSB 的先写入顺序，因为已经固定死了，所有使用该设备的 232/485，上/下位机，都必须遵守这个规则。</p>\n<h3 id=\"高低字节\"><a href=\"#高低字节\" class=\"headerlink\" title=\"高低字节\"></a>高低字节</h3><p>MSB 可以代表 Most Significant Byte，LSB 则代表 Least Significant Byte 根据具体的场景来判别。一般在串口通讯场景中， MSB 和 LSB 代表的是字节。</p>\n<p>数据寻址时，一般读取的都是低位字节的地址（即存储数据的可能占用多个地址，但低位地址代表了这个数据的存储地址）。C 中的数据类型都是从内存的低地址向高地址扩展，取址运算”&amp;”都是取低地址。 所以就有高位地址和地位地址区别，一般来说数字大的就是高地址，数字小的是地址：比如 0x1000 相对于 0x1003 来说是低地址。数据低位和数据高位：比如 0x012345678 0x01 是数据高位（即使 Most Significant Byte，MSB 位），而 0x78 是数据低地址位（Least Significant Byte，LSB）。</p>\n<p>计算机中，究竟高字节先被存储还是低字节先被存储，以及传输过程中先发送高位字节还是低位字节这个往往取决于 CPU 的结构，是大端小端问题，可以参考具体文章。</p>\n","excerpt":"","more":"<p>MSB 和 LSB 在计算机中的意思并不唯一确定，这边分为两种解释：</p>\n<ul>\n<li>MSB ： Most Significant Bit，LSB ： Least Significant Bit</li>\n<li>MSB ： Most Significant Byte，LSB ： Least Significant Byte</li>\n</ul>\n<p>但有一点可以确定的是：MS 往往代表是重要的，而 LS 则代表不重要的，比如 传递数据 1001 时，高位的数据单位是千，肯定比低位数据单位是个来的更加重要，所以往往丢失低位数据的影响要远远小于丢失高位数据。</p>\n<h3 id=\"高低位\"><a href=\"#高低位\" class=\"headerlink\" title=\"高低位\"></a>高低位</h3><p>MSB 可以代表 Most Significant Bit，LSB 则代表 Least Significant Bit 根据具体的场景来判别。在很多涉及到 SPI/IIC 通讯的芯片手册中，如：FM25W256 铁电或者 EEPROM 中，描述的 MSB/LSB 根据时序图往往可以判别代表的是高地位而不是字节。</p>\n<p>一般而言，采用 Data is written MSB first 的方式会更好些，如上面所叙述的那样， MSB 代表的是<strong>重要位（Most Significant Bit</strong>，先传递重要位，能够减少重要位被丢失的可能性，目前像 I2C，SPI等通讯协议都保留了设置先传递 MSB 还是先传递 LSB 的功能，但是绝大多数的厂家的芯片手册都会注明<strong>Data is written MSB first</strong>。</p>\n<p>但值得注意的是，uart 通讯中全部采用<strong>Data is written LSB first</strong>，即先传递低位数据，且芯片配置中是无法更改 uart 传递位的次序的，换言之，uart 是一种较古老的通讯协议，通讯中一定是从低位往高位传递数据。大家在使用时基本不需要考虑 MSB 和 LSB 的先写入顺序，因为已经固定死了，所有使用该设备的 232/485，上/下位机，都必须遵守这个规则。</p>\n<h3 id=\"高低字节\"><a href=\"#高低字节\" class=\"headerlink\" title=\"高低字节\"></a>高低字节</h3><p>MSB 可以代表 Most Significant Byte，LSB 则代表 Least Significant Byte 根据具体的场景来判别。一般在串口通讯场景中， MSB 和 LSB 代表的是字节。</p>\n<p>数据寻址时，一般读取的都是低位字节的地址（即存储数据的可能占用多个地址，但低位地址代表了这个数据的存储地址）。C 中的数据类型都是从内存的低地址向高地址扩展，取址运算”&amp;”都是取低地址。 所以就有高位地址和地位地址区别，一般来说数字大的就是高地址，数字小的是地址：比如 0x1000 相对于 0x1003 来说是低地址。数据低位和数据高位：比如 0x012345678 0x01 是数据高位（即使 Most Significant Byte，MSB 位），而 0x78 是数据低地址位（Least Significant Byte，LSB）。</p>\n<p>计算机中，究竟高字节先被存储还是低字节先被存储，以及传输过程中先发送高位字节还是低位字节这个往往取决于 CPU 的结构，是大端小端问题，可以参考具体文章。</p>\n"},{"layout":"post","title":"SPI通信详解","date":"2016-10-29T06:09:00.000Z","_content":"\n\n\n<!-- more -->\n\n\n\n\n> 参考链接：\n> http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html\n> http://baike.baidu.com/item/SPI\n> https://my.oschina.net/freeblues/blog/67400\n","source":"_posts/2016/2016-10-29-spi通信详解.md","raw":"---\nlayout: \"post\"\ntitle: \"SPI通信详解\"\ndate: \"2016-10-29 14:09\"\n---\n\n\n\n<!-- more -->\n\n\n\n\n> 参考链接：\n> http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html\n> http://baike.baidu.com/item/SPI\n> https://my.oschina.net/freeblues/blog/67400\n","slug":"2016/2016-10-29-spi通信详解","published":1,"updated":"2016-12-16T01:49:55.347Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ain0036mumu56h17nn2","content":"<a id=\"more\"></a>\n<blockquote>\n<p>参考链接：<br><a href=\"http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html\" target=\"_blank\" rel=\"external\">http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html</a><br><a href=\"http://baike.baidu.com/item/SPI\" target=\"_blank\" rel=\"external\">http://baike.baidu.com/item/SPI</a><br><a href=\"https://my.oschina.net/freeblues/blog/67400\" target=\"_blank\" rel=\"external\">https://my.oschina.net/freeblues/blog/67400</a></p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>参考链接：<br><a href=\"http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html\">http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html</a><br><a href=\"http://baike.baidu.com/item/SPI\">http://baike.baidu.com/item/SPI</a><br><a href=\"https://my.oschina.net/freeblues/blog/67400\">https://my.oschina.net/freeblues/blog/67400</a></p>\n</blockquote>"},{"layout":"post","title":"uart/spi/iic的比较","date":"2016-10-30T06:11:00.000Z","_content":"\n\n\n<!-- more -->\n\n\n\n\n> 参考链接：\n> http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html\n> http://blog.sina.com.cn/s/blog_50cfd0fc0101flsn.html\n","source":"_posts/2016/2016-10-30-uart-spi-iic的比较.md","raw":"---\nlayout: \"post\"\ntitle: \"uart/spi/iic的比较\"\ndate: \"2016-10-30 14:11\"\n---\n\n\n\n<!-- more -->\n\n\n\n\n> 参考链接：\n> http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html\n> http://blog.sina.com.cn/s/blog_50cfd0fc0101flsn.html\n","slug":"2016/2016-10-30-uart-spi-iic的比较","published":1,"updated":"2016-12-16T01:49:58.027Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aio0037mumultaawvyt","content":"<a id=\"more\"></a>\n<blockquote>\n<p>参考链接：<br><a href=\"http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html\" target=\"_blank\" rel=\"external\">http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html</a><br><a href=\"http://blog.sina.com.cn/s/blog_50cfd0fc0101flsn.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_50cfd0fc0101flsn.html</a></p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>参考链接：<br><a href=\"http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html\">http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html</a><br><a href=\"http://blog.sina.com.cn/s/blog_50cfd0fc0101flsn.html\">http://blog.sina.com.cn/s/blog_50cfd0fc0101flsn.html</a></p>\n</blockquote>"},{"layout":"post","title":"C语言工程组建","date":"2016-11-10T00:21:00.000Z","_content":"\n每个编程语言都有自己的一些特性，如果了解的很清楚能够减少你编译的时间，减少编译所生成的文件大小，提高你程序的执行效率。虽然现在计算机发展很快，在众多高级语言中已经很少考虑这种问题，但如果是使用c语言编写一些运行在资源较紧张的芯片或编写能耗敏感的一些项目时，仔细研究每个细节，合理的组建自己的工程等还是相当必要的。\n\n<!-- more -->\n","source":"_posts/2016/2016-11-10-c语言工程组建.md","raw":"---\nlayout: \"post\"\ntitle: \"C语言工程组建\"\ndate: \"2016-11-10 08:21\"\n---\n\n每个编程语言都有自己的一些特性，如果了解的很清楚能够减少你编译的时间，减少编译所生成的文件大小，提高你程序的执行效率。虽然现在计算机发展很快，在众多高级语言中已经很少考虑这种问题，但如果是使用c语言编写一些运行在资源较紧张的芯片或编写能耗敏感的一些项目时，仔细研究每个细节，合理的组建自己的工程等还是相当必要的。\n\n<!-- more -->\n","slug":"2016/2016-11-10-c语言工程组建","published":1,"updated":"2016-12-16T01:50:05.463Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aio0038mumucy316n1i","content":"<p>每个编程语言都有自己的一些特性，如果了解的很清楚能够减少你编译的时间，减少编译所生成的文件大小，提高你程序的执行效率。虽然现在计算机发展很快，在众多高级语言中已经很少考虑这种问题，但如果是使用c语言编写一些运行在资源较紧张的芯片或编写能耗敏感的一些项目时，仔细研究每个细节，合理的组建自己的工程等还是相当必要的。</p>\n<a id=\"more\"></a>\n","excerpt":"<p>每个编程语言都有自己的一些特性，如果了解的很清楚能够减少你编译的时间，减少编译所生成的文件大小，提高你程序的执行效率。虽然现在计算机发展很快，在众多高级语言中已经很少考虑这种问题，但如果是使用c语言编写一些运行在资源较紧张的芯片或编写能耗敏感的一些项目时，仔细研究每个细节，合理的组建自己的工程等还是相当必要的。</p>","more":""},{"layout":"post","title":"大端和小端","date":"2016-10-30T02:30:00.000Z","_content":"\n*大小端和字节对齐，与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。*\n\n我们常常看到“alignment\"， \"endian\"之类的字眼， 但很少有 C 语言教材提到这些概念。 实际上它们是与处理器与内存接口， 编译器类型密切相关的。\n\n**端模式(Byte Endian)** 是指字节在内存中的组织，所以也称它为Byte Ordering。这边所谓的端模式一般就是指大端或者小端存储，也就是每个字节的实际排放顺序，上面已经讨论过字节在内存中如何进行对齐，这边讨论字节的常见排放顺序。\n\n数据寻址时，一般读取的都是低位字节的地址（即存储数据的可能占用多个地址，但低位地址代表了这个数据的地址）。C 中的数据类型都是从内存的低地址向高地址扩展，取址运算\"&\"都是取低地址。 所以就有高位地址和地位地址区别，一般来说数字大的就是高地址，数字小的是地址：比如 0x1000 相对于 0x1003 来说是低地址。数据低位和数据高位：比如 0x012345678 0x01 是数据高位（即使 Most Significant Byte，MSB 位），而 0x78 是数据低地址位（Least Significant Byte，LSB）。\n\n注意：有些地方 MSB 也可以代表 Most Significant Bit，LSB 则代表 Least Significant Bit 根据具体的场景来判别。如：FM25W256 铁电或者 EEPROM 中，描述的 MSB/LSB 根据时序图往往可以判别代表的高地位而不是字节。\n\n### 端模式(Byte Endian)简述\n\n- 大端模式：数据低位存放到地址高位。比如：存储数据0x01234567，按照0x01->1000，0x23->1001，0x45->1002，0x67->1003这种顺序存储。通讯中大都采用大段模式，因为数据通讯时，直接可以按照一个个位进行解析，无需每次调换顺序，大端模式往往在通讯中被广泛使用。\n\n- 小端模式：一般也称作内存模式，数据高位存放到地址高位。比如：存储数据0x01234567，按照0x67->1000，0x45->1001，0x23->1002，0x01->1003这种顺序存储。小端比较符合人的一般思维逻辑。嵌入式芯片中目前主流就是小端模式，绝大多数ARM芯片默认也为小端模式，但可以进行更改设置，传统的51芯片为大端模式。\n\n除了大小段模式外，还有一些协议自定义的转换标准，有的协议将两个字节(16bit)作为一个整体，如：传送数据0x00010203（按照内存模式/小端模式传送）时，会解析为0x0100，0x0302，具体分析，实际上采用的是大端模式，每次传输数据时，将16个作为个整体进行解析。\n\n### 详细分析\n\n最近阮一峰老师的博客刚好也写了一篇有关大小端的文章，老实说，大小端本人也接触很久了，但也一直较为困惑，另外时间一长每次就忘了哪个是大端哪个是小端，这边给出一些个人的理解和分析。\n\n描述大小端时有一点表示的比较模糊，这边前后有两种含义：1.内存的寻址肯定是从低往高的，所以下面表示的前或者后，都是以内存作为参照，前表示内存的低地址，后表示内存高地址；2.通信过程中，传输在前表示先被传输打印过来的值，传输在后表示后被传输打印出来的值（传输的过程也需要明确一点，数据的传输打印不是被逐个挤到后面去的，而是在后面以append的形式显示，后来的数据显示在后方）。明确了这两点内容这边详细谈下大小端：\n\n- 大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。内存中低地址对应数据的高位，传输中数据高位先被打印出来，因为先被打印出来（而打印按照从左往右的顺序逐个显示），所以例如：0x789A6B 就会显示为 78 9A 6B 这种更加符合人的阅读习惯。\n- 小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。内存中低地址对应数据的低位，传输中数据低位先被打印出来，因为先被打印出来（而打印按照从左往右的顺序逐个显示），所以例如：0x789A6B 就会显示为 6B 9A 78 这种更加符合人的阅读习惯。\n\n这边有些同学可能又有疑惑，为何 6B 可以解析为 6B(01101011) 而不是反过来 D6(11010110) 呢？事实上计算机在传输过程中确实有一个接近统一的标准的，无论是大端还是小端或者各种通讯协议（至少各种协议我还没有见过违背这个准则的），都满足原则：**先传输字符的低位，后传输字符的高位。**\n\n- *以下内容引用自阮一峰老师的博客：*  \n\n> 首先，为什么会有小端字节序？答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。\n> 但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。\n\n个人认为该内容有待斟酌，如 51 单片机就是大端模式，另外很多 ARM 的 MCU 都是默认小端，且可以用户自己设置选用大端还是小端模式的。个人认为计算机内部并不会因为大小端而影响效率，在设计芯片时应该已经决定了它的特性。小端模式在不考虑传输，人工查看的前提下，对例如：00 78 9A 6B 用 6B所对应的地址来表示 0x789A6B 这个数据数据的存储位置，也是有一定道理的。\n\n\n### 记忆方法\n\n> 在乔纳森·斯威夫特的著名讽刺小说《格列夫游记》中，小人国内部分裂成Big-endian和Little-endian两派，区别在于一派要求从鸡蛋的大头把鸡蛋打破，另一派要求从鸡蛋的小头把鸡蛋打破。斯威夫特借以讽刺英国的政党之争，在计算机工业中指数据储存顺序的分歧。\n\n这边首先需要有个参照物，计算机按照从低位往高位寻址这是毋容置疑的，存储时，也都是讲内存的低位用完后，指针加一，再使用更高的位。大端意味着内存的低位存储了数据的高位，小端则是内存的低位对应了数据的低位。\n\n\n\n### 测试大小端参考代码：\n\n```\n方法1：\ntypedef unsigned char u8;\n\nint main(void)\n{\n\tunsigned long int a = 0x01020304;\n\n\tfor (u8 i = 0; i < 4; i++)\n\t{\n\t\tprintf(\"%d\", *((u8 *)&a + i));  // 注意先加a的地址转换为无符号字符型再加地址，否则每次加1，地址会增加4。\n\t}\n}\n\n如果结果为：4321则为小端模式，而1234为大端模式。\n\n方法2：\n\ntypedef union\n{\n\tunsigned short int a;\n\tunsigned char b;\n}Union;\n\n\nint main(void)\n{\n\tUnion u1;\n\tu1.a = 0x0201;\n\n\tif (u1.b == 0x01)\n\t\tprintf(\"little endian\\n\");\n\telse if (u1.b == 0x02)\n\t\tprintf(\"big endian\\n\");\n}\n\n```\n\n***\n\n> 参考链接：\n> http://blog.csdn.net/vvzaixian/article/details/7067221\n> http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml\n> https://my.oschina.net/chaenomeles/blog/673091\n> http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html\n> http://www.ruanyifeng.com/blog/2016/11/byte-order.html\n","source":"_posts/2016/2016-10-30-大端和小端.md","raw":"---\nlayout: \"post\"\ntitle: \"大端和小端\"\ndate: \"2016-10-30 10:30\"\n---\n\n*大小端和字节对齐，与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。*\n\n我们常常看到“alignment\"， \"endian\"之类的字眼， 但很少有 C 语言教材提到这些概念。 实际上它们是与处理器与内存接口， 编译器类型密切相关的。\n\n**端模式(Byte Endian)** 是指字节在内存中的组织，所以也称它为Byte Ordering。这边所谓的端模式一般就是指大端或者小端存储，也就是每个字节的实际排放顺序，上面已经讨论过字节在内存中如何进行对齐，这边讨论字节的常见排放顺序。\n\n数据寻址时，一般读取的都是低位字节的地址（即存储数据的可能占用多个地址，但低位地址代表了这个数据的地址）。C 中的数据类型都是从内存的低地址向高地址扩展，取址运算\"&\"都是取低地址。 所以就有高位地址和地位地址区别，一般来说数字大的就是高地址，数字小的是地址：比如 0x1000 相对于 0x1003 来说是低地址。数据低位和数据高位：比如 0x012345678 0x01 是数据高位（即使 Most Significant Byte，MSB 位），而 0x78 是数据低地址位（Least Significant Byte，LSB）。\n\n注意：有些地方 MSB 也可以代表 Most Significant Bit，LSB 则代表 Least Significant Bit 根据具体的场景来判别。如：FM25W256 铁电或者 EEPROM 中，描述的 MSB/LSB 根据时序图往往可以判别代表的高地位而不是字节。\n\n### 端模式(Byte Endian)简述\n\n- 大端模式：数据低位存放到地址高位。比如：存储数据0x01234567，按照0x01->1000，0x23->1001，0x45->1002，0x67->1003这种顺序存储。通讯中大都采用大段模式，因为数据通讯时，直接可以按照一个个位进行解析，无需每次调换顺序，大端模式往往在通讯中被广泛使用。\n\n- 小端模式：一般也称作内存模式，数据高位存放到地址高位。比如：存储数据0x01234567，按照0x67->1000，0x45->1001，0x23->1002，0x01->1003这种顺序存储。小端比较符合人的一般思维逻辑。嵌入式芯片中目前主流就是小端模式，绝大多数ARM芯片默认也为小端模式，但可以进行更改设置，传统的51芯片为大端模式。\n\n除了大小段模式外，还有一些协议自定义的转换标准，有的协议将两个字节(16bit)作为一个整体，如：传送数据0x00010203（按照内存模式/小端模式传送）时，会解析为0x0100，0x0302，具体分析，实际上采用的是大端模式，每次传输数据时，将16个作为个整体进行解析。\n\n### 详细分析\n\n最近阮一峰老师的博客刚好也写了一篇有关大小端的文章，老实说，大小端本人也接触很久了，但也一直较为困惑，另外时间一长每次就忘了哪个是大端哪个是小端，这边给出一些个人的理解和分析。\n\n描述大小端时有一点表示的比较模糊，这边前后有两种含义：1.内存的寻址肯定是从低往高的，所以下面表示的前或者后，都是以内存作为参照，前表示内存的低地址，后表示内存高地址；2.通信过程中，传输在前表示先被传输打印过来的值，传输在后表示后被传输打印出来的值（传输的过程也需要明确一点，数据的传输打印不是被逐个挤到后面去的，而是在后面以append的形式显示，后来的数据显示在后方）。明确了这两点内容这边详细谈下大小端：\n\n- 大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。内存中低地址对应数据的高位，传输中数据高位先被打印出来，因为先被打印出来（而打印按照从左往右的顺序逐个显示），所以例如：0x789A6B 就会显示为 78 9A 6B 这种更加符合人的阅读习惯。\n- 小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。内存中低地址对应数据的低位，传输中数据低位先被打印出来，因为先被打印出来（而打印按照从左往右的顺序逐个显示），所以例如：0x789A6B 就会显示为 6B 9A 78 这种更加符合人的阅读习惯。\n\n这边有些同学可能又有疑惑，为何 6B 可以解析为 6B(01101011) 而不是反过来 D6(11010110) 呢？事实上计算机在传输过程中确实有一个接近统一的标准的，无论是大端还是小端或者各种通讯协议（至少各种协议我还没有见过违背这个准则的），都满足原则：**先传输字符的低位，后传输字符的高位。**\n\n- *以下内容引用自阮一峰老师的博客：*  \n\n> 首先，为什么会有小端字节序？答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。\n> 但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。\n\n个人认为该内容有待斟酌，如 51 单片机就是大端模式，另外很多 ARM 的 MCU 都是默认小端，且可以用户自己设置选用大端还是小端模式的。个人认为计算机内部并不会因为大小端而影响效率，在设计芯片时应该已经决定了它的特性。小端模式在不考虑传输，人工查看的前提下，对例如：00 78 9A 6B 用 6B所对应的地址来表示 0x789A6B 这个数据数据的存储位置，也是有一定道理的。\n\n\n### 记忆方法\n\n> 在乔纳森·斯威夫特的著名讽刺小说《格列夫游记》中，小人国内部分裂成Big-endian和Little-endian两派，区别在于一派要求从鸡蛋的大头把鸡蛋打破，另一派要求从鸡蛋的小头把鸡蛋打破。斯威夫特借以讽刺英国的政党之争，在计算机工业中指数据储存顺序的分歧。\n\n这边首先需要有个参照物，计算机按照从低位往高位寻址这是毋容置疑的，存储时，也都是讲内存的低位用完后，指针加一，再使用更高的位。大端意味着内存的低位存储了数据的高位，小端则是内存的低位对应了数据的低位。\n\n\n\n### 测试大小端参考代码：\n\n```\n方法1：\ntypedef unsigned char u8;\n\nint main(void)\n{\n\tunsigned long int a = 0x01020304;\n\n\tfor (u8 i = 0; i < 4; i++)\n\t{\n\t\tprintf(\"%d\", *((u8 *)&a + i));  // 注意先加a的地址转换为无符号字符型再加地址，否则每次加1，地址会增加4。\n\t}\n}\n\n如果结果为：4321则为小端模式，而1234为大端模式。\n\n方法2：\n\ntypedef union\n{\n\tunsigned short int a;\n\tunsigned char b;\n}Union;\n\n\nint main(void)\n{\n\tUnion u1;\n\tu1.a = 0x0201;\n\n\tif (u1.b == 0x01)\n\t\tprintf(\"little endian\\n\");\n\telse if (u1.b == 0x02)\n\t\tprintf(\"big endian\\n\");\n}\n\n```\n\n***\n\n> 参考链接：\n> http://blog.csdn.net/vvzaixian/article/details/7067221\n> http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml\n> https://my.oschina.net/chaenomeles/blog/673091\n> http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html\n> http://www.ruanyifeng.com/blog/2016/11/byte-order.html\n","slug":"2016/2016-10-30-大端和小端","published":1,"updated":"2016-12-27T08:08:37.283Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aiq0039mumufbmq4vn6","content":"<p><em>大小端和字节对齐，与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</em></p>\n<p>我们常常看到“alignment”， “endian”之类的字眼， 但很少有 C 语言教材提到这些概念。 实际上它们是与处理器与内存接口， 编译器类型密切相关的。</p>\n<p><strong>端模式(Byte Endian)</strong> 是指字节在内存中的组织，所以也称它为Byte Ordering。这边所谓的端模式一般就是指大端或者小端存储，也就是每个字节的实际排放顺序，上面已经讨论过字节在内存中如何进行对齐，这边讨论字节的常见排放顺序。</p>\n<p>数据寻址时，一般读取的都是低位字节的地址（即存储数据的可能占用多个地址，但低位地址代表了这个数据的地址）。C 中的数据类型都是从内存的低地址向高地址扩展，取址运算”&amp;”都是取低地址。 所以就有高位地址和地位地址区别，一般来说数字大的就是高地址，数字小的是地址：比如 0x1000 相对于 0x1003 来说是低地址。数据低位和数据高位：比如 0x012345678 0x01 是数据高位（即使 Most Significant Byte，MSB 位），而 0x78 是数据低地址位（Least Significant Byte，LSB）。</p>\n<p>注意：有些地方 MSB 也可以代表 Most Significant Bit，LSB 则代表 Least Significant Bit 根据具体的场景来判别。如：FM25W256 铁电或者 EEPROM 中，描述的 MSB/LSB 根据时序图往往可以判别代表的高地位而不是字节。</p>\n<h3 id=\"端模式-Byte-Endian-简述\"><a href=\"#端模式-Byte-Endian-简述\" class=\"headerlink\" title=\"端模式(Byte Endian)简述\"></a>端模式(Byte Endian)简述</h3><ul>\n<li><p>大端模式：数据低位存放到地址高位。比如：存储数据0x01234567，按照0x01-&gt;1000，0x23-&gt;1001，0x45-&gt;1002，0x67-&gt;1003这种顺序存储。通讯中大都采用大段模式，因为数据通讯时，直接可以按照一个个位进行解析，无需每次调换顺序，大端模式往往在通讯中被广泛使用。</p>\n</li>\n<li><p>小端模式：一般也称作内存模式，数据高位存放到地址高位。比如：存储数据0x01234567，按照0x67-&gt;1000，0x45-&gt;1001，0x23-&gt;1002，0x01-&gt;1003这种顺序存储。小端比较符合人的一般思维逻辑。嵌入式芯片中目前主流就是小端模式，绝大多数ARM芯片默认也为小端模式，但可以进行更改设置，传统的51芯片为大端模式。</p>\n</li>\n</ul>\n<p>除了大小段模式外，还有一些协议自定义的转换标准，有的协议将两个字节(16bit)作为一个整体，如：传送数据0x00010203（按照内存模式/小端模式传送）时，会解析为0x0100，0x0302，具体分析，实际上采用的是大端模式，每次传输数据时，将16个作为个整体进行解析。</p>\n<h3 id=\"详细分析\"><a href=\"#详细分析\" class=\"headerlink\" title=\"详细分析\"></a>详细分析</h3><p>最近阮一峰老师的博客刚好也写了一篇有关大小端的文章，老实说，大小端本人也接触很久了，但也一直较为困惑，另外时间一长每次就忘了哪个是大端哪个是小端，这边给出一些个人的理解和分析。</p>\n<p>描述大小端时有一点表示的比较模糊，这边前后有两种含义：1.内存的寻址肯定是从低往高的，所以下面表示的前或者后，都是以内存作为参照，前表示内存的低地址，后表示内存高地址；2.通信过程中，传输在前表示先被传输打印过来的值，传输在后表示后被传输打印出来的值（传输的过程也需要明确一点，数据的传输打印不是被逐个挤到后面去的，而是在后面以append的形式显示，后来的数据显示在后方）。明确了这两点内容这边详细谈下大小端：</p>\n<ul>\n<li>大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。内存中低地址对应数据的高位，传输中数据高位先被打印出来，因为先被打印出来（而打印按照从左往右的顺序逐个显示），所以例如：0x789A6B 就会显示为 78 9A 6B 这种更加符合人的阅读习惯。</li>\n<li>小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。内存中低地址对应数据的低位，传输中数据低位先被打印出来，因为先被打印出来（而打印按照从左往右的顺序逐个显示），所以例如：0x789A6B 就会显示为 6B 9A 78 这种更加符合人的阅读习惯。</li>\n</ul>\n<p>这边有些同学可能又有疑惑，为何 6B 可以解析为 6B(01101011) 而不是反过来 D6(11010110) 呢？事实上计算机在传输过程中确实有一个接近统一的标准的，无论是大端还是小端或者各种通讯协议（至少各种协议我还没有见过违背这个准则的），都满足原则：<strong>先传输字符的低位，后传输字符的高位。</strong></p>\n<ul>\n<li><em>以下内容引用自阮一峰老师的博客：</em>  </li>\n</ul>\n<blockquote>\n<p>首先，为什么会有小端字节序？答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。<br>但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p>\n</blockquote>\n<p>个人认为该内容有待斟酌，如 51 单片机就是大端模式，另外很多 ARM 的 MCU 都是默认小端，且可以用户自己设置选用大端还是小端模式的。个人认为计算机内部并不会因为大小端而影响效率，在设计芯片时应该已经决定了它的特性。小端模式在不考虑传输，人工查看的前提下，对例如：00 78 9A 6B 用 6B所对应的地址来表示 0x789A6B 这个数据数据的存储位置，也是有一定道理的。</p>\n<h3 id=\"记忆方法\"><a href=\"#记忆方法\" class=\"headerlink\" title=\"记忆方法\"></a>记忆方法</h3><blockquote>\n<p>在乔纳森·斯威夫特的著名讽刺小说《格列夫游记》中，小人国内部分裂成Big-endian和Little-endian两派，区别在于一派要求从鸡蛋的大头把鸡蛋打破，另一派要求从鸡蛋的小头把鸡蛋打破。斯威夫特借以讽刺英国的政党之争，在计算机工业中指数据储存顺序的分歧。</p>\n</blockquote>\n<p>这边首先需要有个参照物，计算机按照从低位往高位寻址这是毋容置疑的，存储时，也都是讲内存的低位用完后，指针加一，再使用更高的位。大端意味着内存的低位存储了数据的高位，小端则是内存的低位对应了数据的低位。</p>\n<h3 id=\"测试大小端参考代码：\"><a href=\"#测试大小端参考代码：\" class=\"headerlink\" title=\"测试大小端参考代码：\"></a>测试大小端参考代码：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">方法1：</div><div class=\"line\">typedef unsigned char u8;</div><div class=\"line\"></div><div class=\"line\">int main(void)</div><div class=\"line\">&#123;</div><div class=\"line\">\tunsigned long int a = 0x01020304;</div><div class=\"line\"></div><div class=\"line\">\tfor (u8 i = 0; i &lt; 4; i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tprintf(&quot;%d&quot;, *((u8 *)&amp;a + i));  // 注意先加a的地址转换为无符号字符型再加地址，否则每次加1，地址会增加4。</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">如果结果为：4321则为小端模式，而1234为大端模式。</div><div class=\"line\"></div><div class=\"line\">方法2：</div><div class=\"line\"></div><div class=\"line\">typedef union</div><div class=\"line\">&#123;</div><div class=\"line\">\tunsigned short int a;</div><div class=\"line\">\tunsigned char b;</div><div class=\"line\">&#125;Union;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">int main(void)</div><div class=\"line\">&#123;</div><div class=\"line\">\tUnion u1;</div><div class=\"line\">\tu1.a = 0x0201;</div><div class=\"line\"></div><div class=\"line\">\tif (u1.b == 0x01)</div><div class=\"line\">\t\tprintf(&quot;little endian\\n&quot;);</div><div class=\"line\">\telse if (u1.b == 0x02)</div><div class=\"line\">\t\tprintf(&quot;big endian\\n&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/vvzaixian/article/details/7067221\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/vvzaixian/article/details/7067221</a><br><a href=\"http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml\" target=\"_blank\" rel=\"external\">http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml</a><br><a href=\"https://my.oschina.net/chaenomeles/blog/673091\" target=\"_blank\" rel=\"external\">https://my.oschina.net/chaenomeles/blog/673091</a><br><a href=\"http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html</a><br><a href=\"http://www.ruanyifeng.com/blog/2016/11/byte-order.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2016/11/byte-order.html</a></p>\n</blockquote>\n","excerpt":"","more":"<p><em>大小端和字节对齐，与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</em></p>\n<p>我们常常看到“alignment”， “endian”之类的字眼， 但很少有 C 语言教材提到这些概念。 实际上它们是与处理器与内存接口， 编译器类型密切相关的。</p>\n<p><strong>端模式(Byte Endian)</strong> 是指字节在内存中的组织，所以也称它为Byte Ordering。这边所谓的端模式一般就是指大端或者小端存储，也就是每个字节的实际排放顺序，上面已经讨论过字节在内存中如何进行对齐，这边讨论字节的常见排放顺序。</p>\n<p>数据寻址时，一般读取的都是低位字节的地址（即存储数据的可能占用多个地址，但低位地址代表了这个数据的地址）。C 中的数据类型都是从内存的低地址向高地址扩展，取址运算”&amp;”都是取低地址。 所以就有高位地址和地位地址区别，一般来说数字大的就是高地址，数字小的是地址：比如 0x1000 相对于 0x1003 来说是低地址。数据低位和数据高位：比如 0x012345678 0x01 是数据高位（即使 Most Significant Byte，MSB 位），而 0x78 是数据低地址位（Least Significant Byte，LSB）。</p>\n<p>注意：有些地方 MSB 也可以代表 Most Significant Bit，LSB 则代表 Least Significant Bit 根据具体的场景来判别。如：FM25W256 铁电或者 EEPROM 中，描述的 MSB/LSB 根据时序图往往可以判别代表的高地位而不是字节。</p>\n<h3 id=\"端模式-Byte-Endian-简述\"><a href=\"#端模式-Byte-Endian-简述\" class=\"headerlink\" title=\"端模式(Byte Endian)简述\"></a>端模式(Byte Endian)简述</h3><ul>\n<li><p>大端模式：数据低位存放到地址高位。比如：存储数据0x01234567，按照0x01-&gt;1000，0x23-&gt;1001，0x45-&gt;1002，0x67-&gt;1003这种顺序存储。通讯中大都采用大段模式，因为数据通讯时，直接可以按照一个个位进行解析，无需每次调换顺序，大端模式往往在通讯中被广泛使用。</p>\n</li>\n<li><p>小端模式：一般也称作内存模式，数据高位存放到地址高位。比如：存储数据0x01234567，按照0x67-&gt;1000，0x45-&gt;1001，0x23-&gt;1002，0x01-&gt;1003这种顺序存储。小端比较符合人的一般思维逻辑。嵌入式芯片中目前主流就是小端模式，绝大多数ARM芯片默认也为小端模式，但可以进行更改设置，传统的51芯片为大端模式。</p>\n</li>\n</ul>\n<p>除了大小段模式外，还有一些协议自定义的转换标准，有的协议将两个字节(16bit)作为一个整体，如：传送数据0x00010203（按照内存模式/小端模式传送）时，会解析为0x0100，0x0302，具体分析，实际上采用的是大端模式，每次传输数据时，将16个作为个整体进行解析。</p>\n<h3 id=\"详细分析\"><a href=\"#详细分析\" class=\"headerlink\" title=\"详细分析\"></a>详细分析</h3><p>最近阮一峰老师的博客刚好也写了一篇有关大小端的文章，老实说，大小端本人也接触很久了，但也一直较为困惑，另外时间一长每次就忘了哪个是大端哪个是小端，这边给出一些个人的理解和分析。</p>\n<p>描述大小端时有一点表示的比较模糊，这边前后有两种含义：1.内存的寻址肯定是从低往高的，所以下面表示的前或者后，都是以内存作为参照，前表示内存的低地址，后表示内存高地址；2.通信过程中，传输在前表示先被传输打印过来的值，传输在后表示后被传输打印出来的值（传输的过程也需要明确一点，数据的传输打印不是被逐个挤到后面去的，而是在后面以append的形式显示，后来的数据显示在后方）。明确了这两点内容这边详细谈下大小端：</p>\n<ul>\n<li>大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。内存中低地址对应数据的高位，传输中数据高位先被打印出来，因为先被打印出来（而打印按照从左往右的顺序逐个显示），所以例如：0x789A6B 就会显示为 78 9A 6B 这种更加符合人的阅读习惯。</li>\n<li>小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。内存中低地址对应数据的低位，传输中数据低位先被打印出来，因为先被打印出来（而打印按照从左往右的顺序逐个显示），所以例如：0x789A6B 就会显示为 6B 9A 78 这种更加符合人的阅读习惯。</li>\n</ul>\n<p>这边有些同学可能又有疑惑，为何 6B 可以解析为 6B(01101011) 而不是反过来 D6(11010110) 呢？事实上计算机在传输过程中确实有一个接近统一的标准的，无论是大端还是小端或者各种通讯协议（至少各种协议我还没有见过违背这个准则的），都满足原则：<strong>先传输字符的低位，后传输字符的高位。</strong></p>\n<ul>\n<li><em>以下内容引用自阮一峰老师的博客：</em>  </li>\n</ul>\n<blockquote>\n<p>首先，为什么会有小端字节序？答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。<br>但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p>\n</blockquote>\n<p>个人认为该内容有待斟酌，如 51 单片机就是大端模式，另外很多 ARM 的 MCU 都是默认小端，且可以用户自己设置选用大端还是小端模式的。个人认为计算机内部并不会因为大小端而影响效率，在设计芯片时应该已经决定了它的特性。小端模式在不考虑传输，人工查看的前提下，对例如：00 78 9A 6B 用 6B所对应的地址来表示 0x789A6B 这个数据数据的存储位置，也是有一定道理的。</p>\n<h3 id=\"记忆方法\"><a href=\"#记忆方法\" class=\"headerlink\" title=\"记忆方法\"></a>记忆方法</h3><blockquote>\n<p>在乔纳森·斯威夫特的著名讽刺小说《格列夫游记》中，小人国内部分裂成Big-endian和Little-endian两派，区别在于一派要求从鸡蛋的大头把鸡蛋打破，另一派要求从鸡蛋的小头把鸡蛋打破。斯威夫特借以讽刺英国的政党之争，在计算机工业中指数据储存顺序的分歧。</p>\n</blockquote>\n<p>这边首先需要有个参照物，计算机按照从低位往高位寻址这是毋容置疑的，存储时，也都是讲内存的低位用完后，指针加一，再使用更高的位。大端意味着内存的低位存储了数据的高位，小端则是内存的低位对应了数据的低位。</p>\n<h3 id=\"测试大小端参考代码：\"><a href=\"#测试大小端参考代码：\" class=\"headerlink\" title=\"测试大小端参考代码：\"></a>测试大小端参考代码：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">方法1：</div><div class=\"line\">typedef unsigned char u8;</div><div class=\"line\"></div><div class=\"line\">int main(void)</div><div class=\"line\">&#123;</div><div class=\"line\">\tunsigned long int a = 0x01020304;</div><div class=\"line\"></div><div class=\"line\">\tfor (u8 i = 0; i &lt; 4; i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tprintf(&quot;%d&quot;, *((u8 *)&amp;a + i));  // 注意先加a的地址转换为无符号字符型再加地址，否则每次加1，地址会增加4。</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">如果结果为：4321则为小端模式，而1234为大端模式。</div><div class=\"line\"></div><div class=\"line\">方法2：</div><div class=\"line\"></div><div class=\"line\">typedef union</div><div class=\"line\">&#123;</div><div class=\"line\">\tunsigned short int a;</div><div class=\"line\">\tunsigned char b;</div><div class=\"line\">&#125;Union;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">int main(void)</div><div class=\"line\">&#123;</div><div class=\"line\">\tUnion u1;</div><div class=\"line\">\tu1.a = 0x0201;</div><div class=\"line\"></div><div class=\"line\">\tif (u1.b == 0x01)</div><div class=\"line\">\t\tprintf(&quot;little endian\\n&quot;);</div><div class=\"line\">\telse if (u1.b == 0x02)</div><div class=\"line\">\t\tprintf(&quot;big endian\\n&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/vvzaixian/article/details/7067221\">http://blog.csdn.net/vvzaixian/article/details/7067221</a><br><a href=\"http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml\">http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml</a><br><a href=\"https://my.oschina.net/chaenomeles/blog/673091\">https://my.oschina.net/chaenomeles/blog/673091</a><br><a href=\"http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html\">http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html</a><br><a href=\"http://www.ruanyifeng.com/blog/2016/11/byte-order.html\">http://www.ruanyifeng.com/blog/2016/11/byte-order.html</a></p>\n</blockquote>\n"},{"layout":"post","title":"美国总统诞生了","date":"2016-11-10T00:53:00.000Z","_content":"\n2016年11月9日，美国大选计票结果显示：共和党候选人唐纳德·特朗普已获得了276张选举人票，超过270张选举人票的获胜标准，成为美国第45位总统。\n\n就在昨天美国总统诞生了，很多网络论坛称新一代总统为喷子界的骄傲。如果特朗普真如他做演讲时那样治国，无疑整个美国或者说全球会发生大的动荡，特朗普于历来总统都不太一样，就他演讲来说，几乎是完全站在美国贫民普通阶层这边的，因此我们通过谷歌各州的投票结果也可以看出，支持特朗普的几乎全是美国欠发达地区。特朗普的政治主张很反科技，甚至有点另类到要将劳动密集的行业重新带回美国，他的很多举止有点让人摸不着头脑，但也确实是针对美国一些顽疾的一剂猛药。这届美国总统是一个较大的变数，就特朗普的种种举措，可以分两点。\n\n其一，特朗普能够切实的成为一个出色的总统，通过降低税收，增强了创业公司的活力，通过自动化和本地工人结合创造了更多就业，解决了民生问题等。\n\n其二，将美国彻底的玩坏了，一味的打压科技公司，阻止了美国的发展，本地的一些民生政策也出现了较大的问题等。\n\n当然除了以上的一些猜测，不得不怀疑，特朗普是一个彻头彻尾的骗子，不择手段上台了之后，并没有履行任何他的承诺。\n\n<!-- more -->\n","source":"_posts/2016/2016-11-10-美国总统诞生了.md","raw":"---\nlayout: \"post\"\ntitle: \"美国总统诞生了\"\ndate: \"2016-11-10 08:53\"\n---\n\n2016年11月9日，美国大选计票结果显示：共和党候选人唐纳德·特朗普已获得了276张选举人票，超过270张选举人票的获胜标准，成为美国第45位总统。\n\n就在昨天美国总统诞生了，很多网络论坛称新一代总统为喷子界的骄傲。如果特朗普真如他做演讲时那样治国，无疑整个美国或者说全球会发生大的动荡，特朗普于历来总统都不太一样，就他演讲来说，几乎是完全站在美国贫民普通阶层这边的，因此我们通过谷歌各州的投票结果也可以看出，支持特朗普的几乎全是美国欠发达地区。特朗普的政治主张很反科技，甚至有点另类到要将劳动密集的行业重新带回美国，他的很多举止有点让人摸不着头脑，但也确实是针对美国一些顽疾的一剂猛药。这届美国总统是一个较大的变数，就特朗普的种种举措，可以分两点。\n\n其一，特朗普能够切实的成为一个出色的总统，通过降低税收，增强了创业公司的活力，通过自动化和本地工人结合创造了更多就业，解决了民生问题等。\n\n其二，将美国彻底的玩坏了，一味的打压科技公司，阻止了美国的发展，本地的一些民生政策也出现了较大的问题等。\n\n当然除了以上的一些猜测，不得不怀疑，特朗普是一个彻头彻尾的骗子，不择手段上台了之后，并没有履行任何他的承诺。\n\n<!-- more -->\n","slug":"2016/2016-11-10-美国总统诞生了","published":1,"updated":"2016-12-16T01:50:16.851Z","comments":1,"photos":[],"link":"","_id":"ciyuv3air003amumuf6wwn78d","content":"<p>2016年11月9日，美国大选计票结果显示：共和党候选人唐纳德·特朗普已获得了276张选举人票，超过270张选举人票的获胜标准，成为美国第45位总统。</p>\n<p>就在昨天美国总统诞生了，很多网络论坛称新一代总统为喷子界的骄傲。如果特朗普真如他做演讲时那样治国，无疑整个美国或者说全球会发生大的动荡，特朗普于历来总统都不太一样，就他演讲来说，几乎是完全站在美国贫民普通阶层这边的，因此我们通过谷歌各州的投票结果也可以看出，支持特朗普的几乎全是美国欠发达地区。特朗普的政治主张很反科技，甚至有点另类到要将劳动密集的行业重新带回美国，他的很多举止有点让人摸不着头脑，但也确实是针对美国一些顽疾的一剂猛药。这届美国总统是一个较大的变数，就特朗普的种种举措，可以分两点。</p>\n<p>其一，特朗普能够切实的成为一个出色的总统，通过降低税收，增强了创业公司的活力，通过自动化和本地工人结合创造了更多就业，解决了民生问题等。</p>\n<p>其二，将美国彻底的玩坏了，一味的打压科技公司，阻止了美国的发展，本地的一些民生政策也出现了较大的问题等。</p>\n<p>当然除了以上的一些猜测，不得不怀疑，特朗普是一个彻头彻尾的骗子，不择手段上台了之后，并没有履行任何他的承诺。</p>\n<a id=\"more\"></a>\n","excerpt":"<p>2016年11月9日，美国大选计票结果显示：共和党候选人唐纳德·特朗普已获得了276张选举人票，超过270张选举人票的获胜标准，成为美国第45位总统。</p>\n<p>就在昨天美国总统诞生了，很多网络论坛称新一代总统为喷子界的骄傲。如果特朗普真如他做演讲时那样治国，无疑整个美国或者说全球会发生大的动荡，特朗普于历来总统都不太一样，就他演讲来说，几乎是完全站在美国贫民普通阶层这边的，因此我们通过谷歌各州的投票结果也可以看出，支持特朗普的几乎全是美国欠发达地区。特朗普的政治主张很反科技，甚至有点另类到要将劳动密集的行业重新带回美国，他的很多举止有点让人摸不着头脑，但也确实是针对美国一些顽疾的一剂猛药。这届美国总统是一个较大的变数，就特朗普的种种举措，可以分两点。</p>\n<p>其一，特朗普能够切实的成为一个出色的总统，通过降低税收，增强了创业公司的活力，通过自动化和本地工人结合创造了更多就业，解决了民生问题等。</p>\n<p>其二，将美国彻底的玩坏了，一味的打压科技公司，阻止了美国的发展，本地的一些民生政策也出现了较大的问题等。</p>\n<p>当然除了以上的一些猜测，不得不怀疑，特朗普是一个彻头彻尾的骗子，不择手段上台了之后，并没有履行任何他的承诺。</p>","more":""},{"layout":"post","title":"字节对齐","date":"2016-10-29T23:32:00.000Z","_content":"\n*大小端和字节对齐，与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。*\n\n我们常常看到“alignment\"， \"endian\"之类的字眼， 但很少有 C 语言教材提到这些概念。 实际上它们是与处理器与内存接口， 编译器类型密切相关的。与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。\n\n### 字节对齐（Byte Alignment）\n\n我们写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。但是，正因为我们一般不需要关心这个问题，所以因为编辑器对数据存放做了对齐，而我们不了解的话，常常会对一些问题感到迷惑。最常见的就是 struct 数据结构的 sizeof 结果，出乎意料。为此，我们需要对对齐算法所了解。\n\n现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。\n\n内存地址对齐，是一种在计算机内存中排列数据、访问数据的一种方式，包含了两种相互独立又相互关联的部分：基本数据对齐和结构体数据对齐。当今的计算机在计算机内存中读写数据时都是按字(word)大小块来进行操作的(在32位系统中，数据总线宽度为32，每次能读取4字节，地址总线宽度为32，因此最大的寻址空间为2^32=4GB，但是最低2位A[0]，A[1]是不用于寻址，A[2-31]才能存储器相连，因此只能访问4的倍数地址空间，但是总的寻址空间还是2^30 * 字长 = 4GB，因此在内存中所有存放的基本类型数据的首地址的最低两位都是0，除结构体中的成员变量)。**基本类型数据对齐就是数据在内存中的偏移地址必须等于一个字的倍数**，按这种存储数据的方式，可以提升系统在读取数据时的性能。**为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节，这就是结构体数据对齐**。\n\n举个例子，假设计算机的字大小为4个字节，因此变量在内存中的首地址都是满足4地址对齐，CPU只能对4的倍数的地址进行读取，而每次能读取4个字节大小的数据。假设有一个整型的数据a的首地址不是4的倍数(如下图所示)，不妨设为0X00FFFFF3，则该整型数据存储在地址范围为0X00FFFFF3~0X00FFFFF6的存储空间中，而CPU每次只能对4的倍数内存地址进行读取，因此想读取a的数据，CPU要分别在0X00FFFFF0和0X00FFFFF4进行两次内存读取，而且还要对两次读取的数据进行处理才能得到a的数据，而一个程序的瓶颈往往不是CPU的速度，而是取决于内存的带宽，因为CPU得处理速度要远大于从内存中读取数据的速度，因此减少对内存空间的访问是提高程序性能的关键。从上例可以看出，采取内存地址对齐策略是提高程序性能的关键。\n\n结构体(struct)是C语言中非常有用的用户自定义数据类型，而结构体类型的变量以及其各成员在内存中的又是怎样布局的呢？怎样对齐的呢？很显然**结构体变量首地址必须是4字节对齐的**，但是**结构体的每个成员有各自默认的对齐方式**，结构体中各成员在内存中出现的位置是随它们的声明顺序依次递增的，并且**第一个成员的首地址等于整个结构体变量的首地址**。下面列出了在Microsoft，Borland，GNU上对于X86架构32位系统的结构体成员各种类型的默认对齐方式。\n\n```\nchar(1字节)，1字节对齐\nshort(2字节)，2字节对齐\nint(4字节)，4字节对齐\nfloat(4字节)，4字节对齐\ndouble(8字节)，Windows系统中8字节对齐，Linux系统中4字节对齐。\n*不同CPU的对其规则可能不同, 请参考手册。*\n```\n\n各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为 32 位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要 2 个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该 int 数据。显然在读取效率上下降很多。这也是空间和时间的博弈。\n\n<!-- more -->\n\n\n### 对齐的算法：\n\n由于各个平台和编译器的不同，现以 gcc 3.4.5 编译器（x64平台）为例，来讨论编译器对 struct 数据结构中的各成员如何进行对齐的。\n\n```\n测试程序如下：\n\ntypedef struct\n{\n\tlong int a;\n\tchar b;\n\tshort c;\n}STRU_A;\n\ntypedef struct\n{\n\tchar b;\n\tlong int a;\n\tshort c;\n}STRU_B;\n\nint main(void)\n{\n\tprintf(\"%d, %d\\n\", sizeof (STRU_A), sizeof (STRU_B));\n}\n```\n结构体 A 中包含了 4 字节长度的 int 1个，1 字节长度的 char 1个和 2 字节长度的 short 型数据1个。所以 A 用到的空间应该是 7 字节。但是因为编译器要对数据成员在空间上进行对齐。所以使用 sizeof(STRU_A)值为 8。现在把该结构体调整成员变量的顺序。这时候同样是总共 7 个字节的变量，但是 sizeof(STRU_B)的值却是 12。\n\n程序编译器对结构存储的特殊处理确实提高了CPU的存储变量速度，但有时候也会带来一些麻烦，这边我们使用#pragma pack (value)来屏蔽掉变量默认的对齐方式。下面我们使用预编译指令#pragma pack (value)来告诉编译器，使用我们指定的对齐值来取代缺省的。\n\n```\n进一步我们修改代码：\n\n#pragma pack (2) /*指定按 2 字节对齐*/\ntypedef struct\n{\n\tchar b;\n\tlong int a;\n\tshort c;\n}STRU1;\n#pragma pack () /*取消指定对齐，恢复缺省对齐*/\n\n#pragma pack (1) /*指定按 1 字节对齐*/\ntypedef struct\n{\n\tchar b;\n\tlong int a;\n\tshort c;\n}STRU2;\n#pragma pack () /*取消指定对齐，恢复缺省对齐*/\n\nint main(void)\n{\n\tprintf(\"%d, %d\\n\", sizeof (STRU1), sizeof (STRU2));\n}\n```\n\nsizeof(STRU1)值为 7。对于 char 型数据，其自身对齐值为 1，对于 short 型为 2，对于 int,float,double类型，其自身对齐值为 4，单位字节。\n\n这里面有四个概念值：\n\n- 数据类型自身的对齐值：就是上面交代的基本数据类型的自身对齐值。\n- 指定对齐值：#pragma pack (value)时的指定对齐值 value。\n- 结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。\n- 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。\n\n有了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值 N 是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是 表示“对齐在 N 上”，也就是说该数据的\"存放起始地址%N=0\".而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整数 倍，结合下面例子理解)。这样就不能理解上面的几个例子的值了。\n\n```\n例子分析：\n分析例子 B；\nstruct B\n{\n\tchar b;\n\tint a;\n\tshort c;\n};\n```\n\n假设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，该值默认为4。第一个成员变量b的自身对齐值是1，比指定或者默认指定对齐值4小，所以其有效对齐值为1，所以其存放地址0x0000符合0x0000%1=0.第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4，所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4=0,且紧靠第一个变量。第三个变量c,自身对齐值为2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2=0。所以从0x0000到0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，0x0009到0x0000=10字节，（10＋2）％4＝0。所以0x0000A到0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节,sizeof(struct B)=12;同理,分析上面例子C：\n\n```\n#pragma pack (2) /*指定按 2 字节对齐*/\nstruct C\n{\n\tchar b;\n\tint a;\n\tshort c;\n};\n#pragma pack () /*取消指定对齐，恢复缺省对齐*/\n```\n\n第一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1=0;第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续字节中，符合0x0002%2=0。第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006、0x0007中，符合0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2=0,C只占用0x0000到0x0007的八个字节。所以sizeof(struct C)=8。\n\n\n下面是一个有char，int，short三种类型，4个成员组成的结构体，该结构体在还未编译之前是大小占8个字节。\n\n```\nstruct AlignData\n{\n\tchar a;\n\tshort b;\n\tint c;\n\tchar d;\n};\n```\n\n编译之后，为了保持结构体中的每个成员都是按照各自的对齐，编译器会在一些成员之间插入一些padding，因此编译后得到如下的结构体：\n\n```\nstruct AlignData \n{\n\tchar a;\n\tchar Padding0[1];\n\tshort b;\n\tint c;\n\tchar d;\n\tchar Padding1[3];\n};\n```\n\n编译后该结构体的大小为12个字节，**最后一个成员d后面填充的字节数要使该结构体的总大小是其成员类型中拥有最大字节数的倍数**(int拥有最大字节数)，因此d后面要填充3个字节。\n\n通过以上的详细分析，我们可以总结编译器在自动分配结构体类型对齐时，**一般是以第一个数据为基准值，然后往后累加地址查找，最终确保将每个需要分配的数据分配到sizeof(data)整数倍的地址上面。至于那些在查找过程中不满足要求的存储空间就空出。**一般主要满足以下规则：\n\n- 单个字节(char)能对齐到任意地址\n- 2字节(short)以2字节边界对齐\n- 4字节(int, long)以4字节边界对齐\n\n\n\n***\n\n> 参考链接：\n> http://blog.csdn.net/vvzaixian/article/details/7067221\n> http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml\n> https://my.oschina.net/chaenomeles/blog/673091\n> http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html\n> http://www.ruanyifeng.com/blog/2016/11/byte-order.html\n","source":"_posts/2016/2016-10-30-字节对齐.md","raw":"---\nlayout: \"post\"\ntitle: \"字节对齐\"\ndate: \"2016-10-30 07:32\"\n---\n\n*大小端和字节对齐，与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。*\n\n我们常常看到“alignment\"， \"endian\"之类的字眼， 但很少有 C 语言教材提到这些概念。 实际上它们是与处理器与内存接口， 编译器类型密切相关的。与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。\n\n### 字节对齐（Byte Alignment）\n\n我们写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。但是，正因为我们一般不需要关心这个问题，所以因为编辑器对数据存放做了对齐，而我们不了解的话，常常会对一些问题感到迷惑。最常见的就是 struct 数据结构的 sizeof 结果，出乎意料。为此，我们需要对对齐算法所了解。\n\n现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。\n\n内存地址对齐，是一种在计算机内存中排列数据、访问数据的一种方式，包含了两种相互独立又相互关联的部分：基本数据对齐和结构体数据对齐。当今的计算机在计算机内存中读写数据时都是按字(word)大小块来进行操作的(在32位系统中，数据总线宽度为32，每次能读取4字节，地址总线宽度为32，因此最大的寻址空间为2^32=4GB，但是最低2位A[0]，A[1]是不用于寻址，A[2-31]才能存储器相连，因此只能访问4的倍数地址空间，但是总的寻址空间还是2^30 * 字长 = 4GB，因此在内存中所有存放的基本类型数据的首地址的最低两位都是0，除结构体中的成员变量)。**基本类型数据对齐就是数据在内存中的偏移地址必须等于一个字的倍数**，按这种存储数据的方式，可以提升系统在读取数据时的性能。**为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节，这就是结构体数据对齐**。\n\n举个例子，假设计算机的字大小为4个字节，因此变量在内存中的首地址都是满足4地址对齐，CPU只能对4的倍数的地址进行读取，而每次能读取4个字节大小的数据。假设有一个整型的数据a的首地址不是4的倍数(如下图所示)，不妨设为0X00FFFFF3，则该整型数据存储在地址范围为0X00FFFFF3~0X00FFFFF6的存储空间中，而CPU每次只能对4的倍数内存地址进行读取，因此想读取a的数据，CPU要分别在0X00FFFFF0和0X00FFFFF4进行两次内存读取，而且还要对两次读取的数据进行处理才能得到a的数据，而一个程序的瓶颈往往不是CPU的速度，而是取决于内存的带宽，因为CPU得处理速度要远大于从内存中读取数据的速度，因此减少对内存空间的访问是提高程序性能的关键。从上例可以看出，采取内存地址对齐策略是提高程序性能的关键。\n\n结构体(struct)是C语言中非常有用的用户自定义数据类型，而结构体类型的变量以及其各成员在内存中的又是怎样布局的呢？怎样对齐的呢？很显然**结构体变量首地址必须是4字节对齐的**，但是**结构体的每个成员有各自默认的对齐方式**，结构体中各成员在内存中出现的位置是随它们的声明顺序依次递增的，并且**第一个成员的首地址等于整个结构体变量的首地址**。下面列出了在Microsoft，Borland，GNU上对于X86架构32位系统的结构体成员各种类型的默认对齐方式。\n\n```\nchar(1字节)，1字节对齐\nshort(2字节)，2字节对齐\nint(4字节)，4字节对齐\nfloat(4字节)，4字节对齐\ndouble(8字节)，Windows系统中8字节对齐，Linux系统中4字节对齐。\n*不同CPU的对其规则可能不同, 请参考手册。*\n```\n\n各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为 32 位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要 2 个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该 int 数据。显然在读取效率上下降很多。这也是空间和时间的博弈。\n\n<!-- more -->\n\n\n### 对齐的算法：\n\n由于各个平台和编译器的不同，现以 gcc 3.4.5 编译器（x64平台）为例，来讨论编译器对 struct 数据结构中的各成员如何进行对齐的。\n\n```\n测试程序如下：\n\ntypedef struct\n{\n\tlong int a;\n\tchar b;\n\tshort c;\n}STRU_A;\n\ntypedef struct\n{\n\tchar b;\n\tlong int a;\n\tshort c;\n}STRU_B;\n\nint main(void)\n{\n\tprintf(\"%d, %d\\n\", sizeof (STRU_A), sizeof (STRU_B));\n}\n```\n结构体 A 中包含了 4 字节长度的 int 1个，1 字节长度的 char 1个和 2 字节长度的 short 型数据1个。所以 A 用到的空间应该是 7 字节。但是因为编译器要对数据成员在空间上进行对齐。所以使用 sizeof(STRU_A)值为 8。现在把该结构体调整成员变量的顺序。这时候同样是总共 7 个字节的变量，但是 sizeof(STRU_B)的值却是 12。\n\n程序编译器对结构存储的特殊处理确实提高了CPU的存储变量速度，但有时候也会带来一些麻烦，这边我们使用#pragma pack (value)来屏蔽掉变量默认的对齐方式。下面我们使用预编译指令#pragma pack (value)来告诉编译器，使用我们指定的对齐值来取代缺省的。\n\n```\n进一步我们修改代码：\n\n#pragma pack (2) /*指定按 2 字节对齐*/\ntypedef struct\n{\n\tchar b;\n\tlong int a;\n\tshort c;\n}STRU1;\n#pragma pack () /*取消指定对齐，恢复缺省对齐*/\n\n#pragma pack (1) /*指定按 1 字节对齐*/\ntypedef struct\n{\n\tchar b;\n\tlong int a;\n\tshort c;\n}STRU2;\n#pragma pack () /*取消指定对齐，恢复缺省对齐*/\n\nint main(void)\n{\n\tprintf(\"%d, %d\\n\", sizeof (STRU1), sizeof (STRU2));\n}\n```\n\nsizeof(STRU1)值为 7。对于 char 型数据，其自身对齐值为 1，对于 short 型为 2，对于 int,float,double类型，其自身对齐值为 4，单位字节。\n\n这里面有四个概念值：\n\n- 数据类型自身的对齐值：就是上面交代的基本数据类型的自身对齐值。\n- 指定对齐值：#pragma pack (value)时的指定对齐值 value。\n- 结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。\n- 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。\n\n有了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值 N 是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是 表示“对齐在 N 上”，也就是说该数据的\"存放起始地址%N=0\".而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整数 倍，结合下面例子理解)。这样就不能理解上面的几个例子的值了。\n\n```\n例子分析：\n分析例子 B；\nstruct B\n{\n\tchar b;\n\tint a;\n\tshort c;\n};\n```\n\n假设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，该值默认为4。第一个成员变量b的自身对齐值是1，比指定或者默认指定对齐值4小，所以其有效对齐值为1，所以其存放地址0x0000符合0x0000%1=0.第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4，所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4=0,且紧靠第一个变量。第三个变量c,自身对齐值为2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2=0。所以从0x0000到0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，0x0009到0x0000=10字节，（10＋2）％4＝0。所以0x0000A到0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节,sizeof(struct B)=12;同理,分析上面例子C：\n\n```\n#pragma pack (2) /*指定按 2 字节对齐*/\nstruct C\n{\n\tchar b;\n\tint a;\n\tshort c;\n};\n#pragma pack () /*取消指定对齐，恢复缺省对齐*/\n```\n\n第一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1=0;第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续字节中，符合0x0002%2=0。第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006、0x0007中，符合0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2=0,C只占用0x0000到0x0007的八个字节。所以sizeof(struct C)=8。\n\n\n下面是一个有char，int，short三种类型，4个成员组成的结构体，该结构体在还未编译之前是大小占8个字节。\n\n```\nstruct AlignData\n{\n\tchar a;\n\tshort b;\n\tint c;\n\tchar d;\n};\n```\n\n编译之后，为了保持结构体中的每个成员都是按照各自的对齐，编译器会在一些成员之间插入一些padding，因此编译后得到如下的结构体：\n\n```\nstruct AlignData \n{\n\tchar a;\n\tchar Padding0[1];\n\tshort b;\n\tint c;\n\tchar d;\n\tchar Padding1[3];\n};\n```\n\n编译后该结构体的大小为12个字节，**最后一个成员d后面填充的字节数要使该结构体的总大小是其成员类型中拥有最大字节数的倍数**(int拥有最大字节数)，因此d后面要填充3个字节。\n\n通过以上的详细分析，我们可以总结编译器在自动分配结构体类型对齐时，**一般是以第一个数据为基准值，然后往后累加地址查找，最终确保将每个需要分配的数据分配到sizeof(data)整数倍的地址上面。至于那些在查找过程中不满足要求的存储空间就空出。**一般主要满足以下规则：\n\n- 单个字节(char)能对齐到任意地址\n- 2字节(short)以2字节边界对齐\n- 4字节(int, long)以4字节边界对齐\n\n\n\n***\n\n> 参考链接：\n> http://blog.csdn.net/vvzaixian/article/details/7067221\n> http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml\n> https://my.oschina.net/chaenomeles/blog/673091\n> http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html\n> http://www.ruanyifeng.com/blog/2016/11/byte-order.html\n","slug":"2016/2016-10-30-字节对齐","published":1,"updated":"2016-12-27T08:01:58.227Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ais003bmumun039dsqy","content":"<p><em>大小端和字节对齐，与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</em></p>\n<p>我们常常看到“alignment”， “endian”之类的字眼， 但很少有 C 语言教材提到这些概念。 实际上它们是与处理器与内存接口， 编译器类型密切相关的。与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</p>\n<h3 id=\"字节对齐（Byte-Alignment）\"><a href=\"#字节对齐（Byte-Alignment）\" class=\"headerlink\" title=\"字节对齐（Byte Alignment）\"></a>字节对齐（Byte Alignment）</h3><p>我们写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。但是，正因为我们一般不需要关心这个问题，所以因为编辑器对数据存放做了对齐，而我们不了解的话，常常会对一些问题感到迷惑。最常见的就是 struct 数据结构的 sizeof 结果，出乎意料。为此，我们需要对对齐算法所了解。</p>\n<p>现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>\n<p>内存地址对齐，是一种在计算机内存中排列数据、访问数据的一种方式，包含了两种相互独立又相互关联的部分：基本数据对齐和结构体数据对齐。当今的计算机在计算机内存中读写数据时都是按字(word)大小块来进行操作的(在32位系统中，数据总线宽度为32，每次能读取4字节，地址总线宽度为32，因此最大的寻址空间为2^32=4GB，但是最低2位A[0]，A[1]是不用于寻址，A[2-31]才能存储器相连，因此只能访问4的倍数地址空间，但是总的寻址空间还是2^30 <em> 字长 = 4GB，因此在内存中所有存放的基本类型数据的首地址的最低两位都是0，除结构体中的成员变量)。<strong>基本类型数据对齐就是数据在内存中的偏移地址必须等于一个字的倍数</strong>，按这种存储数据的方式，可以提升系统在读取数据时的性能。<em>*为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节，这就是结构体数据对齐</em></em>。</p>\n<p>举个例子，假设计算机的字大小为4个字节，因此变量在内存中的首地址都是满足4地址对齐，CPU只能对4的倍数的地址进行读取，而每次能读取4个字节大小的数据。假设有一个整型的数据a的首地址不是4的倍数(如下图所示)，不妨设为0X00FFFFF3，则该整型数据存储在地址范围为0X00FFFFF3~0X00FFFFF6的存储空间中，而CPU每次只能对4的倍数内存地址进行读取，因此想读取a的数据，CPU要分别在0X00FFFFF0和0X00FFFFF4进行两次内存读取，而且还要对两次读取的数据进行处理才能得到a的数据，而一个程序的瓶颈往往不是CPU的速度，而是取决于内存的带宽，因为CPU得处理速度要远大于从内存中读取数据的速度，因此减少对内存空间的访问是提高程序性能的关键。从上例可以看出，采取内存地址对齐策略是提高程序性能的关键。</p>\n<p>结构体(struct)是C语言中非常有用的用户自定义数据类型，而结构体类型的变量以及其各成员在内存中的又是怎样布局的呢？怎样对齐的呢？很显然<strong>结构体变量首地址必须是4字节对齐的</strong>，但是<strong>结构体的每个成员有各自默认的对齐方式</strong>，结构体中各成员在内存中出现的位置是随它们的声明顺序依次递增的，并且<strong>第一个成员的首地址等于整个结构体变量的首地址</strong>。下面列出了在Microsoft，Borland，GNU上对于X86架构32位系统的结构体成员各种类型的默认对齐方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">char(1字节)，1字节对齐</div><div class=\"line\">short(2字节)，2字节对齐</div><div class=\"line\">int(4字节)，4字节对齐</div><div class=\"line\">float(4字节)，4字节对齐</div><div class=\"line\">double(8字节)，Windows系统中8字节对齐，Linux系统中4字节对齐。</div><div class=\"line\">*不同CPU的对其规则可能不同, 请参考手册。*</div></pre></td></tr></table></figure>\n<p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为 32 位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要 2 个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该 int 数据。显然在读取效率上下降很多。这也是空间和时间的博弈。</p>\n<a id=\"more\"></a>\n<h3 id=\"对齐的算法：\"><a href=\"#对齐的算法：\" class=\"headerlink\" title=\"对齐的算法：\"></a>对齐的算法：</h3><p>由于各个平台和编译器的不同，现以 gcc 3.4.5 编译器（x64平台）为例，来讨论编译器对 struct 数据结构中的各成员如何进行对齐的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">测试程序如下：</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">\tlong int a;</div><div class=\"line\">\tchar b;</div><div class=\"line\">\tshort c;</div><div class=\"line\">&#125;STRU_A;</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">\tchar b;</div><div class=\"line\">\tlong int a;</div><div class=\"line\">\tshort c;</div><div class=\"line\">&#125;STRU_B;</div><div class=\"line\"></div><div class=\"line\">int main(void)</div><div class=\"line\">&#123;</div><div class=\"line\">\tprintf(&quot;%d, %d\\n&quot;, sizeof (STRU_A), sizeof (STRU_B));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结构体 A 中包含了 4 字节长度的 int 1个，1 字节长度的 char 1个和 2 字节长度的 short 型数据1个。所以 A 用到的空间应该是 7 字节。但是因为编译器要对数据成员在空间上进行对齐。所以使用 sizeof(STRU_A)值为 8。现在把该结构体调整成员变量的顺序。这时候同样是总共 7 个字节的变量，但是 sizeof(STRU_B)的值却是 12。</p>\n<p>程序编译器对结构存储的特殊处理确实提高了CPU的存储变量速度，但有时候也会带来一些麻烦，这边我们使用#pragma pack (value)来屏蔽掉变量默认的对齐方式。下面我们使用预编译指令#pragma pack (value)来告诉编译器，使用我们指定的对齐值来取代缺省的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">进一步我们修改代码：</div><div class=\"line\"></div><div class=\"line\">#pragma pack (2) /*指定按 2 字节对齐*/</div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">\tchar b;</div><div class=\"line\">\tlong int a;</div><div class=\"line\">\tshort c;</div><div class=\"line\">&#125;STRU1;</div><div class=\"line\">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</div><div class=\"line\"></div><div class=\"line\">#pragma pack (1) /*指定按 1 字节对齐*/</div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">\tchar b;</div><div class=\"line\">\tlong int a;</div><div class=\"line\">\tshort c;</div><div class=\"line\">&#125;STRU2;</div><div class=\"line\">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</div><div class=\"line\"></div><div class=\"line\">int main(void)</div><div class=\"line\">&#123;</div><div class=\"line\">\tprintf(&quot;%d, %d\\n&quot;, sizeof (STRU1), sizeof (STRU2));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>sizeof(STRU1)值为 7。对于 char 型数据，其自身对齐值为 1，对于 short 型为 2，对于 int,float,double类型，其自身对齐值为 4，单位字节。</p>\n<p>这里面有四个概念值：</p>\n<ul>\n<li>数据类型自身的对齐值：就是上面交代的基本数据类型的自身对齐值。</li>\n<li>指定对齐值：#pragma pack (value)时的指定对齐值 value。</li>\n<li>结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。</li>\n<li>数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。</li>\n</ul>\n<p>有了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值 N 是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是 表示“对齐在 N 上”，也就是说该数据的”存放起始地址%N=0”.而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整数 倍，结合下面例子理解)。这样就不能理解上面的几个例子的值了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">例子分析：</div><div class=\"line\">分析例子 B；</div><div class=\"line\">struct B</div><div class=\"line\">&#123;</div><div class=\"line\">\tchar b;</div><div class=\"line\">\tint a;</div><div class=\"line\">\tshort c;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>假设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，该值默认为4。第一个成员变量b的自身对齐值是1，比指定或者默认指定对齐值4小，所以其有效对齐值为1，所以其存放地址0x0000符合0x0000%1=0.第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4，所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4=0,且紧靠第一个变量。第三个变量c,自身对齐值为2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2=0。所以从0x0000到0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，0x0009到0x0000=10字节，（10＋2）％4＝0。所以0x0000A到0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节,sizeof(struct B)=12;同理,分析上面例子C：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma pack (2) /*指定按 2 字节对齐*/</div><div class=\"line\">struct C</div><div class=\"line\">&#123;</div><div class=\"line\">\tchar b;</div><div class=\"line\">\tint a;</div><div class=\"line\">\tshort c;</div><div class=\"line\">&#125;;</div><div class=\"line\">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</div></pre></td></tr></table></figure>\n<p>第一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1=0;第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续字节中，符合0x0002%2=0。第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006、0x0007中，符合0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2=0,C只占用0x0000到0x0007的八个字节。所以sizeof(struct C)=8。</p>\n<p>下面是一个有char，int，short三种类型，4个成员组成的结构体，该结构体在还未编译之前是大小占8个字节。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct AlignData</div><div class=\"line\">&#123;</div><div class=\"line\">\tchar a;</div><div class=\"line\">\tshort b;</div><div class=\"line\">\tint c;</div><div class=\"line\">\tchar d;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>编译之后，为了保持结构体中的每个成员都是按照各自的对齐，编译器会在一些成员之间插入一些padding，因此编译后得到如下的结构体：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct AlignData </div><div class=\"line\">&#123;</div><div class=\"line\">\tchar a;</div><div class=\"line\">\tchar Padding0[1];</div><div class=\"line\">\tshort b;</div><div class=\"line\">\tint c;</div><div class=\"line\">\tchar d;</div><div class=\"line\">\tchar Padding1[3];</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>编译后该结构体的大小为12个字节，<strong>最后一个成员d后面填充的字节数要使该结构体的总大小是其成员类型中拥有最大字节数的倍数</strong>(int拥有最大字节数)，因此d后面要填充3个字节。</p>\n<p>通过以上的详细分析，我们可以总结编译器在自动分配结构体类型对齐时，<strong>一般是以第一个数据为基准值，然后往后累加地址查找，最终确保将每个需要分配的数据分配到sizeof(data)整数倍的地址上面。至于那些在查找过程中不满足要求的存储空间就空出。</strong>一般主要满足以下规则：</p>\n<ul>\n<li>单个字节(char)能对齐到任意地址</li>\n<li>2字节(short)以2字节边界对齐</li>\n<li>4字节(int, long)以4字节边界对齐</li>\n</ul>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/vvzaixian/article/details/7067221\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/vvzaixian/article/details/7067221</a><br><a href=\"http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml\" target=\"_blank\" rel=\"external\">http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml</a><br><a href=\"https://my.oschina.net/chaenomeles/blog/673091\" target=\"_blank\" rel=\"external\">https://my.oschina.net/chaenomeles/blog/673091</a><br><a href=\"http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html</a><br><a href=\"http://www.ruanyifeng.com/blog/2016/11/byte-order.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2016/11/byte-order.html</a></p>\n</blockquote>\n","excerpt":"<p><em>大小端和字节对齐，与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</em></p>\n<p>我们常常看到“alignment”， “endian”之类的字眼， 但很少有 C 语言教材提到这些概念。 实际上它们是与处理器与内存接口， 编译器类型密切相关的。与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</p>\n<h3 id=\"字节对齐（Byte-Alignment）\"><a href=\"#字节对齐（Byte-Alignment）\" class=\"headerlink\" title=\"字节对齐（Byte Alignment）\"></a>字节对齐（Byte Alignment）</h3><p>我们写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。但是，正因为我们一般不需要关心这个问题，所以因为编辑器对数据存放做了对齐，而我们不了解的话，常常会对一些问题感到迷惑。最常见的就是 struct 数据结构的 sizeof 结果，出乎意料。为此，我们需要对对齐算法所了解。</p>\n<p>现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>\n<p>内存地址对齐，是一种在计算机内存中排列数据、访问数据的一种方式，包含了两种相互独立又相互关联的部分：基本数据对齐和结构体数据对齐。当今的计算机在计算机内存中读写数据时都是按字(word)大小块来进行操作的(在32位系统中，数据总线宽度为32，每次能读取4字节，地址总线宽度为32，因此最大的寻址空间为2^32=4GB，但是最低2位A[0]，A[1]是不用于寻址，A[2-31]才能存储器相连，因此只能访问4的倍数地址空间，但是总的寻址空间还是2^30 <em> 字长 = 4GB，因此在内存中所有存放的基本类型数据的首地址的最低两位都是0，除结构体中的成员变量)。<strong>基本类型数据对齐就是数据在内存中的偏移地址必须等于一个字的倍数</strong>，按这种存储数据的方式，可以提升系统在读取数据时的性能。<em>*为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节，这就是结构体数据对齐</em></em>。</p>\n<p>举个例子，假设计算机的字大小为4个字节，因此变量在内存中的首地址都是满足4地址对齐，CPU只能对4的倍数的地址进行读取，而每次能读取4个字节大小的数据。假设有一个整型的数据a的首地址不是4的倍数(如下图所示)，不妨设为0X00FFFFF3，则该整型数据存储在地址范围为0X00FFFFF3~0X00FFFFF6的存储空间中，而CPU每次只能对4的倍数内存地址进行读取，因此想读取a的数据，CPU要分别在0X00FFFFF0和0X00FFFFF4进行两次内存读取，而且还要对两次读取的数据进行处理才能得到a的数据，而一个程序的瓶颈往往不是CPU的速度，而是取决于内存的带宽，因为CPU得处理速度要远大于从内存中读取数据的速度，因此减少对内存空间的访问是提高程序性能的关键。从上例可以看出，采取内存地址对齐策略是提高程序性能的关键。</p>\n<p>结构体(struct)是C语言中非常有用的用户自定义数据类型，而结构体类型的变量以及其各成员在内存中的又是怎样布局的呢？怎样对齐的呢？很显然<strong>结构体变量首地址必须是4字节对齐的</strong>，但是<strong>结构体的每个成员有各自默认的对齐方式</strong>，结构体中各成员在内存中出现的位置是随它们的声明顺序依次递增的，并且<strong>第一个成员的首地址等于整个结构体变量的首地址</strong>。下面列出了在Microsoft，Borland，GNU上对于X86架构32位系统的结构体成员各种类型的默认对齐方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">char(1字节)，1字节对齐</div><div class=\"line\">short(2字节)，2字节对齐</div><div class=\"line\">int(4字节)，4字节对齐</div><div class=\"line\">float(4字节)，4字节对齐</div><div class=\"line\">double(8字节)，Windows系统中8字节对齐，Linux系统中4字节对齐。</div><div class=\"line\">*不同CPU的对其规则可能不同, 请参考手册。*</div></pre></td></tr></table></figure>\n<p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为 32 位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要 2 个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该 int 数据。显然在读取效率上下降很多。这也是空间和时间的博弈。</p>","more":"<h3 id=\"对齐的算法：\"><a href=\"#对齐的算法：\" class=\"headerlink\" title=\"对齐的算法：\"></a>对齐的算法：</h3><p>由于各个平台和编译器的不同，现以 gcc 3.4.5 编译器（x64平台）为例，来讨论编译器对 struct 数据结构中的各成员如何进行对齐的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">测试程序如下：</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">\tlong int a;</div><div class=\"line\">\tchar b;</div><div class=\"line\">\tshort c;</div><div class=\"line\">&#125;STRU_A;</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">\tchar b;</div><div class=\"line\">\tlong int a;</div><div class=\"line\">\tshort c;</div><div class=\"line\">&#125;STRU_B;</div><div class=\"line\"></div><div class=\"line\">int main(void)</div><div class=\"line\">&#123;</div><div class=\"line\">\tprintf(&quot;%d, %d\\n&quot;, sizeof (STRU_A), sizeof (STRU_B));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结构体 A 中包含了 4 字节长度的 int 1个，1 字节长度的 char 1个和 2 字节长度的 short 型数据1个。所以 A 用到的空间应该是 7 字节。但是因为编译器要对数据成员在空间上进行对齐。所以使用 sizeof(STRU_A)值为 8。现在把该结构体调整成员变量的顺序。这时候同样是总共 7 个字节的变量，但是 sizeof(STRU_B)的值却是 12。</p>\n<p>程序编译器对结构存储的特殊处理确实提高了CPU的存储变量速度，但有时候也会带来一些麻烦，这边我们使用#pragma pack (value)来屏蔽掉变量默认的对齐方式。下面我们使用预编译指令#pragma pack (value)来告诉编译器，使用我们指定的对齐值来取代缺省的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">进一步我们修改代码：</div><div class=\"line\"></div><div class=\"line\">#pragma pack (2) /*指定按 2 字节对齐*/</div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">\tchar b;</div><div class=\"line\">\tlong int a;</div><div class=\"line\">\tshort c;</div><div class=\"line\">&#125;STRU1;</div><div class=\"line\">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</div><div class=\"line\"></div><div class=\"line\">#pragma pack (1) /*指定按 1 字节对齐*/</div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">\tchar b;</div><div class=\"line\">\tlong int a;</div><div class=\"line\">\tshort c;</div><div class=\"line\">&#125;STRU2;</div><div class=\"line\">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</div><div class=\"line\"></div><div class=\"line\">int main(void)</div><div class=\"line\">&#123;</div><div class=\"line\">\tprintf(&quot;%d, %d\\n&quot;, sizeof (STRU1), sizeof (STRU2));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>sizeof(STRU1)值为 7。对于 char 型数据，其自身对齐值为 1，对于 short 型为 2，对于 int,float,double类型，其自身对齐值为 4，单位字节。</p>\n<p>这里面有四个概念值：</p>\n<ul>\n<li>数据类型自身的对齐值：就是上面交代的基本数据类型的自身对齐值。</li>\n<li>指定对齐值：#pragma pack (value)时的指定对齐值 value。</li>\n<li>结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。</li>\n<li>数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。</li>\n</ul>\n<p>有了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值 N 是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是 表示“对齐在 N 上”，也就是说该数据的”存放起始地址%N=0”.而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整数 倍，结合下面例子理解)。这样就不能理解上面的几个例子的值了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">例子分析：</div><div class=\"line\">分析例子 B；</div><div class=\"line\">struct B</div><div class=\"line\">&#123;</div><div class=\"line\">\tchar b;</div><div class=\"line\">\tint a;</div><div class=\"line\">\tshort c;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>假设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，该值默认为4。第一个成员变量b的自身对齐值是1，比指定或者默认指定对齐值4小，所以其有效对齐值为1，所以其存放地址0x0000符合0x0000%1=0.第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4，所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4=0,且紧靠第一个变量。第三个变量c,自身对齐值为2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2=0。所以从0x0000到0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，0x0009到0x0000=10字节，（10＋2）％4＝0。所以0x0000A到0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节,sizeof(struct B)=12;同理,分析上面例子C：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma pack (2) /*指定按 2 字节对齐*/</div><div class=\"line\">struct C</div><div class=\"line\">&#123;</div><div class=\"line\">\tchar b;</div><div class=\"line\">\tint a;</div><div class=\"line\">\tshort c;</div><div class=\"line\">&#125;;</div><div class=\"line\">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</div></pre></td></tr></table></figure>\n<p>第一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1=0;第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续字节中，符合0x0002%2=0。第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006、0x0007中，符合0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2=0,C只占用0x0000到0x0007的八个字节。所以sizeof(struct C)=8。</p>\n<p>下面是一个有char，int，short三种类型，4个成员组成的结构体，该结构体在还未编译之前是大小占8个字节。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct AlignData</div><div class=\"line\">&#123;</div><div class=\"line\">\tchar a;</div><div class=\"line\">\tshort b;</div><div class=\"line\">\tint c;</div><div class=\"line\">\tchar d;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>编译之后，为了保持结构体中的每个成员都是按照各自的对齐，编译器会在一些成员之间插入一些padding，因此编译后得到如下的结构体：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct AlignData </div><div class=\"line\">&#123;</div><div class=\"line\">\tchar a;</div><div class=\"line\">\tchar Padding0[1];</div><div class=\"line\">\tshort b;</div><div class=\"line\">\tint c;</div><div class=\"line\">\tchar d;</div><div class=\"line\">\tchar Padding1[3];</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>编译后该结构体的大小为12个字节，<strong>最后一个成员d后面填充的字节数要使该结构体的总大小是其成员类型中拥有最大字节数的倍数</strong>(int拥有最大字节数)，因此d后面要填充3个字节。</p>\n<p>通过以上的详细分析，我们可以总结编译器在自动分配结构体类型对齐时，<strong>一般是以第一个数据为基准值，然后往后累加地址查找，最终确保将每个需要分配的数据分配到sizeof(data)整数倍的地址上面。至于那些在查找过程中不满足要求的存储空间就空出。</strong>一般主要满足以下规则：</p>\n<ul>\n<li>单个字节(char)能对齐到任意地址</li>\n<li>2字节(short)以2字节边界对齐</li>\n<li>4字节(int, long)以4字节边界对齐</li>\n</ul>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/vvzaixian/article/details/7067221\">http://blog.csdn.net/vvzaixian/article/details/7067221</a><br><a href=\"http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml\">http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml</a><br><a href=\"https://my.oschina.net/chaenomeles/blog/673091\">https://my.oschina.net/chaenomeles/blog/673091</a><br><a href=\"http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html\">http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html</a><br><a href=\"http://www.ruanyifeng.com/blog/2016/11/byte-order.html\">http://www.ruanyifeng.com/blog/2016/11/byte-order.html</a></p>\n</blockquote>"},{"layout":"post","title":"notepad++和MinGW","date":"2016-11-15T08:16:00.000Z","_content":"\n今天写一个换算的小程序，但无奈手头没有编译工具，归根结底为何如此麻烦还是因为windows下的开发不友好不自带常规编译器所决定的，一个简单的程序编译需要你去安装庞大的IDE等。以前用windows偶尔弄点c代码编译或者查看一些文件都是使用notepad++的，有算是比较长的一段时间了，但不久前重装了系统，notepad++虽然仅仅需要选几个皮肤，简单配置作为文本编辑器即可，但无奈MinGW如何调用已经忘了，本文列出个简要步骤，以便下次查看。\n\n\n### 实际需求\n\nWindows下编写C语言程序，使用如VS2010之类的IDE往往显得大材小用，并且这些集成开发环境都占用了大量的系统和硬件资源，且不如Notepad++之类的编辑器简单易用、定制性强大。最重要的一点在于学习编程的话，建议不要怕麻烦还是从最基础的学起，IDE往往屏蔽了很多的细节，并不利于初学者的学习。Linux下写C推荐可以研习emacs、vim配gcc。起初是想从网上直接找个教程按部就班执行，轻松配置完成的，但看了几个教程都不尽如人意，通过自己多次尝试最终找到了较为满意的解决方法，文章列出了部分参考网络教程的链接，下面对此详细阐述。而MinGW (Minimalist GNU for Windows)听名字就只是很强大，因为gcc的使用广泛和强大，无疑这个套件是编译的理想选择。\n\n\n### 软件安装\n\n[notepad++](https://pan.baidu.com/s/1slNDMtn)只是一个文本编辑器，本身没有编译C/C++的功能。所以要想先配置，就要先装上一个编译器。MinGW是GNU开源社区面向windows用户提供的一个集成了个编译环境的软件包。一般可以通过搜索MinGW直接去官网下载安装，但官网貌似是在线安装，因此我从其他网站下载了[MinGW-5.1.6](https://pan.baidu.com/s/1bFK8TC)离线包，安装步骤很简单，这边不具体阐述。\n\n<!-- more -->\n\n\n### 相关配置\n\n\n#### MinGW\n\n环境变量，简而言之就是在终端中直接输入名称，系统能够识别，且运行的一些可执行文件名称。在（我的电脑右击－－>系统属性－－>高级－－>环境变量－－>系统变量 中）（以下目录都根据自己的电脑MinGW所在位置不同而改变）在PATH的值中加入“D:\\MinGW\\bin”（如果没有就新建一个PATH）。如果PATH中还有其他内容，需要用英文状态下使用分号进行分割。这是寻找gcc编译器的路径。（这一步中PATH的值根据你的MinGW安装的路径设定，要能够访问的gcc编译器，也就是MInGW安装目录里面的bin文件夹）\n\n下面两步作为可选步骤，如果有确切需求可以添加：新建LIBRARY_PATH变量，在其值中加入“D:\\MinGW\\lib”。这是标准库存放的路径。新建C_INCLUDE_PATH变量，在其值中加入“D:\\MinGW\\include”。这是Include查找头文件的路径。\n\n设置结束之后，在cmd控制台窗口下面，输入gcc -v。若已经成功安装好，会显示gcc的版本信息。比如说我的：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-15-notepad-%E5%92%8Cmingw/2.png)\n\n测试一下：\n随便找个c文件，你也可以自己写个。使用命令提示符cd到c文件保存的目录，然后：输入`gcc -o test.exe (你的c文件名).c`如果有提示语法错误或者在当前目录生成了test.exe那说明gcc可用了，如果提示 'gcc' 不是内部或外部命令，也不是可运行的程序或批处理文件。说明环境MinGW的环境变量未设置成功。\n\n\n#### notepad++\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-15-notepad-%E5%92%8Cmingw/1.png)\n\n如上图，选用自己喜欢的风格模式，对里面的一些背景参数适当的设置，将行号等常用的功能打开，可以隐藏一些不需要的工具栏，菜单中列出了可以执行的一些操作，适当借用于快捷键可以更快的编写代码。\n\n由于这边主要是让notepad++可以一键编译c程序，所以为其加上编译，运行。\n\n- 编译：按F5输入`cmd /k gcc -o \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\" \"$(FULL_CURRENT_PATH)\" & PAUSE & EXIT` 点保存，设置快捷键为F9\n- 运行：按F5输入`cmd /k \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\" & PAUSE & EXIT`保存，设置快捷键为Ctrl+F9\n\n上述两步，环境搭建完成，当你用N++编写程序时，先保存再按F9可编译，然后再按Ctrl+F9开看到运行结果。\n\n熟练习惯后，可以将编译运行一起使用：`cmd /k gcc -std=c99 -o \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\" \"$(FULL_CURRENT_PATH)\" & cmd /k \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\"& PAUSE & EXIT`或者`cmd /k gcc -std=c99 -o \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\" \"$(FULL_CURRENT_PATH)\" & pause & \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\"& PAUSE & EXIT`保存，设置快捷键为Ctrl+F5。\n\n\n\n**关键字说明：**\n\n```\n引号的使用是为了适用于文件名或者路径中带有空格的情况，一定不能省略。\n& PAUSE 含义是命令运行后暂停等待键盘操作\n& EXIT 含义是完成后退出运行窗口，回到notepad++\n$(NAME_PART) 代表当前正操作的文件的文件名，不含后缀；\n$(FULL_CURRENT_PATH) 代表当前正操作的文件的完整路径，包括盘符、路径、文件名、后缀；\n$(CURRENT_DIRECTORY) 代表当前文件所在的目录路径；\n通过以上三个环境变量可以很容易的理解上面一段指令的含义。\n至于gcc，-o参数就是将一个c文件编译成exe文件。gcc的bin目录已经之前在系统环境变量中进行过设定，否则需要补全gcc命令的绝对路径。(很简单，将\"g++.exe\"换成\"D:\\MinGW\\bin\\g++.exe\",还是要参照你安装的路径）\n```\n\n***\n\n> 参考链接：\n> http://jingyan.baidu.com/article/9989c7461dc55ff648ecfe12.html\n","source":"_posts/2016/2016-11-15-notepad-和mingw.md","raw":"---\nlayout: \"post\"\ntitle: \"notepad++和MinGW\"\ndate: \"2016-11-15 16:16\"\n---\n\n今天写一个换算的小程序，但无奈手头没有编译工具，归根结底为何如此麻烦还是因为windows下的开发不友好不自带常规编译器所决定的，一个简单的程序编译需要你去安装庞大的IDE等。以前用windows偶尔弄点c代码编译或者查看一些文件都是使用notepad++的，有算是比较长的一段时间了，但不久前重装了系统，notepad++虽然仅仅需要选几个皮肤，简单配置作为文本编辑器即可，但无奈MinGW如何调用已经忘了，本文列出个简要步骤，以便下次查看。\n\n\n### 实际需求\n\nWindows下编写C语言程序，使用如VS2010之类的IDE往往显得大材小用，并且这些集成开发环境都占用了大量的系统和硬件资源，且不如Notepad++之类的编辑器简单易用、定制性强大。最重要的一点在于学习编程的话，建议不要怕麻烦还是从最基础的学起，IDE往往屏蔽了很多的细节，并不利于初学者的学习。Linux下写C推荐可以研习emacs、vim配gcc。起初是想从网上直接找个教程按部就班执行，轻松配置完成的，但看了几个教程都不尽如人意，通过自己多次尝试最终找到了较为满意的解决方法，文章列出了部分参考网络教程的链接，下面对此详细阐述。而MinGW (Minimalist GNU for Windows)听名字就只是很强大，因为gcc的使用广泛和强大，无疑这个套件是编译的理想选择。\n\n\n### 软件安装\n\n[notepad++](https://pan.baidu.com/s/1slNDMtn)只是一个文本编辑器，本身没有编译C/C++的功能。所以要想先配置，就要先装上一个编译器。MinGW是GNU开源社区面向windows用户提供的一个集成了个编译环境的软件包。一般可以通过搜索MinGW直接去官网下载安装，但官网貌似是在线安装，因此我从其他网站下载了[MinGW-5.1.6](https://pan.baidu.com/s/1bFK8TC)离线包，安装步骤很简单，这边不具体阐述。\n\n<!-- more -->\n\n\n### 相关配置\n\n\n#### MinGW\n\n环境变量，简而言之就是在终端中直接输入名称，系统能够识别，且运行的一些可执行文件名称。在（我的电脑右击－－>系统属性－－>高级－－>环境变量－－>系统变量 中）（以下目录都根据自己的电脑MinGW所在位置不同而改变）在PATH的值中加入“D:\\MinGW\\bin”（如果没有就新建一个PATH）。如果PATH中还有其他内容，需要用英文状态下使用分号进行分割。这是寻找gcc编译器的路径。（这一步中PATH的值根据你的MinGW安装的路径设定，要能够访问的gcc编译器，也就是MInGW安装目录里面的bin文件夹）\n\n下面两步作为可选步骤，如果有确切需求可以添加：新建LIBRARY_PATH变量，在其值中加入“D:\\MinGW\\lib”。这是标准库存放的路径。新建C_INCLUDE_PATH变量，在其值中加入“D:\\MinGW\\include”。这是Include查找头文件的路径。\n\n设置结束之后，在cmd控制台窗口下面，输入gcc -v。若已经成功安装好，会显示gcc的版本信息。比如说我的：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-15-notepad-%E5%92%8Cmingw/2.png)\n\n测试一下：\n随便找个c文件，你也可以自己写个。使用命令提示符cd到c文件保存的目录，然后：输入`gcc -o test.exe (你的c文件名).c`如果有提示语法错误或者在当前目录生成了test.exe那说明gcc可用了，如果提示 'gcc' 不是内部或外部命令，也不是可运行的程序或批处理文件。说明环境MinGW的环境变量未设置成功。\n\n\n#### notepad++\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-15-notepad-%E5%92%8Cmingw/1.png)\n\n如上图，选用自己喜欢的风格模式，对里面的一些背景参数适当的设置，将行号等常用的功能打开，可以隐藏一些不需要的工具栏，菜单中列出了可以执行的一些操作，适当借用于快捷键可以更快的编写代码。\n\n由于这边主要是让notepad++可以一键编译c程序，所以为其加上编译，运行。\n\n- 编译：按F5输入`cmd /k gcc -o \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\" \"$(FULL_CURRENT_PATH)\" & PAUSE & EXIT` 点保存，设置快捷键为F9\n- 运行：按F5输入`cmd /k \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\" & PAUSE & EXIT`保存，设置快捷键为Ctrl+F9\n\n上述两步，环境搭建完成，当你用N++编写程序时，先保存再按F9可编译，然后再按Ctrl+F9开看到运行结果。\n\n熟练习惯后，可以将编译运行一起使用：`cmd /k gcc -std=c99 -o \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\" \"$(FULL_CURRENT_PATH)\" & cmd /k \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\"& PAUSE & EXIT`或者`cmd /k gcc -std=c99 -o \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\" \"$(FULL_CURRENT_PATH)\" & pause & \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\"& PAUSE & EXIT`保存，设置快捷键为Ctrl+F5。\n\n\n\n**关键字说明：**\n\n```\n引号的使用是为了适用于文件名或者路径中带有空格的情况，一定不能省略。\n& PAUSE 含义是命令运行后暂停等待键盘操作\n& EXIT 含义是完成后退出运行窗口，回到notepad++\n$(NAME_PART) 代表当前正操作的文件的文件名，不含后缀；\n$(FULL_CURRENT_PATH) 代表当前正操作的文件的完整路径，包括盘符、路径、文件名、后缀；\n$(CURRENT_DIRECTORY) 代表当前文件所在的目录路径；\n通过以上三个环境变量可以很容易的理解上面一段指令的含义。\n至于gcc，-o参数就是将一个c文件编译成exe文件。gcc的bin目录已经之前在系统环境变量中进行过设定，否则需要补全gcc命令的绝对路径。(很简单，将\"g++.exe\"换成\"D:\\MinGW\\bin\\g++.exe\",还是要参照你安装的路径）\n```\n\n***\n\n> 参考链接：\n> http://jingyan.baidu.com/article/9989c7461dc55ff648ecfe12.html\n","slug":"2016/2016-11-15-notepad-和mingw","published":1,"updated":"2016-12-16T01:50:23.115Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ait003cmumutamh1fsc","content":"<p>今天写一个换算的小程序，但无奈手头没有编译工具，归根结底为何如此麻烦还是因为windows下的开发不友好不自带常规编译器所决定的，一个简单的程序编译需要你去安装庞大的IDE等。以前用windows偶尔弄点c代码编译或者查看一些文件都是使用notepad++的，有算是比较长的一段时间了，但不久前重装了系统，notepad++虽然仅仅需要选几个皮肤，简单配置作为文本编辑器即可，但无奈MinGW如何调用已经忘了，本文列出个简要步骤，以便下次查看。</p>\n<h3 id=\"实际需求\"><a href=\"#实际需求\" class=\"headerlink\" title=\"实际需求\"></a>实际需求</h3><p>Windows下编写C语言程序，使用如VS2010之类的IDE往往显得大材小用，并且这些集成开发环境都占用了大量的系统和硬件资源，且不如Notepad++之类的编辑器简单易用、定制性强大。最重要的一点在于学习编程的话，建议不要怕麻烦还是从最基础的学起，IDE往往屏蔽了很多的细节，并不利于初学者的学习。Linux下写C推荐可以研习emacs、vim配gcc。起初是想从网上直接找个教程按部就班执行，轻松配置完成的，但看了几个教程都不尽如人意，通过自己多次尝试最终找到了较为满意的解决方法，文章列出了部分参考网络教程的链接，下面对此详细阐述。而MinGW (Minimalist GNU for Windows)听名字就只是很强大，因为gcc的使用广泛和强大，无疑这个套件是编译的理想选择。</p>\n<h3 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h3><p><a href=\"https://pan.baidu.com/s/1slNDMtn\" target=\"_blank\" rel=\"external\">notepad++</a>只是一个文本编辑器，本身没有编译C/C++的功能。所以要想先配置，就要先装上一个编译器。MinGW是GNU开源社区面向windows用户提供的一个集成了个编译环境的软件包。一般可以通过搜索MinGW直接去官网下载安装，但官网貌似是在线安装，因此我从其他网站下载了<a href=\"https://pan.baidu.com/s/1bFK8TC\" target=\"_blank\" rel=\"external\">MinGW-5.1.6</a>离线包，安装步骤很简单，这边不具体阐述。</p>\n<a id=\"more\"></a>\n<h3 id=\"相关配置\"><a href=\"#相关配置\" class=\"headerlink\" title=\"相关配置\"></a>相关配置</h3><h4 id=\"MinGW\"><a href=\"#MinGW\" class=\"headerlink\" title=\"MinGW\"></a>MinGW</h4><p>环境变量，简而言之就是在终端中直接输入名称，系统能够识别，且运行的一些可执行文件名称。在（我的电脑右击－－&gt;系统属性－－&gt;高级－－&gt;环境变量－－&gt;系统变量 中）（以下目录都根据自己的电脑MinGW所在位置不同而改变）在PATH的值中加入“D:\\MinGW\\bin”（如果没有就新建一个PATH）。如果PATH中还有其他内容，需要用英文状态下使用分号进行分割。这是寻找gcc编译器的路径。（这一步中PATH的值根据你的MinGW安装的路径设定，要能够访问的gcc编译器，也就是MInGW安装目录里面的bin文件夹）</p>\n<p>下面两步作为可选步骤，如果有确切需求可以添加：新建LIBRARY_PATH变量，在其值中加入“D:\\MinGW\\lib”。这是标准库存放的路径。新建C_INCLUDE_PATH变量，在其值中加入“D:\\MinGW\\include”。这是Include查找头文件的路径。</p>\n<p>设置结束之后，在cmd控制台窗口下面，输入gcc -v。若已经成功安装好，会显示gcc的版本信息。比如说我的：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-15-notepad-%E5%92%8Cmingw/2.png\" alt=\"\"></p>\n<p>测试一下：<br>随便找个c文件，你也可以自己写个。使用命令提示符cd到c文件保存的目录，然后：输入<code>gcc -o test.exe (你的c文件名).c</code>如果有提示语法错误或者在当前目录生成了test.exe那说明gcc可用了，如果提示 ‘gcc’ 不是内部或外部命令，也不是可运行的程序或批处理文件。说明环境MinGW的环境变量未设置成功。</p>\n<h4 id=\"notepad\"><a href=\"#notepad\" class=\"headerlink\" title=\"notepad++\"></a>notepad++</h4><p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-15-notepad-%E5%92%8Cmingw/1.png\" alt=\"\"></p>\n<p>如上图，选用自己喜欢的风格模式，对里面的一些背景参数适当的设置，将行号等常用的功能打开，可以隐藏一些不需要的工具栏，菜单中列出了可以执行的一些操作，适当借用于快捷键可以更快的编写代码。</p>\n<p>由于这边主要是让notepad++可以一键编译c程序，所以为其加上编译，运行。</p>\n<ul>\n<li>编译：按F5输入<code>cmd /k gcc -o &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; PAUSE &amp; EXIT</code> 点保存，设置快捷键为F9</li>\n<li>运行：按F5输入<code>cmd /k &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &amp; PAUSE &amp; EXIT</code>保存，设置快捷键为Ctrl+F9</li>\n</ul>\n<p>上述两步，环境搭建完成，当你用N++编写程序时，先保存再按F9可编译，然后再按Ctrl+F9开看到运行结果。</p>\n<p>熟练习惯后，可以将编译运行一起使用：<code>cmd /k gcc -std=c99 -o &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; cmd /k &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot;&amp; PAUSE &amp; EXIT</code>或者<code>cmd /k gcc -std=c99 -o &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; pause &amp; &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot;&amp; PAUSE &amp; EXIT</code>保存，设置快捷键为Ctrl+F5。</p>\n<p><strong>关键字说明：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">引号的使用是为了适用于文件名或者路径中带有空格的情况，一定不能省略。</div><div class=\"line\">&amp; PAUSE 含义是命令运行后暂停等待键盘操作</div><div class=\"line\">&amp; EXIT 含义是完成后退出运行窗口，回到notepad++</div><div class=\"line\">$(NAME_PART) 代表当前正操作的文件的文件名，不含后缀；</div><div class=\"line\">$(FULL_CURRENT_PATH) 代表当前正操作的文件的完整路径，包括盘符、路径、文件名、后缀；</div><div class=\"line\">$(CURRENT_DIRECTORY) 代表当前文件所在的目录路径；</div><div class=\"line\">通过以上三个环境变量可以很容易的理解上面一段指令的含义。</div><div class=\"line\">至于gcc，-o参数就是将一个c文件编译成exe文件。gcc的bin目录已经之前在系统环境变量中进行过设定，否则需要补全gcc命令的绝对路径。(很简单，将&quot;g++.exe&quot;换成&quot;D:\\MinGW\\bin\\g++.exe&quot;,还是要参照你安装的路径）</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://jingyan.baidu.com/article/9989c7461dc55ff648ecfe12.html\" target=\"_blank\" rel=\"external\">http://jingyan.baidu.com/article/9989c7461dc55ff648ecfe12.html</a></p>\n</blockquote>\n","excerpt":"<p>今天写一个换算的小程序，但无奈手头没有编译工具，归根结底为何如此麻烦还是因为windows下的开发不友好不自带常规编译器所决定的，一个简单的程序编译需要你去安装庞大的IDE等。以前用windows偶尔弄点c代码编译或者查看一些文件都是使用notepad++的，有算是比较长的一段时间了，但不久前重装了系统，notepad++虽然仅仅需要选几个皮肤，简单配置作为文本编辑器即可，但无奈MinGW如何调用已经忘了，本文列出个简要步骤，以便下次查看。</p>\n<h3 id=\"实际需求\"><a href=\"#实际需求\" class=\"headerlink\" title=\"实际需求\"></a>实际需求</h3><p>Windows下编写C语言程序，使用如VS2010之类的IDE往往显得大材小用，并且这些集成开发环境都占用了大量的系统和硬件资源，且不如Notepad++之类的编辑器简单易用、定制性强大。最重要的一点在于学习编程的话，建议不要怕麻烦还是从最基础的学起，IDE往往屏蔽了很多的细节，并不利于初学者的学习。Linux下写C推荐可以研习emacs、vim配gcc。起初是想从网上直接找个教程按部就班执行，轻松配置完成的，但看了几个教程都不尽如人意，通过自己多次尝试最终找到了较为满意的解决方法，文章列出了部分参考网络教程的链接，下面对此详细阐述。而MinGW (Minimalist GNU for Windows)听名字就只是很强大，因为gcc的使用广泛和强大，无疑这个套件是编译的理想选择。</p>\n<h3 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h3><p><a href=\"https://pan.baidu.com/s/1slNDMtn\">notepad++</a>只是一个文本编辑器，本身没有编译C/C++的功能。所以要想先配置，就要先装上一个编译器。MinGW是GNU开源社区面向windows用户提供的一个集成了个编译环境的软件包。一般可以通过搜索MinGW直接去官网下载安装，但官网貌似是在线安装，因此我从其他网站下载了<a href=\"https://pan.baidu.com/s/1bFK8TC\">MinGW-5.1.6</a>离线包，安装步骤很简单，这边不具体阐述。</p>","more":"<h3 id=\"相关配置\"><a href=\"#相关配置\" class=\"headerlink\" title=\"相关配置\"></a>相关配置</h3><h4 id=\"MinGW\"><a href=\"#MinGW\" class=\"headerlink\" title=\"MinGW\"></a>MinGW</h4><p>环境变量，简而言之就是在终端中直接输入名称，系统能够识别，且运行的一些可执行文件名称。在（我的电脑右击－－&gt;系统属性－－&gt;高级－－&gt;环境变量－－&gt;系统变量 中）（以下目录都根据自己的电脑MinGW所在位置不同而改变）在PATH的值中加入“D:\\MinGW\\bin”（如果没有就新建一个PATH）。如果PATH中还有其他内容，需要用英文状态下使用分号进行分割。这是寻找gcc编译器的路径。（这一步中PATH的值根据你的MinGW安装的路径设定，要能够访问的gcc编译器，也就是MInGW安装目录里面的bin文件夹）</p>\n<p>下面两步作为可选步骤，如果有确切需求可以添加：新建LIBRARY_PATH变量，在其值中加入“D:\\MinGW\\lib”。这是标准库存放的路径。新建C_INCLUDE_PATH变量，在其值中加入“D:\\MinGW\\include”。这是Include查找头文件的路径。</p>\n<p>设置结束之后，在cmd控制台窗口下面，输入gcc -v。若已经成功安装好，会显示gcc的版本信息。比如说我的：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-15-notepad-%E5%92%8Cmingw/2.png\" alt=\"\"></p>\n<p>测试一下：<br>随便找个c文件，你也可以自己写个。使用命令提示符cd到c文件保存的目录，然后：输入<code>gcc -o test.exe (你的c文件名).c</code>如果有提示语法错误或者在当前目录生成了test.exe那说明gcc可用了，如果提示 ‘gcc’ 不是内部或外部命令，也不是可运行的程序或批处理文件。说明环境MinGW的环境变量未设置成功。</p>\n<h4 id=\"notepad\"><a href=\"#notepad\" class=\"headerlink\" title=\"notepad++\"></a>notepad++</h4><p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-15-notepad-%E5%92%8Cmingw/1.png\" alt=\"\"></p>\n<p>如上图，选用自己喜欢的风格模式，对里面的一些背景参数适当的设置，将行号等常用的功能打开，可以隐藏一些不需要的工具栏，菜单中列出了可以执行的一些操作，适当借用于快捷键可以更快的编写代码。</p>\n<p>由于这边主要是让notepad++可以一键编译c程序，所以为其加上编译，运行。</p>\n<ul>\n<li>编译：按F5输入<code>cmd /k gcc -o &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; PAUSE &amp; EXIT</code> 点保存，设置快捷键为F9</li>\n<li>运行：按F5输入<code>cmd /k &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &amp; PAUSE &amp; EXIT</code>保存，设置快捷键为Ctrl+F9</li>\n</ul>\n<p>上述两步，环境搭建完成，当你用N++编写程序时，先保存再按F9可编译，然后再按Ctrl+F9开看到运行结果。</p>\n<p>熟练习惯后，可以将编译运行一起使用：<code>cmd /k gcc -std=c99 -o &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; cmd /k &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot;&amp; PAUSE &amp; EXIT</code>或者<code>cmd /k gcc -std=c99 -o &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; pause &amp; &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot;&amp; PAUSE &amp; EXIT</code>保存，设置快捷键为Ctrl+F5。</p>\n<p><strong>关键字说明：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">引号的使用是为了适用于文件名或者路径中带有空格的情况，一定不能省略。</div><div class=\"line\">&amp; PAUSE 含义是命令运行后暂停等待键盘操作</div><div class=\"line\">&amp; EXIT 含义是完成后退出运行窗口，回到notepad++</div><div class=\"line\">$(NAME_PART) 代表当前正操作的文件的文件名，不含后缀；</div><div class=\"line\">$(FULL_CURRENT_PATH) 代表当前正操作的文件的完整路径，包括盘符、路径、文件名、后缀；</div><div class=\"line\">$(CURRENT_DIRECTORY) 代表当前文件所在的目录路径；</div><div class=\"line\">通过以上三个环境变量可以很容易的理解上面一段指令的含义。</div><div class=\"line\">至于gcc，-o参数就是将一个c文件编译成exe文件。gcc的bin目录已经之前在系统环境变量中进行过设定，否则需要补全gcc命令的绝对路径。(很简单，将&quot;g++.exe&quot;换成&quot;D:\\MinGW\\bin\\g++.exe&quot;,还是要参照你安装的路径）</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>参考链接：<br><a href=\"http://jingyan.baidu.com/article/9989c7461dc55ff648ecfe12.html\">http://jingyan.baidu.com/article/9989c7461dc55ff648ecfe12.html</a></p>\n</blockquote>"},{"layout":"post","title":"vim学习","date":"2016-11-21T00:54:00.000Z","_content":"\nvim 和 emacs 一个号称编辑器之神，一个被称为神的编辑器。打开 vim 执行命令：vimtutor 则可以查看官方说明教程，vimtutor是vim使用入门教程。老实说，自从接触vim到现在也有好多年了，但一直没有强迫自己使用，以及它的难定制性，让我至今都还无法像那些大神一样，完全脱离鼠标和IDE，本文对现阶段我学习 vim 进行一个总结，后续还会不断记录更新。\n\n### 最基本操作\n\n- 请按<ESC>键(这是为了确保您处在正常模式)。\n- h 的键位于左边，每次按下就会向左移动。\n- l 的键位于右边，每次按下就会向右移动。\n- j 键看起来很象一支尖端方向朝下的箭头。\n- k朝上移动。\n- :q! <回车>不保存退出。\n- :wq <回车>保存并退出。\n- gg 跳到首行\n- G 跳到末行\n- yy 复制\n- p 粘贴\n- dd 删除单行\n- u 撤销上次操作\n\n#### 复制：\n\nvim有12个粘贴板，分别是 `0、1、2、...、9、a、\"、+` 用 :reg 命令可以查看各个粘贴板里的内容。下面讲一下vim的粘贴板的基础知识：\n\n- +号粘贴板是系统粘贴板，用 \"+y 将内容复制到该粘贴板后可以使用 Ctrl＋V 将其粘贴到其他文档（如firefox、gedit）中，同理，要把在其他地方用 Ctrl＋C 或右键复制的内容复制到 vim 中，需要在正常模式下按 \"+p 。\n- \" 号粘贴板（临时粘贴板）比较特殊，直接按 y 就复制到这个粘贴板中了，直接按 p 就粘贴这个粘贴板中的内容；\n- 要将vim某个粘贴板里的内容粘贴进来，需要退出编辑模式，在正常模式按\"Np，其中N为粘贴板号，如上所述，可以按\"5p将5号粘贴板里的内容粘贴进来，也可以按\"+p将系统全局粘贴板里的内容粘贴进来。\n\n\n<!-- more -->\n\n### 常用命令操作\n\n\n\n\n### 扩展使用\n\n\n> 参考链接：  \n> http://blog.csdn.net/nkguohao/article/details/8937695  \n","source":"_posts/2016/2016-11-21-vim学习.md","raw":"---\nlayout: \"post\"\ntitle: \"vim学习\"\ndate: \"2016-11-21 08:54\"\n---\n\nvim 和 emacs 一个号称编辑器之神，一个被称为神的编辑器。打开 vim 执行命令：vimtutor 则可以查看官方说明教程，vimtutor是vim使用入门教程。老实说，自从接触vim到现在也有好多年了，但一直没有强迫自己使用，以及它的难定制性，让我至今都还无法像那些大神一样，完全脱离鼠标和IDE，本文对现阶段我学习 vim 进行一个总结，后续还会不断记录更新。\n\n### 最基本操作\n\n- 请按<ESC>键(这是为了确保您处在正常模式)。\n- h 的键位于左边，每次按下就会向左移动。\n- l 的键位于右边，每次按下就会向右移动。\n- j 键看起来很象一支尖端方向朝下的箭头。\n- k朝上移动。\n- :q! <回车>不保存退出。\n- :wq <回车>保存并退出。\n- gg 跳到首行\n- G 跳到末行\n- yy 复制\n- p 粘贴\n- dd 删除单行\n- u 撤销上次操作\n\n#### 复制：\n\nvim有12个粘贴板，分别是 `0、1、2、...、9、a、\"、+` 用 :reg 命令可以查看各个粘贴板里的内容。下面讲一下vim的粘贴板的基础知识：\n\n- +号粘贴板是系统粘贴板，用 \"+y 将内容复制到该粘贴板后可以使用 Ctrl＋V 将其粘贴到其他文档（如firefox、gedit）中，同理，要把在其他地方用 Ctrl＋C 或右键复制的内容复制到 vim 中，需要在正常模式下按 \"+p 。\n- \" 号粘贴板（临时粘贴板）比较特殊，直接按 y 就复制到这个粘贴板中了，直接按 p 就粘贴这个粘贴板中的内容；\n- 要将vim某个粘贴板里的内容粘贴进来，需要退出编辑模式，在正常模式按\"Np，其中N为粘贴板号，如上所述，可以按\"5p将5号粘贴板里的内容粘贴进来，也可以按\"+p将系统全局粘贴板里的内容粘贴进来。\n\n\n<!-- more -->\n\n### 常用命令操作\n\n\n\n\n### 扩展使用\n\n\n> 参考链接：  \n> http://blog.csdn.net/nkguohao/article/details/8937695  \n","slug":"2016/2016-11-21-vim学习","published":1,"updated":"2017-01-05T01:36:04.775Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aiu003dmumuh6ttxu0w","content":"<p>vim 和 emacs 一个号称编辑器之神，一个被称为神的编辑器。打开 vim 执行命令：vimtutor 则可以查看官方说明教程，vimtutor是vim使用入门教程。老实说，自从接触vim到现在也有好多年了，但一直没有强迫自己使用，以及它的难定制性，让我至今都还无法像那些大神一样，完全脱离鼠标和IDE，本文对现阶段我学习 vim 进行一个总结，后续还会不断记录更新。</p>\n<h3 id=\"最基本操作\"><a href=\"#最基本操作\" class=\"headerlink\" title=\"最基本操作\"></a>最基本操作</h3><ul>\n<li>请按<esc>键(这是为了确保您处在正常模式)。</esc></li>\n<li>h 的键位于左边，每次按下就会向左移动。</li>\n<li>l 的键位于右边，每次按下就会向右移动。</li>\n<li>j 键看起来很象一支尖端方向朝下的箭头。</li>\n<li>k朝上移动。</li>\n<li>:q! &lt;回车&gt;不保存退出。</li>\n<li>:wq &lt;回车&gt;保存并退出。</li>\n<li>gg 跳到首行</li>\n<li>G 跳到末行</li>\n<li>yy 复制</li>\n<li>p 粘贴</li>\n<li>dd 删除单行</li>\n<li>u 撤销上次操作</li>\n</ul>\n<h4 id=\"复制：\"><a href=\"#复制：\" class=\"headerlink\" title=\"复制：\"></a>复制：</h4><p>vim有12个粘贴板，分别是 <code>0、1、2、...、9、a、&quot;、+</code> 用 :reg 命令可以查看各个粘贴板里的内容。下面讲一下vim的粘贴板的基础知识：</p>\n<ul>\n<li>+号粘贴板是系统粘贴板，用 “+y 将内容复制到该粘贴板后可以使用 Ctrl＋V 将其粘贴到其他文档（如firefox、gedit）中，同理，要把在其他地方用 Ctrl＋C 或右键复制的内容复制到 vim 中，需要在正常模式下按 “+p 。</li>\n<li>“ 号粘贴板（临时粘贴板）比较特殊，直接按 y 就复制到这个粘贴板中了，直接按 p 就粘贴这个粘贴板中的内容；</li>\n<li>要将vim某个粘贴板里的内容粘贴进来，需要退出编辑模式，在正常模式按”Np，其中N为粘贴板号，如上所述，可以按”5p将5号粘贴板里的内容粘贴进来，也可以按”+p将系统全局粘贴板里的内容粘贴进来。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"常用命令操作\"><a href=\"#常用命令操作\" class=\"headerlink\" title=\"常用命令操作\"></a>常用命令操作</h3><h3 id=\"扩展使用\"><a href=\"#扩展使用\" class=\"headerlink\" title=\"扩展使用\"></a>扩展使用</h3><blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/nkguohao/article/details/8937695\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/nkguohao/article/details/8937695</a>  </p>\n</blockquote>\n","excerpt":"<p>vim 和 emacs 一个号称编辑器之神，一个被称为神的编辑器。打开 vim 执行命令：vimtutor 则可以查看官方说明教程，vimtutor是vim使用入门教程。老实说，自从接触vim到现在也有好多年了，但一直没有强迫自己使用，以及它的难定制性，让我至今都还无法像那些大神一样，完全脱离鼠标和IDE，本文对现阶段我学习 vim 进行一个总结，后续还会不断记录更新。</p>\n<h3 id=\"最基本操作\"><a href=\"#最基本操作\" class=\"headerlink\" title=\"最基本操作\"></a>最基本操作</h3><ul>\n<li>请按<ESC>键(这是为了确保您处在正常模式)。</li>\n<li>h 的键位于左边，每次按下就会向左移动。</li>\n<li>l 的键位于右边，每次按下就会向右移动。</li>\n<li>j 键看起来很象一支尖端方向朝下的箭头。</li>\n<li>k朝上移动。</li>\n<li>:q! &lt;回车&gt;不保存退出。</li>\n<li>:wq &lt;回车&gt;保存并退出。</li>\n<li>gg 跳到首行</li>\n<li>G 跳到末行</li>\n<li>yy 复制</li>\n<li>p 粘贴</li>\n<li>dd 删除单行</li>\n<li>u 撤销上次操作</li>\n</ul>\n<h4 id=\"复制：\"><a href=\"#复制：\" class=\"headerlink\" title=\"复制：\"></a>复制：</h4><p>vim有12个粘贴板，分别是 <code>0、1、2、...、9、a、&quot;、+</code> 用 :reg 命令可以查看各个粘贴板里的内容。下面讲一下vim的粘贴板的基础知识：</p>\n<ul>\n<li>+号粘贴板是系统粘贴板，用 “+y 将内容复制到该粘贴板后可以使用 Ctrl＋V 将其粘贴到其他文档（如firefox、gedit）中，同理，要把在其他地方用 Ctrl＋C 或右键复制的内容复制到 vim 中，需要在正常模式下按 “+p 。</li>\n<li>“ 号粘贴板（临时粘贴板）比较特殊，直接按 y 就复制到这个粘贴板中了，直接按 p 就粘贴这个粘贴板中的内容；</li>\n<li>要将vim某个粘贴板里的内容粘贴进来，需要退出编辑模式，在正常模式按”Np，其中N为粘贴板号，如上所述，可以按”5p将5号粘贴板里的内容粘贴进来，也可以按”+p将系统全局粘贴板里的内容粘贴进来。</li>\n</ul>","more":"<h3 id=\"常用命令操作\"><a href=\"#常用命令操作\" class=\"headerlink\" title=\"常用命令操作\"></a>常用命令操作</h3><h3 id=\"扩展使用\"><a href=\"#扩展使用\" class=\"headerlink\" title=\"扩展使用\"></a>扩展使用</h3><blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/nkguohao/article/details/8937695\">http://blog.csdn.net/nkguohao/article/details/8937695</a>  </p>\n</blockquote>"},{"layout":"post","title":"如何看待蓝绿大厂问鼎中国","date":"2016-11-03T14:25:00.000Z","_content":"\n\n根据IDC的数据，今年第三季度，OPPO和VIVO在中国市场的出货量再创新高，首度成为中国市场的冠亚军。OPPO和VIVO历来以低配高价而文明科技圈内，且低于红米的配置和软件优化，但却卖出几倍的价格，一味的再外观上模仿苹果，广告上轰炸观众，再加上市面上很难找到专业的评测机构来测评这两家的手机等一系列因素，因此很多人都会对这两家产品很是不屑，称他们为“蓝绿大厂，高价低配，专坑厂妹”。但本着存在即为合理的看法，OPPO和VIVO一定还是有很多可取之处的，不然不可能在竞争日益激烈的手机市场上面，站稳脚跟，国内销量先干掉小米，后挤掉华为，且业绩日益攀升。我将蓝绿厂家成功可以总结为以下几点。\n\n***\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/1.jpg)\n\n\n### 差强人意\n\n就产品本身而言，两家主打的功能也都基本一致：自拍，音效，快充。这几点都算是手机某一项的特色功能，但老实说都不具备特色，因为国产手机大都在这些功能上面表现的不差，下面进行详细解析。\n\n在评价一个手机拍照性能时，大都以是否能够更加真实的还原场景为标准，常用的参考量为：解析力，白平衡，夜间成像能力等等。因为手机不同于单反之类的产品，毕竟机身空间有限，每次捕捉的光源数据会经过大量的加工处理才会得到样张的，所以硬件参数即便再好（光圈大，像素高），如果没有好的算法，往往会适得其反，这就是为何苹果800w摄像头可以秒杀别人1600w大光圈的原因。说完拍照来提一下自拍，自拍本身属于照骗的一个制造过程（拍的美不美，有可能你自拍出的照片你妈都不认识），摄像头要拍出真实的照片不容易，但要毁照的话，只需要进行一定的图像识别，加上特定的滤镜效果即可。市面上面除了iPhone功能单一外，其他手机大多有很强的自拍功能，什么深度磨破，瘦脸，背景虚化，多人拍照只对自己美化等，各种功能都深入到各家自身的ROM中去了，无需下载第三方软件。而OV两家因为主打自拍，所以前置摄像头像素极高，甚至超过了后置摄像头，这边到底拍的美不美，一来和你参数的选择有关，二来每个人的审美不尽相同。\n\n音效是一个模糊的概念，外放的音效极少有做的好的厂家，毕竟手机越做越小，虽然芯片在不断的发展，但数字电路很难做出模拟电路电路的音效体验。最近两年的主流中高端手机都不会在音效上面大做文章，显然有一道大家无法逾越的屏障拦在前面。目前中高端手机的外放基本只能判别音量大小，音效的好坏目前主要取决于耳机以及针对耳机的一些优化，但一个好耳机动辄千元起步，除了极少数用户，目前也几乎没有谁愿意为它买单。\n\n快充技术基本上在手机界已经普及（除了反应迟钝的苹果），市面上各种快充技术都不尽相同，升压，升流各种方式都有。来自高通的Quick Charge 2.0是随骁龙800开始盛行的快充技术，早在两年多前，小米4就已经实现了快充，另外MTK和麒麟处理器等也都相继推出了自身的快充技术，也就是说快充家家都有，只不过OV两家的广告让大家知道了他们手机有这个功能而已。\n\n在产品上面这两家算是没有任何特长的手机厂家，首先配置差，采用的一般是骁龙最新的中低端处理器（其他国产厂家一般会在千元左右的手机机使用该处理器）；其次是软件上开发能力较弱，缺失一些必备或者特色功能（如：远程协助，微信多开等功能都缺失，虽然可以通过第三方软件实现，但毕竟安全无保障），在一些手机自带功能上面的体验不足，如手势等操作识别错误，可能与这颗CPU性能较差，或者软件优化不足有关；再者其他诸如续航和通话信号等都没太多可以圈点的。综上这些，就可以知道为啥这么多人对它很诟病。\n\n软件和外观极度模仿苹果，很多交互方式和苹果一致，甚至连很多图标都一模一样，也许可以进一步满足很多人的虚荣心。\n\n说完这么多缺点，下面谈一下优点，两家厂家在手机使用上面都能够满足正常的需求，对于很久没试用过其他安卓手机的用户而言，这两款手机基本能够带来舒适愉快的体验，由于从14年开始，安卓手机配置基本上已经能够满足安卓系统的要求了，所以换句话说，14年的所有高配置的手机，只要没有质量问题，且你对拍照，三防等一些附加属性没有特殊要求，重新恢复出厂设置或者耍个新系统，现在一样可以当作新机来使用。\n\n举个例子：OV两家的CPU < 荣耀6的CPU，OV两家的CPU < MI4的CPU；OV两家的GPU > 荣耀6的GPU，OV两家的GPU < MI4的GPU。因此可以看出，在多任务切换体验来说（常规APP，不包含游戏，不包含系统自带软件功能），OV一般只能同时完美体验3-4个应用，荣耀6和MI3一般可以体验6-8个应用。荣耀6基本上已经不能胜任市面的中等要求的游戏（王者荣耀等），MI4和能够完全可以胜任中等要求的游戏，且可以冲击一些高负荷的游戏，OV能够胜任中等要求的游戏。\n\n因为这两年CPU和GPU虽然略有提升，但大多数人很少会玩大型游戏或者运行n多个APP，对CPU和GPU的型号，好坏与否并不关心，甚至很多人觉得手机不错，自始至终并不了解自己的手机比别家的好或者差。\n\n对特色功能的体验一般也仅仅限于手机重度爱好使用者，MIUI，FLYME和EMUI等各家系统很多功能虽然好用，但由于缺乏推广，普通用户并不关注，或者说从来没用过，不知道有这些功能。安卓手机从14年开始早已进入了厂商引导消费体验的阶段，普通消费者对手机已经不存在不满和需求，甚至觉得太强大，很多功能不会用，不会设置，而恰恰是厂家在帮用户思考增加哪些功能会让体验更加的完美，护眼模式，远程协助，单手模式，节电模式等都是各家厂家在提升用户体验上面的尝试。\n\n综上可以看出，在手机同质化的今天，OV基本可以满足市面上面的绝大多数需求，虽然还会有误触，略微卡顿等问题，但相比过去安卓的不响应，发热，死机重启等，已经好了太多，普通消费者看个视频，玩玩小游戏完全可以满足，从苹果转来的用户会觉得便宜几千体验也差不多了多少，较为满意，而从旧款安卓低端机转过来的用户，则会认为大屏不卡顿不死机，好了太多。满足刚需就好，其他能有的功能尽量往上加，作绝大多数普通消费者能够使用的手机即可，这也是OV两家作产品的精髓。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/2.jpg)\n\n\n<!-- more -->\n\n\n\n### 信息轰炸\n\n这个时代是改革开放来最差的时代，因为经济增长缓慢，民营实业入不敷出，房价虚高，资本的寒冬；但这个时代缺失娱乐业最好的时代，各种综艺节目，电视电影，网剧直播等层出不穷，一个全民娱乐的时代。OV两家恰恰是这个时代最大的受益者之一，在娱乐圈，电视台，广告界磨辊打趴了这么多年，积累了深厚的资源和用户，动辄数亿的广告，但却往往能够找准最佳的商机，带来丰厚的回报。细数OV两家的广告可以遍布你身边的一切，从最初的湖南卫视到浙江卫视，从多个热门综艺节目到热门电视剧，从微博到微信。无论你是做哪一行的，逃到哪儿都可以看到这两家的广告。\n\n绝大多数用户的心理都是从众的，OV两家前几年在小米混的风生水起的时候，只能通过电视广告来发展自己偏远地区的业务，那时候两家主要的购买群体一般是三四线城市或者农村，因为网络物流不发达，用户主要获取信息途径通过电视，所以来自这些地方的用户大都购买这两款手机。OV两家那时候属于闷声赚钱，相比于“中酷联”这三家，既不用面对激烈的竞争，也还能谋取较高的利润，但市场占有率不算高，算是小日子过得还不错。\n\n仔细研究OV两家的进程，颇有点“农村包围城市”的韵味，OV两家最近的之所以能够逆袭，不是得益于自身手机的发展，恰恰是整个行业的不发展，苹果两年一大步今年都已经干脆不走了。早从13年的同质化开始，整个行业已经陷入了僵局，各个产品几乎不存在差异化，或者只是微差异化。OV两家只要跟着谷歌走，产品做的不是实在太烂，在有一定知名度的前提下，就可以掌握更多用户。如果说早期的OV两家是牢牢把控了小城市和农村，那现在就是“农村包围城市”，这两家很大成都就是说服了互联网，一二线城市中的原有苹果用户，老旧安卓机转型过来的用户以及追星的用户来购买他们的产品而实现销量增长的。老苹果用户在更新手机的时候想体验其他平台或者因为预算选择稍微便宜的手机，OV两家一般都会是他们的首选，原因有两点：1.广告效应，论知名度，两家无出其右，其他国产机都具备屌丝标签。2.OV两家刻意模仿苹果，用户体验各方面几乎可以和苹果无缝对接了，连图标都做的一致。老旧安卓机用户的原因可以分为两点：1.耳熟能详的知名度。2.更好的外观和体验。\n\n综上可以看出，不断地信息轰炸，建立自己的品牌影响力，让观众普遍认为你手机还不错，这点很重要。在苹果和三星占有率再创新低时，OV两家的信息轰炸还是很有效果的。\n\n\n### 低调专注\n\n**低调专注算是一个褒义词，这边我们只就事论事**，众所周知，做任何事情专注最为重要，OV两家的成功决不能排除专注这一点，当别人都在迫于小米荣耀等线上角逐的势头，而不得不做互联网营销时，这两家却反其道而行之，专注于线下（因为他们也知道自己的手机那时在智能机时代确实毫无竞争力可言），构建更加完善的线下渠道，在更多传统媒体上面布满广告，给予经销商高回报率等，这些都奠定了它成功的基础。我们来重新回顾思考这些事情，当初其实OV在做大规模营销和扩大线下建设时，其实大多数人都认为，这已经是个信息化社会了，线下终将被淘汰，减少中间商环节才是未来数码3C的大势所趋。但事实证明，大多数人的观点并不正确，中国的城市化进程，网络物流的推广覆盖远不是坐在高层写字楼办公的金领白领可以看清的，中国仍然有6亿的农村人口，即便他们可以使用网络但却没有物流，小型城市人口也仍然在中国占了很大的比重，他们虽然可以使用网络，但未必人人都会完全融入信息化社会。可以看出OV两家的“农村包围城市”的战略还是很明智的，这些地盘往往是被忽视了的金库。\n\n各家在网络上面都会进行营销。锤子小米华为等，微博，贴吧上粉黑水军争吵不断。当提及OV两家，不得不说一个有趣的现象，几乎所有这些互联网品牌的手机用户的都看不上OV两家，谁和它比都不屑。这也导致，市面上几乎就找不到OV两家手机的测评，一些测评花了几分钟说了下外观和界面，然后说“这手机就这样也没什么好说的”，但这两家公司历来低调，对这些评论从来都不进行任何回复，也就是说直接无视你们，因为他们知道这些人不是他们的用户群，把事情闹大，万一大家都知道你手机不好，那咋办？另一个低调表现在对高通和谷歌的顺从，当其某厂家发声质疑高通的垄断时而期望获取更多话语权的时候，OV两家义无反顾地积极配合响应高通等公司，这主要取决于他们知道自身的定位，缺乏核心技术，软件研发调优能力弱，同时也不具备芯片等研发能力，所以业务重点更能定为清晰，只做产品的整装与宣传。可见**在商言商**，专注低调赚钱往往更能够成功！\n\n\n### 外观精良\n\n外观这边用不美这个词，还是很讲究的，在我看来精美这个词只能用于“在一定的时期，能够满足社会上8,9成数用户的审美标准，那才可以称得上是精美”，iphone 4刚出来的时候是可以算上精美的，而iphone 6的机身和背面惊人的白带，还是离精美差的较远的。精致的话，一般用在工业制造上面极为考究的产品，如小米的工业陶瓷机身，所以这边考虑到这两家做外观虽然都能看到很多苹果的影子，但还算是用料不错，品质有保证。\n\n就OV的外观而言，国产手机中，也就只有魅族可以和它一起争夺女性用户了。\n\n国内小米和华为在外观上面都有着浓厚的工科生或中年人审美情怀，OPPO，VIVO，魅族的外观类似苹果材质和颜色看起来也更加清新和明快，虽然不能如galaxy edge系类满足绝大多数人审美，但往往更讨年轻人和女性用户的喜欢。这一点尤为重要，上述提到过，当今社会，手机早已同质化严重，创新疲乏，所以试问普通用户除了外观还有啥可以追求？！换句话说，即便各家仍然有软件体验，应用等创新层出不穷，但毕竟这是个看脸的社会，有多少人会喜欢小米正面左上方的LOGO？举个例子：亲身经历，身边有50岁大妈，之前用手机只打电话，所以一直用的红米之类的千元机，现在周围人都用微信，所以入手一智能机，本来是去看华为的手机，结果转了一圈，都嫌太丑，最后买了VIVO的一款主打机型。连三星都将国行版正面LOGO给去掉了，可见对于国人来说，颜值是多么重要！\n\n综上，OV虽然未必美观漂亮，但最起码有明星加持，有苹果的影子，用户不会觉得像其他国产机一样丑，智能手机已经快走过了10个年头，如果它寿命还没有结束的话，未来的竞争恐怕也只有外观的竞争了吧。\n\n\n### 高回报率\n\n再好的策略都离不开优秀的执行者，OV两家的成功离不开线下销售人员的三寸不烂之舌，如何让调用手机销售的积极性，让他们都来卖你的手机，而不是卖其他品牌的呢？大家如果有去电脑城战JS的经理的话，都会知道，JS推荐笔记本或者品牌机都是有选择性的，贵的他不一定推荐给你，便宜的也不一定推荐给你，他们会选择自己赚的最多的推荐给你，举例子说：他们会极力诱导你放弃购买6000的电脑（他只能赚800），而去买4200的电脑（因为他能赚1500）。OV两家同样是如此，在高提成高回报率的前提下，很多销售甚至会阻止你购买其他机型，而大力诱导你买这两家的手机。\n\n\n### 稳步求变\n\nOV在广告领域可谓早有心得，但近期可以看到在微博微信流媒体视频都可以看到OV两家的身影，要想一直繁荣，就必须有增长，只是市场经济不变的法则。OV两家也是看到早已坐实了线下渠道，通过种种手段完成了资本的原始积累，所以从今年开始攻占线上渠道，也就是说等线上销售基本已经定型，各家玩不出什么花样的时候，他们直接拿过来照搬，再加上线下和主流媒体渠道实现全范围的对大家进行轰炸，最终这两个季度用户数量激增，拿下了市场冠亚军的宝座。\n\n总结：虽然黑了OV两家这么多年，但也不得不承认他们确确实实有自身的可取之处。写了这么多，我们可以看出，OV两家成功的主要原因：自始至终大力投资广告，一点点增加自己的品牌影响和曝光度；早期依靠线下在智能机行业站稳脚跟，达到原始资本的积累；后期为了再增长，主打外观，将广告进一步做大，做广，最终在国内手机行业登顶。\n\n\n### 总结\n\n存在即为合理，我们不能否认最近两年来OV两家在市场拓展上面的成功，就如当年小米开创互联网营销模式一样，OV用同样利用全民娱乐，线上线下互补，手机制造门槛降低等打出了一手好牌。但如果一味的模仿抄袭，产品无特色体验差等，最终当消费者觉醒时，依然会被市场所抛弃。我们有理由相信好的产品真金不怕火炼，最终才会经得起消费者检验；但同时，手段和策略能更快地给我们带来更多的资金和市场也同样至关重要。一个公司要想能够持续性发展，势必需要将资金反馈到自己的产品中才行，否则*挂羊头卖狗肉*的事最终会被揭露出来。\n","source":"_posts/2016/2016-11-03-如何看待蓝绿大厂问鼎中国.md","raw":"---\nlayout: \"post\"\ntitle: \"如何看待蓝绿大厂问鼎中国\"\ndate: \"2016-11-03 22:25\"\n---\n\n\n根据IDC的数据，今年第三季度，OPPO和VIVO在中国市场的出货量再创新高，首度成为中国市场的冠亚军。OPPO和VIVO历来以低配高价而文明科技圈内，且低于红米的配置和软件优化，但却卖出几倍的价格，一味的再外观上模仿苹果，广告上轰炸观众，再加上市面上很难找到专业的评测机构来测评这两家的手机等一系列因素，因此很多人都会对这两家产品很是不屑，称他们为“蓝绿大厂，高价低配，专坑厂妹”。但本着存在即为合理的看法，OPPO和VIVO一定还是有很多可取之处的，不然不可能在竞争日益激烈的手机市场上面，站稳脚跟，国内销量先干掉小米，后挤掉华为，且业绩日益攀升。我将蓝绿厂家成功可以总结为以下几点。\n\n***\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/1.jpg)\n\n\n### 差强人意\n\n就产品本身而言，两家主打的功能也都基本一致：自拍，音效，快充。这几点都算是手机某一项的特色功能，但老实说都不具备特色，因为国产手机大都在这些功能上面表现的不差，下面进行详细解析。\n\n在评价一个手机拍照性能时，大都以是否能够更加真实的还原场景为标准，常用的参考量为：解析力，白平衡，夜间成像能力等等。因为手机不同于单反之类的产品，毕竟机身空间有限，每次捕捉的光源数据会经过大量的加工处理才会得到样张的，所以硬件参数即便再好（光圈大，像素高），如果没有好的算法，往往会适得其反，这就是为何苹果800w摄像头可以秒杀别人1600w大光圈的原因。说完拍照来提一下自拍，自拍本身属于照骗的一个制造过程（拍的美不美，有可能你自拍出的照片你妈都不认识），摄像头要拍出真实的照片不容易，但要毁照的话，只需要进行一定的图像识别，加上特定的滤镜效果即可。市面上面除了iPhone功能单一外，其他手机大多有很强的自拍功能，什么深度磨破，瘦脸，背景虚化，多人拍照只对自己美化等，各种功能都深入到各家自身的ROM中去了，无需下载第三方软件。而OV两家因为主打自拍，所以前置摄像头像素极高，甚至超过了后置摄像头，这边到底拍的美不美，一来和你参数的选择有关，二来每个人的审美不尽相同。\n\n音效是一个模糊的概念，外放的音效极少有做的好的厂家，毕竟手机越做越小，虽然芯片在不断的发展，但数字电路很难做出模拟电路电路的音效体验。最近两年的主流中高端手机都不会在音效上面大做文章，显然有一道大家无法逾越的屏障拦在前面。目前中高端手机的外放基本只能判别音量大小，音效的好坏目前主要取决于耳机以及针对耳机的一些优化，但一个好耳机动辄千元起步，除了极少数用户，目前也几乎没有谁愿意为它买单。\n\n快充技术基本上在手机界已经普及（除了反应迟钝的苹果），市面上各种快充技术都不尽相同，升压，升流各种方式都有。来自高通的Quick Charge 2.0是随骁龙800开始盛行的快充技术，早在两年多前，小米4就已经实现了快充，另外MTK和麒麟处理器等也都相继推出了自身的快充技术，也就是说快充家家都有，只不过OV两家的广告让大家知道了他们手机有这个功能而已。\n\n在产品上面这两家算是没有任何特长的手机厂家，首先配置差，采用的一般是骁龙最新的中低端处理器（其他国产厂家一般会在千元左右的手机机使用该处理器）；其次是软件上开发能力较弱，缺失一些必备或者特色功能（如：远程协助，微信多开等功能都缺失，虽然可以通过第三方软件实现，但毕竟安全无保障），在一些手机自带功能上面的体验不足，如手势等操作识别错误，可能与这颗CPU性能较差，或者软件优化不足有关；再者其他诸如续航和通话信号等都没太多可以圈点的。综上这些，就可以知道为啥这么多人对它很诟病。\n\n软件和外观极度模仿苹果，很多交互方式和苹果一致，甚至连很多图标都一模一样，也许可以进一步满足很多人的虚荣心。\n\n说完这么多缺点，下面谈一下优点，两家厂家在手机使用上面都能够满足正常的需求，对于很久没试用过其他安卓手机的用户而言，这两款手机基本能够带来舒适愉快的体验，由于从14年开始，安卓手机配置基本上已经能够满足安卓系统的要求了，所以换句话说，14年的所有高配置的手机，只要没有质量问题，且你对拍照，三防等一些附加属性没有特殊要求，重新恢复出厂设置或者耍个新系统，现在一样可以当作新机来使用。\n\n举个例子：OV两家的CPU < 荣耀6的CPU，OV两家的CPU < MI4的CPU；OV两家的GPU > 荣耀6的GPU，OV两家的GPU < MI4的GPU。因此可以看出，在多任务切换体验来说（常规APP，不包含游戏，不包含系统自带软件功能），OV一般只能同时完美体验3-4个应用，荣耀6和MI3一般可以体验6-8个应用。荣耀6基本上已经不能胜任市面的中等要求的游戏（王者荣耀等），MI4和能够完全可以胜任中等要求的游戏，且可以冲击一些高负荷的游戏，OV能够胜任中等要求的游戏。\n\n因为这两年CPU和GPU虽然略有提升，但大多数人很少会玩大型游戏或者运行n多个APP，对CPU和GPU的型号，好坏与否并不关心，甚至很多人觉得手机不错，自始至终并不了解自己的手机比别家的好或者差。\n\n对特色功能的体验一般也仅仅限于手机重度爱好使用者，MIUI，FLYME和EMUI等各家系统很多功能虽然好用，但由于缺乏推广，普通用户并不关注，或者说从来没用过，不知道有这些功能。安卓手机从14年开始早已进入了厂商引导消费体验的阶段，普通消费者对手机已经不存在不满和需求，甚至觉得太强大，很多功能不会用，不会设置，而恰恰是厂家在帮用户思考增加哪些功能会让体验更加的完美，护眼模式，远程协助，单手模式，节电模式等都是各家厂家在提升用户体验上面的尝试。\n\n综上可以看出，在手机同质化的今天，OV基本可以满足市面上面的绝大多数需求，虽然还会有误触，略微卡顿等问题，但相比过去安卓的不响应，发热，死机重启等，已经好了太多，普通消费者看个视频，玩玩小游戏完全可以满足，从苹果转来的用户会觉得便宜几千体验也差不多了多少，较为满意，而从旧款安卓低端机转过来的用户，则会认为大屏不卡顿不死机，好了太多。满足刚需就好，其他能有的功能尽量往上加，作绝大多数普通消费者能够使用的手机即可，这也是OV两家作产品的精髓。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/2.jpg)\n\n\n<!-- more -->\n\n\n\n### 信息轰炸\n\n这个时代是改革开放来最差的时代，因为经济增长缓慢，民营实业入不敷出，房价虚高，资本的寒冬；但这个时代缺失娱乐业最好的时代，各种综艺节目，电视电影，网剧直播等层出不穷，一个全民娱乐的时代。OV两家恰恰是这个时代最大的受益者之一，在娱乐圈，电视台，广告界磨辊打趴了这么多年，积累了深厚的资源和用户，动辄数亿的广告，但却往往能够找准最佳的商机，带来丰厚的回报。细数OV两家的广告可以遍布你身边的一切，从最初的湖南卫视到浙江卫视，从多个热门综艺节目到热门电视剧，从微博到微信。无论你是做哪一行的，逃到哪儿都可以看到这两家的广告。\n\n绝大多数用户的心理都是从众的，OV两家前几年在小米混的风生水起的时候，只能通过电视广告来发展自己偏远地区的业务，那时候两家主要的购买群体一般是三四线城市或者农村，因为网络物流不发达，用户主要获取信息途径通过电视，所以来自这些地方的用户大都购买这两款手机。OV两家那时候属于闷声赚钱，相比于“中酷联”这三家，既不用面对激烈的竞争，也还能谋取较高的利润，但市场占有率不算高，算是小日子过得还不错。\n\n仔细研究OV两家的进程，颇有点“农村包围城市”的韵味，OV两家最近的之所以能够逆袭，不是得益于自身手机的发展，恰恰是整个行业的不发展，苹果两年一大步今年都已经干脆不走了。早从13年的同质化开始，整个行业已经陷入了僵局，各个产品几乎不存在差异化，或者只是微差异化。OV两家只要跟着谷歌走，产品做的不是实在太烂，在有一定知名度的前提下，就可以掌握更多用户。如果说早期的OV两家是牢牢把控了小城市和农村，那现在就是“农村包围城市”，这两家很大成都就是说服了互联网，一二线城市中的原有苹果用户，老旧安卓机转型过来的用户以及追星的用户来购买他们的产品而实现销量增长的。老苹果用户在更新手机的时候想体验其他平台或者因为预算选择稍微便宜的手机，OV两家一般都会是他们的首选，原因有两点：1.广告效应，论知名度，两家无出其右，其他国产机都具备屌丝标签。2.OV两家刻意模仿苹果，用户体验各方面几乎可以和苹果无缝对接了，连图标都做的一致。老旧安卓机用户的原因可以分为两点：1.耳熟能详的知名度。2.更好的外观和体验。\n\n综上可以看出，不断地信息轰炸，建立自己的品牌影响力，让观众普遍认为你手机还不错，这点很重要。在苹果和三星占有率再创新低时，OV两家的信息轰炸还是很有效果的。\n\n\n### 低调专注\n\n**低调专注算是一个褒义词，这边我们只就事论事**，众所周知，做任何事情专注最为重要，OV两家的成功决不能排除专注这一点，当别人都在迫于小米荣耀等线上角逐的势头，而不得不做互联网营销时，这两家却反其道而行之，专注于线下（因为他们也知道自己的手机那时在智能机时代确实毫无竞争力可言），构建更加完善的线下渠道，在更多传统媒体上面布满广告，给予经销商高回报率等，这些都奠定了它成功的基础。我们来重新回顾思考这些事情，当初其实OV在做大规模营销和扩大线下建设时，其实大多数人都认为，这已经是个信息化社会了，线下终将被淘汰，减少中间商环节才是未来数码3C的大势所趋。但事实证明，大多数人的观点并不正确，中国的城市化进程，网络物流的推广覆盖远不是坐在高层写字楼办公的金领白领可以看清的，中国仍然有6亿的农村人口，即便他们可以使用网络但却没有物流，小型城市人口也仍然在中国占了很大的比重，他们虽然可以使用网络，但未必人人都会完全融入信息化社会。可以看出OV两家的“农村包围城市”的战略还是很明智的，这些地盘往往是被忽视了的金库。\n\n各家在网络上面都会进行营销。锤子小米华为等，微博，贴吧上粉黑水军争吵不断。当提及OV两家，不得不说一个有趣的现象，几乎所有这些互联网品牌的手机用户的都看不上OV两家，谁和它比都不屑。这也导致，市面上几乎就找不到OV两家手机的测评，一些测评花了几分钟说了下外观和界面，然后说“这手机就这样也没什么好说的”，但这两家公司历来低调，对这些评论从来都不进行任何回复，也就是说直接无视你们，因为他们知道这些人不是他们的用户群，把事情闹大，万一大家都知道你手机不好，那咋办？另一个低调表现在对高通和谷歌的顺从，当其某厂家发声质疑高通的垄断时而期望获取更多话语权的时候，OV两家义无反顾地积极配合响应高通等公司，这主要取决于他们知道自身的定位，缺乏核心技术，软件研发调优能力弱，同时也不具备芯片等研发能力，所以业务重点更能定为清晰，只做产品的整装与宣传。可见**在商言商**，专注低调赚钱往往更能够成功！\n\n\n### 外观精良\n\n外观这边用不美这个词，还是很讲究的，在我看来精美这个词只能用于“在一定的时期，能够满足社会上8,9成数用户的审美标准，那才可以称得上是精美”，iphone 4刚出来的时候是可以算上精美的，而iphone 6的机身和背面惊人的白带，还是离精美差的较远的。精致的话，一般用在工业制造上面极为考究的产品，如小米的工业陶瓷机身，所以这边考虑到这两家做外观虽然都能看到很多苹果的影子，但还算是用料不错，品质有保证。\n\n就OV的外观而言，国产手机中，也就只有魅族可以和它一起争夺女性用户了。\n\n国内小米和华为在外观上面都有着浓厚的工科生或中年人审美情怀，OPPO，VIVO，魅族的外观类似苹果材质和颜色看起来也更加清新和明快，虽然不能如galaxy edge系类满足绝大多数人审美，但往往更讨年轻人和女性用户的喜欢。这一点尤为重要，上述提到过，当今社会，手机早已同质化严重，创新疲乏，所以试问普通用户除了外观还有啥可以追求？！换句话说，即便各家仍然有软件体验，应用等创新层出不穷，但毕竟这是个看脸的社会，有多少人会喜欢小米正面左上方的LOGO？举个例子：亲身经历，身边有50岁大妈，之前用手机只打电话，所以一直用的红米之类的千元机，现在周围人都用微信，所以入手一智能机，本来是去看华为的手机，结果转了一圈，都嫌太丑，最后买了VIVO的一款主打机型。连三星都将国行版正面LOGO给去掉了，可见对于国人来说，颜值是多么重要！\n\n综上，OV虽然未必美观漂亮，但最起码有明星加持，有苹果的影子，用户不会觉得像其他国产机一样丑，智能手机已经快走过了10个年头，如果它寿命还没有结束的话，未来的竞争恐怕也只有外观的竞争了吧。\n\n\n### 高回报率\n\n再好的策略都离不开优秀的执行者，OV两家的成功离不开线下销售人员的三寸不烂之舌，如何让调用手机销售的积极性，让他们都来卖你的手机，而不是卖其他品牌的呢？大家如果有去电脑城战JS的经理的话，都会知道，JS推荐笔记本或者品牌机都是有选择性的，贵的他不一定推荐给你，便宜的也不一定推荐给你，他们会选择自己赚的最多的推荐给你，举例子说：他们会极力诱导你放弃购买6000的电脑（他只能赚800），而去买4200的电脑（因为他能赚1500）。OV两家同样是如此，在高提成高回报率的前提下，很多销售甚至会阻止你购买其他机型，而大力诱导你买这两家的手机。\n\n\n### 稳步求变\n\nOV在广告领域可谓早有心得，但近期可以看到在微博微信流媒体视频都可以看到OV两家的身影，要想一直繁荣，就必须有增长，只是市场经济不变的法则。OV两家也是看到早已坐实了线下渠道，通过种种手段完成了资本的原始积累，所以从今年开始攻占线上渠道，也就是说等线上销售基本已经定型，各家玩不出什么花样的时候，他们直接拿过来照搬，再加上线下和主流媒体渠道实现全范围的对大家进行轰炸，最终这两个季度用户数量激增，拿下了市场冠亚军的宝座。\n\n总结：虽然黑了OV两家这么多年，但也不得不承认他们确确实实有自身的可取之处。写了这么多，我们可以看出，OV两家成功的主要原因：自始至终大力投资广告，一点点增加自己的品牌影响和曝光度；早期依靠线下在智能机行业站稳脚跟，达到原始资本的积累；后期为了再增长，主打外观，将广告进一步做大，做广，最终在国内手机行业登顶。\n\n\n### 总结\n\n存在即为合理，我们不能否认最近两年来OV两家在市场拓展上面的成功，就如当年小米开创互联网营销模式一样，OV用同样利用全民娱乐，线上线下互补，手机制造门槛降低等打出了一手好牌。但如果一味的模仿抄袭，产品无特色体验差等，最终当消费者觉醒时，依然会被市场所抛弃。我们有理由相信好的产品真金不怕火炼，最终才会经得起消费者检验；但同时，手段和策略能更快地给我们带来更多的资金和市场也同样至关重要。一个公司要想能够持续性发展，势必需要将资金反馈到自己的产品中才行，否则*挂羊头卖狗肉*的事最终会被揭露出来。\n","slug":"2016/2016-11-03-如何看待蓝绿大厂问鼎中国","published":1,"updated":"2016-12-16T01:50:03.035Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aiv003emumu2nvf0qxi","content":"<p>根据IDC的数据，今年第三季度，OPPO和VIVO在中国市场的出货量再创新高，首度成为中国市场的冠亚军。OPPO和VIVO历来以低配高价而文明科技圈内，且低于红米的配置和软件优化，但却卖出几倍的价格，一味的再外观上模仿苹果，广告上轰炸观众，再加上市面上很难找到专业的评测机构来测评这两家的手机等一系列因素，因此很多人都会对这两家产品很是不屑，称他们为“蓝绿大厂，高价低配，专坑厂妹”。但本着存在即为合理的看法，OPPO和VIVO一定还是有很多可取之处的，不然不可能在竞争日益激烈的手机市场上面，站稳脚跟，国内销量先干掉小米，后挤掉华为，且业绩日益攀升。我将蓝绿厂家成功可以总结为以下几点。</p>\n<hr>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/1.jpg\" alt=\"\"></p>\n<h3 id=\"差强人意\"><a href=\"#差强人意\" class=\"headerlink\" title=\"差强人意\"></a>差强人意</h3><p>就产品本身而言，两家主打的功能也都基本一致：自拍，音效，快充。这几点都算是手机某一项的特色功能，但老实说都不具备特色，因为国产手机大都在这些功能上面表现的不差，下面进行详细解析。</p>\n<p>在评价一个手机拍照性能时，大都以是否能够更加真实的还原场景为标准，常用的参考量为：解析力，白平衡，夜间成像能力等等。因为手机不同于单反之类的产品，毕竟机身空间有限，每次捕捉的光源数据会经过大量的加工处理才会得到样张的，所以硬件参数即便再好（光圈大，像素高），如果没有好的算法，往往会适得其反，这就是为何苹果800w摄像头可以秒杀别人1600w大光圈的原因。说完拍照来提一下自拍，自拍本身属于照骗的一个制造过程（拍的美不美，有可能你自拍出的照片你妈都不认识），摄像头要拍出真实的照片不容易，但要毁照的话，只需要进行一定的图像识别，加上特定的滤镜效果即可。市面上面除了iPhone功能单一外，其他手机大多有很强的自拍功能，什么深度磨破，瘦脸，背景虚化，多人拍照只对自己美化等，各种功能都深入到各家自身的ROM中去了，无需下载第三方软件。而OV两家因为主打自拍，所以前置摄像头像素极高，甚至超过了后置摄像头，这边到底拍的美不美，一来和你参数的选择有关，二来每个人的审美不尽相同。</p>\n<p>音效是一个模糊的概念，外放的音效极少有做的好的厂家，毕竟手机越做越小，虽然芯片在不断的发展，但数字电路很难做出模拟电路电路的音效体验。最近两年的主流中高端手机都不会在音效上面大做文章，显然有一道大家无法逾越的屏障拦在前面。目前中高端手机的外放基本只能判别音量大小，音效的好坏目前主要取决于耳机以及针对耳机的一些优化，但一个好耳机动辄千元起步，除了极少数用户，目前也几乎没有谁愿意为它买单。</p>\n<p>快充技术基本上在手机界已经普及（除了反应迟钝的苹果），市面上各种快充技术都不尽相同，升压，升流各种方式都有。来自高通的Quick Charge 2.0是随骁龙800开始盛行的快充技术，早在两年多前，小米4就已经实现了快充，另外MTK和麒麟处理器等也都相继推出了自身的快充技术，也就是说快充家家都有，只不过OV两家的广告让大家知道了他们手机有这个功能而已。</p>\n<p>在产品上面这两家算是没有任何特长的手机厂家，首先配置差，采用的一般是骁龙最新的中低端处理器（其他国产厂家一般会在千元左右的手机机使用该处理器）；其次是软件上开发能力较弱，缺失一些必备或者特色功能（如：远程协助，微信多开等功能都缺失，虽然可以通过第三方软件实现，但毕竟安全无保障），在一些手机自带功能上面的体验不足，如手势等操作识别错误，可能与这颗CPU性能较差，或者软件优化不足有关；再者其他诸如续航和通话信号等都没太多可以圈点的。综上这些，就可以知道为啥这么多人对它很诟病。</p>\n<p>软件和外观极度模仿苹果，很多交互方式和苹果一致，甚至连很多图标都一模一样，也许可以进一步满足很多人的虚荣心。</p>\n<p>说完这么多缺点，下面谈一下优点，两家厂家在手机使用上面都能够满足正常的需求，对于很久没试用过其他安卓手机的用户而言，这两款手机基本能够带来舒适愉快的体验，由于从14年开始，安卓手机配置基本上已经能够满足安卓系统的要求了，所以换句话说，14年的所有高配置的手机，只要没有质量问题，且你对拍照，三防等一些附加属性没有特殊要求，重新恢复出厂设置或者耍个新系统，现在一样可以当作新机来使用。</p>\n<p>举个例子：OV两家的CPU &lt; 荣耀6的CPU，OV两家的CPU &lt; MI4的CPU；OV两家的GPU &gt; 荣耀6的GPU，OV两家的GPU &lt; MI4的GPU。因此可以看出，在多任务切换体验来说（常规APP，不包含游戏，不包含系统自带软件功能），OV一般只能同时完美体验3-4个应用，荣耀6和MI3一般可以体验6-8个应用。荣耀6基本上已经不能胜任市面的中等要求的游戏（王者荣耀等），MI4和能够完全可以胜任中等要求的游戏，且可以冲击一些高负荷的游戏，OV能够胜任中等要求的游戏。</p>\n<p>因为这两年CPU和GPU虽然略有提升，但大多数人很少会玩大型游戏或者运行n多个APP，对CPU和GPU的型号，好坏与否并不关心，甚至很多人觉得手机不错，自始至终并不了解自己的手机比别家的好或者差。</p>\n<p>对特色功能的体验一般也仅仅限于手机重度爱好使用者，MIUI，FLYME和EMUI等各家系统很多功能虽然好用，但由于缺乏推广，普通用户并不关注，或者说从来没用过，不知道有这些功能。安卓手机从14年开始早已进入了厂商引导消费体验的阶段，普通消费者对手机已经不存在不满和需求，甚至觉得太强大，很多功能不会用，不会设置，而恰恰是厂家在帮用户思考增加哪些功能会让体验更加的完美，护眼模式，远程协助，单手模式，节电模式等都是各家厂家在提升用户体验上面的尝试。</p>\n<p>综上可以看出，在手机同质化的今天，OV基本可以满足市面上面的绝大多数需求，虽然还会有误触，略微卡顿等问题，但相比过去安卓的不响应，发热，死机重启等，已经好了太多，普通消费者看个视频，玩玩小游戏完全可以满足，从苹果转来的用户会觉得便宜几千体验也差不多了多少，较为满意，而从旧款安卓低端机转过来的用户，则会认为大屏不卡顿不死机，好了太多。满足刚需就好，其他能有的功能尽量往上加，作绝大多数普通消费者能够使用的手机即可，这也是OV两家作产品的精髓。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/2.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"信息轰炸\"><a href=\"#信息轰炸\" class=\"headerlink\" title=\"信息轰炸\"></a>信息轰炸</h3><p>这个时代是改革开放来最差的时代，因为经济增长缓慢，民营实业入不敷出，房价虚高，资本的寒冬；但这个时代缺失娱乐业最好的时代，各种综艺节目，电视电影，网剧直播等层出不穷，一个全民娱乐的时代。OV两家恰恰是这个时代最大的受益者之一，在娱乐圈，电视台，广告界磨辊打趴了这么多年，积累了深厚的资源和用户，动辄数亿的广告，但却往往能够找准最佳的商机，带来丰厚的回报。细数OV两家的广告可以遍布你身边的一切，从最初的湖南卫视到浙江卫视，从多个热门综艺节目到热门电视剧，从微博到微信。无论你是做哪一行的，逃到哪儿都可以看到这两家的广告。</p>\n<p>绝大多数用户的心理都是从众的，OV两家前几年在小米混的风生水起的时候，只能通过电视广告来发展自己偏远地区的业务，那时候两家主要的购买群体一般是三四线城市或者农村，因为网络物流不发达，用户主要获取信息途径通过电视，所以来自这些地方的用户大都购买这两款手机。OV两家那时候属于闷声赚钱，相比于“中酷联”这三家，既不用面对激烈的竞争，也还能谋取较高的利润，但市场占有率不算高，算是小日子过得还不错。</p>\n<p>仔细研究OV两家的进程，颇有点“农村包围城市”的韵味，OV两家最近的之所以能够逆袭，不是得益于自身手机的发展，恰恰是整个行业的不发展，苹果两年一大步今年都已经干脆不走了。早从13年的同质化开始，整个行业已经陷入了僵局，各个产品几乎不存在差异化，或者只是微差异化。OV两家只要跟着谷歌走，产品做的不是实在太烂，在有一定知名度的前提下，就可以掌握更多用户。如果说早期的OV两家是牢牢把控了小城市和农村，那现在就是“农村包围城市”，这两家很大成都就是说服了互联网，一二线城市中的原有苹果用户，老旧安卓机转型过来的用户以及追星的用户来购买他们的产品而实现销量增长的。老苹果用户在更新手机的时候想体验其他平台或者因为预算选择稍微便宜的手机，OV两家一般都会是他们的首选，原因有两点：1.广告效应，论知名度，两家无出其右，其他国产机都具备屌丝标签。2.OV两家刻意模仿苹果，用户体验各方面几乎可以和苹果无缝对接了，连图标都做的一致。老旧安卓机用户的原因可以分为两点：1.耳熟能详的知名度。2.更好的外观和体验。</p>\n<p>综上可以看出，不断地信息轰炸，建立自己的品牌影响力，让观众普遍认为你手机还不错，这点很重要。在苹果和三星占有率再创新低时，OV两家的信息轰炸还是很有效果的。</p>\n<h3 id=\"低调专注\"><a href=\"#低调专注\" class=\"headerlink\" title=\"低调专注\"></a>低调专注</h3><p><strong>低调专注算是一个褒义词，这边我们只就事论事</strong>，众所周知，做任何事情专注最为重要，OV两家的成功决不能排除专注这一点，当别人都在迫于小米荣耀等线上角逐的势头，而不得不做互联网营销时，这两家却反其道而行之，专注于线下（因为他们也知道自己的手机那时在智能机时代确实毫无竞争力可言），构建更加完善的线下渠道，在更多传统媒体上面布满广告，给予经销商高回报率等，这些都奠定了它成功的基础。我们来重新回顾思考这些事情，当初其实OV在做大规模营销和扩大线下建设时，其实大多数人都认为，这已经是个信息化社会了，线下终将被淘汰，减少中间商环节才是未来数码3C的大势所趋。但事实证明，大多数人的观点并不正确，中国的城市化进程，网络物流的推广覆盖远不是坐在高层写字楼办公的金领白领可以看清的，中国仍然有6亿的农村人口，即便他们可以使用网络但却没有物流，小型城市人口也仍然在中国占了很大的比重，他们虽然可以使用网络，但未必人人都会完全融入信息化社会。可以看出OV两家的“农村包围城市”的战略还是很明智的，这些地盘往往是被忽视了的金库。</p>\n<p>各家在网络上面都会进行营销。锤子小米华为等，微博，贴吧上粉黑水军争吵不断。当提及OV两家，不得不说一个有趣的现象，几乎所有这些互联网品牌的手机用户的都看不上OV两家，谁和它比都不屑。这也导致，市面上几乎就找不到OV两家手机的测评，一些测评花了几分钟说了下外观和界面，然后说“这手机就这样也没什么好说的”，但这两家公司历来低调，对这些评论从来都不进行任何回复，也就是说直接无视你们，因为他们知道这些人不是他们的用户群，把事情闹大，万一大家都知道你手机不好，那咋办？另一个低调表现在对高通和谷歌的顺从，当其某厂家发声质疑高通的垄断时而期望获取更多话语权的时候，OV两家义无反顾地积极配合响应高通等公司，这主要取决于他们知道自身的定位，缺乏核心技术，软件研发调优能力弱，同时也不具备芯片等研发能力，所以业务重点更能定为清晰，只做产品的整装与宣传。可见<strong>在商言商</strong>，专注低调赚钱往往更能够成功！</p>\n<h3 id=\"外观精良\"><a href=\"#外观精良\" class=\"headerlink\" title=\"外观精良\"></a>外观精良</h3><p>外观这边用不美这个词，还是很讲究的，在我看来精美这个词只能用于“在一定的时期，能够满足社会上8,9成数用户的审美标准，那才可以称得上是精美”，iphone 4刚出来的时候是可以算上精美的，而iphone 6的机身和背面惊人的白带，还是离精美差的较远的。精致的话，一般用在工业制造上面极为考究的产品，如小米的工业陶瓷机身，所以这边考虑到这两家做外观虽然都能看到很多苹果的影子，但还算是用料不错，品质有保证。</p>\n<p>就OV的外观而言，国产手机中，也就只有魅族可以和它一起争夺女性用户了。</p>\n<p>国内小米和华为在外观上面都有着浓厚的工科生或中年人审美情怀，OPPO，VIVO，魅族的外观类似苹果材质和颜色看起来也更加清新和明快，虽然不能如galaxy edge系类满足绝大多数人审美，但往往更讨年轻人和女性用户的喜欢。这一点尤为重要，上述提到过，当今社会，手机早已同质化严重，创新疲乏，所以试问普通用户除了外观还有啥可以追求？！换句话说，即便各家仍然有软件体验，应用等创新层出不穷，但毕竟这是个看脸的社会，有多少人会喜欢小米正面左上方的LOGO？举个例子：亲身经历，身边有50岁大妈，之前用手机只打电话，所以一直用的红米之类的千元机，现在周围人都用微信，所以入手一智能机，本来是去看华为的手机，结果转了一圈，都嫌太丑，最后买了VIVO的一款主打机型。连三星都将国行版正面LOGO给去掉了，可见对于国人来说，颜值是多么重要！</p>\n<p>综上，OV虽然未必美观漂亮，但最起码有明星加持，有苹果的影子，用户不会觉得像其他国产机一样丑，智能手机已经快走过了10个年头，如果它寿命还没有结束的话，未来的竞争恐怕也只有外观的竞争了吧。</p>\n<h3 id=\"高回报率\"><a href=\"#高回报率\" class=\"headerlink\" title=\"高回报率\"></a>高回报率</h3><p>再好的策略都离不开优秀的执行者，OV两家的成功离不开线下销售人员的三寸不烂之舌，如何让调用手机销售的积极性，让他们都来卖你的手机，而不是卖其他品牌的呢？大家如果有去电脑城战JS的经理的话，都会知道，JS推荐笔记本或者品牌机都是有选择性的，贵的他不一定推荐给你，便宜的也不一定推荐给你，他们会选择自己赚的最多的推荐给你，举例子说：他们会极力诱导你放弃购买6000的电脑（他只能赚800），而去买4200的电脑（因为他能赚1500）。OV两家同样是如此，在高提成高回报率的前提下，很多销售甚至会阻止你购买其他机型，而大力诱导你买这两家的手机。</p>\n<h3 id=\"稳步求变\"><a href=\"#稳步求变\" class=\"headerlink\" title=\"稳步求变\"></a>稳步求变</h3><p>OV在广告领域可谓早有心得，但近期可以看到在微博微信流媒体视频都可以看到OV两家的身影，要想一直繁荣，就必须有增长，只是市场经济不变的法则。OV两家也是看到早已坐实了线下渠道，通过种种手段完成了资本的原始积累，所以从今年开始攻占线上渠道，也就是说等线上销售基本已经定型，各家玩不出什么花样的时候，他们直接拿过来照搬，再加上线下和主流媒体渠道实现全范围的对大家进行轰炸，最终这两个季度用户数量激增，拿下了市场冠亚军的宝座。</p>\n<p>总结：虽然黑了OV两家这么多年，但也不得不承认他们确确实实有自身的可取之处。写了这么多，我们可以看出，OV两家成功的主要原因：自始至终大力投资广告，一点点增加自己的品牌影响和曝光度；早期依靠线下在智能机行业站稳脚跟，达到原始资本的积累；后期为了再增长，主打外观，将广告进一步做大，做广，最终在国内手机行业登顶。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>存在即为合理，我们不能否认最近两年来OV两家在市场拓展上面的成功，就如当年小米开创互联网营销模式一样，OV用同样利用全民娱乐，线上线下互补，手机制造门槛降低等打出了一手好牌。但如果一味的模仿抄袭，产品无特色体验差等，最终当消费者觉醒时，依然会被市场所抛弃。我们有理由相信好的产品真金不怕火炼，最终才会经得起消费者检验；但同时，手段和策略能更快地给我们带来更多的资金和市场也同样至关重要。一个公司要想能够持续性发展，势必需要将资金反馈到自己的产品中才行，否则<em>挂羊头卖狗肉</em>的事最终会被揭露出来。</p>\n","excerpt":"<p>根据IDC的数据，今年第三季度，OPPO和VIVO在中国市场的出货量再创新高，首度成为中国市场的冠亚军。OPPO和VIVO历来以低配高价而文明科技圈内，且低于红米的配置和软件优化，但却卖出几倍的价格，一味的再外观上模仿苹果，广告上轰炸观众，再加上市面上很难找到专业的评测机构来测评这两家的手机等一系列因素，因此很多人都会对这两家产品很是不屑，称他们为“蓝绿大厂，高价低配，专坑厂妹”。但本着存在即为合理的看法，OPPO和VIVO一定还是有很多可取之处的，不然不可能在竞争日益激烈的手机市场上面，站稳脚跟，国内销量先干掉小米，后挤掉华为，且业绩日益攀升。我将蓝绿厂家成功可以总结为以下几点。</p>\n<hr>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/1.jpg\" alt=\"\"></p>\n<h3 id=\"差强人意\"><a href=\"#差强人意\" class=\"headerlink\" title=\"差强人意\"></a>差强人意</h3><p>就产品本身而言，两家主打的功能也都基本一致：自拍，音效，快充。这几点都算是手机某一项的特色功能，但老实说都不具备特色，因为国产手机大都在这些功能上面表现的不差，下面进行详细解析。</p>\n<p>在评价一个手机拍照性能时，大都以是否能够更加真实的还原场景为标准，常用的参考量为：解析力，白平衡，夜间成像能力等等。因为手机不同于单反之类的产品，毕竟机身空间有限，每次捕捉的光源数据会经过大量的加工处理才会得到样张的，所以硬件参数即便再好（光圈大，像素高），如果没有好的算法，往往会适得其反，这就是为何苹果800w摄像头可以秒杀别人1600w大光圈的原因。说完拍照来提一下自拍，自拍本身属于照骗的一个制造过程（拍的美不美，有可能你自拍出的照片你妈都不认识），摄像头要拍出真实的照片不容易，但要毁照的话，只需要进行一定的图像识别，加上特定的滤镜效果即可。市面上面除了iPhone功能单一外，其他手机大多有很强的自拍功能，什么深度磨破，瘦脸，背景虚化，多人拍照只对自己美化等，各种功能都深入到各家自身的ROM中去了，无需下载第三方软件。而OV两家因为主打自拍，所以前置摄像头像素极高，甚至超过了后置摄像头，这边到底拍的美不美，一来和你参数的选择有关，二来每个人的审美不尽相同。</p>\n<p>音效是一个模糊的概念，外放的音效极少有做的好的厂家，毕竟手机越做越小，虽然芯片在不断的发展，但数字电路很难做出模拟电路电路的音效体验。最近两年的主流中高端手机都不会在音效上面大做文章，显然有一道大家无法逾越的屏障拦在前面。目前中高端手机的外放基本只能判别音量大小，音效的好坏目前主要取决于耳机以及针对耳机的一些优化，但一个好耳机动辄千元起步，除了极少数用户，目前也几乎没有谁愿意为它买单。</p>\n<p>快充技术基本上在手机界已经普及（除了反应迟钝的苹果），市面上各种快充技术都不尽相同，升压，升流各种方式都有。来自高通的Quick Charge 2.0是随骁龙800开始盛行的快充技术，早在两年多前，小米4就已经实现了快充，另外MTK和麒麟处理器等也都相继推出了自身的快充技术，也就是说快充家家都有，只不过OV两家的广告让大家知道了他们手机有这个功能而已。</p>\n<p>在产品上面这两家算是没有任何特长的手机厂家，首先配置差，采用的一般是骁龙最新的中低端处理器（其他国产厂家一般会在千元左右的手机机使用该处理器）；其次是软件上开发能力较弱，缺失一些必备或者特色功能（如：远程协助，微信多开等功能都缺失，虽然可以通过第三方软件实现，但毕竟安全无保障），在一些手机自带功能上面的体验不足，如手势等操作识别错误，可能与这颗CPU性能较差，或者软件优化不足有关；再者其他诸如续航和通话信号等都没太多可以圈点的。综上这些，就可以知道为啥这么多人对它很诟病。</p>\n<p>软件和外观极度模仿苹果，很多交互方式和苹果一致，甚至连很多图标都一模一样，也许可以进一步满足很多人的虚荣心。</p>\n<p>说完这么多缺点，下面谈一下优点，两家厂家在手机使用上面都能够满足正常的需求，对于很久没试用过其他安卓手机的用户而言，这两款手机基本能够带来舒适愉快的体验，由于从14年开始，安卓手机配置基本上已经能够满足安卓系统的要求了，所以换句话说，14年的所有高配置的手机，只要没有质量问题，且你对拍照，三防等一些附加属性没有特殊要求，重新恢复出厂设置或者耍个新系统，现在一样可以当作新机来使用。</p>\n<p>举个例子：OV两家的CPU &lt; 荣耀6的CPU，OV两家的CPU &lt; MI4的CPU；OV两家的GPU &gt; 荣耀6的GPU，OV两家的GPU &lt; MI4的GPU。因此可以看出，在多任务切换体验来说（常规APP，不包含游戏，不包含系统自带软件功能），OV一般只能同时完美体验3-4个应用，荣耀6和MI3一般可以体验6-8个应用。荣耀6基本上已经不能胜任市面的中等要求的游戏（王者荣耀等），MI4和能够完全可以胜任中等要求的游戏，且可以冲击一些高负荷的游戏，OV能够胜任中等要求的游戏。</p>\n<p>因为这两年CPU和GPU虽然略有提升，但大多数人很少会玩大型游戏或者运行n多个APP，对CPU和GPU的型号，好坏与否并不关心，甚至很多人觉得手机不错，自始至终并不了解自己的手机比别家的好或者差。</p>\n<p>对特色功能的体验一般也仅仅限于手机重度爱好使用者，MIUI，FLYME和EMUI等各家系统很多功能虽然好用，但由于缺乏推广，普通用户并不关注，或者说从来没用过，不知道有这些功能。安卓手机从14年开始早已进入了厂商引导消费体验的阶段，普通消费者对手机已经不存在不满和需求，甚至觉得太强大，很多功能不会用，不会设置，而恰恰是厂家在帮用户思考增加哪些功能会让体验更加的完美，护眼模式，远程协助，单手模式，节电模式等都是各家厂家在提升用户体验上面的尝试。</p>\n<p>综上可以看出，在手机同质化的今天，OV基本可以满足市面上面的绝大多数需求，虽然还会有误触，略微卡顿等问题，但相比过去安卓的不响应，发热，死机重启等，已经好了太多，普通消费者看个视频，玩玩小游戏完全可以满足，从苹果转来的用户会觉得便宜几千体验也差不多了多少，较为满意，而从旧款安卓低端机转过来的用户，则会认为大屏不卡顿不死机，好了太多。满足刚需就好，其他能有的功能尽量往上加，作绝大多数普通消费者能够使用的手机即可，这也是OV两家作产品的精髓。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/2.jpg\" alt=\"\"></p>","more":"<h3 id=\"信息轰炸\"><a href=\"#信息轰炸\" class=\"headerlink\" title=\"信息轰炸\"></a>信息轰炸</h3><p>这个时代是改革开放来最差的时代，因为经济增长缓慢，民营实业入不敷出，房价虚高，资本的寒冬；但这个时代缺失娱乐业最好的时代，各种综艺节目，电视电影，网剧直播等层出不穷，一个全民娱乐的时代。OV两家恰恰是这个时代最大的受益者之一，在娱乐圈，电视台，广告界磨辊打趴了这么多年，积累了深厚的资源和用户，动辄数亿的广告，但却往往能够找准最佳的商机，带来丰厚的回报。细数OV两家的广告可以遍布你身边的一切，从最初的湖南卫视到浙江卫视，从多个热门综艺节目到热门电视剧，从微博到微信。无论你是做哪一行的，逃到哪儿都可以看到这两家的广告。</p>\n<p>绝大多数用户的心理都是从众的，OV两家前几年在小米混的风生水起的时候，只能通过电视广告来发展自己偏远地区的业务，那时候两家主要的购买群体一般是三四线城市或者农村，因为网络物流不发达，用户主要获取信息途径通过电视，所以来自这些地方的用户大都购买这两款手机。OV两家那时候属于闷声赚钱，相比于“中酷联”这三家，既不用面对激烈的竞争，也还能谋取较高的利润，但市场占有率不算高，算是小日子过得还不错。</p>\n<p>仔细研究OV两家的进程，颇有点“农村包围城市”的韵味，OV两家最近的之所以能够逆袭，不是得益于自身手机的发展，恰恰是整个行业的不发展，苹果两年一大步今年都已经干脆不走了。早从13年的同质化开始，整个行业已经陷入了僵局，各个产品几乎不存在差异化，或者只是微差异化。OV两家只要跟着谷歌走，产品做的不是实在太烂，在有一定知名度的前提下，就可以掌握更多用户。如果说早期的OV两家是牢牢把控了小城市和农村，那现在就是“农村包围城市”，这两家很大成都就是说服了互联网，一二线城市中的原有苹果用户，老旧安卓机转型过来的用户以及追星的用户来购买他们的产品而实现销量增长的。老苹果用户在更新手机的时候想体验其他平台或者因为预算选择稍微便宜的手机，OV两家一般都会是他们的首选，原因有两点：1.广告效应，论知名度，两家无出其右，其他国产机都具备屌丝标签。2.OV两家刻意模仿苹果，用户体验各方面几乎可以和苹果无缝对接了，连图标都做的一致。老旧安卓机用户的原因可以分为两点：1.耳熟能详的知名度。2.更好的外观和体验。</p>\n<p>综上可以看出，不断地信息轰炸，建立自己的品牌影响力，让观众普遍认为你手机还不错，这点很重要。在苹果和三星占有率再创新低时，OV两家的信息轰炸还是很有效果的。</p>\n<h3 id=\"低调专注\"><a href=\"#低调专注\" class=\"headerlink\" title=\"低调专注\"></a>低调专注</h3><p><strong>低调专注算是一个褒义词，这边我们只就事论事</strong>，众所周知，做任何事情专注最为重要，OV两家的成功决不能排除专注这一点，当别人都在迫于小米荣耀等线上角逐的势头，而不得不做互联网营销时，这两家却反其道而行之，专注于线下（因为他们也知道自己的手机那时在智能机时代确实毫无竞争力可言），构建更加完善的线下渠道，在更多传统媒体上面布满广告，给予经销商高回报率等，这些都奠定了它成功的基础。我们来重新回顾思考这些事情，当初其实OV在做大规模营销和扩大线下建设时，其实大多数人都认为，这已经是个信息化社会了，线下终将被淘汰，减少中间商环节才是未来数码3C的大势所趋。但事实证明，大多数人的观点并不正确，中国的城市化进程，网络物流的推广覆盖远不是坐在高层写字楼办公的金领白领可以看清的，中国仍然有6亿的农村人口，即便他们可以使用网络但却没有物流，小型城市人口也仍然在中国占了很大的比重，他们虽然可以使用网络，但未必人人都会完全融入信息化社会。可以看出OV两家的“农村包围城市”的战略还是很明智的，这些地盘往往是被忽视了的金库。</p>\n<p>各家在网络上面都会进行营销。锤子小米华为等，微博，贴吧上粉黑水军争吵不断。当提及OV两家，不得不说一个有趣的现象，几乎所有这些互联网品牌的手机用户的都看不上OV两家，谁和它比都不屑。这也导致，市面上几乎就找不到OV两家手机的测评，一些测评花了几分钟说了下外观和界面，然后说“这手机就这样也没什么好说的”，但这两家公司历来低调，对这些评论从来都不进行任何回复，也就是说直接无视你们，因为他们知道这些人不是他们的用户群，把事情闹大，万一大家都知道你手机不好，那咋办？另一个低调表现在对高通和谷歌的顺从，当其某厂家发声质疑高通的垄断时而期望获取更多话语权的时候，OV两家义无反顾地积极配合响应高通等公司，这主要取决于他们知道自身的定位，缺乏核心技术，软件研发调优能力弱，同时也不具备芯片等研发能力，所以业务重点更能定为清晰，只做产品的整装与宣传。可见<strong>在商言商</strong>，专注低调赚钱往往更能够成功！</p>\n<h3 id=\"外观精良\"><a href=\"#外观精良\" class=\"headerlink\" title=\"外观精良\"></a>外观精良</h3><p>外观这边用不美这个词，还是很讲究的，在我看来精美这个词只能用于“在一定的时期，能够满足社会上8,9成数用户的审美标准，那才可以称得上是精美”，iphone 4刚出来的时候是可以算上精美的，而iphone 6的机身和背面惊人的白带，还是离精美差的较远的。精致的话，一般用在工业制造上面极为考究的产品，如小米的工业陶瓷机身，所以这边考虑到这两家做外观虽然都能看到很多苹果的影子，但还算是用料不错，品质有保证。</p>\n<p>就OV的外观而言，国产手机中，也就只有魅族可以和它一起争夺女性用户了。</p>\n<p>国内小米和华为在外观上面都有着浓厚的工科生或中年人审美情怀，OPPO，VIVO，魅族的外观类似苹果材质和颜色看起来也更加清新和明快，虽然不能如galaxy edge系类满足绝大多数人审美，但往往更讨年轻人和女性用户的喜欢。这一点尤为重要，上述提到过，当今社会，手机早已同质化严重，创新疲乏，所以试问普通用户除了外观还有啥可以追求？！换句话说，即便各家仍然有软件体验，应用等创新层出不穷，但毕竟这是个看脸的社会，有多少人会喜欢小米正面左上方的LOGO？举个例子：亲身经历，身边有50岁大妈，之前用手机只打电话，所以一直用的红米之类的千元机，现在周围人都用微信，所以入手一智能机，本来是去看华为的手机，结果转了一圈，都嫌太丑，最后买了VIVO的一款主打机型。连三星都将国行版正面LOGO给去掉了，可见对于国人来说，颜值是多么重要！</p>\n<p>综上，OV虽然未必美观漂亮，但最起码有明星加持，有苹果的影子，用户不会觉得像其他国产机一样丑，智能手机已经快走过了10个年头，如果它寿命还没有结束的话，未来的竞争恐怕也只有外观的竞争了吧。</p>\n<h3 id=\"高回报率\"><a href=\"#高回报率\" class=\"headerlink\" title=\"高回报率\"></a>高回报率</h3><p>再好的策略都离不开优秀的执行者，OV两家的成功离不开线下销售人员的三寸不烂之舌，如何让调用手机销售的积极性，让他们都来卖你的手机，而不是卖其他品牌的呢？大家如果有去电脑城战JS的经理的话，都会知道，JS推荐笔记本或者品牌机都是有选择性的，贵的他不一定推荐给你，便宜的也不一定推荐给你，他们会选择自己赚的最多的推荐给你，举例子说：他们会极力诱导你放弃购买6000的电脑（他只能赚800），而去买4200的电脑（因为他能赚1500）。OV两家同样是如此，在高提成高回报率的前提下，很多销售甚至会阻止你购买其他机型，而大力诱导你买这两家的手机。</p>\n<h3 id=\"稳步求变\"><a href=\"#稳步求变\" class=\"headerlink\" title=\"稳步求变\"></a>稳步求变</h3><p>OV在广告领域可谓早有心得，但近期可以看到在微博微信流媒体视频都可以看到OV两家的身影，要想一直繁荣，就必须有增长，只是市场经济不变的法则。OV两家也是看到早已坐实了线下渠道，通过种种手段完成了资本的原始积累，所以从今年开始攻占线上渠道，也就是说等线上销售基本已经定型，各家玩不出什么花样的时候，他们直接拿过来照搬，再加上线下和主流媒体渠道实现全范围的对大家进行轰炸，最终这两个季度用户数量激增，拿下了市场冠亚军的宝座。</p>\n<p>总结：虽然黑了OV两家这么多年，但也不得不承认他们确确实实有自身的可取之处。写了这么多，我们可以看出，OV两家成功的主要原因：自始至终大力投资广告，一点点增加自己的品牌影响和曝光度；早期依靠线下在智能机行业站稳脚跟，达到原始资本的积累；后期为了再增长，主打外观，将广告进一步做大，做广，最终在国内手机行业登顶。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>存在即为合理，我们不能否认最近两年来OV两家在市场拓展上面的成功，就如当年小米开创互联网营销模式一样，OV用同样利用全民娱乐，线上线下互补，手机制造门槛降低等打出了一手好牌。但如果一味的模仿抄袭，产品无特色体验差等，最终当消费者觉醒时，依然会被市场所抛弃。我们有理由相信好的产品真金不怕火炼，最终才会经得起消费者检验；但同时，手段和策略能更快地给我们带来更多的资金和市场也同样至关重要。一个公司要想能够持续性发展，势必需要将资金反馈到自己的产品中才行，否则<em>挂羊头卖狗肉</em>的事最终会被揭露出来。</p>"},{"layout":"post","title":"keil工程的代码优化","date":"2016-11-16T08:39:00.000Z","_content":"\n\n### C项目的工程优化\n\n这边主要参考另外一篇文章，不仅仅是针对C语言，C++等其他一些类C语言也同样适用。我们在构建自己的项目时，主要需要考虑：宏定义，类型，全局变量等的作用范围，针对头文件的引用和复制是否有存在的必要等。只有对每个细节都了如指掌，才能够减少代码的出错，以及优化代码空间等。就目前的芯片发展而言，很多时候都是硬件性能过剩，大多数程序员已经不再考虑或者极少考虑代码如何优化节省空间等问题了，往往更加注重代码的可阅读可扩展性，这边之所以注重这个问题，主要是考虑到工控节能领域，以及很多使用的模块可能存在代码量不足，不能胜任工作等问题。\n\n\n### keil\n\nkeil是一款MCU的IDE，有文章介绍过详细配置和调试步骤，这边不再详细累述。因为针对的是MCU的代码优化，所以首先我们必须知道编译器生成的代码量等信息。\n\n每次点击编译后，下方会出现KEIL RVMDK编译后的信息，例如：Program Size: Code=19160 RO-data=6420 RW-data=108 ZI-data=1532，这边代表我的无任何优化的前提下，keil编译生成的代码为19160个字节。\n\n**Code是代码占用的空间；RO-data(Read Only) 是只读常量的大小，如const型；RW-data（Read Write）是初始化了的可读写变量的大小，ZI-data（Zero Initialize）是没有初始化的可读写变量的大小。ZI-data不会被算做代码里因为不会被初始化。Total ROM Size ：Code + RO Data + RW Data（ROM Size并不等于Code + RO Data，初始化不为零的 RW Data 数据本身也会占用相同大小的 ROM 和 RAM 存储单元，变量在 RAM 中，而变量的初始值存在 ROM 中） ，Total RW  Size：RW Data + ZI Data 。这边在考虑芯片的 ROM 和 RAM 选型时，注意： ROM > Code + RO Data + RW Data  ， 而 RAM > RW-data+ZI-data，具体我们可以查看 KDE 编译后生成的 .map文件。**\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/1.png)\n\n<!-- more -->\n\n\n\nKDE 生成的 .map 文件分析：\n\n```\nProduct: MDK-ARM Standard 5.10\nComponent: ARM Compiler 5.04 update 1 (build 49)\nTool: armlink [5040049]\n\n==============================================================================\n\nSection Cross References\n\n    main.o(i.AdjustTask) refers to memseta.o(.text) for __aeabi_memclr4\n    main.o(i.AdjustTask) refers to analogin.o(i.AnalogInConvert) for AnalogInConvert\n\t...\n\t\n==============================================================================\n\nRemoving Unused input sections from the image.\n\n    Removing main.o(.data), (1 bytes).\n    Removing main.o(.data), (4 bytes).\n\t...\n\n329 unused section(s) (total 12428 bytes) removed from the image.\n\n==============================================================================\n\nImage Symbol Table\n\n    Local Symbols\n\n    Symbol Name                              Value     Ov Type        Size  Object(Section)\n\n    ../clib/../cmprslib/zerorunl2.c          0x00000000   Number         0  __dczerorl2.o ABSOLUTE\n    ../clib/microlib/division.c              0x00000000   Number         0  uldiv.o ABSOLUTE\n\t...\n\t\n==============================================================================\n\nMemory Map of the image\n\n  Image Entry point : 0x08000131\n\n  Load Region LR_IROM1 (Base: 0x08000000, Size: 0x0001c0c8, Max: 0x00080000, ABSOLUTE, COMPRESSED[0x0001bc94])\n\n    Execution Region ER_IROM1 (Base: 0x08000000, Size: 0x0001baa0, Max: 0x00080000, ABSOLUTE)\n\n    Base Addr    Size         Type   Attr      Idx    E Section Name        Object\n\n    0x08000000   0x00000130   Data   RO         4967    RESET               startup_stm32f10x_hd.o\n    0x08000130   0x00000000   Code   RO         5008  * .ARM.Collect$$$$00000000  mc_w.l(entry.o)\n    0x08000130   0x00000004   Code   RO         5086    .ARM.Collect$$$$00000001  mc_w.l(entry2.o)\n\t...\n\t\n    Execution Region RW_IRAM1 (Base: 0x20000000, Size: 0x0000f050, Max: 0x00010000, ABSOLUTE, COMPRESSED[0x000001f4])\n\n    Base Addr    Size         Type   Attr      Idx    E Section Name        Object\n\n    0x20000000   0x00000038   Data   RW           27    .data               main.o\n    0x20000038   0x00000005   Data   RW          422    .data               analogin.o\n\t...\n\t\n==============================================================================\n\nImage component sizes\n\n\n      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name\n\n      1252        138          0          5        200       3550   analogin.o\n       704         74         12         24          0       5534   analogout.o\n\t...\n\n==============================================================================\n\n\n      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   \n\n     80732       6214      32580       1576      59944     659393   Grand Totals\n     80732       6214      32580        500      59944     659393   ELF Image Totals (compressed)\n     80732       6214      32580        500          0          0   ROM Totals\n\n==============================================================================\n\n    Total RO  Size (Code + RO Data)               113312 ( 110.66kB)\n    Total RW  Size (RW Data + ZI Data)             61520 (  60.08kB)\n    Total ROM Size (Code + RO Data + RW Data)     113812 ( 111.14kB)\n\n==============================================================================\n\n\n```\n\n\n\n\n优化步骤如下：\n\n- project >> Option for Target “**” 打开如图 2界面。选择“target”，勾选上“Use MicroLIB”再编译。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/2.png)\n\n**分析：microLIB是缺省的C库，而且microLIB进行了高度优化。如果不勾选“Use MicroLIB”，keil会连接标准C库。所以勾选“Use MicroLIB”会减小code大小。**\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/3.png)\n\n- project >> Option for Target “**” 打开如界面。选择“C/C++”，勾选上“One ELF Section per Functin”再编译。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/4.png)\n\n**分析：“One ELF Section per Functin”就是将每个函数都生成一个ELF文件，最会将需要的函数链接成一个大的ELF文件。但是如果没有勾选“One ELF Section per Functin”。Keil将每个文件编译成一个ELF文件（即使文件中用未被使用的函数），最会链接成一个ELF文件。所以勾选“One ELF Section per Functin”会使code变小。**\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/5.png)\n\n\n\n> 参考链接：\n> http://blog.csdn.net/abclixu123/article/details/46923725\n> http://blog.csdn.net/gasbi/article/details/6186312\n","source":"_posts/2016/2016-11-16-keil工程的代码优化.md","raw":"---\nlayout: \"post\"\ntitle: \"keil工程的代码优化\"\ndate: \"2016-11-16 16:39\"\n---\n\n\n### C项目的工程优化\n\n这边主要参考另外一篇文章，不仅仅是针对C语言，C++等其他一些类C语言也同样适用。我们在构建自己的项目时，主要需要考虑：宏定义，类型，全局变量等的作用范围，针对头文件的引用和复制是否有存在的必要等。只有对每个细节都了如指掌，才能够减少代码的出错，以及优化代码空间等。就目前的芯片发展而言，很多时候都是硬件性能过剩，大多数程序员已经不再考虑或者极少考虑代码如何优化节省空间等问题了，往往更加注重代码的可阅读可扩展性，这边之所以注重这个问题，主要是考虑到工控节能领域，以及很多使用的模块可能存在代码量不足，不能胜任工作等问题。\n\n\n### keil\n\nkeil是一款MCU的IDE，有文章介绍过详细配置和调试步骤，这边不再详细累述。因为针对的是MCU的代码优化，所以首先我们必须知道编译器生成的代码量等信息。\n\n每次点击编译后，下方会出现KEIL RVMDK编译后的信息，例如：Program Size: Code=19160 RO-data=6420 RW-data=108 ZI-data=1532，这边代表我的无任何优化的前提下，keil编译生成的代码为19160个字节。\n\n**Code是代码占用的空间；RO-data(Read Only) 是只读常量的大小，如const型；RW-data（Read Write）是初始化了的可读写变量的大小，ZI-data（Zero Initialize）是没有初始化的可读写变量的大小。ZI-data不会被算做代码里因为不会被初始化。Total ROM Size ：Code + RO Data + RW Data（ROM Size并不等于Code + RO Data，初始化不为零的 RW Data 数据本身也会占用相同大小的 ROM 和 RAM 存储单元，变量在 RAM 中，而变量的初始值存在 ROM 中） ，Total RW  Size：RW Data + ZI Data 。这边在考虑芯片的 ROM 和 RAM 选型时，注意： ROM > Code + RO Data + RW Data  ， 而 RAM > RW-data+ZI-data，具体我们可以查看 KDE 编译后生成的 .map文件。**\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/1.png)\n\n<!-- more -->\n\n\n\nKDE 生成的 .map 文件分析：\n\n```\nProduct: MDK-ARM Standard 5.10\nComponent: ARM Compiler 5.04 update 1 (build 49)\nTool: armlink [5040049]\n\n==============================================================================\n\nSection Cross References\n\n    main.o(i.AdjustTask) refers to memseta.o(.text) for __aeabi_memclr4\n    main.o(i.AdjustTask) refers to analogin.o(i.AnalogInConvert) for AnalogInConvert\n\t...\n\t\n==============================================================================\n\nRemoving Unused input sections from the image.\n\n    Removing main.o(.data), (1 bytes).\n    Removing main.o(.data), (4 bytes).\n\t...\n\n329 unused section(s) (total 12428 bytes) removed from the image.\n\n==============================================================================\n\nImage Symbol Table\n\n    Local Symbols\n\n    Symbol Name                              Value     Ov Type        Size  Object(Section)\n\n    ../clib/../cmprslib/zerorunl2.c          0x00000000   Number         0  __dczerorl2.o ABSOLUTE\n    ../clib/microlib/division.c              0x00000000   Number         0  uldiv.o ABSOLUTE\n\t...\n\t\n==============================================================================\n\nMemory Map of the image\n\n  Image Entry point : 0x08000131\n\n  Load Region LR_IROM1 (Base: 0x08000000, Size: 0x0001c0c8, Max: 0x00080000, ABSOLUTE, COMPRESSED[0x0001bc94])\n\n    Execution Region ER_IROM1 (Base: 0x08000000, Size: 0x0001baa0, Max: 0x00080000, ABSOLUTE)\n\n    Base Addr    Size         Type   Attr      Idx    E Section Name        Object\n\n    0x08000000   0x00000130   Data   RO         4967    RESET               startup_stm32f10x_hd.o\n    0x08000130   0x00000000   Code   RO         5008  * .ARM.Collect$$$$00000000  mc_w.l(entry.o)\n    0x08000130   0x00000004   Code   RO         5086    .ARM.Collect$$$$00000001  mc_w.l(entry2.o)\n\t...\n\t\n    Execution Region RW_IRAM1 (Base: 0x20000000, Size: 0x0000f050, Max: 0x00010000, ABSOLUTE, COMPRESSED[0x000001f4])\n\n    Base Addr    Size         Type   Attr      Idx    E Section Name        Object\n\n    0x20000000   0x00000038   Data   RW           27    .data               main.o\n    0x20000038   0x00000005   Data   RW          422    .data               analogin.o\n\t...\n\t\n==============================================================================\n\nImage component sizes\n\n\n      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name\n\n      1252        138          0          5        200       3550   analogin.o\n       704         74         12         24          0       5534   analogout.o\n\t...\n\n==============================================================================\n\n\n      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   \n\n     80732       6214      32580       1576      59944     659393   Grand Totals\n     80732       6214      32580        500      59944     659393   ELF Image Totals (compressed)\n     80732       6214      32580        500          0          0   ROM Totals\n\n==============================================================================\n\n    Total RO  Size (Code + RO Data)               113312 ( 110.66kB)\n    Total RW  Size (RW Data + ZI Data)             61520 (  60.08kB)\n    Total ROM Size (Code + RO Data + RW Data)     113812 ( 111.14kB)\n\n==============================================================================\n\n\n```\n\n\n\n\n优化步骤如下：\n\n- project >> Option for Target “**” 打开如图 2界面。选择“target”，勾选上“Use MicroLIB”再编译。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/2.png)\n\n**分析：microLIB是缺省的C库，而且microLIB进行了高度优化。如果不勾选“Use MicroLIB”，keil会连接标准C库。所以勾选“Use MicroLIB”会减小code大小。**\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/3.png)\n\n- project >> Option for Target “**” 打开如界面。选择“C/C++”，勾选上“One ELF Section per Functin”再编译。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/4.png)\n\n**分析：“One ELF Section per Functin”就是将每个函数都生成一个ELF文件，最会将需要的函数链接成一个大的ELF文件。但是如果没有勾选“One ELF Section per Functin”。Keil将每个文件编译成一个ELF文件（即使文件中用未被使用的函数），最会链接成一个ELF文件。所以勾选“One ELF Section per Functin”会使code变小。**\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/5.png)\n\n\n\n> 参考链接：\n> http://blog.csdn.net/abclixu123/article/details/46923725\n> http://blog.csdn.net/gasbi/article/details/6186312\n","slug":"2016/2016-11-16-keil工程的代码优化","published":1,"updated":"2016-12-16T01:50:33.467Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aiw003fmumugbc7y73n","content":"<h3 id=\"C项目的工程优化\"><a href=\"#C项目的工程优化\" class=\"headerlink\" title=\"C项目的工程优化\"></a>C项目的工程优化</h3><p>这边主要参考另外一篇文章，不仅仅是针对C语言，C++等其他一些类C语言也同样适用。我们在构建自己的项目时，主要需要考虑：宏定义，类型，全局变量等的作用范围，针对头文件的引用和复制是否有存在的必要等。只有对每个细节都了如指掌，才能够减少代码的出错，以及优化代码空间等。就目前的芯片发展而言，很多时候都是硬件性能过剩，大多数程序员已经不再考虑或者极少考虑代码如何优化节省空间等问题了，往往更加注重代码的可阅读可扩展性，这边之所以注重这个问题，主要是考虑到工控节能领域，以及很多使用的模块可能存在代码量不足，不能胜任工作等问题。</p>\n<h3 id=\"keil\"><a href=\"#keil\" class=\"headerlink\" title=\"keil\"></a>keil</h3><p>keil是一款MCU的IDE，有文章介绍过详细配置和调试步骤，这边不再详细累述。因为针对的是MCU的代码优化，所以首先我们必须知道编译器生成的代码量等信息。</p>\n<p>每次点击编译后，下方会出现KEIL RVMDK编译后的信息，例如：Program Size: Code=19160 RO-data=6420 RW-data=108 ZI-data=1532，这边代表我的无任何优化的前提下，keil编译生成的代码为19160个字节。</p>\n<p><strong>Code是代码占用的空间；RO-data(Read Only) 是只读常量的大小，如const型；RW-data（Read Write）是初始化了的可读写变量的大小，ZI-data（Zero Initialize）是没有初始化的可读写变量的大小。ZI-data不会被算做代码里因为不会被初始化。Total ROM Size ：Code + RO Data + RW Data（ROM Size并不等于Code + RO Data，初始化不为零的 RW Data 数据本身也会占用相同大小的 ROM 和 RAM 存储单元，变量在 RAM 中，而变量的初始值存在 ROM 中） ，Total RW  Size：RW Data + ZI Data 。这边在考虑芯片的 ROM 和 RAM 选型时，注意： ROM &gt; Code + RO Data + RW Data  ， 而 RAM &gt; RW-data+ZI-data，具体我们可以查看 KDE 编译后生成的 .map文件。</strong></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/1.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>KDE 生成的 .map 文件分析：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\">Product: MDK-ARM Standard 5.10</div><div class=\"line\">Component: ARM Compiler 5.04 update 1 (build 49)</div><div class=\"line\">Tool: armlink [5040049]</div><div class=\"line\"></div><div class=\"line\">==============================================================================</div><div class=\"line\"></div><div class=\"line\">Section Cross References</div><div class=\"line\"></div><div class=\"line\">    main.o(i.AdjustTask) refers to memseta.o(.text) for __aeabi_memclr4</div><div class=\"line\">    main.o(i.AdjustTask) refers to analogin.o(i.AnalogInConvert) for AnalogInConvert</div><div class=\"line\">\t...</div><div class=\"line\">\t</div><div class=\"line\">==============================================================================</div><div class=\"line\"></div><div class=\"line\">Removing Unused input sections from the image.</div><div class=\"line\"></div><div class=\"line\">    Removing main.o(.data), (1 bytes).</div><div class=\"line\">    Removing main.o(.data), (4 bytes).</div><div class=\"line\">\t...</div><div class=\"line\"></div><div class=\"line\">329 unused section(s) (total 12428 bytes) removed from the image.</div><div class=\"line\"></div><div class=\"line\">==============================================================================</div><div class=\"line\"></div><div class=\"line\">Image Symbol Table</div><div class=\"line\"></div><div class=\"line\">    Local Symbols</div><div class=\"line\"></div><div class=\"line\">    Symbol Name                              Value     Ov Type        Size  Object(Section)</div><div class=\"line\"></div><div class=\"line\">    ../clib/../cmprslib/zerorunl2.c          0x00000000   Number         0  __dczerorl2.o ABSOLUTE</div><div class=\"line\">    ../clib/microlib/division.c              0x00000000   Number         0  uldiv.o ABSOLUTE</div><div class=\"line\">\t...</div><div class=\"line\">\t</div><div class=\"line\">==============================================================================</div><div class=\"line\"></div><div class=\"line\">Memory Map of the image</div><div class=\"line\"></div><div class=\"line\">  Image Entry point : 0x08000131</div><div class=\"line\"></div><div class=\"line\">  Load Region LR_IROM1 (Base: 0x08000000, Size: 0x0001c0c8, Max: 0x00080000, ABSOLUTE, COMPRESSED[0x0001bc94])</div><div class=\"line\"></div><div class=\"line\">    Execution Region ER_IROM1 (Base: 0x08000000, Size: 0x0001baa0, Max: 0x00080000, ABSOLUTE)</div><div class=\"line\"></div><div class=\"line\">    Base Addr    Size         Type   Attr      Idx    E Section Name        Object</div><div class=\"line\"></div><div class=\"line\">    0x08000000   0x00000130   Data   RO         4967    RESET               startup_stm32f10x_hd.o</div><div class=\"line\">    0x08000130   0x00000000   Code   RO         5008  * .ARM.Collect$$$$00000000  mc_w.l(entry.o)</div><div class=\"line\">    0x08000130   0x00000004   Code   RO         5086    .ARM.Collect$$$$00000001  mc_w.l(entry2.o)</div><div class=\"line\">\t...</div><div class=\"line\">\t</div><div class=\"line\">    Execution Region RW_IRAM1 (Base: 0x20000000, Size: 0x0000f050, Max: 0x00010000, ABSOLUTE, COMPRESSED[0x000001f4])</div><div class=\"line\"></div><div class=\"line\">    Base Addr    Size         Type   Attr      Idx    E Section Name        Object</div><div class=\"line\"></div><div class=\"line\">    0x20000000   0x00000038   Data   RW           27    .data               main.o</div><div class=\"line\">    0x20000038   0x00000005   Data   RW          422    .data               analogin.o</div><div class=\"line\">\t...</div><div class=\"line\">\t</div><div class=\"line\">==============================================================================</div><div class=\"line\"></div><div class=\"line\">Image component sizes</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</div><div class=\"line\"></div><div class=\"line\">      1252        138          0          5        200       3550   analogin.o</div><div class=\"line\">       704         74         12         24          0       5534   analogout.o</div><div class=\"line\">\t...</div><div class=\"line\"></div><div class=\"line\">==============================================================================</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   </div><div class=\"line\"></div><div class=\"line\">     80732       6214      32580       1576      59944     659393   Grand Totals</div><div class=\"line\">     80732       6214      32580        500      59944     659393   ELF Image Totals (compressed)</div><div class=\"line\">     80732       6214      32580        500          0          0   ROM Totals</div><div class=\"line\"></div><div class=\"line\">==============================================================================</div><div class=\"line\"></div><div class=\"line\">    Total RO  Size (Code + RO Data)               113312 ( 110.66kB)</div><div class=\"line\">    Total RW  Size (RW Data + ZI Data)             61520 (  60.08kB)</div><div class=\"line\">    Total ROM Size (Code + RO Data + RW Data)     113812 ( 111.14kB)</div><div class=\"line\"></div><div class=\"line\">==============================================================================</div></pre></td></tr></table></figure>\n<p>优化步骤如下：</p>\n<ul>\n<li>project &gt;&gt; Option for Target “**” 打开如图 2界面。选择“target”，勾选上“Use MicroLIB”再编译。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/2.png\" alt=\"\"></p>\n<p><strong>分析：microLIB是缺省的C库，而且microLIB进行了高度优化。如果不勾选“Use MicroLIB”，keil会连接标准C库。所以勾选“Use MicroLIB”会减小code大小。</strong></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/3.png\" alt=\"\"></p>\n<ul>\n<li>project &gt;&gt; Option for Target “**” 打开如界面。选择“C/C++”，勾选上“One ELF Section per Functin”再编译。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/4.png\" alt=\"\"></p>\n<p><strong>分析：“One ELF Section per Functin”就是将每个函数都生成一个ELF文件，最会将需要的函数链接成一个大的ELF文件。但是如果没有勾选“One ELF Section per Functin”。Keil将每个文件编译成一个ELF文件（即使文件中用未被使用的函数），最会链接成一个ELF文件。所以勾选“One ELF Section per Functin”会使code变小。</strong></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/5.png\" alt=\"\"></p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/abclixu123/article/details/46923725\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/abclixu123/article/details/46923725</a><br><a href=\"http://blog.csdn.net/gasbi/article/details/6186312\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/gasbi/article/details/6186312</a></p>\n</blockquote>\n","excerpt":"<h3 id=\"C项目的工程优化\"><a href=\"#C项目的工程优化\" class=\"headerlink\" title=\"C项目的工程优化\"></a>C项目的工程优化</h3><p>这边主要参考另外一篇文章，不仅仅是针对C语言，C++等其他一些类C语言也同样适用。我们在构建自己的项目时，主要需要考虑：宏定义，类型，全局变量等的作用范围，针对头文件的引用和复制是否有存在的必要等。只有对每个细节都了如指掌，才能够减少代码的出错，以及优化代码空间等。就目前的芯片发展而言，很多时候都是硬件性能过剩，大多数程序员已经不再考虑或者极少考虑代码如何优化节省空间等问题了，往往更加注重代码的可阅读可扩展性，这边之所以注重这个问题，主要是考虑到工控节能领域，以及很多使用的模块可能存在代码量不足，不能胜任工作等问题。</p>\n<h3 id=\"keil\"><a href=\"#keil\" class=\"headerlink\" title=\"keil\"></a>keil</h3><p>keil是一款MCU的IDE，有文章介绍过详细配置和调试步骤，这边不再详细累述。因为针对的是MCU的代码优化，所以首先我们必须知道编译器生成的代码量等信息。</p>\n<p>每次点击编译后，下方会出现KEIL RVMDK编译后的信息，例如：Program Size: Code=19160 RO-data=6420 RW-data=108 ZI-data=1532，这边代表我的无任何优化的前提下，keil编译生成的代码为19160个字节。</p>\n<p><strong>Code是代码占用的空间；RO-data(Read Only) 是只读常量的大小，如const型；RW-data（Read Write）是初始化了的可读写变量的大小，ZI-data（Zero Initialize）是没有初始化的可读写变量的大小。ZI-data不会被算做代码里因为不会被初始化。Total ROM Size ：Code + RO Data + RW Data（ROM Size并不等于Code + RO Data，初始化不为零的 RW Data 数据本身也会占用相同大小的 ROM 和 RAM 存储单元，变量在 RAM 中，而变量的初始值存在 ROM 中） ，Total RW  Size：RW Data + ZI Data 。这边在考虑芯片的 ROM 和 RAM 选型时，注意： ROM &gt; Code + RO Data + RW Data  ， 而 RAM &gt; RW-data+ZI-data，具体我们可以查看 KDE 编译后生成的 .map文件。</strong></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/1.png\" alt=\"\"></p>","more":"<p>KDE 生成的 .map 文件分析：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\">Product: MDK-ARM Standard 5.10</div><div class=\"line\">Component: ARM Compiler 5.04 update 1 (build 49)</div><div class=\"line\">Tool: armlink [5040049]</div><div class=\"line\"></div><div class=\"line\">==============================================================================</div><div class=\"line\"></div><div class=\"line\">Section Cross References</div><div class=\"line\"></div><div class=\"line\">    main.o(i.AdjustTask) refers to memseta.o(.text) for __aeabi_memclr4</div><div class=\"line\">    main.o(i.AdjustTask) refers to analogin.o(i.AnalogInConvert) for AnalogInConvert</div><div class=\"line\">\t...</div><div class=\"line\">\t</div><div class=\"line\">==============================================================================</div><div class=\"line\"></div><div class=\"line\">Removing Unused input sections from the image.</div><div class=\"line\"></div><div class=\"line\">    Removing main.o(.data), (1 bytes).</div><div class=\"line\">    Removing main.o(.data), (4 bytes).</div><div class=\"line\">\t...</div><div class=\"line\"></div><div class=\"line\">329 unused section(s) (total 12428 bytes) removed from the image.</div><div class=\"line\"></div><div class=\"line\">==============================================================================</div><div class=\"line\"></div><div class=\"line\">Image Symbol Table</div><div class=\"line\"></div><div class=\"line\">    Local Symbols</div><div class=\"line\"></div><div class=\"line\">    Symbol Name                              Value     Ov Type        Size  Object(Section)</div><div class=\"line\"></div><div class=\"line\">    ../clib/../cmprslib/zerorunl2.c          0x00000000   Number         0  __dczerorl2.o ABSOLUTE</div><div class=\"line\">    ../clib/microlib/division.c              0x00000000   Number         0  uldiv.o ABSOLUTE</div><div class=\"line\">\t...</div><div class=\"line\">\t</div><div class=\"line\">==============================================================================</div><div class=\"line\"></div><div class=\"line\">Memory Map of the image</div><div class=\"line\"></div><div class=\"line\">  Image Entry point : 0x08000131</div><div class=\"line\"></div><div class=\"line\">  Load Region LR_IROM1 (Base: 0x08000000, Size: 0x0001c0c8, Max: 0x00080000, ABSOLUTE, COMPRESSED[0x0001bc94])</div><div class=\"line\"></div><div class=\"line\">    Execution Region ER_IROM1 (Base: 0x08000000, Size: 0x0001baa0, Max: 0x00080000, ABSOLUTE)</div><div class=\"line\"></div><div class=\"line\">    Base Addr    Size         Type   Attr      Idx    E Section Name        Object</div><div class=\"line\"></div><div class=\"line\">    0x08000000   0x00000130   Data   RO         4967    RESET               startup_stm32f10x_hd.o</div><div class=\"line\">    0x08000130   0x00000000   Code   RO         5008  * .ARM.Collect$$$$00000000  mc_w.l(entry.o)</div><div class=\"line\">    0x08000130   0x00000004   Code   RO         5086    .ARM.Collect$$$$00000001  mc_w.l(entry2.o)</div><div class=\"line\">\t...</div><div class=\"line\">\t</div><div class=\"line\">    Execution Region RW_IRAM1 (Base: 0x20000000, Size: 0x0000f050, Max: 0x00010000, ABSOLUTE, COMPRESSED[0x000001f4])</div><div class=\"line\"></div><div class=\"line\">    Base Addr    Size         Type   Attr      Idx    E Section Name        Object</div><div class=\"line\"></div><div class=\"line\">    0x20000000   0x00000038   Data   RW           27    .data               main.o</div><div class=\"line\">    0x20000038   0x00000005   Data   RW          422    .data               analogin.o</div><div class=\"line\">\t...</div><div class=\"line\">\t</div><div class=\"line\">==============================================================================</div><div class=\"line\"></div><div class=\"line\">Image component sizes</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</div><div class=\"line\"></div><div class=\"line\">      1252        138          0          5        200       3550   analogin.o</div><div class=\"line\">       704         74         12         24          0       5534   analogout.o</div><div class=\"line\">\t...</div><div class=\"line\"></div><div class=\"line\">==============================================================================</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   </div><div class=\"line\"></div><div class=\"line\">     80732       6214      32580       1576      59944     659393   Grand Totals</div><div class=\"line\">     80732       6214      32580        500      59944     659393   ELF Image Totals (compressed)</div><div class=\"line\">     80732       6214      32580        500          0          0   ROM Totals</div><div class=\"line\"></div><div class=\"line\">==============================================================================</div><div class=\"line\"></div><div class=\"line\">    Total RO  Size (Code + RO Data)               113312 ( 110.66kB)</div><div class=\"line\">    Total RW  Size (RW Data + ZI Data)             61520 (  60.08kB)</div><div class=\"line\">    Total ROM Size (Code + RO Data + RW Data)     113812 ( 111.14kB)</div><div class=\"line\"></div><div class=\"line\">==============================================================================</div></pre></td></tr></table></figure>\n<p>优化步骤如下：</p>\n<ul>\n<li>project &gt;&gt; Option for Target “**” 打开如图 2界面。选择“target”，勾选上“Use MicroLIB”再编译。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/2.png\" alt=\"\"></p>\n<p><strong>分析：microLIB是缺省的C库，而且microLIB进行了高度优化。如果不勾选“Use MicroLIB”，keil会连接标准C库。所以勾选“Use MicroLIB”会减小code大小。</strong></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/3.png\" alt=\"\"></p>\n<ul>\n<li>project &gt;&gt; Option for Target “**” 打开如界面。选择“C/C++”，勾选上“One ELF Section per Functin”再编译。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/4.png\" alt=\"\"></p>\n<p><strong>分析：“One ELF Section per Functin”就是将每个函数都生成一个ELF文件，最会将需要的函数链接成一个大的ELF文件。但是如果没有勾选“One ELF Section per Functin”。Keil将每个文件编译成一个ELF文件（即使文件中用未被使用的函数），最会链接成一个ELF文件。所以勾选“One ELF Section per Functin”会使code变小。</strong></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/5.png\" alt=\"\"></p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/abclixu123/article/details/46923725\">http://blog.csdn.net/abclixu123/article/details/46923725</a><br><a href=\"http://blog.csdn.net/gasbi/article/details/6186312\">http://blog.csdn.net/gasbi/article/details/6186312</a></p>\n</blockquote>"},{"layout":"post","title":"CRC校验","date":"2016-11-22T01:23:00.000Z","_content":"\n### 简介\n\n### 原理规则\n\n<!-- more -->\n\n\n\n### 参考案例\n\n### 扩展\n\n\n\n\n> 参考链接：\n> http://wenku.baidu.com/link?url=FLbB1d-cPj5uuxsaORgTaLYDUcEwziU4VFE3dHzIxv_2UNwvBiBAo4_n5D2n9zbmgM3kJMJHKOptYbd6bJd21sHtDIOLysViDIHcHN5UpgK\n> http://wenku.baidu.com/link?url=_jgyTFPUC5EdnDykoVR-hbtutdNnZjgOhlbHaJ0Ipcy04SZiLHCaUY2zTyiZjn4WpNPxQZUDtBXJD5Z1K56EUffQ7nk3qM5lxH0ux9Qz7OS\n> http://blog.csdn.net/husion01/article/details/17440333\n","source":"_posts/2016/2016-11-22-crc校验.md","raw":"---\nlayout: \"post\"\ntitle: \"CRC校验\"\ndate: \"2016-11-22 09:23\"\n---\n\n### 简介\n\n### 原理规则\n\n<!-- more -->\n\n\n\n### 参考案例\n\n### 扩展\n\n\n\n\n> 参考链接：\n> http://wenku.baidu.com/link?url=FLbB1d-cPj5uuxsaORgTaLYDUcEwziU4VFE3dHzIxv_2UNwvBiBAo4_n5D2n9zbmgM3kJMJHKOptYbd6bJd21sHtDIOLysViDIHcHN5UpgK\n> http://wenku.baidu.com/link?url=_jgyTFPUC5EdnDykoVR-hbtutdNnZjgOhlbHaJ0Ipcy04SZiLHCaUY2zTyiZjn4WpNPxQZUDtBXJD5Z1K56EUffQ7nk3qM5lxH0ux9Qz7OS\n> http://blog.csdn.net/husion01/article/details/17440333\n","slug":"2016/2016-11-22-crc校验","published":1,"updated":"2016-12-16T01:51:29.916Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aix003gmumu6zid6pbn","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><h3 id=\"原理规则\"><a href=\"#原理规则\" class=\"headerlink\" title=\"原理规则\"></a>原理规则</h3><a id=\"more\"></a>\n<h3 id=\"参考案例\"><a href=\"#参考案例\" class=\"headerlink\" title=\"参考案例\"></a>参考案例</h3><h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><blockquote>\n<p>参考链接：<br><a href=\"http://wenku.baidu.com/link?url=FLbB1d-cPj5uuxsaORgTaLYDUcEwziU4VFE3dHzIxv_2UNwvBiBAo4_n5D2n9zbmgM3kJMJHKOptYbd6bJd21sHtDIOLysViDIHcHN5UpgK\" target=\"_blank\" rel=\"external\">http://wenku.baidu.com/link?url=FLbB1d-cPj5uuxsaORgTaLYDUcEwziU4VFE3dHzIxv_2UNwvBiBAo4_n5D2n9zbmgM3kJMJHKOptYbd6bJd21sHtDIOLysViDIHcHN5UpgK</a><br><a href=\"http://wenku.baidu.com/link?url=_jgyTFPUC5EdnDykoVR-hbtutdNnZjgOhlbHaJ0Ipcy04SZiLHCaUY2zTyiZjn4WpNPxQZUDtBXJD5Z1K56EUffQ7nk3qM5lxH0ux9Qz7OS\" target=\"_blank\" rel=\"external\">http://wenku.baidu.com/link?url=_jgyTFPUC5EdnDykoVR-hbtutdNnZjgOhlbHaJ0Ipcy04SZiLHCaUY2zTyiZjn4WpNPxQZUDtBXJD5Z1K56EUffQ7nk3qM5lxH0ux9Qz7OS</a><br><a href=\"http://blog.csdn.net/husion01/article/details/17440333\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/husion01/article/details/17440333</a></p>\n</blockquote>\n","excerpt":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><h3 id=\"原理规则\"><a href=\"#原理规则\" class=\"headerlink\" title=\"原理规则\"></a>原理规则</h3>","more":"<h3 id=\"参考案例\"><a href=\"#参考案例\" class=\"headerlink\" title=\"参考案例\"></a>参考案例</h3><h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><blockquote>\n<p>参考链接：<br><a href=\"http://wenku.baidu.com/link?url=FLbB1d-cPj5uuxsaORgTaLYDUcEwziU4VFE3dHzIxv_2UNwvBiBAo4_n5D2n9zbmgM3kJMJHKOptYbd6bJd21sHtDIOLysViDIHcHN5UpgK\">http://wenku.baidu.com/link?url=FLbB1d-cPj5uuxsaORgTaLYDUcEwziU4VFE3dHzIxv_2UNwvBiBAo4_n5D2n9zbmgM3kJMJHKOptYbd6bJd21sHtDIOLysViDIHcHN5UpgK</a><br><a href=\"http://wenku.baidu.com/link?url=_jgyTFPUC5EdnDykoVR-hbtutdNnZjgOhlbHaJ0Ipcy04SZiLHCaUY2zTyiZjn4WpNPxQZUDtBXJD5Z1K56EUffQ7nk3qM5lxH0ux9Qz7OS\">http://wenku.baidu.com/link?url=_jgyTFPUC5EdnDykoVR-hbtutdNnZjgOhlbHaJ0Ipcy04SZiLHCaUY2zTyiZjn4WpNPxQZUDtBXJD5Z1K56EUffQ7nk3qM5lxH0ux9Qz7OS</a><br><a href=\"http://blog.csdn.net/husion01/article/details/17440333\">http://blog.csdn.net/husion01/article/details/17440333</a></p>\n</blockquote>"},{"layout":"post","title":"git submodule 详解","date":"2016-11-23T01:02:00.000Z","_content":"\n使用 git 也有一段时间，但不得不说 git 的功能相当强大和复杂，需要你不断的去摸索学习。这边介绍一个 git 很强大的功能：git submodule 。起初发现这个文件是在我本人 fork 了一个 awesome 的配置文件，用了也蛮久，但最近由于总是出现连接错误，然后手动去更改了一些文件，但意外发现更改的文件无法提交， status 中竟然没有这些文件的信息，另外通过其他官方文档 gitignore 中的几个 ignore 中仔细查看，很确定项目中并没有忽略这些文件，通过排查最后才发现是 .gitmodules 这个文件捣的鬼。仔细研究发现git-submodule是一个十分强大的功能，值得去学习研究。\n\n\n<!-- more -->\n\n\n\n> 参考链接：\n> http://www.kafeitu.me/git/2012/03/27/git-submodule.html\n> https://git-scm.com/docs/git-submodule\n> https://git-scm.com/docs/git-config\n> https://git-scm.com/docs/gitignore\n","source":"_posts/2016/2016-11-23-git-submodule-详解.md","raw":"---\nlayout: \"post\"\ntitle: \"git submodule 详解\"\ndate: \"2016-11-23 09:02\"\n---\n\n使用 git 也有一段时间，但不得不说 git 的功能相当强大和复杂，需要你不断的去摸索学习。这边介绍一个 git 很强大的功能：git submodule 。起初发现这个文件是在我本人 fork 了一个 awesome 的配置文件，用了也蛮久，但最近由于总是出现连接错误，然后手动去更改了一些文件，但意外发现更改的文件无法提交， status 中竟然没有这些文件的信息，另外通过其他官方文档 gitignore 中的几个 ignore 中仔细查看，很确定项目中并没有忽略这些文件，通过排查最后才发现是 .gitmodules 这个文件捣的鬼。仔细研究发现git-submodule是一个十分强大的功能，值得去学习研究。\n\n\n<!-- more -->\n\n\n\n> 参考链接：\n> http://www.kafeitu.me/git/2012/03/27/git-submodule.html\n> https://git-scm.com/docs/git-submodule\n> https://git-scm.com/docs/git-config\n> https://git-scm.com/docs/gitignore\n","slug":"2016/2016-11-23-git-submodule-详解","published":1,"updated":"2016-12-16T01:51:27.128Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aix003hmumuakfmggds","content":"<p>使用 git 也有一段时间，但不得不说 git 的功能相当强大和复杂，需要你不断的去摸索学习。这边介绍一个 git 很强大的功能：git submodule 。起初发现这个文件是在我本人 fork 了一个 awesome 的配置文件，用了也蛮久，但最近由于总是出现连接错误，然后手动去更改了一些文件，但意外发现更改的文件无法提交， status 中竟然没有这些文件的信息，另外通过其他官方文档 gitignore 中的几个 ignore 中仔细查看，很确定项目中并没有忽略这些文件，通过排查最后才发现是 .gitmodules 这个文件捣的鬼。仔细研究发现git-submodule是一个十分强大的功能，值得去学习研究。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.kafeitu.me/git/2012/03/27/git-submodule.html\" target=\"_blank\" rel=\"external\">http://www.kafeitu.me/git/2012/03/27/git-submodule.html</a><br><a href=\"https://git-scm.com/docs/git-submodule\" target=\"_blank\" rel=\"external\">https://git-scm.com/docs/git-submodule</a><br><a href=\"https://git-scm.com/docs/git-config\" target=\"_blank\" rel=\"external\">https://git-scm.com/docs/git-config</a><br><a href=\"https://git-scm.com/docs/gitignore\" target=\"_blank\" rel=\"external\">https://git-scm.com/docs/gitignore</a></p>\n</blockquote>\n","excerpt":"<p>使用 git 也有一段时间，但不得不说 git 的功能相当强大和复杂，需要你不断的去摸索学习。这边介绍一个 git 很强大的功能：git submodule 。起初发现这个文件是在我本人 fork 了一个 awesome 的配置文件，用了也蛮久，但最近由于总是出现连接错误，然后手动去更改了一些文件，但意外发现更改的文件无法提交， status 中竟然没有这些文件的信息，另外通过其他官方文档 gitignore 中的几个 ignore 中仔细查看，很确定项目中并没有忽略这些文件，通过排查最后才发现是 .gitmodules 这个文件捣的鬼。仔细研究发现git-submodule是一个十分强大的功能，值得去学习研究。</p>","more":"<blockquote>\n<p>参考链接：<br><a href=\"http://www.kafeitu.me/git/2012/03/27/git-submodule.html\">http://www.kafeitu.me/git/2012/03/27/git-submodule.html</a><br><a href=\"https://git-scm.com/docs/git-submodule\">https://git-scm.com/docs/git-submodule</a><br><a href=\"https://git-scm.com/docs/git-config\">https://git-scm.com/docs/git-config</a><br><a href=\"https://git-scm.com/docs/gitignore\">https://git-scm.com/docs/gitignore</a></p>\n</blockquote>"},{"layout":"post","title":"检测VPS虚拟化技术","date":"2016-11-26T08:51:00.000Z","_content":"\n很多时候，我们需要知道自己的 VPS 是通过什么软件进行分配的，这是可以使用如下的几种方式：\n\n### 方法1：\n\n使用如下命令运行\n\n`wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/code/master/vm_check.sh && bash vm_check.sh`\n\n代码运行结束就会在最后一行显示虚拟化技术：kvm还是openv或者是xen一目了然。\n\n```\n...\n...\nmake[1]: Leaving directory `/root/virt-what-1.12'\nopenvz\nkvm\n```\n\n<!-- more -->\n\n\n如上述内容，看末尾显示如果是：openvz 和 kvm 表示经过了 openvz 和 kvm 两层虚拟化最后构建了你所用的 VPS 。\n\n\n### 方法2：\n\n这种方法是后来看到的，方法更为简单:\n- apt-get install virt-what\n- 直接执行 virt-what 这个脚本，就会报告结果，例如：\n\n```\nroot@a118:~# virt-what \nopenvz\nkvm\n```\n\n\n> 参考地址：\n> https://www.91yun.org/zh/archives/836\n","source":"_posts/2016/2016-11-26-检测VPS虚拟化技术.md","raw":"---\nlayout: \"post\"\ntitle: \"检测VPS虚拟化技术\"\ndate: \"2016-11-26 16:51\"\n---\n\n很多时候，我们需要知道自己的 VPS 是通过什么软件进行分配的，这是可以使用如下的几种方式：\n\n### 方法1：\n\n使用如下命令运行\n\n`wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/code/master/vm_check.sh && bash vm_check.sh`\n\n代码运行结束就会在最后一行显示虚拟化技术：kvm还是openv或者是xen一目了然。\n\n```\n...\n...\nmake[1]: Leaving directory `/root/virt-what-1.12'\nopenvz\nkvm\n```\n\n<!-- more -->\n\n\n如上述内容，看末尾显示如果是：openvz 和 kvm 表示经过了 openvz 和 kvm 两层虚拟化最后构建了你所用的 VPS 。\n\n\n### 方法2：\n\n这种方法是后来看到的，方法更为简单:\n- apt-get install virt-what\n- 直接执行 virt-what 这个脚本，就会报告结果，例如：\n\n```\nroot@a118:~# virt-what \nopenvz\nkvm\n```\n\n\n> 参考地址：\n> https://www.91yun.org/zh/archives/836\n","slug":"2016/2016-11-26-检测VPS虚拟化技术","published":1,"updated":"2016-12-22T13:07:08.439Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aiy003imumu6gox51q9","content":"<p>很多时候，我们需要知道自己的 VPS 是通过什么软件进行分配的，这是可以使用如下的几种方式：</p>\n<h3 id=\"方法1：\"><a href=\"#方法1：\" class=\"headerlink\" title=\"方法1：\"></a>方法1：</h3><p>使用如下命令运行</p>\n<p><code>wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/code/master/vm_check.sh &amp;&amp; bash vm_check.sh</code></p>\n<p>代码运行结束就会在最后一行显示虚拟化技术：kvm还是openv或者是xen一目了然。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">...</div><div class=\"line\">make[1]: Leaving directory `/root/virt-what-1.12&apos;</div><div class=\"line\">openvz</div><div class=\"line\">kvm</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>如上述内容，看末尾显示如果是：openvz 和 kvm 表示经过了 openvz 和 kvm 两层虚拟化最后构建了你所用的 VPS 。</p>\n<h3 id=\"方法2：\"><a href=\"#方法2：\" class=\"headerlink\" title=\"方法2：\"></a>方法2：</h3><p>这种方法是后来看到的，方法更为简单:</p>\n<ul>\n<li>apt-get install virt-what</li>\n<li>直接执行 virt-what 这个脚本，就会报告结果，例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@a118:~# virt-what </div><div class=\"line\">openvz</div><div class=\"line\">kvm</div></pre></td></tr></table></figure>\n<blockquote>\n<p>参考地址：<br><a href=\"https://www.91yun.org/zh/archives/836\" target=\"_blank\" rel=\"external\">https://www.91yun.org/zh/archives/836</a></p>\n</blockquote>\n","excerpt":"<p>很多时候，我们需要知道自己的 VPS 是通过什么软件进行分配的，这是可以使用如下的几种方式：</p>\n<h3 id=\"方法1：\"><a href=\"#方法1：\" class=\"headerlink\" title=\"方法1：\"></a>方法1：</h3><p>使用如下命令运行</p>\n<p><code>wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/code/master/vm_check.sh &amp;&amp; bash vm_check.sh</code></p>\n<p>代码运行结束就会在最后一行显示虚拟化技术：kvm还是openv或者是xen一目了然。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">...</div><div class=\"line\">make[1]: Leaving directory `/root/virt-what-1.12&apos;</div><div class=\"line\">openvz</div><div class=\"line\">kvm</div></pre></td></tr></table></figure>","more":"<p>如上述内容，看末尾显示如果是：openvz 和 kvm 表示经过了 openvz 和 kvm 两层虚拟化最后构建了你所用的 VPS 。</p>\n<h3 id=\"方法2：\"><a href=\"#方法2：\" class=\"headerlink\" title=\"方法2：\"></a>方法2：</h3><p>这种方法是后来看到的，方法更为简单:</p>\n<ul>\n<li>apt-get install virt-what</li>\n<li>直接执行 virt-what 这个脚本，就会报告结果，例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@a118:~# virt-what </div><div class=\"line\">openvz</div><div class=\"line\">kvm</div></pre></td></tr></table></figure>\n<blockquote>\n<p>参考地址：<br><a href=\"https://www.91yun.org/zh/archives/836\">https://www.91yun.org/zh/archives/836</a></p>\n</blockquote>"},{"layout":"post","title":"vps-docker","date":"2016-11-28T05:21:00.000Z","_content":"\n\n<!-- more -->\n","source":"_posts/2016/2016-11-28-vps-docker.md","raw":"---\nlayout: \"post\"\ntitle: \"vps-docker\"\ndate: \"2016-11-28 13:21\"\n---\n\n\n<!-- more -->\n","slug":"2016/2016-11-28-vps-docker","published":1,"updated":"2016-12-16T01:51:10.240Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aiz003jmumu38o4y46c","content":"<a id=\"more\"></a>\n","excerpt":"","more":""},{"layout":"post","title":"(转)虚拟主机、VPS和云主机","date":"2016-11-23T13:03:00.000Z","_content":"\n> 转载链接：http://www.chinaz.com/prime/2012/1021/279069.shtml\n\n\n云计算时代，云主机其可扩展性、价格便宜、安全可靠的特性深受企业和开发者欢迎，但目前有些IDC企业，新瓶装旧酒，将虚拟主机、VPS进行包装推出所谓的云主机服务，为了帮助用户更好的辨别和挑选云主机，下文详细介绍虚拟主机、VPS和云主机产品的特点以及差异性。\n\n### 一、虚拟主机、VPS和云主机\n\n共享主机也称虚拟主机，从互联网诞生至今，大部分站长都是从”共享主机”(shared hosting)开始学习建站的。所谓”共享主机”，就是一台服务器上有许多网站，大家共享这台服务器的硬件和带宽。如果它发生故障，那么上面的所有网站都无法访问。\n\nVPS主机(Virtual Private Server 虚拟专用服务器)，将一部服务器分割成多个虚拟专享服务器的优质服务。每个VPS都可分配独立公网IP地址、独立操作系统、独立超大空间、独立内存、独立CPU资源、独立执行程序和独立系统配置等。用户除了可以分配多个虚拟主机及无限企业邮箱外，更具有独立服务器功能，可自行安装程序，单独重启服务器。\n\n”云主机”(Cloud hosting)可以看成是新一代的共享主机。\n\n首先，主机公司将它的硬件和网络线路，做成一朵”云”，然后提供一些通向这朵”云”的网络接口API，供客户使用。这时，每个客户共享的不再是某一台特定的服务器，而是云里的所有服务器。\n\n比如，假设你要把本机的文件备份到网上，你可以使用共享主机，把文件传到某一台服务器上;也可以使用云主机，通过某种形式的接口，把它们传到云里。也就是说，共享主机用户直接面对特定的服务器，而云主机用户直接面对网络接口，看不到服务器内部。\n\n一个通俗的比喻是，你可以向银行租一个编号为”8888″的保险箱(共享主机)，也可以把贵重物品直接交给保管公司，听任他们保管。\n\n诸如Gmail、FaceBook、Twitter、Flickr这样的产品，都可以看作是基于”云主机”的服务。\n\n云主机能真正获得root权限，用户可以重装和升级操作系统，而VPS主机用户没有root权限，无法重装和升级操作系统。\n\n<!-- more -->\n\n\n### 二、虚拟主机、VPS、云主机的区别\n\n#### 供应和部署时间\n\n虚拟主机——数天至数周\n\nVPS———即时，无需安装操作系统\n\n云主机——即时，几分钟即可完成，可一键部署、也可自主安装操作系统\n\n#### 安全可靠性\n\n虚拟主机——一般：租用白牌服务器故障率高、基本无ARP、木马和DDOS防范能力、基本无备机和数据备份服务\n\nVPS———差：同一台物理服务器上其他VPS上安装的程序缺陷、ARP欺骗、病毒、资源挤占等会严重影响到自身;基本无ARP、木马和DDOS防范能力\n\n云主机——高：内置ARP防范，规模化提升DDOS防攻击能力;分享品牌企业级服务器和硬件虚拟化的性能和可靠性，内置HA;提供备机、快照、数据备份等多种快速恢复措施\n\n#### 性能及保障\n\n虚拟主机——好且有保障\n\nVPS———差：性能一般，只适用于小规模并发访问;性能无保障，易遭受同一台物理服务器上其他VPS的挤压\n\n云主机——好且有保障：同物理服务器\n\n#### 弹性和扩展性\n\n虚拟主机——扩容需要重新租用新服务器、还需为原有租用资源付费\n\nVPS———扩容快，受制于单台服务器配置\n\n云主机——即时供应、按需扩展 ，无需为原有租用资源付费\n\n#### 拥有成本\n\n虚拟主机——季付年付成本高、需要为服务商转嫁CapEx支出支付押金;需要自己维护租用的服务器导致Opex较高\n\nVPS———低配置的VPS租用价格最低;但低安全可靠性和无保障的性能导致服务质量无保障，运营成本难控制且偏高\n\n云主机——综合成本最低：月付无押金、按需使用按需付费、基本零维护 ，还可分享规模化、绿色节能、最佳IT实践带来的成本优势\n\n#### 易用、易管理性\n\n虚拟主机——需要远程控制卡且只有租用品牌机才有可能，无法实现集中统一管理\n\nVPS———提供单一的单机管理界面，无root或超级管理员操作系统权限，管理灵活性受制于管理界面\n\n云主机——内置KVM、客户通过自服务系统可以集中统一管理分布在各地的云主机;完全拥有root或超级管理员操作系统权限\n\n### 三、云主机的优点\n\n云主机主要有三大优点。\n\n- 便宜:因为服务可以分散到多台服务器，因此能够充分利用资源，这样就降低了硬件、电力和维护成本。而且，云主机是根据使用量计费的，多用多付，少用少付，所以对小网站特别有利。\n\n- 可靠:因为服务分布在多台服务器、甚至多个机房，所以不容易彻底宕机，抗灾容错能力强，可以保证长时间在线。\n\n- 可扩展性好(scalability):云主机的基本特点就是分布式架构，所以可以轻而易举地增加服务器，成倍扩展服务能力。\n\n### 四、云主机的缺点\n\n一些客户担心云主机的安全问题，感到对服务缺乏控制。\n\n因为云主机只是提供网络接口，所以客户的数据必然全部服从云服务公司的安排，完全在后者控制之下。数据是否安全保密，取决于后者的职业道德和保护能力。\n\n但是，这其实是一个”伪问题”，因为绝大多数情况下，云服务公司会比客户更在乎、也更善于保护数据。Paul Graham在《黑客与画家》一书中，就谈过这一点：\n\n”反对者往往觉得我们的产品不安全，如果员工可以很容易地登录，那么坏人也可以很容易地登录。一些大公司觉得不能把客户的信用卡资料交给我们，而是放在自己的服务器上更安全。……但是事实上，他们的服务器就是没我们的安全，我们对数据的保护几乎肯定比他们好。\n\n想想看，谁能雇到更高水平的网络安全专家，是一个所有业务就是管理服务器的技术型创业公司，还是一家服装零售商？……而且我们比他们更关心数据的安全。如果一家服装零售商的服务器被入侵，最多只影响到这家公司本身，这件事也很可能在公司内部被掩盖起来，最严重的情况下可能还会有一个员工被解雇。但是，如果我们的服务器被入侵，就有成千上万家公司可能受到影响，这件事也许还会被当作新闻，发表在业内网站上面，使得我们生意做不下去，不得不关门歇业。\n\n如果你想把钱藏在安全的地方，请问你是选择家中床垫下面，还是选择银行？这个比喻对服务器管理的方方面面都适用，不仅是安全性，还包括正常运行时间、带宽、负载管理、备份等等，都是我们占优。”\n","source":"_posts/2016/2016-11-23-转-虚拟主机、vps和云主机.md","raw":"---\nlayout: \"post\"\ntitle: \"(转)虚拟主机、VPS和云主机\"\ndate: \"2016-11-23 21:03\"\n---\n\n> 转载链接：http://www.chinaz.com/prime/2012/1021/279069.shtml\n\n\n云计算时代，云主机其可扩展性、价格便宜、安全可靠的特性深受企业和开发者欢迎，但目前有些IDC企业，新瓶装旧酒，将虚拟主机、VPS进行包装推出所谓的云主机服务，为了帮助用户更好的辨别和挑选云主机，下文详细介绍虚拟主机、VPS和云主机产品的特点以及差异性。\n\n### 一、虚拟主机、VPS和云主机\n\n共享主机也称虚拟主机，从互联网诞生至今，大部分站长都是从”共享主机”(shared hosting)开始学习建站的。所谓”共享主机”，就是一台服务器上有许多网站，大家共享这台服务器的硬件和带宽。如果它发生故障，那么上面的所有网站都无法访问。\n\nVPS主机(Virtual Private Server 虚拟专用服务器)，将一部服务器分割成多个虚拟专享服务器的优质服务。每个VPS都可分配独立公网IP地址、独立操作系统、独立超大空间、独立内存、独立CPU资源、独立执行程序和独立系统配置等。用户除了可以分配多个虚拟主机及无限企业邮箱外，更具有独立服务器功能，可自行安装程序，单独重启服务器。\n\n”云主机”(Cloud hosting)可以看成是新一代的共享主机。\n\n首先，主机公司将它的硬件和网络线路，做成一朵”云”，然后提供一些通向这朵”云”的网络接口API，供客户使用。这时，每个客户共享的不再是某一台特定的服务器，而是云里的所有服务器。\n\n比如，假设你要把本机的文件备份到网上，你可以使用共享主机，把文件传到某一台服务器上;也可以使用云主机，通过某种形式的接口，把它们传到云里。也就是说，共享主机用户直接面对特定的服务器，而云主机用户直接面对网络接口，看不到服务器内部。\n\n一个通俗的比喻是，你可以向银行租一个编号为”8888″的保险箱(共享主机)，也可以把贵重物品直接交给保管公司，听任他们保管。\n\n诸如Gmail、FaceBook、Twitter、Flickr这样的产品，都可以看作是基于”云主机”的服务。\n\n云主机能真正获得root权限，用户可以重装和升级操作系统，而VPS主机用户没有root权限，无法重装和升级操作系统。\n\n<!-- more -->\n\n\n### 二、虚拟主机、VPS、云主机的区别\n\n#### 供应和部署时间\n\n虚拟主机——数天至数周\n\nVPS———即时，无需安装操作系统\n\n云主机——即时，几分钟即可完成，可一键部署、也可自主安装操作系统\n\n#### 安全可靠性\n\n虚拟主机——一般：租用白牌服务器故障率高、基本无ARP、木马和DDOS防范能力、基本无备机和数据备份服务\n\nVPS———差：同一台物理服务器上其他VPS上安装的程序缺陷、ARP欺骗、病毒、资源挤占等会严重影响到自身;基本无ARP、木马和DDOS防范能力\n\n云主机——高：内置ARP防范，规模化提升DDOS防攻击能力;分享品牌企业级服务器和硬件虚拟化的性能和可靠性，内置HA;提供备机、快照、数据备份等多种快速恢复措施\n\n#### 性能及保障\n\n虚拟主机——好且有保障\n\nVPS———差：性能一般，只适用于小规模并发访问;性能无保障，易遭受同一台物理服务器上其他VPS的挤压\n\n云主机——好且有保障：同物理服务器\n\n#### 弹性和扩展性\n\n虚拟主机——扩容需要重新租用新服务器、还需为原有租用资源付费\n\nVPS———扩容快，受制于单台服务器配置\n\n云主机——即时供应、按需扩展 ，无需为原有租用资源付费\n\n#### 拥有成本\n\n虚拟主机——季付年付成本高、需要为服务商转嫁CapEx支出支付押金;需要自己维护租用的服务器导致Opex较高\n\nVPS———低配置的VPS租用价格最低;但低安全可靠性和无保障的性能导致服务质量无保障，运营成本难控制且偏高\n\n云主机——综合成本最低：月付无押金、按需使用按需付费、基本零维护 ，还可分享规模化、绿色节能、最佳IT实践带来的成本优势\n\n#### 易用、易管理性\n\n虚拟主机——需要远程控制卡且只有租用品牌机才有可能，无法实现集中统一管理\n\nVPS———提供单一的单机管理界面，无root或超级管理员操作系统权限，管理灵活性受制于管理界面\n\n云主机——内置KVM、客户通过自服务系统可以集中统一管理分布在各地的云主机;完全拥有root或超级管理员操作系统权限\n\n### 三、云主机的优点\n\n云主机主要有三大优点。\n\n- 便宜:因为服务可以分散到多台服务器，因此能够充分利用资源，这样就降低了硬件、电力和维护成本。而且，云主机是根据使用量计费的，多用多付，少用少付，所以对小网站特别有利。\n\n- 可靠:因为服务分布在多台服务器、甚至多个机房，所以不容易彻底宕机，抗灾容错能力强，可以保证长时间在线。\n\n- 可扩展性好(scalability):云主机的基本特点就是分布式架构，所以可以轻而易举地增加服务器，成倍扩展服务能力。\n\n### 四、云主机的缺点\n\n一些客户担心云主机的安全问题，感到对服务缺乏控制。\n\n因为云主机只是提供网络接口，所以客户的数据必然全部服从云服务公司的安排，完全在后者控制之下。数据是否安全保密，取决于后者的职业道德和保护能力。\n\n但是，这其实是一个”伪问题”，因为绝大多数情况下，云服务公司会比客户更在乎、也更善于保护数据。Paul Graham在《黑客与画家》一书中，就谈过这一点：\n\n”反对者往往觉得我们的产品不安全，如果员工可以很容易地登录，那么坏人也可以很容易地登录。一些大公司觉得不能把客户的信用卡资料交给我们，而是放在自己的服务器上更安全。……但是事实上，他们的服务器就是没我们的安全，我们对数据的保护几乎肯定比他们好。\n\n想想看，谁能雇到更高水平的网络安全专家，是一个所有业务就是管理服务器的技术型创业公司，还是一家服装零售商？……而且我们比他们更关心数据的安全。如果一家服装零售商的服务器被入侵，最多只影响到这家公司本身，这件事也很可能在公司内部被掩盖起来，最严重的情况下可能还会有一个员工被解雇。但是，如果我们的服务器被入侵，就有成千上万家公司可能受到影响，这件事也许还会被当作新闻，发表在业内网站上面，使得我们生意做不下去，不得不关门歇业。\n\n如果你想把钱藏在安全的地方，请问你是选择家中床垫下面，还是选择银行？这个比喻对服务器管理的方方面面都适用，不仅是安全性，还包括正常运行时间、带宽、负载管理、备份等等，都是我们占优。”\n","slug":"2016/2016-11-23-转-虚拟主机、vps和云主机","published":1,"updated":"2016-12-16T01:51:25.100Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aj0003kmumudkkv9xfi","content":"<blockquote>\n<p>转载链接：<a href=\"http://www.chinaz.com/prime/2012/1021/279069.shtml\" target=\"_blank\" rel=\"external\">http://www.chinaz.com/prime/2012/1021/279069.shtml</a></p>\n</blockquote>\n<p>云计算时代，云主机其可扩展性、价格便宜、安全可靠的特性深受企业和开发者欢迎，但目前有些IDC企业，新瓶装旧酒，将虚拟主机、VPS进行包装推出所谓的云主机服务，为了帮助用户更好的辨别和挑选云主机，下文详细介绍虚拟主机、VPS和云主机产品的特点以及差异性。</p>\n<h3 id=\"一、虚拟主机、VPS和云主机\"><a href=\"#一、虚拟主机、VPS和云主机\" class=\"headerlink\" title=\"一、虚拟主机、VPS和云主机\"></a>一、虚拟主机、VPS和云主机</h3><p>共享主机也称虚拟主机，从互联网诞生至今，大部分站长都是从”共享主机”(shared hosting)开始学习建站的。所谓”共享主机”，就是一台服务器上有许多网站，大家共享这台服务器的硬件和带宽。如果它发生故障，那么上面的所有网站都无法访问。</p>\n<p>VPS主机(Virtual Private Server 虚拟专用服务器)，将一部服务器分割成多个虚拟专享服务器的优质服务。每个VPS都可分配独立公网IP地址、独立操作系统、独立超大空间、独立内存、独立CPU资源、独立执行程序和独立系统配置等。用户除了可以分配多个虚拟主机及无限企业邮箱外，更具有独立服务器功能，可自行安装程序，单独重启服务器。</p>\n<p>”云主机”(Cloud hosting)可以看成是新一代的共享主机。</p>\n<p>首先，主机公司将它的硬件和网络线路，做成一朵”云”，然后提供一些通向这朵”云”的网络接口API，供客户使用。这时，每个客户共享的不再是某一台特定的服务器，而是云里的所有服务器。</p>\n<p>比如，假设你要把本机的文件备份到网上，你可以使用共享主机，把文件传到某一台服务器上;也可以使用云主机，通过某种形式的接口，把它们传到云里。也就是说，共享主机用户直接面对特定的服务器，而云主机用户直接面对网络接口，看不到服务器内部。</p>\n<p>一个通俗的比喻是，你可以向银行租一个编号为”8888″的保险箱(共享主机)，也可以把贵重物品直接交给保管公司，听任他们保管。</p>\n<p>诸如Gmail、FaceBook、Twitter、Flickr这样的产品，都可以看作是基于”云主机”的服务。</p>\n<p>云主机能真正获得root权限，用户可以重装和升级操作系统，而VPS主机用户没有root权限，无法重装和升级操作系统。</p>\n<a id=\"more\"></a>\n<h3 id=\"二、虚拟主机、VPS、云主机的区别\"><a href=\"#二、虚拟主机、VPS、云主机的区别\" class=\"headerlink\" title=\"二、虚拟主机、VPS、云主机的区别\"></a>二、虚拟主机、VPS、云主机的区别</h3><h4 id=\"供应和部署时间\"><a href=\"#供应和部署时间\" class=\"headerlink\" title=\"供应和部署时间\"></a>供应和部署时间</h4><p>虚拟主机——数天至数周</p>\n<p>VPS———即时，无需安装操作系统</p>\n<p>云主机——即时，几分钟即可完成，可一键部署、也可自主安装操作系统</p>\n<h4 id=\"安全可靠性\"><a href=\"#安全可靠性\" class=\"headerlink\" title=\"安全可靠性\"></a>安全可靠性</h4><p>虚拟主机——一般：租用白牌服务器故障率高、基本无ARP、木马和DDOS防范能力、基本无备机和数据备份服务</p>\n<p>VPS———差：同一台物理服务器上其他VPS上安装的程序缺陷、ARP欺骗、病毒、资源挤占等会严重影响到自身;基本无ARP、木马和DDOS防范能力</p>\n<p>云主机——高：内置ARP防范，规模化提升DDOS防攻击能力;分享品牌企业级服务器和硬件虚拟化的性能和可靠性，内置HA;提供备机、快照、数据备份等多种快速恢复措施</p>\n<h4 id=\"性能及保障\"><a href=\"#性能及保障\" class=\"headerlink\" title=\"性能及保障\"></a>性能及保障</h4><p>虚拟主机——好且有保障</p>\n<p>VPS———差：性能一般，只适用于小规模并发访问;性能无保障，易遭受同一台物理服务器上其他VPS的挤压</p>\n<p>云主机——好且有保障：同物理服务器</p>\n<h4 id=\"弹性和扩展性\"><a href=\"#弹性和扩展性\" class=\"headerlink\" title=\"弹性和扩展性\"></a>弹性和扩展性</h4><p>虚拟主机——扩容需要重新租用新服务器、还需为原有租用资源付费</p>\n<p>VPS———扩容快，受制于单台服务器配置</p>\n<p>云主机——即时供应、按需扩展 ，无需为原有租用资源付费</p>\n<h4 id=\"拥有成本\"><a href=\"#拥有成本\" class=\"headerlink\" title=\"拥有成本\"></a>拥有成本</h4><p>虚拟主机——季付年付成本高、需要为服务商转嫁CapEx支出支付押金;需要自己维护租用的服务器导致Opex较高</p>\n<p>VPS———低配置的VPS租用价格最低;但低安全可靠性和无保障的性能导致服务质量无保障，运营成本难控制且偏高</p>\n<p>云主机——综合成本最低：月付无押金、按需使用按需付费、基本零维护 ，还可分享规模化、绿色节能、最佳IT实践带来的成本优势</p>\n<h4 id=\"易用、易管理性\"><a href=\"#易用、易管理性\" class=\"headerlink\" title=\"易用、易管理性\"></a>易用、易管理性</h4><p>虚拟主机——需要远程控制卡且只有租用品牌机才有可能，无法实现集中统一管理</p>\n<p>VPS———提供单一的单机管理界面，无root或超级管理员操作系统权限，管理灵活性受制于管理界面</p>\n<p>云主机——内置KVM、客户通过自服务系统可以集中统一管理分布在各地的云主机;完全拥有root或超级管理员操作系统权限</p>\n<h3 id=\"三、云主机的优点\"><a href=\"#三、云主机的优点\" class=\"headerlink\" title=\"三、云主机的优点\"></a>三、云主机的优点</h3><p>云主机主要有三大优点。</p>\n<ul>\n<li><p>便宜:因为服务可以分散到多台服务器，因此能够充分利用资源，这样就降低了硬件、电力和维护成本。而且，云主机是根据使用量计费的，多用多付，少用少付，所以对小网站特别有利。</p>\n</li>\n<li><p>可靠:因为服务分布在多台服务器、甚至多个机房，所以不容易彻底宕机，抗灾容错能力强，可以保证长时间在线。</p>\n</li>\n<li><p>可扩展性好(scalability):云主机的基本特点就是分布式架构，所以可以轻而易举地增加服务器，成倍扩展服务能力。</p>\n</li>\n</ul>\n<h3 id=\"四、云主机的缺点\"><a href=\"#四、云主机的缺点\" class=\"headerlink\" title=\"四、云主机的缺点\"></a>四、云主机的缺点</h3><p>一些客户担心云主机的安全问题，感到对服务缺乏控制。</p>\n<p>因为云主机只是提供网络接口，所以客户的数据必然全部服从云服务公司的安排，完全在后者控制之下。数据是否安全保密，取决于后者的职业道德和保护能力。</p>\n<p>但是，这其实是一个”伪问题”，因为绝大多数情况下，云服务公司会比客户更在乎、也更善于保护数据。Paul Graham在《黑客与画家》一书中，就谈过这一点：</p>\n<p>”反对者往往觉得我们的产品不安全，如果员工可以很容易地登录，那么坏人也可以很容易地登录。一些大公司觉得不能把客户的信用卡资料交给我们，而是放在自己的服务器上更安全。……但是事实上，他们的服务器就是没我们的安全，我们对数据的保护几乎肯定比他们好。</p>\n<p>想想看，谁能雇到更高水平的网络安全专家，是一个所有业务就是管理服务器的技术型创业公司，还是一家服装零售商？……而且我们比他们更关心数据的安全。如果一家服装零售商的服务器被入侵，最多只影响到这家公司本身，这件事也很可能在公司内部被掩盖起来，最严重的情况下可能还会有一个员工被解雇。但是，如果我们的服务器被入侵，就有成千上万家公司可能受到影响，这件事也许还会被当作新闻，发表在业内网站上面，使得我们生意做不下去，不得不关门歇业。</p>\n<p>如果你想把钱藏在安全的地方，请问你是选择家中床垫下面，还是选择银行？这个比喻对服务器管理的方方面面都适用，不仅是安全性，还包括正常运行时间、带宽、负载管理、备份等等，都是我们占优。”</p>\n","excerpt":"<blockquote>\n<p>转载链接：<a href=\"http://www.chinaz.com/prime/2012/1021/279069.shtml\">http://www.chinaz.com/prime/2012/1021/279069.shtml</a></p>\n</blockquote>\n<p>云计算时代，云主机其可扩展性、价格便宜、安全可靠的特性深受企业和开发者欢迎，但目前有些IDC企业，新瓶装旧酒，将虚拟主机、VPS进行包装推出所谓的云主机服务，为了帮助用户更好的辨别和挑选云主机，下文详细介绍虚拟主机、VPS和云主机产品的特点以及差异性。</p>\n<h3 id=\"一、虚拟主机、VPS和云主机\"><a href=\"#一、虚拟主机、VPS和云主机\" class=\"headerlink\" title=\"一、虚拟主机、VPS和云主机\"></a>一、虚拟主机、VPS和云主机</h3><p>共享主机也称虚拟主机，从互联网诞生至今，大部分站长都是从”共享主机”(shared hosting)开始学习建站的。所谓”共享主机”，就是一台服务器上有许多网站，大家共享这台服务器的硬件和带宽。如果它发生故障，那么上面的所有网站都无法访问。</p>\n<p>VPS主机(Virtual Private Server 虚拟专用服务器)，将一部服务器分割成多个虚拟专享服务器的优质服务。每个VPS都可分配独立公网IP地址、独立操作系统、独立超大空间、独立内存、独立CPU资源、独立执行程序和独立系统配置等。用户除了可以分配多个虚拟主机及无限企业邮箱外，更具有独立服务器功能，可自行安装程序，单独重启服务器。</p>\n<p>”云主机”(Cloud hosting)可以看成是新一代的共享主机。</p>\n<p>首先，主机公司将它的硬件和网络线路，做成一朵”云”，然后提供一些通向这朵”云”的网络接口API，供客户使用。这时，每个客户共享的不再是某一台特定的服务器，而是云里的所有服务器。</p>\n<p>比如，假设你要把本机的文件备份到网上，你可以使用共享主机，把文件传到某一台服务器上;也可以使用云主机，通过某种形式的接口，把它们传到云里。也就是说，共享主机用户直接面对特定的服务器，而云主机用户直接面对网络接口，看不到服务器内部。</p>\n<p>一个通俗的比喻是，你可以向银行租一个编号为”8888″的保险箱(共享主机)，也可以把贵重物品直接交给保管公司，听任他们保管。</p>\n<p>诸如Gmail、FaceBook、Twitter、Flickr这样的产品，都可以看作是基于”云主机”的服务。</p>\n<p>云主机能真正获得root权限，用户可以重装和升级操作系统，而VPS主机用户没有root权限，无法重装和升级操作系统。</p>","more":"<h3 id=\"二、虚拟主机、VPS、云主机的区别\"><a href=\"#二、虚拟主机、VPS、云主机的区别\" class=\"headerlink\" title=\"二、虚拟主机、VPS、云主机的区别\"></a>二、虚拟主机、VPS、云主机的区别</h3><h4 id=\"供应和部署时间\"><a href=\"#供应和部署时间\" class=\"headerlink\" title=\"供应和部署时间\"></a>供应和部署时间</h4><p>虚拟主机——数天至数周</p>\n<p>VPS———即时，无需安装操作系统</p>\n<p>云主机——即时，几分钟即可完成，可一键部署、也可自主安装操作系统</p>\n<h4 id=\"安全可靠性\"><a href=\"#安全可靠性\" class=\"headerlink\" title=\"安全可靠性\"></a>安全可靠性</h4><p>虚拟主机——一般：租用白牌服务器故障率高、基本无ARP、木马和DDOS防范能力、基本无备机和数据备份服务</p>\n<p>VPS———差：同一台物理服务器上其他VPS上安装的程序缺陷、ARP欺骗、病毒、资源挤占等会严重影响到自身;基本无ARP、木马和DDOS防范能力</p>\n<p>云主机——高：内置ARP防范，规模化提升DDOS防攻击能力;分享品牌企业级服务器和硬件虚拟化的性能和可靠性，内置HA;提供备机、快照、数据备份等多种快速恢复措施</p>\n<h4 id=\"性能及保障\"><a href=\"#性能及保障\" class=\"headerlink\" title=\"性能及保障\"></a>性能及保障</h4><p>虚拟主机——好且有保障</p>\n<p>VPS———差：性能一般，只适用于小规模并发访问;性能无保障，易遭受同一台物理服务器上其他VPS的挤压</p>\n<p>云主机——好且有保障：同物理服务器</p>\n<h4 id=\"弹性和扩展性\"><a href=\"#弹性和扩展性\" class=\"headerlink\" title=\"弹性和扩展性\"></a>弹性和扩展性</h4><p>虚拟主机——扩容需要重新租用新服务器、还需为原有租用资源付费</p>\n<p>VPS———扩容快，受制于单台服务器配置</p>\n<p>云主机——即时供应、按需扩展 ，无需为原有租用资源付费</p>\n<h4 id=\"拥有成本\"><a href=\"#拥有成本\" class=\"headerlink\" title=\"拥有成本\"></a>拥有成本</h4><p>虚拟主机——季付年付成本高、需要为服务商转嫁CapEx支出支付押金;需要自己维护租用的服务器导致Opex较高</p>\n<p>VPS———低配置的VPS租用价格最低;但低安全可靠性和无保障的性能导致服务质量无保障，运营成本难控制且偏高</p>\n<p>云主机——综合成本最低：月付无押金、按需使用按需付费、基本零维护 ，还可分享规模化、绿色节能、最佳IT实践带来的成本优势</p>\n<h4 id=\"易用、易管理性\"><a href=\"#易用、易管理性\" class=\"headerlink\" title=\"易用、易管理性\"></a>易用、易管理性</h4><p>虚拟主机——需要远程控制卡且只有租用品牌机才有可能，无法实现集中统一管理</p>\n<p>VPS———提供单一的单机管理界面，无root或超级管理员操作系统权限，管理灵活性受制于管理界面</p>\n<p>云主机——内置KVM、客户通过自服务系统可以集中统一管理分布在各地的云主机;完全拥有root或超级管理员操作系统权限</p>\n<h3 id=\"三、云主机的优点\"><a href=\"#三、云主机的优点\" class=\"headerlink\" title=\"三、云主机的优点\"></a>三、云主机的优点</h3><p>云主机主要有三大优点。</p>\n<ul>\n<li><p>便宜:因为服务可以分散到多台服务器，因此能够充分利用资源，这样就降低了硬件、电力和维护成本。而且，云主机是根据使用量计费的，多用多付，少用少付，所以对小网站特别有利。</p>\n</li>\n<li><p>可靠:因为服务分布在多台服务器、甚至多个机房，所以不容易彻底宕机，抗灾容错能力强，可以保证长时间在线。</p>\n</li>\n<li><p>可扩展性好(scalability):云主机的基本特点就是分布式架构，所以可以轻而易举地增加服务器，成倍扩展服务能力。</p>\n</li>\n</ul>\n<h3 id=\"四、云主机的缺点\"><a href=\"#四、云主机的缺点\" class=\"headerlink\" title=\"四、云主机的缺点\"></a>四、云主机的缺点</h3><p>一些客户担心云主机的安全问题，感到对服务缺乏控制。</p>\n<p>因为云主机只是提供网络接口，所以客户的数据必然全部服从云服务公司的安排，完全在后者控制之下。数据是否安全保密，取决于后者的职业道德和保护能力。</p>\n<p>但是，这其实是一个”伪问题”，因为绝大多数情况下，云服务公司会比客户更在乎、也更善于保护数据。Paul Graham在《黑客与画家》一书中，就谈过这一点：</p>\n<p>”反对者往往觉得我们的产品不安全，如果员工可以很容易地登录，那么坏人也可以很容易地登录。一些大公司觉得不能把客户的信用卡资料交给我们，而是放在自己的服务器上更安全。……但是事实上，他们的服务器就是没我们的安全，我们对数据的保护几乎肯定比他们好。</p>\n<p>想想看，谁能雇到更高水平的网络安全专家，是一个所有业务就是管理服务器的技术型创业公司，还是一家服装零售商？……而且我们比他们更关心数据的安全。如果一家服装零售商的服务器被入侵，最多只影响到这家公司本身，这件事也很可能在公司内部被掩盖起来，最严重的情况下可能还会有一个员工被解雇。但是，如果我们的服务器被入侵，就有成千上万家公司可能受到影响，这件事也许还会被当作新闻，发表在业内网站上面，使得我们生意做不下去，不得不关门歇业。</p>\n<p>如果你想把钱藏在安全的地方，请问你是选择家中床垫下面，还是选择银行？这个比喻对服务器管理的方方面面都适用，不仅是安全性，还包括正常运行时间、带宽、负载管理、备份等等，都是我们占优。”</p>"},{"layout":"post","title":"LAMP 环境搭建","date":"2016-12-09T01:05:00.000Z","_content":"\n之前写过一些服务器的配置文章，但当时都只是按部就班，对于相关服务的理解很欠缺。由于很多的博客系统，网站都依赖于：操作系统，服务器软件，数据库，后台编程语言等，本质上他们都存在很大的共性，细心品尝里面的门道其实不可谓不多，这边重新梳理 LAMP 环境的搭建，帮助学习和理解。\n\n<!-- more -->\n","source":"_posts/2016/2016-12-09-lamp-环境搭建.md","raw":"---\nlayout: \"post\"\ntitle: \"LAMP 环境搭建\"\ndate: \"2016-12-09 09:05\"\n---\n\n之前写过一些服务器的配置文章，但当时都只是按部就班，对于相关服务的理解很欠缺。由于很多的博客系统，网站都依赖于：操作系统，服务器软件，数据库，后台编程语言等，本质上他们都存在很大的共性，细心品尝里面的门道其实不可谓不多，这边重新梳理 LAMP 环境的搭建，帮助学习和理解。\n\n<!-- more -->\n","slug":"2016/2016-12-09-lamp-环境搭建","published":1,"updated":"2016-12-16T01:50:54.959Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aj1003lmumujsf34mmn","content":"<p>之前写过一些服务器的配置文章，但当时都只是按部就班，对于相关服务的理解很欠缺。由于很多的博客系统，网站都依赖于：操作系统，服务器软件，数据库，后台编程语言等，本质上他们都存在很大的共性，细心品尝里面的门道其实不可谓不多，这边重新梳理 LAMP 环境的搭建，帮助学习和理解。</p>\n<a id=\"more\"></a>\n","excerpt":"<p>之前写过一些服务器的配置文章，但当时都只是按部就班，对于相关服务的理解很欠缺。由于很多的博客系统，网站都依赖于：操作系统，服务器软件，数据库，后台编程语言等，本质上他们都存在很大的共性，细心品尝里面的门道其实不可谓不多，这边重新梳理 LAMP 环境的搭建，帮助学习和理解。</p>","more":""},{"layout":"post","title":"VPS : shadowsocks","date":"2016-11-25T01:30:00.000Z","_content":"\n日常生活中，由于GFW的强大，很多学习资料等内容我们无法获取或者检索，因此科学上网往往相当重要，本文章使用 VPS 搭建 shadowsocks 服务让安全的科学上网成为可能，需要注意的是 VPS 必须是境外服务器，推荐 vultr 搬瓦工等廉价vpn。\n\n### 工作原理\n\n**这边可以参考[原文博客](http://vc2tea.com/whats-shadowsocks/)，以下只是简单罗列一些原理：**\n\n- 早期互联网用户访问网站时，用户的请求通过互联网发送到服务提供方，服务提供方直接将信息反馈给用户： \n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss1.png)\n\n- GFW 出现后，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容 \n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss2.png)\n\n- 为了绕过GFW的过滤（包含了各种HTTP代理服务、Socks服务、VPN服务等等），以 ssh tunnel 的方法为例：1) 首先用户和境外服务器基于 ssh 建立起一条加密的通道 2-3) 用户通过建立起的隧道进行代理，通过 ssh server 向真实的服务发起请求 4-5) 服务通过 ssh server，再通过创建好的隧道返回给用户。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss3.png)\n\n**由于 ssh 本身就是基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，ssh 本身的特征是明显的，所以 GFW 一度通过分析连接的特征进行干扰，导致 ssh 存在被定向进行干扰的问题**\n\n- shadowsocks 是将原来 ssh 创建的 Socks5 协议拆开成 server 端和 client 端，所以下面这个原理图基本上和利用 ssh tunnel 大致类似:1、6) 客户端发出的请求基于 Socks5 协议跟 ss-local 端进行通讯，由于这个 ss-local 一般是本机或路由器或局域网的其他机器，不经过 GFW，所以解决了上面被 GFW 通过特征分析进行干扰的问题 2、5) ss-local 和 ss-server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密 3、4) ss-server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回:\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss4.png)\n\n\n- GFW 就出现了，他像一个收过路费的强盗一样夹在了在用户和服务之间，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容 \n\n### 软件简介：\n\n#### shadowsocks:\n\n[shadowsocks：A secure socks5 proxy,designed to protect your Internet traffic.](https://shadowsocks.org/en/index.html)。\n\nShadowsocks（中文名称：影梭）是使用Python、C++、C#等语言开发的、基于Apache许可证的开放源代码软件，用于保护网络流量、加密数据传输。Shadowsocks使用Socks5代理方式。Shadowsocks分为服务器端和客户端。在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。在中国大陆，本工具也被广泛用于突破防火长城（GFW），以浏览被封锁、屏蔽或干扰的内容。在2015年8月22日，Shadowsocks原作者Clowwindy称受到了中国政府的压力，宣布停止维护此项目并移除其用户页面所载的源代码。\n\nShadowsocks的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。在服务器端部署完成后，用户需要按照指定的密码、加密方式和端口使用客户端软件与其连接。在成功连接到服务器后，客户端会在用户的电脑上构建一个本地Socks5代理。浏览网络时，网络流量会被分到本地socks5代理，客户端将其加密之后发送到服务器，服务器以同样的加密方式将流量回传给客户端，以此实现代理上网。\n\n- Shadowsocks使用自行设计的协议进行加密通信。[4]加密算法有AES、Blowfish、IDEA、RC4等，除创建TCP连接外无需握手，每次请求只转发一个连接，因此使用起来网速较快，在移动设备上也比较省电。\n- 所有的流量都经过算法加密，允许自行选择算法，所以比较安全。\n- Shadowsocks通过异步I/O和事件驱动程序运行，响应速度快。\n- 客户端覆盖多个主流操作系统和平台，包括Windows，OS X，Android和iOS系统和路由器（OpenWrt）等[5]。\n- 专为移动设备和无线网络优化。\n\n\n\n\n\n#### supervisor:\n\nLinux的后台进程运行有好几种方法，例如nohup，screen等，但是，如果是一个服务程序，要可靠地在后台运行，我们就需要把它做成daemon，最好还能监控进程状态，在意外结束时能自动重启。supervisor就是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。\n\n\n### VPS 安装及配置：\n\n#### 软件列表：\n\n- vps（Debian GNU/Linux 7 ），这边采用 Debian 系列linux，ubuntu 应该步骤类似，如果使用 redhat 系列，部分指令需要自行更改，这边不做累述。\n- shadowsocks-severs： 注意安装 shadowsocks 的 severs 版本\n- supervisor ： 用于Linux后台进程管理的利器\n\n<!-- more -->\n\n\n#### 详细步骤：\n\n- 安装软件，终端输入：`apt-get install python-pip && pip install shadowsocks`。\n- 写 shadowsocks 配置文件： vim /etc/shadowsocks.json ， 具体内容如下：\n\n```\n{\n    \"server\":\"0.0.0.0\",\n    \"server_port\":50003,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"123456\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n\n\n说明： \nserver 你vps的IP\nservier_port 服务端的端口\nlocal_port 本地端口，一般默认1080\npassword 服务端设置的密码\ntimeout 超时设置\nmethod 加密方法\n\n如要你需要分享SS服务给朋友或家人，可以配置多个SS账户，具体可以参考下面的代码:\n{\n    \"timeout\": 600,\n    \"method\": \"aes-256-cfb\",\n    \"port_password\":\n    {\n        \"40001\": \"password1\",\n        \"40002\": \"password2\",\n        \"40003\": \"password3\"\n    },\n    \"_comment\":\n    {\n        \"40001\": \"xiaoming\",\n        \"40002\": \"lilei\",\n        \"40003\": \"mike\"\n    }\n}\n```\n\n注意这边 server 的地址可以通过 ipconfig 获取本机地址，如果是一些多层虚拟出来的机器，如果无法获得本机IP，则输入0.0.0.0即可。\n\n- 安装 supervisor： apt-get install supervisor\n- 将 shadowsocks 加入到 supervisor 中进行管理：vim /etc/supervisor/supervisord.conf 在末尾加入如下内容：\n\n```\n[program:shadowsocks]\ncommand=ssserver -c /etc/shadowsocks.json\nautostart=true\nautorestart=true\nuser=root\nlog_stderr=true\nlogfile=/var/log/shadowsocks.log\n```\n- 最后让 supervisor 开机自启动：在 `vim /etc/rc.local` 空白行加入 `service supervisor restart` (事实上这一步可以不用加，supervisor 本身就会开机自启动，在 `/etc/rc2.d/` 下 我们可以看到 `lrwxrwxrwx 1 root root  20 Nov 25 11:56 S01supervisor -> ../init.d/supervisor` ，当然如果你的系统没能自动开启 supervisor 守护进程，则需要手动完成上述操作)，重启服务器查看是否配置成功。\n\n\n*采用 supervisor 的原因很大程度上是：将 `sslocal -c /etc/shadowsocks.json` 放入/etc/rc.local中没法开启自启该服务，有待查找原因。*\n\n\n**以上内容均为个人总结转述，如果可以访问外网，请参考[官网](https://shadowsocks.org/en/download/servers.html)给出的更加详细的配置步骤。以下为客户端配置，注意只有在完成了服务器端配置或者你已经有一个可以使用的 shadowsocks 服务器，才能够在本地搭建以下服务。**\n\n\n\n### 本地 linux 下的安装配置\n\n#### 软件列表：\n\n- linux PC端： shadowsocks ， 本地操作系统 ubuntu 16.04 , 。\n- shadowsocks-severs： 注意安装 shadowsocks 的 severs 版本\n- supervisor ： 用于Linux后台进程管理的利器\n- chrome 插件 SwitchyOmega ：\n\n#### 详细步骤：\n\n- 安装 shadowsocks （我们这边不采用 GUI 软件而直接使用 shadowsocks 命令工具连接 shadowsocks 服务器。）步骤如下：\n\n```\nsudo apt-get update\nsudo apt-get install python-pip\nsudo apt-get install python-setuptools m2crypto\npip install shadowsocks\n\n注意： 如果是 ubuntu 16.04 的版本执行完以上命令后可能仍然无法执行 sslocal 命令，需要手动执行 `sudo apt install shadowsocks` （ubuntu16.04 直接可以直接用apt 而不用 apt-get 这是一项改进）。\n\n```\n\n- 配置 Shadowsocks ：同服务器类似， 也是配置 shadowsocks.json 这个文件，可以在你想要指定的目录下新建这个文件如：~/.config/shadowsocks.json ， 编辑该文件：\n\n```\n{\n    \"server\":\"www.baidu.com\",\n    \"server_port\":50003,\n    \"local_port\":1080,\n    \"password\":\"123456\",\n    \"timeout\":600,\n    \"method\":\"aes-256-cfb\"\n}\n\n\n说明：\nserver 后面填写你需要链接的服务器地址\nserver_port 后面填写你 Shadowsocks 服务器配置的 server_port 端口\nlocal_port 无需修改\npassword 需要和 Shadowsocks 服务器保持一致\n```\n\n- 完成以下步骤后，你的浏览器仍然不能浏览网页，Shadowsocks 仅提供了转发服务，而你本地的端口发送的数据还无法和server_port进行链接，这时候，你可以采用全局代理的软件让所有数据帮转发，这边推荐chrome的 SwitchyOmega 插件。可以从Github上直接下载最新版 [SwitchyOmega](https://github.com/FelisCatus/SwitchyOmega/releases/) （这个是chrome的）然后浏览器地址打开chrome://extensions/，将下载的插件托进去安装。安装好之后下面开始设置代理，如下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/1.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/2.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/3.png)\n\n上图步骤中注意类型条件中勾选**规则列表规则**， 规则地址： https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt 填入其中。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/4.png)\n\n点击 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。\n\n如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。\n\n\n- 安装 supervisor： sudo apt-get install supervisor\n- 将 shadowsocks 加入到 supervisor 中进行管理：vim /etc/supervisor/supervisor.conf 在末尾加入如下内容，或者在 /etc/supervisor/conf.d 下新建新的文件增加如下内容（注意 shadowsocks.json 文件路径写对）：\n\n```\n[program:shadowsocks]\ncommand=sslocal -c /home/username/.config/shadowsocks.json\nautostart=true\nautorestart=true\nuser=root\nlog_stderr=true\nlogfile=/var/log/shadowsocks.log\n```\n\n- 最后让 supervisor 开机自启动：在 `sudo vim /etc/rc.local` 空白行加入 `sudo service supervisor restart`。*不知出于什么原因这边 supervisor 必须手动写入 /etc/rc.local 中才会开机自启动* 查看是否配置成功可以重启电脑。\n\n*如果需要让 linux 下其他软件也都可以使用 ss 服务，可以参考我的另外一篇文章：linux-shadowsocks全局代理。*\n\n### 本地 windows 下安装配置\n\n[下载客户端](https://github.com/shadowsocks/shadowsocks-windows/releases/download/3.3.5/Shadowsocks-3.3.5.zip)，作为一个开源软件 GUI 客户端分为多个版本，这边提供了 win 版本，需要安装 微软的库，打开后如下图所示：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/5.png)\n\n这边的服务器 IP 同上面 linux 的类似，填写你的域名或者 IP 即可，密码也要和服务器的 shadowsocks 服务保持一致。值得一提的是 windows 下面的客户端直接可以设置全局代理，右击任务栏的小图标可以设置相关选项。\n\n### 本地 安卓手机端 安装配置\n\n安卓用户这边推荐使用腾讯自家的应用宝，直接搜索 shadowsocks 会看到中文名“影梭”的这个软件(*注意应用宝中的软件版本较老，为 2.8.3 目前最新版本为 3.2.7。*)，设置基本和 windows 的类似，设置完毕后，点击右上角的开启按钮。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/6.png)\n\n\n\n> 参考链接：\n> http://vc2tea.com/whats-shadowsocks/\n> https://aitanlu.com/ubuntu-shadowsocks-ke-hu-duan-pei-zhi.html\n> https://aitanlu.com/linux-ubuntu-install-shadowsocks.html\n> https://php-rmcr7.rhcloud.com/shadowsocks-server/\n> http://blog.chinaunix.net/uid-25530360-id-5595974.html\n> http://www.liaoxuefeng.com/article/0013738926914703df5e93589a14c19807f0e285194fe84000\n> https://zh.wikipedia.org/zh-hans/Shadowsocks\n> https://github.com/shadowsocks/shadowsocks/tree/master\n> http://webcache.googleusercontent.com/search?q=cache:http://everet.org/shadowsocks.html\n","source":"_posts/2016/2016-11-25-vps-shadowsocks.md","raw":"---\nlayout: \"post\"\ntitle: \"VPS : shadowsocks\"\ndate: \"2016-11-25 09:30\"\n---\n\n日常生活中，由于GFW的强大，很多学习资料等内容我们无法获取或者检索，因此科学上网往往相当重要，本文章使用 VPS 搭建 shadowsocks 服务让安全的科学上网成为可能，需要注意的是 VPS 必须是境外服务器，推荐 vultr 搬瓦工等廉价vpn。\n\n### 工作原理\n\n**这边可以参考[原文博客](http://vc2tea.com/whats-shadowsocks/)，以下只是简单罗列一些原理：**\n\n- 早期互联网用户访问网站时，用户的请求通过互联网发送到服务提供方，服务提供方直接将信息反馈给用户： \n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss1.png)\n\n- GFW 出现后，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容 \n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss2.png)\n\n- 为了绕过GFW的过滤（包含了各种HTTP代理服务、Socks服务、VPN服务等等），以 ssh tunnel 的方法为例：1) 首先用户和境外服务器基于 ssh 建立起一条加密的通道 2-3) 用户通过建立起的隧道进行代理，通过 ssh server 向真实的服务发起请求 4-5) 服务通过 ssh server，再通过创建好的隧道返回给用户。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss3.png)\n\n**由于 ssh 本身就是基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，ssh 本身的特征是明显的，所以 GFW 一度通过分析连接的特征进行干扰，导致 ssh 存在被定向进行干扰的问题**\n\n- shadowsocks 是将原来 ssh 创建的 Socks5 协议拆开成 server 端和 client 端，所以下面这个原理图基本上和利用 ssh tunnel 大致类似:1、6) 客户端发出的请求基于 Socks5 协议跟 ss-local 端进行通讯，由于这个 ss-local 一般是本机或路由器或局域网的其他机器，不经过 GFW，所以解决了上面被 GFW 通过特征分析进行干扰的问题 2、5) ss-local 和 ss-server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密 3、4) ss-server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回:\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss4.png)\n\n\n- GFW 就出现了，他像一个收过路费的强盗一样夹在了在用户和服务之间，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容 \n\n### 软件简介：\n\n#### shadowsocks:\n\n[shadowsocks：A secure socks5 proxy,designed to protect your Internet traffic.](https://shadowsocks.org/en/index.html)。\n\nShadowsocks（中文名称：影梭）是使用Python、C++、C#等语言开发的、基于Apache许可证的开放源代码软件，用于保护网络流量、加密数据传输。Shadowsocks使用Socks5代理方式。Shadowsocks分为服务器端和客户端。在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。在中国大陆，本工具也被广泛用于突破防火长城（GFW），以浏览被封锁、屏蔽或干扰的内容。在2015年8月22日，Shadowsocks原作者Clowwindy称受到了中国政府的压力，宣布停止维护此项目并移除其用户页面所载的源代码。\n\nShadowsocks的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。在服务器端部署完成后，用户需要按照指定的密码、加密方式和端口使用客户端软件与其连接。在成功连接到服务器后，客户端会在用户的电脑上构建一个本地Socks5代理。浏览网络时，网络流量会被分到本地socks5代理，客户端将其加密之后发送到服务器，服务器以同样的加密方式将流量回传给客户端，以此实现代理上网。\n\n- Shadowsocks使用自行设计的协议进行加密通信。[4]加密算法有AES、Blowfish、IDEA、RC4等，除创建TCP连接外无需握手，每次请求只转发一个连接，因此使用起来网速较快，在移动设备上也比较省电。\n- 所有的流量都经过算法加密，允许自行选择算法，所以比较安全。\n- Shadowsocks通过异步I/O和事件驱动程序运行，响应速度快。\n- 客户端覆盖多个主流操作系统和平台，包括Windows，OS X，Android和iOS系统和路由器（OpenWrt）等[5]。\n- 专为移动设备和无线网络优化。\n\n\n\n\n\n#### supervisor:\n\nLinux的后台进程运行有好几种方法，例如nohup，screen等，但是，如果是一个服务程序，要可靠地在后台运行，我们就需要把它做成daemon，最好还能监控进程状态，在意外结束时能自动重启。supervisor就是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。\n\n\n### VPS 安装及配置：\n\n#### 软件列表：\n\n- vps（Debian GNU/Linux 7 ），这边采用 Debian 系列linux，ubuntu 应该步骤类似，如果使用 redhat 系列，部分指令需要自行更改，这边不做累述。\n- shadowsocks-severs： 注意安装 shadowsocks 的 severs 版本\n- supervisor ： 用于Linux后台进程管理的利器\n\n<!-- more -->\n\n\n#### 详细步骤：\n\n- 安装软件，终端输入：`apt-get install python-pip && pip install shadowsocks`。\n- 写 shadowsocks 配置文件： vim /etc/shadowsocks.json ， 具体内容如下：\n\n```\n{\n    \"server\":\"0.0.0.0\",\n    \"server_port\":50003,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"123456\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n\n\n说明： \nserver 你vps的IP\nservier_port 服务端的端口\nlocal_port 本地端口，一般默认1080\npassword 服务端设置的密码\ntimeout 超时设置\nmethod 加密方法\n\n如要你需要分享SS服务给朋友或家人，可以配置多个SS账户，具体可以参考下面的代码:\n{\n    \"timeout\": 600,\n    \"method\": \"aes-256-cfb\",\n    \"port_password\":\n    {\n        \"40001\": \"password1\",\n        \"40002\": \"password2\",\n        \"40003\": \"password3\"\n    },\n    \"_comment\":\n    {\n        \"40001\": \"xiaoming\",\n        \"40002\": \"lilei\",\n        \"40003\": \"mike\"\n    }\n}\n```\n\n注意这边 server 的地址可以通过 ipconfig 获取本机地址，如果是一些多层虚拟出来的机器，如果无法获得本机IP，则输入0.0.0.0即可。\n\n- 安装 supervisor： apt-get install supervisor\n- 将 shadowsocks 加入到 supervisor 中进行管理：vim /etc/supervisor/supervisord.conf 在末尾加入如下内容：\n\n```\n[program:shadowsocks]\ncommand=ssserver -c /etc/shadowsocks.json\nautostart=true\nautorestart=true\nuser=root\nlog_stderr=true\nlogfile=/var/log/shadowsocks.log\n```\n- 最后让 supervisor 开机自启动：在 `vim /etc/rc.local` 空白行加入 `service supervisor restart` (事实上这一步可以不用加，supervisor 本身就会开机自启动，在 `/etc/rc2.d/` 下 我们可以看到 `lrwxrwxrwx 1 root root  20 Nov 25 11:56 S01supervisor -> ../init.d/supervisor` ，当然如果你的系统没能自动开启 supervisor 守护进程，则需要手动完成上述操作)，重启服务器查看是否配置成功。\n\n\n*采用 supervisor 的原因很大程度上是：将 `sslocal -c /etc/shadowsocks.json` 放入/etc/rc.local中没法开启自启该服务，有待查找原因。*\n\n\n**以上内容均为个人总结转述，如果可以访问外网，请参考[官网](https://shadowsocks.org/en/download/servers.html)给出的更加详细的配置步骤。以下为客户端配置，注意只有在完成了服务器端配置或者你已经有一个可以使用的 shadowsocks 服务器，才能够在本地搭建以下服务。**\n\n\n\n### 本地 linux 下的安装配置\n\n#### 软件列表：\n\n- linux PC端： shadowsocks ， 本地操作系统 ubuntu 16.04 , 。\n- shadowsocks-severs： 注意安装 shadowsocks 的 severs 版本\n- supervisor ： 用于Linux后台进程管理的利器\n- chrome 插件 SwitchyOmega ：\n\n#### 详细步骤：\n\n- 安装 shadowsocks （我们这边不采用 GUI 软件而直接使用 shadowsocks 命令工具连接 shadowsocks 服务器。）步骤如下：\n\n```\nsudo apt-get update\nsudo apt-get install python-pip\nsudo apt-get install python-setuptools m2crypto\npip install shadowsocks\n\n注意： 如果是 ubuntu 16.04 的版本执行完以上命令后可能仍然无法执行 sslocal 命令，需要手动执行 `sudo apt install shadowsocks` （ubuntu16.04 直接可以直接用apt 而不用 apt-get 这是一项改进）。\n\n```\n\n- 配置 Shadowsocks ：同服务器类似， 也是配置 shadowsocks.json 这个文件，可以在你想要指定的目录下新建这个文件如：~/.config/shadowsocks.json ， 编辑该文件：\n\n```\n{\n    \"server\":\"www.baidu.com\",\n    \"server_port\":50003,\n    \"local_port\":1080,\n    \"password\":\"123456\",\n    \"timeout\":600,\n    \"method\":\"aes-256-cfb\"\n}\n\n\n说明：\nserver 后面填写你需要链接的服务器地址\nserver_port 后面填写你 Shadowsocks 服务器配置的 server_port 端口\nlocal_port 无需修改\npassword 需要和 Shadowsocks 服务器保持一致\n```\n\n- 完成以下步骤后，你的浏览器仍然不能浏览网页，Shadowsocks 仅提供了转发服务，而你本地的端口发送的数据还无法和server_port进行链接，这时候，你可以采用全局代理的软件让所有数据帮转发，这边推荐chrome的 SwitchyOmega 插件。可以从Github上直接下载最新版 [SwitchyOmega](https://github.com/FelisCatus/SwitchyOmega/releases/) （这个是chrome的）然后浏览器地址打开chrome://extensions/，将下载的插件托进去安装。安装好之后下面开始设置代理，如下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/1.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/2.png)\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/3.png)\n\n上图步骤中注意类型条件中勾选**规则列表规则**， 规则地址： https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt 填入其中。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/4.png)\n\n点击 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。\n\n如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。\n\n\n- 安装 supervisor： sudo apt-get install supervisor\n- 将 shadowsocks 加入到 supervisor 中进行管理：vim /etc/supervisor/supervisor.conf 在末尾加入如下内容，或者在 /etc/supervisor/conf.d 下新建新的文件增加如下内容（注意 shadowsocks.json 文件路径写对）：\n\n```\n[program:shadowsocks]\ncommand=sslocal -c /home/username/.config/shadowsocks.json\nautostart=true\nautorestart=true\nuser=root\nlog_stderr=true\nlogfile=/var/log/shadowsocks.log\n```\n\n- 最后让 supervisor 开机自启动：在 `sudo vim /etc/rc.local` 空白行加入 `sudo service supervisor restart`。*不知出于什么原因这边 supervisor 必须手动写入 /etc/rc.local 中才会开机自启动* 查看是否配置成功可以重启电脑。\n\n*如果需要让 linux 下其他软件也都可以使用 ss 服务，可以参考我的另外一篇文章：linux-shadowsocks全局代理。*\n\n### 本地 windows 下安装配置\n\n[下载客户端](https://github.com/shadowsocks/shadowsocks-windows/releases/download/3.3.5/Shadowsocks-3.3.5.zip)，作为一个开源软件 GUI 客户端分为多个版本，这边提供了 win 版本，需要安装 微软的库，打开后如下图所示：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/5.png)\n\n这边的服务器 IP 同上面 linux 的类似，填写你的域名或者 IP 即可，密码也要和服务器的 shadowsocks 服务保持一致。值得一提的是 windows 下面的客户端直接可以设置全局代理，右击任务栏的小图标可以设置相关选项。\n\n### 本地 安卓手机端 安装配置\n\n安卓用户这边推荐使用腾讯自家的应用宝，直接搜索 shadowsocks 会看到中文名“影梭”的这个软件(*注意应用宝中的软件版本较老，为 2.8.3 目前最新版本为 3.2.7。*)，设置基本和 windows 的类似，设置完毕后，点击右上角的开启按钮。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/6.png)\n\n\n\n> 参考链接：\n> http://vc2tea.com/whats-shadowsocks/\n> https://aitanlu.com/ubuntu-shadowsocks-ke-hu-duan-pei-zhi.html\n> https://aitanlu.com/linux-ubuntu-install-shadowsocks.html\n> https://php-rmcr7.rhcloud.com/shadowsocks-server/\n> http://blog.chinaunix.net/uid-25530360-id-5595974.html\n> http://www.liaoxuefeng.com/article/0013738926914703df5e93589a14c19807f0e285194fe84000\n> https://zh.wikipedia.org/zh-hans/Shadowsocks\n> https://github.com/shadowsocks/shadowsocks/tree/master\n> http://webcache.googleusercontent.com/search?q=cache:http://everet.org/shadowsocks.html\n","slug":"2016/2016-11-25-vps-shadowsocks","published":1,"updated":"2017-01-25T03:01:54.775Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aj2003mmumua0rzz4uh","content":"<p>日常生活中，由于GFW的强大，很多学习资料等内容我们无法获取或者检索，因此科学上网往往相当重要，本文章使用 VPS 搭建 shadowsocks 服务让安全的科学上网成为可能，需要注意的是 VPS 必须是境外服务器，推荐 vultr 搬瓦工等廉价vpn。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p><strong>这边可以参考<a href=\"http://vc2tea.com/whats-shadowsocks/\" target=\"_blank\" rel=\"external\">原文博客</a>，以下只是简单罗列一些原理：</strong></p>\n<ul>\n<li>早期互联网用户访问网站时，用户的请求通过互联网发送到服务提供方，服务提供方直接将信息反馈给用户： </li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss1.png\" alt=\"\"></p>\n<ul>\n<li>GFW 出现后，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容 </li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss2.png\" alt=\"\"></p>\n<ul>\n<li>为了绕过GFW的过滤（包含了各种HTTP代理服务、Socks服务、VPN服务等等），以 ssh tunnel 的方法为例：1) 首先用户和境外服务器基于 ssh 建立起一条加密的通道 2-3) 用户通过建立起的隧道进行代理，通过 ssh server 向真实的服务发起请求 4-5) 服务通过 ssh server，再通过创建好的隧道返回给用户。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss3.png\" alt=\"\"></p>\n<p><strong>由于 ssh 本身就是基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，ssh 本身的特征是明显的，所以 GFW 一度通过分析连接的特征进行干扰，导致 ssh 存在被定向进行干扰的问题</strong></p>\n<ul>\n<li>shadowsocks 是将原来 ssh 创建的 Socks5 协议拆开成 server 端和 client 端，所以下面这个原理图基本上和利用 ssh tunnel 大致类似:1、6) 客户端发出的请求基于 Socks5 协议跟 ss-local 端进行通讯，由于这个 ss-local 一般是本机或路由器或局域网的其他机器，不经过 GFW，所以解决了上面被 GFW 通过特征分析进行干扰的问题 2、5) ss-local 和 ss-server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密 3、4) ss-server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回:</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss4.png\" alt=\"\"></p>\n<ul>\n<li>GFW 就出现了，他像一个收过路费的强盗一样夹在了在用户和服务之间，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容 </li>\n</ul>\n<h3 id=\"软件简介：\"><a href=\"#软件简介：\" class=\"headerlink\" title=\"软件简介：\"></a>软件简介：</h3><h4 id=\"shadowsocks\"><a href=\"#shadowsocks\" class=\"headerlink\" title=\"shadowsocks:\"></a>shadowsocks:</h4><p><a href=\"https://shadowsocks.org/en/index.html\" target=\"_blank\" rel=\"external\">shadowsocks：A secure socks5 proxy,designed to protect your Internet traffic.</a>。</p>\n<p>Shadowsocks（中文名称：影梭）是使用Python、C++、C#等语言开发的、基于Apache许可证的开放源代码软件，用于保护网络流量、加密数据传输。Shadowsocks使用Socks5代理方式。Shadowsocks分为服务器端和客户端。在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。在中国大陆，本工具也被广泛用于突破防火长城（GFW），以浏览被封锁、屏蔽或干扰的内容。在2015年8月22日，Shadowsocks原作者Clowwindy称受到了中国政府的压力，宣布停止维护此项目并移除其用户页面所载的源代码。</p>\n<p>Shadowsocks的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。在服务器端部署完成后，用户需要按照指定的密码、加密方式和端口使用客户端软件与其连接。在成功连接到服务器后，客户端会在用户的电脑上构建一个本地Socks5代理。浏览网络时，网络流量会被分到本地socks5代理，客户端将其加密之后发送到服务器，服务器以同样的加密方式将流量回传给客户端，以此实现代理上网。</p>\n<ul>\n<li>Shadowsocks使用自行设计的协议进行加密通信。[4]加密算法有AES、Blowfish、IDEA、RC4等，除创建TCP连接外无需握手，每次请求只转发一个连接，因此使用起来网速较快，在移动设备上也比较省电。</li>\n<li>所有的流量都经过算法加密，允许自行选择算法，所以比较安全。</li>\n<li>Shadowsocks通过异步I/O和事件驱动程序运行，响应速度快。</li>\n<li>客户端覆盖多个主流操作系统和平台，包括Windows，OS X，Android和iOS系统和路由器（OpenWrt）等[5]。</li>\n<li>专为移动设备和无线网络优化。</li>\n</ul>\n<h4 id=\"supervisor\"><a href=\"#supervisor\" class=\"headerlink\" title=\"supervisor:\"></a>supervisor:</h4><p>Linux的后台进程运行有好几种方法，例如nohup，screen等，但是，如果是一个服务程序，要可靠地在后台运行，我们就需要把它做成daemon，最好还能监控进程状态，在意外结束时能自动重启。supervisor就是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。</p>\n<h3 id=\"VPS-安装及配置：\"><a href=\"#VPS-安装及配置：\" class=\"headerlink\" title=\"VPS 安装及配置：\"></a>VPS 安装及配置：</h3><h4 id=\"软件列表：\"><a href=\"#软件列表：\" class=\"headerlink\" title=\"软件列表：\"></a>软件列表：</h4><ul>\n<li>vps（Debian GNU/Linux 7 ），这边采用 Debian 系列linux，ubuntu 应该步骤类似，如果使用 redhat 系列，部分指令需要自行更改，这边不做累述。</li>\n<li>shadowsocks-severs： 注意安装 shadowsocks 的 severs 版本</li>\n<li>supervisor ： 用于Linux后台进程管理的利器</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"详细步骤：\"><a href=\"#详细步骤：\" class=\"headerlink\" title=\"详细步骤：\"></a>详细步骤：</h4><ul>\n<li>安装软件，终端输入：<code>apt-get install python-pip &amp;&amp; pip install shadowsocks</code>。</li>\n<li>写 shadowsocks 配置文件： vim /etc/shadowsocks.json ， 具体内容如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;server&quot;:&quot;0.0.0.0&quot;,</div><div class=\"line\">    &quot;server_port&quot;:50003,</div><div class=\"line\">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;password&quot;:&quot;123456&quot;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">说明： </div><div class=\"line\">server 你vps的IP</div><div class=\"line\">servier_port 服务端的端口</div><div class=\"line\">local_port 本地端口，一般默认1080</div><div class=\"line\">password 服务端设置的密码</div><div class=\"line\">timeout 超时设置</div><div class=\"line\">method 加密方法</div><div class=\"line\"></div><div class=\"line\">如要你需要分享SS服务给朋友或家人，可以配置多个SS账户，具体可以参考下面的代码:</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;timeout&quot;: 600,</div><div class=\"line\">    &quot;method&quot;: &quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;port_password&quot;:</div><div class=\"line\">    &#123;</div><div class=\"line\">        &quot;40001&quot;: &quot;password1&quot;,</div><div class=\"line\">        &quot;40002&quot;: &quot;password2&quot;,</div><div class=\"line\">        &quot;40003&quot;: &quot;password3&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;_comment&quot;:</div><div class=\"line\">    &#123;</div><div class=\"line\">        &quot;40001&quot;: &quot;xiaoming&quot;,</div><div class=\"line\">        &quot;40002&quot;: &quot;lilei&quot;,</div><div class=\"line\">        &quot;40003&quot;: &quot;mike&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意这边 server 的地址可以通过 ipconfig 获取本机地址，如果是一些多层虚拟出来的机器，如果无法获得本机IP，则输入0.0.0.0即可。</p>\n<ul>\n<li>安装 supervisor： apt-get install supervisor</li>\n<li>将 shadowsocks 加入到 supervisor 中进行管理：vim /etc/supervisor/supervisord.conf 在末尾加入如下内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">[program:shadowsocks]</div><div class=\"line\">command=ssserver -c /etc/shadowsocks.json</div><div class=\"line\">autostart=true</div><div class=\"line\">autorestart=true</div><div class=\"line\">user=root</div><div class=\"line\">log_stderr=true</div><div class=\"line\">logfile=/var/log/shadowsocks.log</div></pre></td></tr></table></figure>\n<ul>\n<li>最后让 supervisor 开机自启动：在 <code>vim /etc/rc.local</code> 空白行加入 <code>service supervisor restart</code> (事实上这一步可以不用加，supervisor 本身就会开机自启动，在 <code>/etc/rc2.d/</code> 下 我们可以看到 <code>lrwxrwxrwx 1 root root  20 Nov 25 11:56 S01supervisor -&gt; ../init.d/supervisor</code> ，当然如果你的系统没能自动开启 supervisor 守护进程，则需要手动完成上述操作)，重启服务器查看是否配置成功。</li>\n</ul>\n<p><em>采用 supervisor 的原因很大程度上是：将 <code>sslocal -c /etc/shadowsocks.json</code> 放入/etc/rc.local中没法开启自启该服务，有待查找原因。</em></p>\n<p><strong>以上内容均为个人总结转述，如果可以访问外网，请参考<a href=\"https://shadowsocks.org/en/download/servers.html\" target=\"_blank\" rel=\"external\">官网</a>给出的更加详细的配置步骤。以下为客户端配置，注意只有在完成了服务器端配置或者你已经有一个可以使用的 shadowsocks 服务器，才能够在本地搭建以下服务。</strong></p>\n<h3 id=\"本地-linux-下的安装配置\"><a href=\"#本地-linux-下的安装配置\" class=\"headerlink\" title=\"本地 linux 下的安装配置\"></a>本地 linux 下的安装配置</h3><h4 id=\"软件列表：-1\"><a href=\"#软件列表：-1\" class=\"headerlink\" title=\"软件列表：\"></a>软件列表：</h4><ul>\n<li>linux PC端： shadowsocks ， 本地操作系统 ubuntu 16.04 , 。</li>\n<li>shadowsocks-severs： 注意安装 shadowsocks 的 severs 版本</li>\n<li>supervisor ： 用于Linux后台进程管理的利器</li>\n<li>chrome 插件 SwitchyOmega ：</li>\n</ul>\n<h4 id=\"详细步骤：-1\"><a href=\"#详细步骤：-1\" class=\"headerlink\" title=\"详细步骤：\"></a>详细步骤：</h4><ul>\n<li>安装 shadowsocks （我们这边不采用 GUI 软件而直接使用 shadowsocks 命令工具连接 shadowsocks 服务器。）步骤如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install python-pip</div><div class=\"line\">sudo apt-get install python-setuptools m2crypto</div><div class=\"line\">pip install shadowsocks</div><div class=\"line\"></div><div class=\"line\">注意： 如果是 ubuntu 16.04 的版本执行完以上命令后可能仍然无法执行 sslocal 命令，需要手动执行 `sudo apt install shadowsocks` （ubuntu16.04 直接可以直接用apt 而不用 apt-get 这是一项改进）。</div></pre></td></tr></table></figure>\n<ul>\n<li>配置 Shadowsocks ：同服务器类似， 也是配置 shadowsocks.json 这个文件，可以在你想要指定的目录下新建这个文件如：~/.config/shadowsocks.json ， 编辑该文件：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;server&quot;:&quot;www.baidu.com&quot;,</div><div class=\"line\">    &quot;server_port&quot;:50003,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;password&quot;:&quot;123456&quot;,</div><div class=\"line\">    &quot;timeout&quot;:600,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">说明：</div><div class=\"line\">server 后面填写你需要链接的服务器地址</div><div class=\"line\">server_port 后面填写你 Shadowsocks 服务器配置的 server_port 端口</div><div class=\"line\">local_port 无需修改</div><div class=\"line\">password 需要和 Shadowsocks 服务器保持一致</div></pre></td></tr></table></figure>\n<ul>\n<li>完成以下步骤后，你的浏览器仍然不能浏览网页，Shadowsocks 仅提供了转发服务，而你本地的端口发送的数据还无法和server_port进行链接，这时候，你可以采用全局代理的软件让所有数据帮转发，这边推荐chrome的 SwitchyOmega 插件。可以从Github上直接下载最新版 <a href=\"https://github.com/FelisCatus/SwitchyOmega/releases/\" target=\"_blank\" rel=\"external\">SwitchyOmega</a> （这个是chrome的）然后浏览器地址打开chrome://extensions/，将下载的插件托进去安装。安装好之后下面开始设置代理，如下图：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/1.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/2.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/3.png\" alt=\"\"></p>\n<p>上图步骤中注意类型条件中勾选<strong>规则列表规则</strong>， 规则地址： <a href=\"https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\" target=\"_blank\" rel=\"external\">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a> 填入其中。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/4.png\" alt=\"\"></p>\n<p>点击 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。</p>\n<p>如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。</p>\n<ul>\n<li>安装 supervisor： sudo apt-get install supervisor</li>\n<li>将 shadowsocks 加入到 supervisor 中进行管理：vim /etc/supervisor/supervisor.conf 在末尾加入如下内容，或者在 /etc/supervisor/conf.d 下新建新的文件增加如下内容（注意 shadowsocks.json 文件路径写对）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">[program:shadowsocks]</div><div class=\"line\">command=sslocal -c /home/username/.config/shadowsocks.json</div><div class=\"line\">autostart=true</div><div class=\"line\">autorestart=true</div><div class=\"line\">user=root</div><div class=\"line\">log_stderr=true</div><div class=\"line\">logfile=/var/log/shadowsocks.log</div></pre></td></tr></table></figure>\n<ul>\n<li>最后让 supervisor 开机自启动：在 <code>sudo vim /etc/rc.local</code> 空白行加入 <code>sudo service supervisor restart</code>。<em>不知出于什么原因这边 supervisor 必须手动写入 /etc/rc.local 中才会开机自启动</em> 查看是否配置成功可以重启电脑。</li>\n</ul>\n<p><em>如果需要让 linux 下其他软件也都可以使用 ss 服务，可以参考我的另外一篇文章：linux-shadowsocks全局代理。</em></p>\n<h3 id=\"本地-windows-下安装配置\"><a href=\"#本地-windows-下安装配置\" class=\"headerlink\" title=\"本地 windows 下安装配置\"></a>本地 windows 下安装配置</h3><p><a href=\"https://github.com/shadowsocks/shadowsocks-windows/releases/download/3.3.5/Shadowsocks-3.3.5.zip\" target=\"_blank\" rel=\"external\">下载客户端</a>，作为一个开源软件 GUI 客户端分为多个版本，这边提供了 win 版本，需要安装 微软的库，打开后如下图所示：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/5.png\" alt=\"\"></p>\n<p>这边的服务器 IP 同上面 linux 的类似，填写你的域名或者 IP 即可，密码也要和服务器的 shadowsocks 服务保持一致。值得一提的是 windows 下面的客户端直接可以设置全局代理，右击任务栏的小图标可以设置相关选项。</p>\n<h3 id=\"本地-安卓手机端-安装配置\"><a href=\"#本地-安卓手机端-安装配置\" class=\"headerlink\" title=\"本地 安卓手机端 安装配置\"></a>本地 安卓手机端 安装配置</h3><p>安卓用户这边推荐使用腾讯自家的应用宝，直接搜索 shadowsocks 会看到中文名“影梭”的这个软件(<em>注意应用宝中的软件版本较老，为 2.8.3 目前最新版本为 3.2.7。</em>)，设置基本和 windows 的类似，设置完毕后，点击右上角的开启按钮。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/6.png\" alt=\"\"></p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://vc2tea.com/whats-shadowsocks/\" target=\"_blank\" rel=\"external\">http://vc2tea.com/whats-shadowsocks/</a><br><a href=\"https://aitanlu.com/ubuntu-shadowsocks-ke-hu-duan-pei-zhi.html\" target=\"_blank\" rel=\"external\">https://aitanlu.com/ubuntu-shadowsocks-ke-hu-duan-pei-zhi.html</a><br><a href=\"https://aitanlu.com/linux-ubuntu-install-shadowsocks.html\" target=\"_blank\" rel=\"external\">https://aitanlu.com/linux-ubuntu-install-shadowsocks.html</a><br><a href=\"https://php-rmcr7.rhcloud.com/shadowsocks-server/\" target=\"_blank\" rel=\"external\">https://php-rmcr7.rhcloud.com/shadowsocks-server/</a><br><a href=\"http://blog.chinaunix.net/uid-25530360-id-5595974.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-25530360-id-5595974.html</a><br><a href=\"http://www.liaoxuefeng.com/article/0013738926914703df5e93589a14c19807f0e285194fe84000\" target=\"_blank\" rel=\"external\">http://www.liaoxuefeng.com/article/0013738926914703df5e93589a14c19807f0e285194fe84000</a><br><a href=\"https://zh.wikipedia.org/zh-hans/Shadowsocks\" target=\"_blank\" rel=\"external\">https://zh.wikipedia.org/zh-hans/Shadowsocks</a><br><a href=\"https://github.com/shadowsocks/shadowsocks/tree/master\" target=\"_blank\" rel=\"external\">https://github.com/shadowsocks/shadowsocks/tree/master</a><br><a href=\"http://webcache.googleusercontent.com/search?q=cache:http://everet.org/shadowsocks.html\" target=\"_blank\" rel=\"external\">http://webcache.googleusercontent.com/search?q=cache:http://everet.org/shadowsocks.html</a></p>\n</blockquote>\n","excerpt":"<p>日常生活中，由于GFW的强大，很多学习资料等内容我们无法获取或者检索，因此科学上网往往相当重要，本文章使用 VPS 搭建 shadowsocks 服务让安全的科学上网成为可能，需要注意的是 VPS 必须是境外服务器，推荐 vultr 搬瓦工等廉价vpn。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p><strong>这边可以参考<a href=\"http://vc2tea.com/whats-shadowsocks/\">原文博客</a>，以下只是简单罗列一些原理：</strong></p>\n<ul>\n<li>早期互联网用户访问网站时，用户的请求通过互联网发送到服务提供方，服务提供方直接将信息反馈给用户： </li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss1.png\" alt=\"\"></p>\n<ul>\n<li>GFW 出现后，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容 </li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss2.png\" alt=\"\"></p>\n<ul>\n<li>为了绕过GFW的过滤（包含了各种HTTP代理服务、Socks服务、VPN服务等等），以 ssh tunnel 的方法为例：1) 首先用户和境外服务器基于 ssh 建立起一条加密的通道 2-3) 用户通过建立起的隧道进行代理，通过 ssh server 向真实的服务发起请求 4-5) 服务通过 ssh server，再通过创建好的隧道返回给用户。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss3.png\" alt=\"\"></p>\n<p><strong>由于 ssh 本身就是基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，ssh 本身的特征是明显的，所以 GFW 一度通过分析连接的特征进行干扰，导致 ssh 存在被定向进行干扰的问题</strong></p>\n<ul>\n<li>shadowsocks 是将原来 ssh 创建的 Socks5 协议拆开成 server 端和 client 端，所以下面这个原理图基本上和利用 ssh tunnel 大致类似:1、6) 客户端发出的请求基于 Socks5 协议跟 ss-local 端进行通讯，由于这个 ss-local 一般是本机或路由器或局域网的其他机器，不经过 GFW，所以解决了上面被 GFW 通过特征分析进行干扰的问题 2、5) ss-local 和 ss-server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密 3、4) ss-server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回:</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/ss4.png\" alt=\"\"></p>\n<ul>\n<li>GFW 就出现了，他像一个收过路费的强盗一样夹在了在用户和服务之间，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容 </li>\n</ul>\n<h3 id=\"软件简介：\"><a href=\"#软件简介：\" class=\"headerlink\" title=\"软件简介：\"></a>软件简介：</h3><h4 id=\"shadowsocks\"><a href=\"#shadowsocks\" class=\"headerlink\" title=\"shadowsocks:\"></a>shadowsocks:</h4><p><a href=\"https://shadowsocks.org/en/index.html\">shadowsocks：A secure socks5 proxy,designed to protect your Internet traffic.</a>。</p>\n<p>Shadowsocks（中文名称：影梭）是使用Python、C++、C#等语言开发的、基于Apache许可证的开放源代码软件，用于保护网络流量、加密数据传输。Shadowsocks使用Socks5代理方式。Shadowsocks分为服务器端和客户端。在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。在中国大陆，本工具也被广泛用于突破防火长城（GFW），以浏览被封锁、屏蔽或干扰的内容。在2015年8月22日，Shadowsocks原作者Clowwindy称受到了中国政府的压力，宣布停止维护此项目并移除其用户页面所载的源代码。</p>\n<p>Shadowsocks的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。在服务器端部署完成后，用户需要按照指定的密码、加密方式和端口使用客户端软件与其连接。在成功连接到服务器后，客户端会在用户的电脑上构建一个本地Socks5代理。浏览网络时，网络流量会被分到本地socks5代理，客户端将其加密之后发送到服务器，服务器以同样的加密方式将流量回传给客户端，以此实现代理上网。</p>\n<ul>\n<li>Shadowsocks使用自行设计的协议进行加密通信。[4]加密算法有AES、Blowfish、IDEA、RC4等，除创建TCP连接外无需握手，每次请求只转发一个连接，因此使用起来网速较快，在移动设备上也比较省电。</li>\n<li>所有的流量都经过算法加密，允许自行选择算法，所以比较安全。</li>\n<li>Shadowsocks通过异步I/O和事件驱动程序运行，响应速度快。</li>\n<li>客户端覆盖多个主流操作系统和平台，包括Windows，OS X，Android和iOS系统和路由器（OpenWrt）等[5]。</li>\n<li>专为移动设备和无线网络优化。</li>\n</ul>\n<h4 id=\"supervisor\"><a href=\"#supervisor\" class=\"headerlink\" title=\"supervisor:\"></a>supervisor:</h4><p>Linux的后台进程运行有好几种方法，例如nohup，screen等，但是，如果是一个服务程序，要可靠地在后台运行，我们就需要把它做成daemon，最好还能监控进程状态，在意外结束时能自动重启。supervisor就是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。</p>\n<h3 id=\"VPS-安装及配置：\"><a href=\"#VPS-安装及配置：\" class=\"headerlink\" title=\"VPS 安装及配置：\"></a>VPS 安装及配置：</h3><h4 id=\"软件列表：\"><a href=\"#软件列表：\" class=\"headerlink\" title=\"软件列表：\"></a>软件列表：</h4><ul>\n<li>vps（Debian GNU/Linux 7 ），这边采用 Debian 系列linux，ubuntu 应该步骤类似，如果使用 redhat 系列，部分指令需要自行更改，这边不做累述。</li>\n<li>shadowsocks-severs： 注意安装 shadowsocks 的 severs 版本</li>\n<li>supervisor ： 用于Linux后台进程管理的利器</li>\n</ul>","more":"<h4 id=\"详细步骤：\"><a href=\"#详细步骤：\" class=\"headerlink\" title=\"详细步骤：\"></a>详细步骤：</h4><ul>\n<li>安装软件，终端输入：<code>apt-get install python-pip &amp;&amp; pip install shadowsocks</code>。</li>\n<li>写 shadowsocks 配置文件： vim /etc/shadowsocks.json ， 具体内容如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;server&quot;:&quot;0.0.0.0&quot;,</div><div class=\"line\">    &quot;server_port&quot;:50003,</div><div class=\"line\">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;password&quot;:&quot;123456&quot;,</div><div class=\"line\">    &quot;timeout&quot;:300,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;fast_open&quot;: false</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">说明： </div><div class=\"line\">server 你vps的IP</div><div class=\"line\">servier_port 服务端的端口</div><div class=\"line\">local_port 本地端口，一般默认1080</div><div class=\"line\">password 服务端设置的密码</div><div class=\"line\">timeout 超时设置</div><div class=\"line\">method 加密方法</div><div class=\"line\"></div><div class=\"line\">如要你需要分享SS服务给朋友或家人，可以配置多个SS账户，具体可以参考下面的代码:</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;timeout&quot;: 600,</div><div class=\"line\">    &quot;method&quot;: &quot;aes-256-cfb&quot;,</div><div class=\"line\">    &quot;port_password&quot;:</div><div class=\"line\">    &#123;</div><div class=\"line\">        &quot;40001&quot;: &quot;password1&quot;,</div><div class=\"line\">        &quot;40002&quot;: &quot;password2&quot;,</div><div class=\"line\">        &quot;40003&quot;: &quot;password3&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;_comment&quot;:</div><div class=\"line\">    &#123;</div><div class=\"line\">        &quot;40001&quot;: &quot;xiaoming&quot;,</div><div class=\"line\">        &quot;40002&quot;: &quot;lilei&quot;,</div><div class=\"line\">        &quot;40003&quot;: &quot;mike&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意这边 server 的地址可以通过 ipconfig 获取本机地址，如果是一些多层虚拟出来的机器，如果无法获得本机IP，则输入0.0.0.0即可。</p>\n<ul>\n<li>安装 supervisor： apt-get install supervisor</li>\n<li>将 shadowsocks 加入到 supervisor 中进行管理：vim /etc/supervisor/supervisord.conf 在末尾加入如下内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">[program:shadowsocks]</div><div class=\"line\">command=ssserver -c /etc/shadowsocks.json</div><div class=\"line\">autostart=true</div><div class=\"line\">autorestart=true</div><div class=\"line\">user=root</div><div class=\"line\">log_stderr=true</div><div class=\"line\">logfile=/var/log/shadowsocks.log</div></pre></td></tr></table></figure>\n<ul>\n<li>最后让 supervisor 开机自启动：在 <code>vim /etc/rc.local</code> 空白行加入 <code>service supervisor restart</code> (事实上这一步可以不用加，supervisor 本身就会开机自启动，在 <code>/etc/rc2.d/</code> 下 我们可以看到 <code>lrwxrwxrwx 1 root root  20 Nov 25 11:56 S01supervisor -&gt; ../init.d/supervisor</code> ，当然如果你的系统没能自动开启 supervisor 守护进程，则需要手动完成上述操作)，重启服务器查看是否配置成功。</li>\n</ul>\n<p><em>采用 supervisor 的原因很大程度上是：将 <code>sslocal -c /etc/shadowsocks.json</code> 放入/etc/rc.local中没法开启自启该服务，有待查找原因。</em></p>\n<p><strong>以上内容均为个人总结转述，如果可以访问外网，请参考<a href=\"https://shadowsocks.org/en/download/servers.html\">官网</a>给出的更加详细的配置步骤。以下为客户端配置，注意只有在完成了服务器端配置或者你已经有一个可以使用的 shadowsocks 服务器，才能够在本地搭建以下服务。</strong></p>\n<h3 id=\"本地-linux-下的安装配置\"><a href=\"#本地-linux-下的安装配置\" class=\"headerlink\" title=\"本地 linux 下的安装配置\"></a>本地 linux 下的安装配置</h3><h4 id=\"软件列表：-1\"><a href=\"#软件列表：-1\" class=\"headerlink\" title=\"软件列表：\"></a>软件列表：</h4><ul>\n<li>linux PC端： shadowsocks ， 本地操作系统 ubuntu 16.04 , 。</li>\n<li>shadowsocks-severs： 注意安装 shadowsocks 的 severs 版本</li>\n<li>supervisor ： 用于Linux后台进程管理的利器</li>\n<li>chrome 插件 SwitchyOmega ：</li>\n</ul>\n<h4 id=\"详细步骤：-1\"><a href=\"#详细步骤：-1\" class=\"headerlink\" title=\"详细步骤：\"></a>详细步骤：</h4><ul>\n<li>安装 shadowsocks （我们这边不采用 GUI 软件而直接使用 shadowsocks 命令工具连接 shadowsocks 服务器。）步骤如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install python-pip</div><div class=\"line\">sudo apt-get install python-setuptools m2crypto</div><div class=\"line\">pip install shadowsocks</div><div class=\"line\"></div><div class=\"line\">注意： 如果是 ubuntu 16.04 的版本执行完以上命令后可能仍然无法执行 sslocal 命令，需要手动执行 `sudo apt install shadowsocks` （ubuntu16.04 直接可以直接用apt 而不用 apt-get 这是一项改进）。</div></pre></td></tr></table></figure>\n<ul>\n<li>配置 Shadowsocks ：同服务器类似， 也是配置 shadowsocks.json 这个文件，可以在你想要指定的目录下新建这个文件如：~/.config/shadowsocks.json ， 编辑该文件：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;server&quot;:&quot;www.baidu.com&quot;,</div><div class=\"line\">    &quot;server_port&quot;:50003,</div><div class=\"line\">    &quot;local_port&quot;:1080,</div><div class=\"line\">    &quot;password&quot;:&quot;123456&quot;,</div><div class=\"line\">    &quot;timeout&quot;:600,</div><div class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">说明：</div><div class=\"line\">server 后面填写你需要链接的服务器地址</div><div class=\"line\">server_port 后面填写你 Shadowsocks 服务器配置的 server_port 端口</div><div class=\"line\">local_port 无需修改</div><div class=\"line\">password 需要和 Shadowsocks 服务器保持一致</div></pre></td></tr></table></figure>\n<ul>\n<li>完成以下步骤后，你的浏览器仍然不能浏览网页，Shadowsocks 仅提供了转发服务，而你本地的端口发送的数据还无法和server_port进行链接，这时候，你可以采用全局代理的软件让所有数据帮转发，这边推荐chrome的 SwitchyOmega 插件。可以从Github上直接下载最新版 <a href=\"https://github.com/FelisCatus/SwitchyOmega/releases/\">SwitchyOmega</a> （这个是chrome的）然后浏览器地址打开chrome://extensions/，将下载的插件托进去安装。安装好之后下面开始设置代理，如下图：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/1.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/2.png\" alt=\"\"></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/3.png\" alt=\"\"></p>\n<p>上图步骤中注意类型条件中勾选<strong>规则列表规则</strong>， 规则地址： <a href=\"https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a> 填入其中。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/4.png\" alt=\"\"></p>\n<p>点击 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。</p>\n<p>如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。</p>\n<ul>\n<li>安装 supervisor： sudo apt-get install supervisor</li>\n<li>将 shadowsocks 加入到 supervisor 中进行管理：vim /etc/supervisor/supervisor.conf 在末尾加入如下内容，或者在 /etc/supervisor/conf.d 下新建新的文件增加如下内容（注意 shadowsocks.json 文件路径写对）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">[program:shadowsocks]</div><div class=\"line\">command=sslocal -c /home/username/.config/shadowsocks.json</div><div class=\"line\">autostart=true</div><div class=\"line\">autorestart=true</div><div class=\"line\">user=root</div><div class=\"line\">log_stderr=true</div><div class=\"line\">logfile=/var/log/shadowsocks.log</div></pre></td></tr></table></figure>\n<ul>\n<li>最后让 supervisor 开机自启动：在 <code>sudo vim /etc/rc.local</code> 空白行加入 <code>sudo service supervisor restart</code>。<em>不知出于什么原因这边 supervisor 必须手动写入 /etc/rc.local 中才会开机自启动</em> 查看是否配置成功可以重启电脑。</li>\n</ul>\n<p><em>如果需要让 linux 下其他软件也都可以使用 ss 服务，可以参考我的另外一篇文章：linux-shadowsocks全局代理。</em></p>\n<h3 id=\"本地-windows-下安装配置\"><a href=\"#本地-windows-下安装配置\" class=\"headerlink\" title=\"本地 windows 下安装配置\"></a>本地 windows 下安装配置</h3><p><a href=\"https://github.com/shadowsocks/shadowsocks-windows/releases/download/3.3.5/Shadowsocks-3.3.5.zip\">下载客户端</a>，作为一个开源软件 GUI 客户端分为多个版本，这边提供了 win 版本，需要安装 微软的库，打开后如下图所示：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/5.png\" alt=\"\"></p>\n<p>这边的服务器 IP 同上面 linux 的类似，填写你的域名或者 IP 即可，密码也要和服务器的 shadowsocks 服务保持一致。值得一提的是 windows 下面的客户端直接可以设置全局代理，右击任务栏的小图标可以设置相关选项。</p>\n<h3 id=\"本地-安卓手机端-安装配置\"><a href=\"#本地-安卓手机端-安装配置\" class=\"headerlink\" title=\"本地 安卓手机端 安装配置\"></a>本地 安卓手机端 安装配置</h3><p>安卓用户这边推荐使用腾讯自家的应用宝，直接搜索 shadowsocks 会看到中文名“影梭”的这个软件(<em>注意应用宝中的软件版本较老，为 2.8.3 目前最新版本为 3.2.7。</em>)，设置基本和 windows 的类似，设置完毕后，点击右上角的开启按钮。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-25-vps-shadowsocks/6.png\" alt=\"\"></p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://vc2tea.com/whats-shadowsocks/\">http://vc2tea.com/whats-shadowsocks/</a><br><a href=\"https://aitanlu.com/ubuntu-shadowsocks-ke-hu-duan-pei-zhi.html\">https://aitanlu.com/ubuntu-shadowsocks-ke-hu-duan-pei-zhi.html</a><br><a href=\"https://aitanlu.com/linux-ubuntu-install-shadowsocks.html\">https://aitanlu.com/linux-ubuntu-install-shadowsocks.html</a><br><a href=\"https://php-rmcr7.rhcloud.com/shadowsocks-server/\">https://php-rmcr7.rhcloud.com/shadowsocks-server/</a><br><a href=\"http://blog.chinaunix.net/uid-25530360-id-5595974.html\">http://blog.chinaunix.net/uid-25530360-id-5595974.html</a><br><a href=\"http://www.liaoxuefeng.com/article/0013738926914703df5e93589a14c19807f0e285194fe84000\">http://www.liaoxuefeng.com/article/0013738926914703df5e93589a14c19807f0e285194fe84000</a><br><a href=\"https://zh.wikipedia.org/zh-hans/Shadowsocks\">https://zh.wikipedia.org/zh-hans/Shadowsocks</a><br><a href=\"https://github.com/shadowsocks/shadowsocks/tree/master\">https://github.com/shadowsocks/shadowsocks/tree/master</a><br><a href=\"http://webcache.googleusercontent.com/search?q=cache:http://everet.org/shadowsocks.html\">http://webcache.googleusercontent.com/search?q=cache:http://everet.org/shadowsocks.html</a></p>\n</blockquote>"},{"layout":"post","title":"PuTTY + Xming 远程使用 Linux GUI","date":"2016-12-01T04:11:00.000Z","_content":"\n就目前而言，将 linux 作为个人电脑操作系统使用的人还比较少，而 linux 也一直以来因为其占用资源少，系统稳定，强大的 CLI 而闻名于世。因此显而易见，广大用户一般都是通过 ssh 等方式登录连接 linux ，然后使用 CLI 完成需要的操作，而使用 linux GUI 用户较少，甚至可以被忽略，但出于个人的需要，本人需要通过 windows 远程登录 linux 然后通过 chrome 等\n\n\n### 操作系统：\n\n- windows 7 x64 中文旗舰版\n- ubuntu 16.04 \n\n<!-- more -->\n\n\n### 软件配置：\n\n#### Xming ：\n\nXming是一个在 Microsoft Windows 操作系统上运行 X Window System 的自由软件。其主要功能是通过在Linux平台上通过交叉编译的方法，实现了跨越操作系统对X GUI的表现。\n\n正常安装该软件：这边使用过的是： Xming-6-9-0-31-setup.exe 的版本，正常安装过，一般都没有问题，设置按照下图选择不安装 ssh client。 Display 设置按照个人习惯进行设置，如果仅是打开个别 GUI 窗口的话，建议采用 Multiple windows ，可以讲所有的 GUI 窗口作为一个个应用进行打开。接下来按照默认设置进行下一步即可，另外最后一步可以保存当前设置作为一个快捷方式，下次直接打开即可。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/1.png)\n\n#### putty :\n\nPuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件。较早的版本仅支持Windows平台，在最近的版本中开始支持各类Unix平台，并打算移植至Mac OS X上。自带SSH Forwarding的功能，包括X11 Forwarding。\n\n- 输入需要拨号的地址（这边注意本机和目标机器在同一个网段）\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/2.png)\n\n- 设置拨号的账户名，方便下次登录\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/3.png)\n\n- 一定要打开 X11 转发模式，可以让 ssh 图形化转发给 Xming 进行工作。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/4.png)\n\n#### SecureCRT 方式（可以跳过）\n\n这边补充 SecureCRT 这个软件的方式，原理和 putty 类似，得益于 SecureCRT 在用户界面上面更加友好方便，常常用作远程管理使用，如果已经使用了 putty 的这边可以跳过，两种方式选其一即可。\n\nSecureCRT 同 putty 类似，设置时，需要在 session options -> connection -> port forwarding -> remote/x11 中勾选 x11 forwarding 下面的 forward x11 packets 和 enforce x11 authentication 。注意：不需要添加 remotely forwarded connections 中的内容。\n\n#### linux端设置\n\n- 要允许Linux主机上的SSH X转发，查看 /etc/ssh/sshd_config 文件，加入以下一行，`X11Forwrding yes` 至此配置完成。\n- 保证 linux 端至少要有多个可以访问的用户。\n\n#### 工作运行\n\n- 上述部分 putty 设置完成后，开始登录，注意使用不同于 linux 上已经登录图形界面的账户登录 putty 。\n- 在 windows 上使用 PuTTY 连接到 linux ，输入 xclock & ，可以看到一个图形化时钟出现了，说明图形化转发已经成功了。\n- 输入 `google-chrome` 则可以在 xming 中打开 chrome 浏览器进行需要的操作了。\n- 输入 `gnome-session` 则可以远程打开 GUI 交互环境。\n\n**这边要注意的是：如果 putty 和 linux GUI 登录了同一个账号，则输入相关命令可能会无法打开相关 GUI，检查发现事实上，你要打开的窗口在 linux 主机上面被打开了，因此最好的办法是登录一个新的账号，进行相关的图形化操作。**\n\n\n#### 小结\n\n通过步骤可以发现，PuTTY + Xming 或 SecureCRT + Xming 的配置较为简单，但效率较低，即便传输速率达到 4mb/s 图像依然刷新较慢，体验效果很差。可能是 ssh 的直接访问方式，没有对视频等多媒体进行过优化，推荐可以采用其他方式进行远程桌面连接，这边可以参考博客中另外一篇文章 *TeamViewer 远程控制*。\n\n\n\n\n> 参考链接：\n> http://www.zw1840.com/blog/zw1840/2008/10/putty-xming-linux-gui.html\n","source":"_posts/2016/2016-12-01-putty-xming-远程使用-linux-gui.md","raw":"---\nlayout: \"post\"\ntitle: \"PuTTY + Xming 远程使用 Linux GUI\"\ndate: \"2016-12-01 12:11\"\n---\n\n就目前而言，将 linux 作为个人电脑操作系统使用的人还比较少，而 linux 也一直以来因为其占用资源少，系统稳定，强大的 CLI 而闻名于世。因此显而易见，广大用户一般都是通过 ssh 等方式登录连接 linux ，然后使用 CLI 完成需要的操作，而使用 linux GUI 用户较少，甚至可以被忽略，但出于个人的需要，本人需要通过 windows 远程登录 linux 然后通过 chrome 等\n\n\n### 操作系统：\n\n- windows 7 x64 中文旗舰版\n- ubuntu 16.04 \n\n<!-- more -->\n\n\n### 软件配置：\n\n#### Xming ：\n\nXming是一个在 Microsoft Windows 操作系统上运行 X Window System 的自由软件。其主要功能是通过在Linux平台上通过交叉编译的方法，实现了跨越操作系统对X GUI的表现。\n\n正常安装该软件：这边使用过的是： Xming-6-9-0-31-setup.exe 的版本，正常安装过，一般都没有问题，设置按照下图选择不安装 ssh client。 Display 设置按照个人习惯进行设置，如果仅是打开个别 GUI 窗口的话，建议采用 Multiple windows ，可以讲所有的 GUI 窗口作为一个个应用进行打开。接下来按照默认设置进行下一步即可，另外最后一步可以保存当前设置作为一个快捷方式，下次直接打开即可。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/1.png)\n\n#### putty :\n\nPuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件。较早的版本仅支持Windows平台，在最近的版本中开始支持各类Unix平台，并打算移植至Mac OS X上。自带SSH Forwarding的功能，包括X11 Forwarding。\n\n- 输入需要拨号的地址（这边注意本机和目标机器在同一个网段）\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/2.png)\n\n- 设置拨号的账户名，方便下次登录\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/3.png)\n\n- 一定要打开 X11 转发模式，可以让 ssh 图形化转发给 Xming 进行工作。\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/4.png)\n\n#### SecureCRT 方式（可以跳过）\n\n这边补充 SecureCRT 这个软件的方式，原理和 putty 类似，得益于 SecureCRT 在用户界面上面更加友好方便，常常用作远程管理使用，如果已经使用了 putty 的这边可以跳过，两种方式选其一即可。\n\nSecureCRT 同 putty 类似，设置时，需要在 session options -> connection -> port forwarding -> remote/x11 中勾选 x11 forwarding 下面的 forward x11 packets 和 enforce x11 authentication 。注意：不需要添加 remotely forwarded connections 中的内容。\n\n#### linux端设置\n\n- 要允许Linux主机上的SSH X转发，查看 /etc/ssh/sshd_config 文件，加入以下一行，`X11Forwrding yes` 至此配置完成。\n- 保证 linux 端至少要有多个可以访问的用户。\n\n#### 工作运行\n\n- 上述部分 putty 设置完成后，开始登录，注意使用不同于 linux 上已经登录图形界面的账户登录 putty 。\n- 在 windows 上使用 PuTTY 连接到 linux ，输入 xclock & ，可以看到一个图形化时钟出现了，说明图形化转发已经成功了。\n- 输入 `google-chrome` 则可以在 xming 中打开 chrome 浏览器进行需要的操作了。\n- 输入 `gnome-session` 则可以远程打开 GUI 交互环境。\n\n**这边要注意的是：如果 putty 和 linux GUI 登录了同一个账号，则输入相关命令可能会无法打开相关 GUI，检查发现事实上，你要打开的窗口在 linux 主机上面被打开了，因此最好的办法是登录一个新的账号，进行相关的图形化操作。**\n\n\n#### 小结\n\n通过步骤可以发现，PuTTY + Xming 或 SecureCRT + Xming 的配置较为简单，但效率较低，即便传输速率达到 4mb/s 图像依然刷新较慢，体验效果很差。可能是 ssh 的直接访问方式，没有对视频等多媒体进行过优化，推荐可以采用其他方式进行远程桌面连接，这边可以参考博客中另外一篇文章 *TeamViewer 远程控制*。\n\n\n\n\n> 参考链接：\n> http://www.zw1840.com/blog/zw1840/2008/10/putty-xming-linux-gui.html\n","slug":"2016/2016-12-01-putty-xming-远程使用-linux-gui","published":1,"updated":"2016-12-16T01:51:05.895Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aj3003nmumuhrzfkkjz","content":"<p>就目前而言，将 linux 作为个人电脑操作系统使用的人还比较少，而 linux 也一直以来因为其占用资源少，系统稳定，强大的 CLI 而闻名于世。因此显而易见，广大用户一般都是通过 ssh 等方式登录连接 linux ，然后使用 CLI 完成需要的操作，而使用 linux GUI 用户较少，甚至可以被忽略，但出于个人的需要，本人需要通过 windows 远程登录 linux 然后通过 chrome 等</p>\n<h3 id=\"操作系统：\"><a href=\"#操作系统：\" class=\"headerlink\" title=\"操作系统：\"></a>操作系统：</h3><ul>\n<li>windows 7 x64 中文旗舰版</li>\n<li>ubuntu 16.04 </li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"软件配置：\"><a href=\"#软件配置：\" class=\"headerlink\" title=\"软件配置：\"></a>软件配置：</h3><h4 id=\"Xming-：\"><a href=\"#Xming-：\" class=\"headerlink\" title=\"Xming ：\"></a>Xming ：</h4><p>Xming是一个在 Microsoft Windows 操作系统上运行 X Window System 的自由软件。其主要功能是通过在Linux平台上通过交叉编译的方法，实现了跨越操作系统对X GUI的表现。</p>\n<p>正常安装该软件：这边使用过的是： Xming-6-9-0-31-setup.exe 的版本，正常安装过，一般都没有问题，设置按照下图选择不安装 ssh client。 Display 设置按照个人习惯进行设置，如果仅是打开个别 GUI 窗口的话，建议采用 Multiple windows ，可以讲所有的 GUI 窗口作为一个个应用进行打开。接下来按照默认设置进行下一步即可，另外最后一步可以保存当前设置作为一个快捷方式，下次直接打开即可。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/1.png\" alt=\"\"></p>\n<h4 id=\"putty\"><a href=\"#putty\" class=\"headerlink\" title=\"putty :\"></a>putty :</h4><p>PuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件。较早的版本仅支持Windows平台，在最近的版本中开始支持各类Unix平台，并打算移植至Mac OS X上。自带SSH Forwarding的功能，包括X11 Forwarding。</p>\n<ul>\n<li>输入需要拨号的地址（这边注意本机和目标机器在同一个网段）</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/2.png\" alt=\"\"></p>\n<ul>\n<li>设置拨号的账户名，方便下次登录</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/3.png\" alt=\"\"></p>\n<ul>\n<li>一定要打开 X11 转发模式，可以让 ssh 图形化转发给 Xming 进行工作。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/4.png\" alt=\"\"></p>\n<h4 id=\"SecureCRT-方式（可以跳过）\"><a href=\"#SecureCRT-方式（可以跳过）\" class=\"headerlink\" title=\"SecureCRT 方式（可以跳过）\"></a>SecureCRT 方式（可以跳过）</h4><p>这边补充 SecureCRT 这个软件的方式，原理和 putty 类似，得益于 SecureCRT 在用户界面上面更加友好方便，常常用作远程管理使用，如果已经使用了 putty 的这边可以跳过，两种方式选其一即可。</p>\n<p>SecureCRT 同 putty 类似，设置时，需要在 session options -&gt; connection -&gt; port forwarding -&gt; remote/x11 中勾选 x11 forwarding 下面的 forward x11 packets 和 enforce x11 authentication 。注意：不需要添加 remotely forwarded connections 中的内容。</p>\n<h4 id=\"linux端设置\"><a href=\"#linux端设置\" class=\"headerlink\" title=\"linux端设置\"></a>linux端设置</h4><ul>\n<li>要允许Linux主机上的SSH X转发，查看 /etc/ssh/sshd_config 文件，加入以下一行，<code>X11Forwrding yes</code> 至此配置完成。</li>\n<li>保证 linux 端至少要有多个可以访问的用户。</li>\n</ul>\n<h4 id=\"工作运行\"><a href=\"#工作运行\" class=\"headerlink\" title=\"工作运行\"></a>工作运行</h4><ul>\n<li>上述部分 putty 设置完成后，开始登录，注意使用不同于 linux 上已经登录图形界面的账户登录 putty 。</li>\n<li>在 windows 上使用 PuTTY 连接到 linux ，输入 xclock &amp; ，可以看到一个图形化时钟出现了，说明图形化转发已经成功了。</li>\n<li>输入 <code>google-chrome</code> 则可以在 xming 中打开 chrome 浏览器进行需要的操作了。</li>\n<li>输入 <code>gnome-session</code> 则可以远程打开 GUI 交互环境。</li>\n</ul>\n<p><strong>这边要注意的是：如果 putty 和 linux GUI 登录了同一个账号，则输入相关命令可能会无法打开相关 GUI，检查发现事实上，你要打开的窗口在 linux 主机上面被打开了，因此最好的办法是登录一个新的账号，进行相关的图形化操作。</strong></p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>通过步骤可以发现，PuTTY + Xming 或 SecureCRT + Xming 的配置较为简单，但效率较低，即便传输速率达到 4mb/s 图像依然刷新较慢，体验效果很差。可能是 ssh 的直接访问方式，没有对视频等多媒体进行过优化，推荐可以采用其他方式进行远程桌面连接，这边可以参考博客中另外一篇文章 <em>TeamViewer 远程控制</em>。</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.zw1840.com/blog/zw1840/2008/10/putty-xming-linux-gui.html\" target=\"_blank\" rel=\"external\">http://www.zw1840.com/blog/zw1840/2008/10/putty-xming-linux-gui.html</a></p>\n</blockquote>\n","excerpt":"<p>就目前而言，将 linux 作为个人电脑操作系统使用的人还比较少，而 linux 也一直以来因为其占用资源少，系统稳定，强大的 CLI 而闻名于世。因此显而易见，广大用户一般都是通过 ssh 等方式登录连接 linux ，然后使用 CLI 完成需要的操作，而使用 linux GUI 用户较少，甚至可以被忽略，但出于个人的需要，本人需要通过 windows 远程登录 linux 然后通过 chrome 等</p>\n<h3 id=\"操作系统：\"><a href=\"#操作系统：\" class=\"headerlink\" title=\"操作系统：\"></a>操作系统：</h3><ul>\n<li>windows 7 x64 中文旗舰版</li>\n<li>ubuntu 16.04 </li>\n</ul>","more":"<h3 id=\"软件配置：\"><a href=\"#软件配置：\" class=\"headerlink\" title=\"软件配置：\"></a>软件配置：</h3><h4 id=\"Xming-：\"><a href=\"#Xming-：\" class=\"headerlink\" title=\"Xming ：\"></a>Xming ：</h4><p>Xming是一个在 Microsoft Windows 操作系统上运行 X Window System 的自由软件。其主要功能是通过在Linux平台上通过交叉编译的方法，实现了跨越操作系统对X GUI的表现。</p>\n<p>正常安装该软件：这边使用过的是： Xming-6-9-0-31-setup.exe 的版本，正常安装过，一般都没有问题，设置按照下图选择不安装 ssh client。 Display 设置按照个人习惯进行设置，如果仅是打开个别 GUI 窗口的话，建议采用 Multiple windows ，可以讲所有的 GUI 窗口作为一个个应用进行打开。接下来按照默认设置进行下一步即可，另外最后一步可以保存当前设置作为一个快捷方式，下次直接打开即可。</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/1.png\" alt=\"\"></p>\n<h4 id=\"putty\"><a href=\"#putty\" class=\"headerlink\" title=\"putty :\"></a>putty :</h4><p>PuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件。较早的版本仅支持Windows平台，在最近的版本中开始支持各类Unix平台，并打算移植至Mac OS X上。自带SSH Forwarding的功能，包括X11 Forwarding。</p>\n<ul>\n<li>输入需要拨号的地址（这边注意本机和目标机器在同一个网段）</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/2.png\" alt=\"\"></p>\n<ul>\n<li>设置拨号的账户名，方便下次登录</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/3.png\" alt=\"\"></p>\n<ul>\n<li>一定要打开 X11 转发模式，可以让 ssh 图形化转发给 Xming 进行工作。</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/4.png\" alt=\"\"></p>\n<h4 id=\"SecureCRT-方式（可以跳过）\"><a href=\"#SecureCRT-方式（可以跳过）\" class=\"headerlink\" title=\"SecureCRT 方式（可以跳过）\"></a>SecureCRT 方式（可以跳过）</h4><p>这边补充 SecureCRT 这个软件的方式，原理和 putty 类似，得益于 SecureCRT 在用户界面上面更加友好方便，常常用作远程管理使用，如果已经使用了 putty 的这边可以跳过，两种方式选其一即可。</p>\n<p>SecureCRT 同 putty 类似，设置时，需要在 session options -&gt; connection -&gt; port forwarding -&gt; remote/x11 中勾选 x11 forwarding 下面的 forward x11 packets 和 enforce x11 authentication 。注意：不需要添加 remotely forwarded connections 中的内容。</p>\n<h4 id=\"linux端设置\"><a href=\"#linux端设置\" class=\"headerlink\" title=\"linux端设置\"></a>linux端设置</h4><ul>\n<li>要允许Linux主机上的SSH X转发，查看 /etc/ssh/sshd_config 文件，加入以下一行，<code>X11Forwrding yes</code> 至此配置完成。</li>\n<li>保证 linux 端至少要有多个可以访问的用户。</li>\n</ul>\n<h4 id=\"工作运行\"><a href=\"#工作运行\" class=\"headerlink\" title=\"工作运行\"></a>工作运行</h4><ul>\n<li>上述部分 putty 设置完成后，开始登录，注意使用不同于 linux 上已经登录图形界面的账户登录 putty 。</li>\n<li>在 windows 上使用 PuTTY 连接到 linux ，输入 xclock &amp; ，可以看到一个图形化时钟出现了，说明图形化转发已经成功了。</li>\n<li>输入 <code>google-chrome</code> 则可以在 xming 中打开 chrome 浏览器进行需要的操作了。</li>\n<li>输入 <code>gnome-session</code> 则可以远程打开 GUI 交互环境。</li>\n</ul>\n<p><strong>这边要注意的是：如果 putty 和 linux GUI 登录了同一个账号，则输入相关命令可能会无法打开相关 GUI，检查发现事实上，你要打开的窗口在 linux 主机上面被打开了，因此最好的办法是登录一个新的账号，进行相关的图形化操作。</strong></p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>通过步骤可以发现，PuTTY + Xming 或 SecureCRT + Xming 的配置较为简单，但效率较低，即便传输速率达到 4mb/s 图像依然刷新较慢，体验效果很差。可能是 ssh 的直接访问方式，没有对视频等多媒体进行过优化，推荐可以采用其他方式进行远程桌面连接，这边可以参考博客中另外一篇文章 <em>TeamViewer 远程控制</em>。</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.zw1840.com/blog/zw1840/2008/10/putty-xming-linux-gui.html\">http://www.zw1840.com/blog/zw1840/2008/10/putty-xming-linux-gui.html</a></p>\n</blockquote>"},{"layout":"post","title":"efm32 开发板问题总结","date":"2016-12-08T08:03:00.000Z","_content":"\nsilabs 的 EFM 系列芯片历来以低能耗，可信的加密而文明，比较遗憾的是，国内用的较少，且基本上没有什么中文参考资料，刚刚开办没多久的官方中文论坛贴出来的资料也大都是英文版，且论坛在 GFW 下访问相当困难。因为项目需求，这边我入手了两个系列的 EFM 开发板，但都出了大大小小的问题。\n\n个人总结：1.因为前期缺少相关指导，且官方指导手册仅告诉要如何做，却没指示相关工具的位置和使用。2.该芯片配备专有 IDE 且还分好几个版本，无疑增加了摸索的难度。3.个人经验不足，之前上手的都是开发板，没接触过这种官方自带的评估板。\n\n其实上手这个评估板并不困难，困难的是没有一个详尽的指导手册，不知道如何用评估板去烧录上面的 MCU ，如何用评估板烧录自己产品的 MCU等。\n\n\n### 评估板简介：\n\nEFM32 配套评估板 上 Jlink 是从Segger授权的, 功能上应该没有缩减。因此价格也较贵，原价 $69 现价 $29 ，一般网购的价格在 ￥200 左右，这个价位对于国内 STM32 满地跑，部分 STM32 开发板价格甚至在 100 左右来说的话，还是较贵的，最关键的是淘宝购买的厂家不承担售后服务之类的，出问题只能自己解决。\n\n另外，EFM32 官方配套软件很强大，将编码，烧录，仿真，能耗监控，文档，样例等等都集成在了一起，很多资料都需要去这个 IDE 中查找，对英语不好或者不善于摸索的人来说也是一道门槛。\n\n评估板的功能：\n- 根据你的版型，不同的板子有不同的功能，一般都会有显示器，按键，led等基本功能\n- 能耗检测模块\n- 板载 Jlink ：可以烧录板载 MCU，也可以烧录外置芯片。\n- 可以使用外置 Jlink 来烧录板载的 MCU。\n- 大多数引脚引出，且预留焊盘，另外还有 EXP 扩展口（注意 debug-out 是小灯，而不是指 EXP 扩展口）。\n\n\n<!-- more -->\n\n\n\n### 使用方法：\n\n评估板的 debug 主要分为 in,out,mcu,off 等选项，这几个选项至关重要，我们可以不使用 simplicity studio 这个 IDE，但如果需要使用这个评估板，就必须得弄清楚如何设置评估板的 debug 模式。\n\n这边我使用 simplicity v3 版本，设置 debug 模式，需要通过一个 commander 的软件，该软件在 simplicity v3 安装包中可以检索到，如果需要在 simplicity studio 中打开，则安装时需要安装无线模块套件（如果不安装这个套件，软件中无法打开这个 commander 工具，因此建议新手安装完整版的 simplicity v3 而不是只安装你所需要的芯片组建），打开 simplicity IDE 然后在 file 中打开 simplicity commander。\n\n每次使用评估板要进行相关操作时，都需要使用 commander 进行设置，详细配置说明：\n- debug-in ： 烧录评估板上面的 jlink 固件，注意烧录的是 jlink 而不是评估板的 EFM芯片。\n- debug-out : 使用评估板作为 jlink 烧录其他板子上面的外置芯片。mcu 资料中可以读出外置芯片具体信息，另外评估板有个 debug-out 灯会亮起。\n- debug-mcu : 烧录评估板上面自带的 EFM 芯片。mcu 资料中可以读出板载芯片具体信息。\n\n**评估板作为 jlink 是官方正版授权的，烧录程序一般没有问题，但如果需要打多个断点进行仿真，则可能会仿真失败，应该是和 jink 采用的芯片有关系。**\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-08-efm32-%E5%BC%80%E5%8F%91%E6%9D%BF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/1.png)\n\n\n\n### 固件烧录\n\n普通升级，官方推荐使用 Kit Manager 打开后会自动判断固件是否需要升级，事实上 Kit Manager 和 simplicity commander 功能基本相同，但 Kit Manager 更显得傻瓜式，而且也会经常出现无法打开，无法连接芯片等问题，如果遇到了这些问题，建议还是使用 simplicity commander 进行所有操作。\n\n如果无法找到 commander 工具，这边推荐给出两个该工具的下载地址：\n\n固件烧录失败后，如何重新烧录固件，步骤差不多如下：\n\n- 将评估板的 bootloader 接地（bootloader 位置各个开发板不尽相同，可以参照原理图，或者查看下面给出的参考连接），接下来连接电脑，打开 simplicity commander ，如果 bootloader 接地成功则会显示 j-link device 信息，否则读取不到信息。\n- 设置 debug mode:in 烧录 jlink 芯片，找到固件包，安装包（包为 .emz 格式，在 simplicity 安装目录中，可以电脑自行检索包路径）。\n\n\n\n\n\n\n> 参考链接：\n> http://m.blog.csdn.net/article/details?id=41648431\n> http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Recover-EFM32-or-EFM8-kit-that-was-bricked-during-firmware/ta-p/122142\n> http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Unlock-a-Bricked-EFM32/ta-p/122776\n> http://wenku.baidu.com/view/ee891f3a5a8102d276a22ffc.html?re=view\n> http://community.silabs.com/t5/ChineseForum/%E7%96%91%E4%BC%BC%E8%8A%AF%E7%89%87%E6%98%AF%E5%90%A6%E7%83%A7%E5%9D%8F%E4%BA%86/m-p/184134/highlight/false#M1227\n> http://www.silabs.com/products/mcu/32-bit/efm32-gecko/pages/efm32-gecko.aspx\n","source":"_posts/2016/2016-12-08-efm32-开发板问题总结.md","raw":"---\nlayout: \"post\"\ntitle: \"efm32 开发板问题总结\"\ndate: \"2016-12-08 16:03\"\n---\n\nsilabs 的 EFM 系列芯片历来以低能耗，可信的加密而文明，比较遗憾的是，国内用的较少，且基本上没有什么中文参考资料，刚刚开办没多久的官方中文论坛贴出来的资料也大都是英文版，且论坛在 GFW 下访问相当困难。因为项目需求，这边我入手了两个系列的 EFM 开发板，但都出了大大小小的问题。\n\n个人总结：1.因为前期缺少相关指导，且官方指导手册仅告诉要如何做，却没指示相关工具的位置和使用。2.该芯片配备专有 IDE 且还分好几个版本，无疑增加了摸索的难度。3.个人经验不足，之前上手的都是开发板，没接触过这种官方自带的评估板。\n\n其实上手这个评估板并不困难，困难的是没有一个详尽的指导手册，不知道如何用评估板去烧录上面的 MCU ，如何用评估板烧录自己产品的 MCU等。\n\n\n### 评估板简介：\n\nEFM32 配套评估板 上 Jlink 是从Segger授权的, 功能上应该没有缩减。因此价格也较贵，原价 $69 现价 $29 ，一般网购的价格在 ￥200 左右，这个价位对于国内 STM32 满地跑，部分 STM32 开发板价格甚至在 100 左右来说的话，还是较贵的，最关键的是淘宝购买的厂家不承担售后服务之类的，出问题只能自己解决。\n\n另外，EFM32 官方配套软件很强大，将编码，烧录，仿真，能耗监控，文档，样例等等都集成在了一起，很多资料都需要去这个 IDE 中查找，对英语不好或者不善于摸索的人来说也是一道门槛。\n\n评估板的功能：\n- 根据你的版型，不同的板子有不同的功能，一般都会有显示器，按键，led等基本功能\n- 能耗检测模块\n- 板载 Jlink ：可以烧录板载 MCU，也可以烧录外置芯片。\n- 可以使用外置 Jlink 来烧录板载的 MCU。\n- 大多数引脚引出，且预留焊盘，另外还有 EXP 扩展口（注意 debug-out 是小灯，而不是指 EXP 扩展口）。\n\n\n<!-- more -->\n\n\n\n### 使用方法：\n\n评估板的 debug 主要分为 in,out,mcu,off 等选项，这几个选项至关重要，我们可以不使用 simplicity studio 这个 IDE，但如果需要使用这个评估板，就必须得弄清楚如何设置评估板的 debug 模式。\n\n这边我使用 simplicity v3 版本，设置 debug 模式，需要通过一个 commander 的软件，该软件在 simplicity v3 安装包中可以检索到，如果需要在 simplicity studio 中打开，则安装时需要安装无线模块套件（如果不安装这个套件，软件中无法打开这个 commander 工具，因此建议新手安装完整版的 simplicity v3 而不是只安装你所需要的芯片组建），打开 simplicity IDE 然后在 file 中打开 simplicity commander。\n\n每次使用评估板要进行相关操作时，都需要使用 commander 进行设置，详细配置说明：\n- debug-in ： 烧录评估板上面的 jlink 固件，注意烧录的是 jlink 而不是评估板的 EFM芯片。\n- debug-out : 使用评估板作为 jlink 烧录其他板子上面的外置芯片。mcu 资料中可以读出外置芯片具体信息，另外评估板有个 debug-out 灯会亮起。\n- debug-mcu : 烧录评估板上面自带的 EFM 芯片。mcu 资料中可以读出板载芯片具体信息。\n\n**评估板作为 jlink 是官方正版授权的，烧录程序一般没有问题，但如果需要打多个断点进行仿真，则可能会仿真失败，应该是和 jink 采用的芯片有关系。**\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-08-efm32-%E5%BC%80%E5%8F%91%E6%9D%BF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/1.png)\n\n\n\n### 固件烧录\n\n普通升级，官方推荐使用 Kit Manager 打开后会自动判断固件是否需要升级，事实上 Kit Manager 和 simplicity commander 功能基本相同，但 Kit Manager 更显得傻瓜式，而且也会经常出现无法打开，无法连接芯片等问题，如果遇到了这些问题，建议还是使用 simplicity commander 进行所有操作。\n\n如果无法找到 commander 工具，这边推荐给出两个该工具的下载地址：\n\n固件烧录失败后，如何重新烧录固件，步骤差不多如下：\n\n- 将评估板的 bootloader 接地（bootloader 位置各个开发板不尽相同，可以参照原理图，或者查看下面给出的参考连接），接下来连接电脑，打开 simplicity commander ，如果 bootloader 接地成功则会显示 j-link device 信息，否则读取不到信息。\n- 设置 debug mode:in 烧录 jlink 芯片，找到固件包，安装包（包为 .emz 格式，在 simplicity 安装目录中，可以电脑自行检索包路径）。\n\n\n\n\n\n\n> 参考链接：\n> http://m.blog.csdn.net/article/details?id=41648431\n> http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Recover-EFM32-or-EFM8-kit-that-was-bricked-during-firmware/ta-p/122142\n> http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Unlock-a-Bricked-EFM32/ta-p/122776\n> http://wenku.baidu.com/view/ee891f3a5a8102d276a22ffc.html?re=view\n> http://community.silabs.com/t5/ChineseForum/%E7%96%91%E4%BC%BC%E8%8A%AF%E7%89%87%E6%98%AF%E5%90%A6%E7%83%A7%E5%9D%8F%E4%BA%86/m-p/184134/highlight/false#M1227\n> http://www.silabs.com/products/mcu/32-bit/efm32-gecko/pages/efm32-gecko.aspx\n","slug":"2016/2016-12-08-efm32-开发板问题总结","published":1,"updated":"2016-12-16T01:50:57.999Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aj5003omumuoffqu7tb","content":"<p>silabs 的 EFM 系列芯片历来以低能耗，可信的加密而文明，比较遗憾的是，国内用的较少，且基本上没有什么中文参考资料，刚刚开办没多久的官方中文论坛贴出来的资料也大都是英文版，且论坛在 GFW 下访问相当困难。因为项目需求，这边我入手了两个系列的 EFM 开发板，但都出了大大小小的问题。</p>\n<p>个人总结：1.因为前期缺少相关指导，且官方指导手册仅告诉要如何做，却没指示相关工具的位置和使用。2.该芯片配备专有 IDE 且还分好几个版本，无疑增加了摸索的难度。3.个人经验不足，之前上手的都是开发板，没接触过这种官方自带的评估板。</p>\n<p>其实上手这个评估板并不困难，困难的是没有一个详尽的指导手册，不知道如何用评估板去烧录上面的 MCU ，如何用评估板烧录自己产品的 MCU等。</p>\n<h3 id=\"评估板简介：\"><a href=\"#评估板简介：\" class=\"headerlink\" title=\"评估板简介：\"></a>评估板简介：</h3><p>EFM32 配套评估板 上 Jlink 是从Segger授权的, 功能上应该没有缩减。因此价格也较贵，原价 $69 现价 $29 ，一般网购的价格在 ￥200 左右，这个价位对于国内 STM32 满地跑，部分 STM32 开发板价格甚至在 100 左右来说的话，还是较贵的，最关键的是淘宝购买的厂家不承担售后服务之类的，出问题只能自己解决。</p>\n<p>另外，EFM32 官方配套软件很强大，将编码，烧录，仿真，能耗监控，文档，样例等等都集成在了一起，很多资料都需要去这个 IDE 中查找，对英语不好或者不善于摸索的人来说也是一道门槛。</p>\n<p>评估板的功能：</p>\n<ul>\n<li>根据你的版型，不同的板子有不同的功能，一般都会有显示器，按键，led等基本功能</li>\n<li>能耗检测模块</li>\n<li>板载 Jlink ：可以烧录板载 MCU，也可以烧录外置芯片。</li>\n<li>可以使用外置 Jlink 来烧录板载的 MCU。</li>\n<li>大多数引脚引出，且预留焊盘，另外还有 EXP 扩展口（注意 debug-out 是小灯，而不是指 EXP 扩展口）。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"使用方法：\"><a href=\"#使用方法：\" class=\"headerlink\" title=\"使用方法：\"></a>使用方法：</h3><p>评估板的 debug 主要分为 in,out,mcu,off 等选项，这几个选项至关重要，我们可以不使用 simplicity studio 这个 IDE，但如果需要使用这个评估板，就必须得弄清楚如何设置评估板的 debug 模式。</p>\n<p>这边我使用 simplicity v3 版本，设置 debug 模式，需要通过一个 commander 的软件，该软件在 simplicity v3 安装包中可以检索到，如果需要在 simplicity studio 中打开，则安装时需要安装无线模块套件（如果不安装这个套件，软件中无法打开这个 commander 工具，因此建议新手安装完整版的 simplicity v3 而不是只安装你所需要的芯片组建），打开 simplicity IDE 然后在 file 中打开 simplicity commander。</p>\n<p>每次使用评估板要进行相关操作时，都需要使用 commander 进行设置，详细配置说明：</p>\n<ul>\n<li>debug-in ： 烧录评估板上面的 jlink 固件，注意烧录的是 jlink 而不是评估板的 EFM芯片。</li>\n<li>debug-out : 使用评估板作为 jlink 烧录其他板子上面的外置芯片。mcu 资料中可以读出外置芯片具体信息，另外评估板有个 debug-out 灯会亮起。</li>\n<li>debug-mcu : 烧录评估板上面自带的 EFM 芯片。mcu 资料中可以读出板载芯片具体信息。</li>\n</ul>\n<p><strong>评估板作为 jlink 是官方正版授权的，烧录程序一般没有问题，但如果需要打多个断点进行仿真，则可能会仿真失败，应该是和 jink 采用的芯片有关系。</strong></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-08-efm32-%E5%BC%80%E5%8F%91%E6%9D%BF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/1.png\" alt=\"\"></p>\n<h3 id=\"固件烧录\"><a href=\"#固件烧录\" class=\"headerlink\" title=\"固件烧录\"></a>固件烧录</h3><p>普通升级，官方推荐使用 Kit Manager 打开后会自动判断固件是否需要升级，事实上 Kit Manager 和 simplicity commander 功能基本相同，但 Kit Manager 更显得傻瓜式，而且也会经常出现无法打开，无法连接芯片等问题，如果遇到了这些问题，建议还是使用 simplicity commander 进行所有操作。</p>\n<p>如果无法找到 commander 工具，这边推荐给出两个该工具的下载地址：</p>\n<p>固件烧录失败后，如何重新烧录固件，步骤差不多如下：</p>\n<ul>\n<li>将评估板的 bootloader 接地（bootloader 位置各个开发板不尽相同，可以参照原理图，或者查看下面给出的参考连接），接下来连接电脑，打开 simplicity commander ，如果 bootloader 接地成功则会显示 j-link device 信息，否则读取不到信息。</li>\n<li>设置 debug mode:in 烧录 jlink 芯片，找到固件包，安装包（包为 .emz 格式，在 simplicity 安装目录中，可以电脑自行检索包路径）。</li>\n</ul>\n<blockquote>\n<p>参考链接：<br><a href=\"http://m.blog.csdn.net/article/details?id=41648431\" target=\"_blank\" rel=\"external\">http://m.blog.csdn.net/article/details?id=41648431</a><br><a href=\"http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Recover-EFM32-or-EFM8-kit-that-was-bricked-during-firmware/ta-p/122142\" target=\"_blank\" rel=\"external\">http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Recover-EFM32-or-EFM8-kit-that-was-bricked-during-firmware/ta-p/122142</a><br><a href=\"http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Unlock-a-Bricked-EFM32/ta-p/122776\" target=\"_blank\" rel=\"external\">http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Unlock-a-Bricked-EFM32/ta-p/122776</a><br><a href=\"http://wenku.baidu.com/view/ee891f3a5a8102d276a22ffc.html?re=view\" target=\"_blank\" rel=\"external\">http://wenku.baidu.com/view/ee891f3a5a8102d276a22ffc.html?re=view</a><br><a href=\"http://community.silabs.com/t5/ChineseForum/%E7%96%91%E4%BC%BC%E8%8A%AF%E7%89%87%E6%98%AF%E5%90%A6%E7%83%A7%E5%9D%8F%E4%BA%86/m-p/184134/highlight/false#M1227\" target=\"_blank\" rel=\"external\">http://community.silabs.com/t5/ChineseForum/%E7%96%91%E4%BC%BC%E8%8A%AF%E7%89%87%E6%98%AF%E5%90%A6%E7%83%A7%E5%9D%8F%E4%BA%86/m-p/184134/highlight/false#M1227</a><br><a href=\"http://www.silabs.com/products/mcu/32-bit/efm32-gecko/pages/efm32-gecko.aspx\" target=\"_blank\" rel=\"external\">http://www.silabs.com/products/mcu/32-bit/efm32-gecko/pages/efm32-gecko.aspx</a></p>\n</blockquote>\n","excerpt":"<p>silabs 的 EFM 系列芯片历来以低能耗，可信的加密而文明，比较遗憾的是，国内用的较少，且基本上没有什么中文参考资料，刚刚开办没多久的官方中文论坛贴出来的资料也大都是英文版，且论坛在 GFW 下访问相当困难。因为项目需求，这边我入手了两个系列的 EFM 开发板，但都出了大大小小的问题。</p>\n<p>个人总结：1.因为前期缺少相关指导，且官方指导手册仅告诉要如何做，却没指示相关工具的位置和使用。2.该芯片配备专有 IDE 且还分好几个版本，无疑增加了摸索的难度。3.个人经验不足，之前上手的都是开发板，没接触过这种官方自带的评估板。</p>\n<p>其实上手这个评估板并不困难，困难的是没有一个详尽的指导手册，不知道如何用评估板去烧录上面的 MCU ，如何用评估板烧录自己产品的 MCU等。</p>\n<h3 id=\"评估板简介：\"><a href=\"#评估板简介：\" class=\"headerlink\" title=\"评估板简介：\"></a>评估板简介：</h3><p>EFM32 配套评估板 上 Jlink 是从Segger授权的, 功能上应该没有缩减。因此价格也较贵，原价 $69 现价 $29 ，一般网购的价格在 ￥200 左右，这个价位对于国内 STM32 满地跑，部分 STM32 开发板价格甚至在 100 左右来说的话，还是较贵的，最关键的是淘宝购买的厂家不承担售后服务之类的，出问题只能自己解决。</p>\n<p>另外，EFM32 官方配套软件很强大，将编码，烧录，仿真，能耗监控，文档，样例等等都集成在了一起，很多资料都需要去这个 IDE 中查找，对英语不好或者不善于摸索的人来说也是一道门槛。</p>\n<p>评估板的功能：</p>\n<ul>\n<li>根据你的版型，不同的板子有不同的功能，一般都会有显示器，按键，led等基本功能</li>\n<li>能耗检测模块</li>\n<li>板载 Jlink ：可以烧录板载 MCU，也可以烧录外置芯片。</li>\n<li>可以使用外置 Jlink 来烧录板载的 MCU。</li>\n<li>大多数引脚引出，且预留焊盘，另外还有 EXP 扩展口（注意 debug-out 是小灯，而不是指 EXP 扩展口）。</li>\n</ul>","more":"<h3 id=\"使用方法：\"><a href=\"#使用方法：\" class=\"headerlink\" title=\"使用方法：\"></a>使用方法：</h3><p>评估板的 debug 主要分为 in,out,mcu,off 等选项，这几个选项至关重要，我们可以不使用 simplicity studio 这个 IDE，但如果需要使用这个评估板，就必须得弄清楚如何设置评估板的 debug 模式。</p>\n<p>这边我使用 simplicity v3 版本，设置 debug 模式，需要通过一个 commander 的软件，该软件在 simplicity v3 安装包中可以检索到，如果需要在 simplicity studio 中打开，则安装时需要安装无线模块套件（如果不安装这个套件，软件中无法打开这个 commander 工具，因此建议新手安装完整版的 simplicity v3 而不是只安装你所需要的芯片组建），打开 simplicity IDE 然后在 file 中打开 simplicity commander。</p>\n<p>每次使用评估板要进行相关操作时，都需要使用 commander 进行设置，详细配置说明：</p>\n<ul>\n<li>debug-in ： 烧录评估板上面的 jlink 固件，注意烧录的是 jlink 而不是评估板的 EFM芯片。</li>\n<li>debug-out : 使用评估板作为 jlink 烧录其他板子上面的外置芯片。mcu 资料中可以读出外置芯片具体信息，另外评估板有个 debug-out 灯会亮起。</li>\n<li>debug-mcu : 烧录评估板上面自带的 EFM 芯片。mcu 资料中可以读出板载芯片具体信息。</li>\n</ul>\n<p><strong>评估板作为 jlink 是官方正版授权的，烧录程序一般没有问题，但如果需要打多个断点进行仿真，则可能会仿真失败，应该是和 jink 采用的芯片有关系。</strong></p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-08-efm32-%E5%BC%80%E5%8F%91%E6%9D%BF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/1.png\" alt=\"\"></p>\n<h3 id=\"固件烧录\"><a href=\"#固件烧录\" class=\"headerlink\" title=\"固件烧录\"></a>固件烧录</h3><p>普通升级，官方推荐使用 Kit Manager 打开后会自动判断固件是否需要升级，事实上 Kit Manager 和 simplicity commander 功能基本相同，但 Kit Manager 更显得傻瓜式，而且也会经常出现无法打开，无法连接芯片等问题，如果遇到了这些问题，建议还是使用 simplicity commander 进行所有操作。</p>\n<p>如果无法找到 commander 工具，这边推荐给出两个该工具的下载地址：</p>\n<p>固件烧录失败后，如何重新烧录固件，步骤差不多如下：</p>\n<ul>\n<li>将评估板的 bootloader 接地（bootloader 位置各个开发板不尽相同，可以参照原理图，或者查看下面给出的参考连接），接下来连接电脑，打开 simplicity commander ，如果 bootloader 接地成功则会显示 j-link device 信息，否则读取不到信息。</li>\n<li>设置 debug mode:in 烧录 jlink 芯片，找到固件包，安装包（包为 .emz 格式，在 simplicity 安装目录中，可以电脑自行检索包路径）。</li>\n</ul>\n<blockquote>\n<p>参考链接：<br><a href=\"http://m.blog.csdn.net/article/details?id=41648431\">http://m.blog.csdn.net/article/details?id=41648431</a><br><a href=\"http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Recover-EFM32-or-EFM8-kit-that-was-bricked-during-firmware/ta-p/122142\">http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Recover-EFM32-or-EFM8-kit-that-was-bricked-during-firmware/ta-p/122142</a><br><a href=\"http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Unlock-a-Bricked-EFM32/ta-p/122776\">http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Unlock-a-Bricked-EFM32/ta-p/122776</a><br><a href=\"http://wenku.baidu.com/view/ee891f3a5a8102d276a22ffc.html?re=view\">http://wenku.baidu.com/view/ee891f3a5a8102d276a22ffc.html?re=view</a><br><a href=\"http://community.silabs.com/t5/ChineseForum/%E7%96%91%E4%BC%BC%E8%8A%AF%E7%89%87%E6%98%AF%E5%90%A6%E7%83%A7%E5%9D%8F%E4%BA%86/m-p/184134/highlight/false#M1227\">http://community.silabs.com/t5/ChineseForum/%E7%96%91%E4%BC%BC%E8%8A%AF%E7%89%87%E6%98%AF%E5%90%A6%E7%83%A7%E5%9D%8F%E4%BA%86/m-p/184134/highlight/false#M1227</a><br><a href=\"http://www.silabs.com/products/mcu/32-bit/efm32-gecko/pages/efm32-gecko.aspx\">http://www.silabs.com/products/mcu/32-bit/efm32-gecko/pages/efm32-gecko.aspx</a></p>\n</blockquote>"},{"layout":"post","title":"TeamViewer 远程控制","date":"2016-12-12T03:25:00.000Z","_content":"\nTeamViewer 是一款最流行的远程桌面连接工具，特点：连接稳定，功能强大，跨平台，对网络稳定性要求低等等，几乎集成了市面上大多数远程工具的优点，实时性很强，且资源消耗低，这些都远不是 qq 等国内软件的远程服务可以比拟的。本篇文章就是 windows 远程连接 Ubuntu 桌面编辑完成的。\n\n本文主要介绍如何在局域网内使用 TeamViewer 完成远程桌面的设置。\n\n\n### 软件安装\n\n这边给出[官方下载地址](https://www.teamviewer.com/zhcn/download/linux/)，可以看到官方提供了目前主流移动端和 PC 端的各个版本的软件。这边根据你自己的平台下载需要的版本。因为平台需要这边我下载的是 windows 版本和 Ubuntu 版本。需要注意的是：下载版本为完整版，而不是缩减版（缩减版中需要联网登录，且不直接存在登录远程功能），图示如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/1.jpg)\n\n<!-- more -->\n\n\n### 操作方法\n\n#### 广域网连接\n\n通过ID+密码连接，首先，输入对方的 ID 地址，然后选择下方的远程控制后点击连接到小伙伴，最后输入对方的密码即可完成远程控制。比较诡异的是远程链接到对方的 windows 后，背景图会变成黑色，但这无须担心，退出连接后，会恢复原来主题。另外如果实在看的不舒服，登录后点击“查看”，然后把“删除墙纸”勾掉就可以了。\n\n#### 局域网连接\n\n- 使用局域网链接，需要先配置下本机设置，找开软件后，先要设置允许接入lan（或者叫允许局域网连接），那样的话，ID的地方就显示内网的IP了。如果你的 ID 不能显示自己的 IP 地址，重新启动软件即可。如下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/2.jpg)\n\n\n- 局域网内同样需要两边都先打开软件，然后使用 IP 代替伙伴ID输入，后续操作和上面类似，直接点远程控制，输入密码即可。如下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/3.jpg)\n\n\n### 小结\n\nTeamViewer 的链接方式稳定，带宽占用资源小，高质量模式下，也仅有 200kb/s 的传输速度，操作也很及时，附带的录屏文件传输等功能强大。但 TeamViewer 并非完全免费的软件，一些附带功能和商业用途需要付费支持，另外 TeamViewer 只能用于远程图形化界面的使用的话，说白了就是只能一个人使用，不能类似于 ssh 可以多人使用登录。\n\n\n\n\n\n> 参考链接：\n> http://www.wuji8.com/meta/864411156.html\n> https://zhidao.baidu.com/question/497787316.html\n","source":"_posts/2016/2016-12-12-teamviewer-远程控制.md","raw":"---\nlayout: \"post\"\ntitle: \"TeamViewer 远程控制\"\ndate: \"2016-12-12 11:25\"\n---\n\nTeamViewer 是一款最流行的远程桌面连接工具，特点：连接稳定，功能强大，跨平台，对网络稳定性要求低等等，几乎集成了市面上大多数远程工具的优点，实时性很强，且资源消耗低，这些都远不是 qq 等国内软件的远程服务可以比拟的。本篇文章就是 windows 远程连接 Ubuntu 桌面编辑完成的。\n\n本文主要介绍如何在局域网内使用 TeamViewer 完成远程桌面的设置。\n\n\n### 软件安装\n\n这边给出[官方下载地址](https://www.teamviewer.com/zhcn/download/linux/)，可以看到官方提供了目前主流移动端和 PC 端的各个版本的软件。这边根据你自己的平台下载需要的版本。因为平台需要这边我下载的是 windows 版本和 Ubuntu 版本。需要注意的是：下载版本为完整版，而不是缩减版（缩减版中需要联网登录，且不直接存在登录远程功能），图示如下：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/1.jpg)\n\n<!-- more -->\n\n\n### 操作方法\n\n#### 广域网连接\n\n通过ID+密码连接，首先，输入对方的 ID 地址，然后选择下方的远程控制后点击连接到小伙伴，最后输入对方的密码即可完成远程控制。比较诡异的是远程链接到对方的 windows 后，背景图会变成黑色，但这无须担心，退出连接后，会恢复原来主题。另外如果实在看的不舒服，登录后点击“查看”，然后把“删除墙纸”勾掉就可以了。\n\n#### 局域网连接\n\n- 使用局域网链接，需要先配置下本机设置，找开软件后，先要设置允许接入lan（或者叫允许局域网连接），那样的话，ID的地方就显示内网的IP了。如果你的 ID 不能显示自己的 IP 地址，重新启动软件即可。如下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/2.jpg)\n\n\n- 局域网内同样需要两边都先打开软件，然后使用 IP 代替伙伴ID输入，后续操作和上面类似，直接点远程控制，输入密码即可。如下图：\n\n![](https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/3.jpg)\n\n\n### 小结\n\nTeamViewer 的链接方式稳定，带宽占用资源小，高质量模式下，也仅有 200kb/s 的传输速度，操作也很及时，附带的录屏文件传输等功能强大。但 TeamViewer 并非完全免费的软件，一些附带功能和商业用途需要付费支持，另外 TeamViewer 只能用于远程图形化界面的使用的话，说白了就是只能一个人使用，不能类似于 ssh 可以多人使用登录。\n\n\n\n\n\n> 参考链接：\n> http://www.wuji8.com/meta/864411156.html\n> https://zhidao.baidu.com/question/497787316.html\n","slug":"2016/2016-12-12-teamviewer-远程控制","published":1,"updated":"2016-12-16T01:50:52.619Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aj6003pmumurkga789k","content":"<p>TeamViewer 是一款最流行的远程桌面连接工具，特点：连接稳定，功能强大，跨平台，对网络稳定性要求低等等，几乎集成了市面上大多数远程工具的优点，实时性很强，且资源消耗低，这些都远不是 qq 等国内软件的远程服务可以比拟的。本篇文章就是 windows 远程连接 Ubuntu 桌面编辑完成的。</p>\n<p>本文主要介绍如何在局域网内使用 TeamViewer 完成远程桌面的设置。</p>\n<h3 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h3><p>这边给出<a href=\"https://www.teamviewer.com/zhcn/download/linux/\" target=\"_blank\" rel=\"external\">官方下载地址</a>，可以看到官方提供了目前主流移动端和 PC 端的各个版本的软件。这边根据你自己的平台下载需要的版本。因为平台需要这边我下载的是 windows 版本和 Ubuntu 版本。需要注意的是：下载版本为完整版，而不是缩减版（缩减版中需要联网登录，且不直接存在登录远程功能），图示如下：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/1.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h3><h4 id=\"广域网连接\"><a href=\"#广域网连接\" class=\"headerlink\" title=\"广域网连接\"></a>广域网连接</h4><p>通过ID+密码连接，首先，输入对方的 ID 地址，然后选择下方的远程控制后点击连接到小伙伴，最后输入对方的密码即可完成远程控制。比较诡异的是远程链接到对方的 windows 后，背景图会变成黑色，但这无须担心，退出连接后，会恢复原来主题。另外如果实在看的不舒服，登录后点击“查看”，然后把“删除墙纸”勾掉就可以了。</p>\n<h4 id=\"局域网连接\"><a href=\"#局域网连接\" class=\"headerlink\" title=\"局域网连接\"></a>局域网连接</h4><ul>\n<li>使用局域网链接，需要先配置下本机设置，找开软件后，先要设置允许接入lan（或者叫允许局域网连接），那样的话，ID的地方就显示内网的IP了。如果你的 ID 不能显示自己的 IP 地址，重新启动软件即可。如下图：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/2.jpg\" alt=\"\"></p>\n<ul>\n<li>局域网内同样需要两边都先打开软件，然后使用 IP 代替伙伴ID输入，后续操作和上面类似，直接点远程控制，输入密码即可。如下图：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/3.jpg\" alt=\"\"></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>TeamViewer 的链接方式稳定，带宽占用资源小，高质量模式下，也仅有 200kb/s 的传输速度，操作也很及时，附带的录屏文件传输等功能强大。但 TeamViewer 并非完全免费的软件，一些附带功能和商业用途需要付费支持，另外 TeamViewer 只能用于远程图形化界面的使用的话，说白了就是只能一个人使用，不能类似于 ssh 可以多人使用登录。</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.wuji8.com/meta/864411156.html\" target=\"_blank\" rel=\"external\">http://www.wuji8.com/meta/864411156.html</a><br><a href=\"https://zhidao.baidu.com/question/497787316.html\" target=\"_blank\" rel=\"external\">https://zhidao.baidu.com/question/497787316.html</a></p>\n</blockquote>\n","excerpt":"<p>TeamViewer 是一款最流行的远程桌面连接工具，特点：连接稳定，功能强大，跨平台，对网络稳定性要求低等等，几乎集成了市面上大多数远程工具的优点，实时性很强，且资源消耗低，这些都远不是 qq 等国内软件的远程服务可以比拟的。本篇文章就是 windows 远程连接 Ubuntu 桌面编辑完成的。</p>\n<p>本文主要介绍如何在局域网内使用 TeamViewer 完成远程桌面的设置。</p>\n<h3 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h3><p>这边给出<a href=\"https://www.teamviewer.com/zhcn/download/linux/\">官方下载地址</a>，可以看到官方提供了目前主流移动端和 PC 端的各个版本的软件。这边根据你自己的平台下载需要的版本。因为平台需要这边我下载的是 windows 版本和 Ubuntu 版本。需要注意的是：下载版本为完整版，而不是缩减版（缩减版中需要联网登录，且不直接存在登录远程功能），图示如下：</p>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/1.jpg\" alt=\"\"></p>","more":"<h3 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h3><h4 id=\"广域网连接\"><a href=\"#广域网连接\" class=\"headerlink\" title=\"广域网连接\"></a>广域网连接</h4><p>通过ID+密码连接，首先，输入对方的 ID 地址，然后选择下方的远程控制后点击连接到小伙伴，最后输入对方的密码即可完成远程控制。比较诡异的是远程链接到对方的 windows 后，背景图会变成黑色，但这无须担心，退出连接后，会恢复原来主题。另外如果实在看的不舒服，登录后点击“查看”，然后把“删除墙纸”勾掉就可以了。</p>\n<h4 id=\"局域网连接\"><a href=\"#局域网连接\" class=\"headerlink\" title=\"局域网连接\"></a>局域网连接</h4><ul>\n<li>使用局域网链接，需要先配置下本机设置，找开软件后，先要设置允许接入lan（或者叫允许局域网连接），那样的话，ID的地方就显示内网的IP了。如果你的 ID 不能显示自己的 IP 地址，重新启动软件即可。如下图：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/2.jpg\" alt=\"\"></p>\n<ul>\n<li>局域网内同样需要两边都先打开软件，然后使用 IP 代替伙伴ID输入，后续操作和上面类似，直接点远程控制，输入密码即可。如下图：</li>\n</ul>\n<p><img src=\"https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/3.jpg\" alt=\"\"></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>TeamViewer 的链接方式稳定，带宽占用资源小，高质量模式下，也仅有 200kb/s 的传输速度，操作也很及时，附带的录屏文件传输等功能强大。但 TeamViewer 并非完全免费的软件，一些附带功能和商业用途需要付费支持，另外 TeamViewer 只能用于远程图形化界面的使用的话，说白了就是只能一个人使用，不能类似于 ssh 可以多人使用登录。</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.wuji8.com/meta/864411156.html\">http://www.wuji8.com/meta/864411156.html</a><br><a href=\"https://zhidao.baidu.com/question/497787316.html\">https://zhidao.baidu.com/question/497787316.html</a></p>\n</blockquote>"},{"layout":"post","title":"VPS 简介","date":"2016-12-19T09:41:00.000Z","_content":"\n\n起初对云服务很好奇，完全不知所云，无从下手的感觉，但经过一段时间的摸索研究，也基本能够搭建一些自己想要的服务了，这边根据一些网络资料和自己的学习研究，对这阶段进行一个总结，希望对那些刚刚开始尝试搭建云服务的网友有所帮助。\n\n\n### 虚拟技术\n\n利用虚拟话技术在一台物理服务器上面创建多个相互隔离的虚拟化私有主机(\"Virtual Private Server -- VPS\")，可以看出原理和 PC 上面用虚拟机自己虚拟出来的系统并没有什么本质区别，只不过 VPS 是虚拟化之后放到网络上面使用的而已。对用户和应用程序来说，每个 VPS 平台的运行和管理都与一台独立主机完全相同，每个 VPS 均可以独立进行重启并且拥有 root 访问权限，用户，IP地址，内存，进程，文件，应用程序，系统函数库以及配置文件等。\n\n目前一般 VPS 结构是这样的：最底层为 Host Hardware 硬件， 然后是 Host Operating System 宿主机/真实系统，再然后是真实系统上面运行的虚拟化软件，最后是虚拟机软件内部运行的操作系统 Guest OS 访客系统（这边看上去和我们个人电脑 PC 上面跑的虚拟机中的虚拟操作系统并没啥区别）。\n\n随着云技术的不断成熟，现在的 VPS 也有了很大的改进，例如国内的腾讯，阿里等都给自己的 VPS 起了新名字，什么弹性云服务，无虚拟机，云服务器等等，从用户角度来看和 VPS 没有区别，但技术层面一般现在都会将 Host Hardware 硬件通过集群技术搭建，几百上千台主机共建一个硬件平台，然后分配资源建立 VPS，这边一般可以看作是 cloud VPS，可以做到弹性扩展，无缝对接，无需在需要时再去更新硬件资源。\n\n能够使用 linux VPS 完成的优先使用 linux。\n\n这边如果对 VPS 服务器等还有疑惑可以参考本博客的另外一篇文章**虚拟主机、VPS和云主机**。\n\n\n<!-- more -->\n\n\n#### 桌面用户：\n\nvmware，virtualbox，virutalPC等，vmware，virtualbox都是支持多个操作系统的跨平台软件功能强大，用的也比较多。\n\n#### 服务器用户：\n\n- Hyper-V：微软自带的虚拟化技术，只能在 windows 上运行，买 windows vps 很可能是 Hype-V 虚拟的\n- vmware：专业做虚拟话技术的公司，产品覆盖很广，个人企业都有，功能强大，可运行在各个平台，虚拟出各种操作系统。\n- OpenVZ：很老的一款软件，只能运行在 linux 上，也只能虚拟出 linux 操作系统，国内很多在拆分的时候没有很好的维护以及滥用超售，不能运行需要编译内核的应用。\n- Xen：版虚拟化技术，性能有一定损失，可以升级内核等\n- KVM：最近两年刚流行的，是一个开源系统虚拟化模块，KVM 目前已经成为学术界主流的虚拟机监控器之一，目前因为硬件虚拟化技术等都比较成熟，KVM 性能优势等相当明显。\n\n对于 VPS 的免费软件选择： KVM > XEN > OpenVZ。\n\n#### 用途分析：\n\n- 搭建网站平台\n- 不熟企业信息化系统，中小型企业不存在机房，使用 VPS 会节约成本。\n- 挂 PT 数据传输分享\n- 加密数据访问，科学上网\n- 多人协作开发，代码托管\n- 私有云存储空间\n- 等等\n\n#### VPS 选择\n\n- 优先选择 linux VPS ，软件多，性能稳定，占用资源少，价格便宜等等。\n- 选择国内 VPS （阿里云/腾讯云）：面向群体为国内用户，需要 ICP 备案，时间较长；另外支持备案的域名较少，使用国内 VPS 时，购买域名需要慎重。\n- 选择国外 VPS （vultr，digitalocean, 搬瓦工）：客户是国外用户或者不用于商业用途，价格为国内一半以下，带宽充足。\n\n#### 选择虚拟技术\n\n优先选择 KVM， 其次 XEN 或 vmware，最后 OpenVZ。\n\n#### 硬件资源选择\n\n一般 VPS 会提供多种方案或者自由搭配组合，主要根据自己的实际需求选择硬件资源。\n\n- 应用要求高，则选择内存大的，CPU 强劲的方案，例如游戏服务器等\n- 网络应用，主要分享文件视频等，选择流量大的\n- 主要用于存储数据的，选择较大的硬盘空间。\n\n\n\n\n\n\n> https://www.youtube.com/watch?v=Hs-er4JwHc8\n> http://www.chinaz.com/prime/2012/1021/279069.shtml\n","source":"_posts/2016/2016-12-19-vps-简介.md","raw":"---\nlayout: \"post\"\ntitle: \"VPS 简介\"\ndate: \"2016-12-19 17:41\"\n---\n\n\n起初对云服务很好奇，完全不知所云，无从下手的感觉，但经过一段时间的摸索研究，也基本能够搭建一些自己想要的服务了，这边根据一些网络资料和自己的学习研究，对这阶段进行一个总结，希望对那些刚刚开始尝试搭建云服务的网友有所帮助。\n\n\n### 虚拟技术\n\n利用虚拟话技术在一台物理服务器上面创建多个相互隔离的虚拟化私有主机(\"Virtual Private Server -- VPS\")，可以看出原理和 PC 上面用虚拟机自己虚拟出来的系统并没有什么本质区别，只不过 VPS 是虚拟化之后放到网络上面使用的而已。对用户和应用程序来说，每个 VPS 平台的运行和管理都与一台独立主机完全相同，每个 VPS 均可以独立进行重启并且拥有 root 访问权限，用户，IP地址，内存，进程，文件，应用程序，系统函数库以及配置文件等。\n\n目前一般 VPS 结构是这样的：最底层为 Host Hardware 硬件， 然后是 Host Operating System 宿主机/真实系统，再然后是真实系统上面运行的虚拟化软件，最后是虚拟机软件内部运行的操作系统 Guest OS 访客系统（这边看上去和我们个人电脑 PC 上面跑的虚拟机中的虚拟操作系统并没啥区别）。\n\n随着云技术的不断成熟，现在的 VPS 也有了很大的改进，例如国内的腾讯，阿里等都给自己的 VPS 起了新名字，什么弹性云服务，无虚拟机，云服务器等等，从用户角度来看和 VPS 没有区别，但技术层面一般现在都会将 Host Hardware 硬件通过集群技术搭建，几百上千台主机共建一个硬件平台，然后分配资源建立 VPS，这边一般可以看作是 cloud VPS，可以做到弹性扩展，无缝对接，无需在需要时再去更新硬件资源。\n\n能够使用 linux VPS 完成的优先使用 linux。\n\n这边如果对 VPS 服务器等还有疑惑可以参考本博客的另外一篇文章**虚拟主机、VPS和云主机**。\n\n\n<!-- more -->\n\n\n#### 桌面用户：\n\nvmware，virtualbox，virutalPC等，vmware，virtualbox都是支持多个操作系统的跨平台软件功能强大，用的也比较多。\n\n#### 服务器用户：\n\n- Hyper-V：微软自带的虚拟化技术，只能在 windows 上运行，买 windows vps 很可能是 Hype-V 虚拟的\n- vmware：专业做虚拟话技术的公司，产品覆盖很广，个人企业都有，功能强大，可运行在各个平台，虚拟出各种操作系统。\n- OpenVZ：很老的一款软件，只能运行在 linux 上，也只能虚拟出 linux 操作系统，国内很多在拆分的时候没有很好的维护以及滥用超售，不能运行需要编译内核的应用。\n- Xen：版虚拟化技术，性能有一定损失，可以升级内核等\n- KVM：最近两年刚流行的，是一个开源系统虚拟化模块，KVM 目前已经成为学术界主流的虚拟机监控器之一，目前因为硬件虚拟化技术等都比较成熟，KVM 性能优势等相当明显。\n\n对于 VPS 的免费软件选择： KVM > XEN > OpenVZ。\n\n#### 用途分析：\n\n- 搭建网站平台\n- 不熟企业信息化系统，中小型企业不存在机房，使用 VPS 会节约成本。\n- 挂 PT 数据传输分享\n- 加密数据访问，科学上网\n- 多人协作开发，代码托管\n- 私有云存储空间\n- 等等\n\n#### VPS 选择\n\n- 优先选择 linux VPS ，软件多，性能稳定，占用资源少，价格便宜等等。\n- 选择国内 VPS （阿里云/腾讯云）：面向群体为国内用户，需要 ICP 备案，时间较长；另外支持备案的域名较少，使用国内 VPS 时，购买域名需要慎重。\n- 选择国外 VPS （vultr，digitalocean, 搬瓦工）：客户是国外用户或者不用于商业用途，价格为国内一半以下，带宽充足。\n\n#### 选择虚拟技术\n\n优先选择 KVM， 其次 XEN 或 vmware，最后 OpenVZ。\n\n#### 硬件资源选择\n\n一般 VPS 会提供多种方案或者自由搭配组合，主要根据自己的实际需求选择硬件资源。\n\n- 应用要求高，则选择内存大的，CPU 强劲的方案，例如游戏服务器等\n- 网络应用，主要分享文件视频等，选择流量大的\n- 主要用于存储数据的，选择较大的硬盘空间。\n\n\n\n\n\n\n> https://www.youtube.com/watch?v=Hs-er4JwHc8\n> http://www.chinaz.com/prime/2012/1021/279069.shtml\n","slug":"2016/2016-12-19-vps-简介","published":1,"updated":"2016-12-20T15:00:16.341Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aj6003qmumu0fgfx5e6","content":"<p>起初对云服务很好奇，完全不知所云，无从下手的感觉，但经过一段时间的摸索研究，也基本能够搭建一些自己想要的服务了，这边根据一些网络资料和自己的学习研究，对这阶段进行一个总结，希望对那些刚刚开始尝试搭建云服务的网友有所帮助。</p>\n<h3 id=\"虚拟技术\"><a href=\"#虚拟技术\" class=\"headerlink\" title=\"虚拟技术\"></a>虚拟技术</h3><p>利用虚拟话技术在一台物理服务器上面创建多个相互隔离的虚拟化私有主机(“Virtual Private Server – VPS”)，可以看出原理和 PC 上面用虚拟机自己虚拟出来的系统并没有什么本质区别，只不过 VPS 是虚拟化之后放到网络上面使用的而已。对用户和应用程序来说，每个 VPS 平台的运行和管理都与一台独立主机完全相同，每个 VPS 均可以独立进行重启并且拥有 root 访问权限，用户，IP地址，内存，进程，文件，应用程序，系统函数库以及配置文件等。</p>\n<p>目前一般 VPS 结构是这样的：最底层为 Host Hardware 硬件， 然后是 Host Operating System 宿主机/真实系统，再然后是真实系统上面运行的虚拟化软件，最后是虚拟机软件内部运行的操作系统 Guest OS 访客系统（这边看上去和我们个人电脑 PC 上面跑的虚拟机中的虚拟操作系统并没啥区别）。</p>\n<p>随着云技术的不断成熟，现在的 VPS 也有了很大的改进，例如国内的腾讯，阿里等都给自己的 VPS 起了新名字，什么弹性云服务，无虚拟机，云服务器等等，从用户角度来看和 VPS 没有区别，但技术层面一般现在都会将 Host Hardware 硬件通过集群技术搭建，几百上千台主机共建一个硬件平台，然后分配资源建立 VPS，这边一般可以看作是 cloud VPS，可以做到弹性扩展，无缝对接，无需在需要时再去更新硬件资源。</p>\n<p>能够使用 linux VPS 完成的优先使用 linux。</p>\n<p>这边如果对 VPS 服务器等还有疑惑可以参考本博客的另外一篇文章<strong>虚拟主机、VPS和云主机</strong>。</p>\n<a id=\"more\"></a>\n<h4 id=\"桌面用户：\"><a href=\"#桌面用户：\" class=\"headerlink\" title=\"桌面用户：\"></a>桌面用户：</h4><p>vmware，virtualbox，virutalPC等，vmware，virtualbox都是支持多个操作系统的跨平台软件功能强大，用的也比较多。</p>\n<h4 id=\"服务器用户：\"><a href=\"#服务器用户：\" class=\"headerlink\" title=\"服务器用户：\"></a>服务器用户：</h4><ul>\n<li>Hyper-V：微软自带的虚拟化技术，只能在 windows 上运行，买 windows vps 很可能是 Hype-V 虚拟的</li>\n<li>vmware：专业做虚拟话技术的公司，产品覆盖很广，个人企业都有，功能强大，可运行在各个平台，虚拟出各种操作系统。</li>\n<li>OpenVZ：很老的一款软件，只能运行在 linux 上，也只能虚拟出 linux 操作系统，国内很多在拆分的时候没有很好的维护以及滥用超售，不能运行需要编译内核的应用。</li>\n<li>Xen：版虚拟化技术，性能有一定损失，可以升级内核等</li>\n<li>KVM：最近两年刚流行的，是一个开源系统虚拟化模块，KVM 目前已经成为学术界主流的虚拟机监控器之一，目前因为硬件虚拟化技术等都比较成熟，KVM 性能优势等相当明显。</li>\n</ul>\n<p>对于 VPS 的免费软件选择： KVM &gt; XEN &gt; OpenVZ。</p>\n<h4 id=\"用途分析：\"><a href=\"#用途分析：\" class=\"headerlink\" title=\"用途分析：\"></a>用途分析：</h4><ul>\n<li>搭建网站平台</li>\n<li>不熟企业信息化系统，中小型企业不存在机房，使用 VPS 会节约成本。</li>\n<li>挂 PT 数据传输分享</li>\n<li>加密数据访问，科学上网</li>\n<li>多人协作开发，代码托管</li>\n<li>私有云存储空间</li>\n<li>等等</li>\n</ul>\n<h4 id=\"VPS-选择\"><a href=\"#VPS-选择\" class=\"headerlink\" title=\"VPS 选择\"></a>VPS 选择</h4><ul>\n<li>优先选择 linux VPS ，软件多，性能稳定，占用资源少，价格便宜等等。</li>\n<li>选择国内 VPS （阿里云/腾讯云）：面向群体为国内用户，需要 ICP 备案，时间较长；另外支持备案的域名较少，使用国内 VPS 时，购买域名需要慎重。</li>\n<li>选择国外 VPS （vultr，digitalocean, 搬瓦工）：客户是国外用户或者不用于商业用途，价格为国内一半以下，带宽充足。</li>\n</ul>\n<h4 id=\"选择虚拟技术\"><a href=\"#选择虚拟技术\" class=\"headerlink\" title=\"选择虚拟技术\"></a>选择虚拟技术</h4><p>优先选择 KVM， 其次 XEN 或 vmware，最后 OpenVZ。</p>\n<h4 id=\"硬件资源选择\"><a href=\"#硬件资源选择\" class=\"headerlink\" title=\"硬件资源选择\"></a>硬件资源选择</h4><p>一般 VPS 会提供多种方案或者自由搭配组合，主要根据自己的实际需求选择硬件资源。</p>\n<ul>\n<li>应用要求高，则选择内存大的，CPU 强劲的方案，例如游戏服务器等</li>\n<li>网络应用，主要分享文件视频等，选择流量大的</li>\n<li>主要用于存储数据的，选择较大的硬盘空间。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.youtube.com/watch?v=Hs-er4JwHc8\" target=\"_blank\" rel=\"external\">https://www.youtube.com/watch?v=Hs-er4JwHc8</a><br><a href=\"http://www.chinaz.com/prime/2012/1021/279069.shtml\" target=\"_blank\" rel=\"external\">http://www.chinaz.com/prime/2012/1021/279069.shtml</a></p>\n</blockquote>\n","excerpt":"<p>起初对云服务很好奇，完全不知所云，无从下手的感觉，但经过一段时间的摸索研究，也基本能够搭建一些自己想要的服务了，这边根据一些网络资料和自己的学习研究，对这阶段进行一个总结，希望对那些刚刚开始尝试搭建云服务的网友有所帮助。</p>\n<h3 id=\"虚拟技术\"><a href=\"#虚拟技术\" class=\"headerlink\" title=\"虚拟技术\"></a>虚拟技术</h3><p>利用虚拟话技术在一台物理服务器上面创建多个相互隔离的虚拟化私有主机(“Virtual Private Server – VPS”)，可以看出原理和 PC 上面用虚拟机自己虚拟出来的系统并没有什么本质区别，只不过 VPS 是虚拟化之后放到网络上面使用的而已。对用户和应用程序来说，每个 VPS 平台的运行和管理都与一台独立主机完全相同，每个 VPS 均可以独立进行重启并且拥有 root 访问权限，用户，IP地址，内存，进程，文件，应用程序，系统函数库以及配置文件等。</p>\n<p>目前一般 VPS 结构是这样的：最底层为 Host Hardware 硬件， 然后是 Host Operating System 宿主机/真实系统，再然后是真实系统上面运行的虚拟化软件，最后是虚拟机软件内部运行的操作系统 Guest OS 访客系统（这边看上去和我们个人电脑 PC 上面跑的虚拟机中的虚拟操作系统并没啥区别）。</p>\n<p>随着云技术的不断成熟，现在的 VPS 也有了很大的改进，例如国内的腾讯，阿里等都给自己的 VPS 起了新名字，什么弹性云服务，无虚拟机，云服务器等等，从用户角度来看和 VPS 没有区别，但技术层面一般现在都会将 Host Hardware 硬件通过集群技术搭建，几百上千台主机共建一个硬件平台，然后分配资源建立 VPS，这边一般可以看作是 cloud VPS，可以做到弹性扩展，无缝对接，无需在需要时再去更新硬件资源。</p>\n<p>能够使用 linux VPS 完成的优先使用 linux。</p>\n<p>这边如果对 VPS 服务器等还有疑惑可以参考本博客的另外一篇文章<strong>虚拟主机、VPS和云主机</strong>。</p>","more":"<h4 id=\"桌面用户：\"><a href=\"#桌面用户：\" class=\"headerlink\" title=\"桌面用户：\"></a>桌面用户：</h4><p>vmware，virtualbox，virutalPC等，vmware，virtualbox都是支持多个操作系统的跨平台软件功能强大，用的也比较多。</p>\n<h4 id=\"服务器用户：\"><a href=\"#服务器用户：\" class=\"headerlink\" title=\"服务器用户：\"></a>服务器用户：</h4><ul>\n<li>Hyper-V：微软自带的虚拟化技术，只能在 windows 上运行，买 windows vps 很可能是 Hype-V 虚拟的</li>\n<li>vmware：专业做虚拟话技术的公司，产品覆盖很广，个人企业都有，功能强大，可运行在各个平台，虚拟出各种操作系统。</li>\n<li>OpenVZ：很老的一款软件，只能运行在 linux 上，也只能虚拟出 linux 操作系统，国内很多在拆分的时候没有很好的维护以及滥用超售，不能运行需要编译内核的应用。</li>\n<li>Xen：版虚拟化技术，性能有一定损失，可以升级内核等</li>\n<li>KVM：最近两年刚流行的，是一个开源系统虚拟化模块，KVM 目前已经成为学术界主流的虚拟机监控器之一，目前因为硬件虚拟化技术等都比较成熟，KVM 性能优势等相当明显。</li>\n</ul>\n<p>对于 VPS 的免费软件选择： KVM &gt; XEN &gt; OpenVZ。</p>\n<h4 id=\"用途分析：\"><a href=\"#用途分析：\" class=\"headerlink\" title=\"用途分析：\"></a>用途分析：</h4><ul>\n<li>搭建网站平台</li>\n<li>不熟企业信息化系统，中小型企业不存在机房，使用 VPS 会节约成本。</li>\n<li>挂 PT 数据传输分享</li>\n<li>加密数据访问，科学上网</li>\n<li>多人协作开发，代码托管</li>\n<li>私有云存储空间</li>\n<li>等等</li>\n</ul>\n<h4 id=\"VPS-选择\"><a href=\"#VPS-选择\" class=\"headerlink\" title=\"VPS 选择\"></a>VPS 选择</h4><ul>\n<li>优先选择 linux VPS ，软件多，性能稳定，占用资源少，价格便宜等等。</li>\n<li>选择国内 VPS （阿里云/腾讯云）：面向群体为国内用户，需要 ICP 备案，时间较长；另外支持备案的域名较少，使用国内 VPS 时，购买域名需要慎重。</li>\n<li>选择国外 VPS （vultr，digitalocean, 搬瓦工）：客户是国外用户或者不用于商业用途，价格为国内一半以下，带宽充足。</li>\n</ul>\n<h4 id=\"选择虚拟技术\"><a href=\"#选择虚拟技术\" class=\"headerlink\" title=\"选择虚拟技术\"></a>选择虚拟技术</h4><p>优先选择 KVM， 其次 XEN 或 vmware，最后 OpenVZ。</p>\n<h4 id=\"硬件资源选择\"><a href=\"#硬件资源选择\" class=\"headerlink\" title=\"硬件资源选择\"></a>硬件资源选择</h4><p>一般 VPS 会提供多种方案或者自由搭配组合，主要根据自己的实际需求选择硬件资源。</p>\n<ul>\n<li>应用要求高，则选择内存大的，CPU 强劲的方案，例如游戏服务器等</li>\n<li>网络应用，主要分享文件视频等，选择流量大的</li>\n<li>主要用于存储数据的，选择较大的硬盘空间。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.youtube.com/watch?v=Hs-er4JwHc8\">https://www.youtube.com/watch?v=Hs-er4JwHc8</a><br><a href=\"http://www.chinaz.com/prime/2012/1021/279069.shtml\">http://www.chinaz.com/prime/2012/1021/279069.shtml</a></p>\n</blockquote>"},{"layout":"post","title":"linux 系统瘦身","date":"2016-12-20T05:07:00.000Z","_content":"\n目前 PC 市场中，硬盘内存等硬件设备越来越廉价不值钱，所以很多人不再考虑删减系统清除无用文件等来节省更多的空间。然而，很多不同的应用对存储空间运行空间等依然十分敏感，本文主要针对是在个人使用的 VPS 上，如何使用更少的资源运行更多的服务。\n\n系统以 ubuntu/debian 为例，作为 VPS 普通服务器的操作系统来使用，进行优化，删除不会经常使用的工具，保留一些个人认为有用的功能。\n\n### 清理下载的缓存包\n\n在 Ubuntu 中通过 sudo apt-get install 安装软件时，其下载的包都缓存在 /var/cache/apt/archives/ 目录中。如果要清理掉这些已下载的缓存包，那么可以执行命令：\n`sudo apt-get autoclean` 和 `sudo apt-get clean` 。\n\n<!-- more -->\n\n### 清理不再需要的包\n\n在 Ubuntu 系统中安装软件时，该软件的依赖通常也会自动安装上。那么，在删除该软件后，其依赖可能需要我们手动删除之。可以运行 sudo apt-get autoremove 命令来解决这个问题。\n\n### 清除 update 库\n\n清除 apt-get update 过程中所下载的软件库列表： `rm -rf /var/lib/apt/lists/*` 。但注意每次执行 apt-get update 后还会重新更新这些文件，因此在仍然需要安装软件的 VPS 上这个用处不大，但是如果服务器已经配置成功了，可以接连使用  `rm -rf /var/lib/apt/lists/* &&  apt-get autoclean && apt-get autoremove` 来清除空间。\n\n### 清理无用的语言文件\n\nUbuntu 与其他 Linux 发行版一样，是一个支持多语言界面的系统。其实，对使用自己母语的我们来说，通常保留中文即可，也可以保留自己所需要使用的语言，如英文。其他的语言文件则没有必要保留。为了清理这些无用的语言文件，需要在 Ubuntu 系统中安装一个名为 localepurge 的小工具，apt-get install localepurge。执行 localepurge，软件会提示你如何操作，服务器端建议只保留 en, en_US, en_US.UTF-8 。该软件分为两种界面，一种是直接按空格选择需要保留的包，另外一种是输入包序号选择保留包。\n\n\n### 清理 build-essential \n\n查看该软件包的依赖关系，可以看到以下内容：\n$ apt-cache depends build-essential\n```\n\tbuild-essential\n\t|依赖: libc6-dev\n\t依赖: <libc-dev>\n\tlibc6-dev\n\t依赖: gcc\n\t依赖: g++\n\t依赖: make\n\t依赖: dpkg-dev\n```\n也就是说，安装了该软件包，编译c/c++所需要的软件包也都会被安装。因此如果想在Ubuntu中编译c/c++程序，需要安装该软件包就可以了， build-essential 里面包含了最常用的编译工具，编译程序有了这个软件包\n它才知道头文件在哪，也才知道库函数在哪，还会下载其他依赖的软件包，最后才组成一个开发环境。\n\n对于不开发 c/c++ 用的服务器来说，如果只是用安装包安装，不用源码编译的话，则可以卸载这个软件包。\n\n\n### 清除部分文档帮助文件\n\n清除其中的一些帮助说明文档： `rm -rf /usr/share/{doc,man}` 。\n\n\n### 编辑器安装和卸载\n\n安装 vim，个人习惯只用 vim ，但 vim 的套件也会占用 20M 以上的空间，这边如果对编辑器没有特殊要求的可以安装使用 nano （约 2M 大小）。\n\n\n\n\n> 参考链接：\n> https://zhidao.baidu.com/question/2051702708087103867.html\n> http://www.cnblogs.com/dolphi/p/3622570.html\n","source":"_posts/2016/2016-12-20-linux-系统瘦身.md","raw":"---\nlayout: \"post\"\ntitle: \"linux 系统瘦身\"\ndate: \"2016-12-20 13:07\"\n---\n\n目前 PC 市场中，硬盘内存等硬件设备越来越廉价不值钱，所以很多人不再考虑删减系统清除无用文件等来节省更多的空间。然而，很多不同的应用对存储空间运行空间等依然十分敏感，本文主要针对是在个人使用的 VPS 上，如何使用更少的资源运行更多的服务。\n\n系统以 ubuntu/debian 为例，作为 VPS 普通服务器的操作系统来使用，进行优化，删除不会经常使用的工具，保留一些个人认为有用的功能。\n\n### 清理下载的缓存包\n\n在 Ubuntu 中通过 sudo apt-get install 安装软件时，其下载的包都缓存在 /var/cache/apt/archives/ 目录中。如果要清理掉这些已下载的缓存包，那么可以执行命令：\n`sudo apt-get autoclean` 和 `sudo apt-get clean` 。\n\n<!-- more -->\n\n### 清理不再需要的包\n\n在 Ubuntu 系统中安装软件时，该软件的依赖通常也会自动安装上。那么，在删除该软件后，其依赖可能需要我们手动删除之。可以运行 sudo apt-get autoremove 命令来解决这个问题。\n\n### 清除 update 库\n\n清除 apt-get update 过程中所下载的软件库列表： `rm -rf /var/lib/apt/lists/*` 。但注意每次执行 apt-get update 后还会重新更新这些文件，因此在仍然需要安装软件的 VPS 上这个用处不大，但是如果服务器已经配置成功了，可以接连使用  `rm -rf /var/lib/apt/lists/* &&  apt-get autoclean && apt-get autoremove` 来清除空间。\n\n### 清理无用的语言文件\n\nUbuntu 与其他 Linux 发行版一样，是一个支持多语言界面的系统。其实，对使用自己母语的我们来说，通常保留中文即可，也可以保留自己所需要使用的语言，如英文。其他的语言文件则没有必要保留。为了清理这些无用的语言文件，需要在 Ubuntu 系统中安装一个名为 localepurge 的小工具，apt-get install localepurge。执行 localepurge，软件会提示你如何操作，服务器端建议只保留 en, en_US, en_US.UTF-8 。该软件分为两种界面，一种是直接按空格选择需要保留的包，另外一种是输入包序号选择保留包。\n\n\n### 清理 build-essential \n\n查看该软件包的依赖关系，可以看到以下内容：\n$ apt-cache depends build-essential\n```\n\tbuild-essential\n\t|依赖: libc6-dev\n\t依赖: <libc-dev>\n\tlibc6-dev\n\t依赖: gcc\n\t依赖: g++\n\t依赖: make\n\t依赖: dpkg-dev\n```\n也就是说，安装了该软件包，编译c/c++所需要的软件包也都会被安装。因此如果想在Ubuntu中编译c/c++程序，需要安装该软件包就可以了， build-essential 里面包含了最常用的编译工具，编译程序有了这个软件包\n它才知道头文件在哪，也才知道库函数在哪，还会下载其他依赖的软件包，最后才组成一个开发环境。\n\n对于不开发 c/c++ 用的服务器来说，如果只是用安装包安装，不用源码编译的话，则可以卸载这个软件包。\n\n\n### 清除部分文档帮助文件\n\n清除其中的一些帮助说明文档： `rm -rf /usr/share/{doc,man}` 。\n\n\n### 编辑器安装和卸载\n\n安装 vim，个人习惯只用 vim ，但 vim 的套件也会占用 20M 以上的空间，这边如果对编辑器没有特殊要求的可以安装使用 nano （约 2M 大小）。\n\n\n\n\n> 参考链接：\n> https://zhidao.baidu.com/question/2051702708087103867.html\n> http://www.cnblogs.com/dolphi/p/3622570.html\n","slug":"2016/2016-12-20-linux-系统瘦身","published":1,"updated":"2017-01-05T01:37:56.214Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aj8003rmumufcriam49","content":"<p>目前 PC 市场中，硬盘内存等硬件设备越来越廉价不值钱，所以很多人不再考虑删减系统清除无用文件等来节省更多的空间。然而，很多不同的应用对存储空间运行空间等依然十分敏感，本文主要针对是在个人使用的 VPS 上，如何使用更少的资源运行更多的服务。</p>\n<p>系统以 ubuntu/debian 为例，作为 VPS 普通服务器的操作系统来使用，进行优化，删除不会经常使用的工具，保留一些个人认为有用的功能。</p>\n<h3 id=\"清理下载的缓存包\"><a href=\"#清理下载的缓存包\" class=\"headerlink\" title=\"清理下载的缓存包\"></a>清理下载的缓存包</h3><p>在 Ubuntu 中通过 sudo apt-get install 安装软件时，其下载的包都缓存在 /var/cache/apt/archives/ 目录中。如果要清理掉这些已下载的缓存包，那么可以执行命令：<br><code>sudo apt-get autoclean</code> 和 <code>sudo apt-get clean</code> 。</p>\n<a id=\"more\"></a>\n<h3 id=\"清理不再需要的包\"><a href=\"#清理不再需要的包\" class=\"headerlink\" title=\"清理不再需要的包\"></a>清理不再需要的包</h3><p>在 Ubuntu 系统中安装软件时，该软件的依赖通常也会自动安装上。那么，在删除该软件后，其依赖可能需要我们手动删除之。可以运行 sudo apt-get autoremove 命令来解决这个问题。</p>\n<h3 id=\"清除-update-库\"><a href=\"#清除-update-库\" class=\"headerlink\" title=\"清除 update 库\"></a>清除 update 库</h3><p>清除 apt-get update 过程中所下载的软件库列表： <code>rm -rf /var/lib/apt/lists/*</code> 。但注意每次执行 apt-get update 后还会重新更新这些文件，因此在仍然需要安装软件的 VPS 上这个用处不大，但是如果服务器已经配置成功了，可以接连使用  <code>rm -rf /var/lib/apt/lists/* &amp;&amp;  apt-get autoclean &amp;&amp; apt-get autoremove</code> 来清除空间。</p>\n<h3 id=\"清理无用的语言文件\"><a href=\"#清理无用的语言文件\" class=\"headerlink\" title=\"清理无用的语言文件\"></a>清理无用的语言文件</h3><p>Ubuntu 与其他 Linux 发行版一样，是一个支持多语言界面的系统。其实，对使用自己母语的我们来说，通常保留中文即可，也可以保留自己所需要使用的语言，如英文。其他的语言文件则没有必要保留。为了清理这些无用的语言文件，需要在 Ubuntu 系统中安装一个名为 localepurge 的小工具，apt-get install localepurge。执行 localepurge，软件会提示你如何操作，服务器端建议只保留 en, en_US, en_US.UTF-8 。该软件分为两种界面，一种是直接按空格选择需要保留的包，另外一种是输入包序号选择保留包。</p>\n<h3 id=\"清理-build-essential\"><a href=\"#清理-build-essential\" class=\"headerlink\" title=\"清理 build-essential\"></a>清理 build-essential</h3><p>查看该软件包的依赖关系，可以看到以下内容：<br>$ apt-cache depends build-essential<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">build-essential</div><div class=\"line\">|依赖: libc6-dev</div><div class=\"line\">依赖: &lt;libc-dev&gt;</div><div class=\"line\">libc6-dev</div><div class=\"line\">依赖: gcc</div><div class=\"line\">依赖: g++</div><div class=\"line\">依赖: make</div><div class=\"line\">依赖: dpkg-dev</div></pre></td></tr></table></figure></p>\n<p>也就是说，安装了该软件包，编译c/c++所需要的软件包也都会被安装。因此如果想在Ubuntu中编译c/c++程序，需要安装该软件包就可以了， build-essential 里面包含了最常用的编译工具，编译程序有了这个软件包<br>它才知道头文件在哪，也才知道库函数在哪，还会下载其他依赖的软件包，最后才组成一个开发环境。</p>\n<p>对于不开发 c/c++ 用的服务器来说，如果只是用安装包安装，不用源码编译的话，则可以卸载这个软件包。</p>\n<h3 id=\"清除部分文档帮助文件\"><a href=\"#清除部分文档帮助文件\" class=\"headerlink\" title=\"清除部分文档帮助文件\"></a>清除部分文档帮助文件</h3><p>清除其中的一些帮助说明文档： <code>rm -rf /usr/share/{doc,man}</code> 。</p>\n<h3 id=\"编辑器安装和卸载\"><a href=\"#编辑器安装和卸载\" class=\"headerlink\" title=\"编辑器安装和卸载\"></a>编辑器安装和卸载</h3><p>安装 vim，个人习惯只用 vim ，但 vim 的套件也会占用 20M 以上的空间，这边如果对编辑器没有特殊要求的可以安装使用 nano （约 2M 大小）。</p>\n<blockquote>\n<p>参考链接：<br><a href=\"https://zhidao.baidu.com/question/2051702708087103867.html\" target=\"_blank\" rel=\"external\">https://zhidao.baidu.com/question/2051702708087103867.html</a><br><a href=\"http://www.cnblogs.com/dolphi/p/3622570.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/dolphi/p/3622570.html</a></p>\n</blockquote>\n","excerpt":"<p>目前 PC 市场中，硬盘内存等硬件设备越来越廉价不值钱，所以很多人不再考虑删减系统清除无用文件等来节省更多的空间。然而，很多不同的应用对存储空间运行空间等依然十分敏感，本文主要针对是在个人使用的 VPS 上，如何使用更少的资源运行更多的服务。</p>\n<p>系统以 ubuntu/debian 为例，作为 VPS 普通服务器的操作系统来使用，进行优化，删除不会经常使用的工具，保留一些个人认为有用的功能。</p>\n<h3 id=\"清理下载的缓存包\"><a href=\"#清理下载的缓存包\" class=\"headerlink\" title=\"清理下载的缓存包\"></a>清理下载的缓存包</h3><p>在 Ubuntu 中通过 sudo apt-get install 安装软件时，其下载的包都缓存在 /var/cache/apt/archives/ 目录中。如果要清理掉这些已下载的缓存包，那么可以执行命令：<br><code>sudo apt-get autoclean</code> 和 <code>sudo apt-get clean</code> 。</p>","more":"<h3 id=\"清理不再需要的包\"><a href=\"#清理不再需要的包\" class=\"headerlink\" title=\"清理不再需要的包\"></a>清理不再需要的包</h3><p>在 Ubuntu 系统中安装软件时，该软件的依赖通常也会自动安装上。那么，在删除该软件后，其依赖可能需要我们手动删除之。可以运行 sudo apt-get autoremove 命令来解决这个问题。</p>\n<h3 id=\"清除-update-库\"><a href=\"#清除-update-库\" class=\"headerlink\" title=\"清除 update 库\"></a>清除 update 库</h3><p>清除 apt-get update 过程中所下载的软件库列表： <code>rm -rf /var/lib/apt/lists/*</code> 。但注意每次执行 apt-get update 后还会重新更新这些文件，因此在仍然需要安装软件的 VPS 上这个用处不大，但是如果服务器已经配置成功了，可以接连使用  <code>rm -rf /var/lib/apt/lists/* &amp;&amp;  apt-get autoclean &amp;&amp; apt-get autoremove</code> 来清除空间。</p>\n<h3 id=\"清理无用的语言文件\"><a href=\"#清理无用的语言文件\" class=\"headerlink\" title=\"清理无用的语言文件\"></a>清理无用的语言文件</h3><p>Ubuntu 与其他 Linux 发行版一样，是一个支持多语言界面的系统。其实，对使用自己母语的我们来说，通常保留中文即可，也可以保留自己所需要使用的语言，如英文。其他的语言文件则没有必要保留。为了清理这些无用的语言文件，需要在 Ubuntu 系统中安装一个名为 localepurge 的小工具，apt-get install localepurge。执行 localepurge，软件会提示你如何操作，服务器端建议只保留 en, en_US, en_US.UTF-8 。该软件分为两种界面，一种是直接按空格选择需要保留的包，另外一种是输入包序号选择保留包。</p>\n<h3 id=\"清理-build-essential\"><a href=\"#清理-build-essential\" class=\"headerlink\" title=\"清理 build-essential\"></a>清理 build-essential</h3><p>查看该软件包的依赖关系，可以看到以下内容：<br>$ apt-cache depends build-essential<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">build-essential</div><div class=\"line\">|依赖: libc6-dev</div><div class=\"line\">依赖: &lt;libc-dev&gt;</div><div class=\"line\">libc6-dev</div><div class=\"line\">依赖: gcc</div><div class=\"line\">依赖: g++</div><div class=\"line\">依赖: make</div><div class=\"line\">依赖: dpkg-dev</div></pre></td></tr></table></figure></p>\n<p>也就是说，安装了该软件包，编译c/c++所需要的软件包也都会被安装。因此如果想在Ubuntu中编译c/c++程序，需要安装该软件包就可以了， build-essential 里面包含了最常用的编译工具，编译程序有了这个软件包<br>它才知道头文件在哪，也才知道库函数在哪，还会下载其他依赖的软件包，最后才组成一个开发环境。</p>\n<p>对于不开发 c/c++ 用的服务器来说，如果只是用安装包安装，不用源码编译的话，则可以卸载这个软件包。</p>\n<h3 id=\"清除部分文档帮助文件\"><a href=\"#清除部分文档帮助文件\" class=\"headerlink\" title=\"清除部分文档帮助文件\"></a>清除部分文档帮助文件</h3><p>清除其中的一些帮助说明文档： <code>rm -rf /usr/share/{doc,man}</code> 。</p>\n<h3 id=\"编辑器安装和卸载\"><a href=\"#编辑器安装和卸载\" class=\"headerlink\" title=\"编辑器安装和卸载\"></a>编辑器安装和卸载</h3><p>安装 vim，个人习惯只用 vim ，但 vim 的套件也会占用 20M 以上的空间，这边如果对编辑器没有特殊要求的可以安装使用 nano （约 2M 大小）。</p>\n<blockquote>\n<p>参考链接：<br><a href=\"https://zhidao.baidu.com/question/2051702708087103867.html\">https://zhidao.baidu.com/question/2051702708087103867.html</a><br><a href=\"http://www.cnblogs.com/dolphi/p/3622570.html\">http://www.cnblogs.com/dolphi/p/3622570.html</a></p>\n</blockquote>"},{"layout":"post","title":"GithubPage+Hexo搭建博客","date":"2016-12-14T11:01:00.000Z","_content":"\n\n个人博客是使用 githubpage+jekyll 搭建的，且博客已经工作有半年了，但由于期初的模板没有找好，加上一些其他的问题，导致博客看起来比较凌乱，这边给出另外一个 GithubPage+Hexo 的博客搭建方法供大家参考，本文操作系统主要使用的是 ubuntu 16.04，使用其他 linux 发行版的用户，可以参考本文。附上最终效果图如下：\n\n\n### 安装步骤\n\n#### 安装 node.js\n\nNode.js 是一个开放源代码、跨平台的、可用于服务器端和网络应用的运行环境，该应用由 C++ 语言写成，在 Node.js 运行时运行。Node.js 提供事件驱动和非阻塞 I/O API，可优化应用程序的吞吐量和规模。这些技术通常被用于实时应用程序。并且它是采用 Google 的 V8 引擎来执行代码，它的大部分基本模块都是用 JavaScript 写成的，包含有一系列内置模块，使得程序可以作为独立服务器运行，从而脱离 Apache HTTP Server 或 IIS 运行。npm 也即 Node包管理器（Node Package Manager），它是一个以 Javascript 编写的软件包管理系统，默认环境为 Node.js 。\n\n- 安装 nodejs ： sudo apt-get install nodejs , 注意 ubuntu 16.04 使用：sudo apt install nodejs\n- 安装 npm ： sudo apt-get install npm ， 注意 ubuntu 16.04 使用：sudo apt install npm\n\n需要安装 nrm ， nrm 是 npm 的资源管理器，借助各个工具可以方便快捷地对 npm 的源进行管理。另外，由于国内网络环境原因在使用 npm 默认下载源的时候不仅速度非常慢而且常常会超时，因此这里还手动指定了从淘宝源下载。`sudo npm install nrm -g --registry https://registry.npm.taobao.org`，`nrm use taobao`（如果出现无法找到 node 则执行： `sudo  ln -s /usr/bin/nodejs /usr/bin/node` ）\n\n<!-- more -->\n\n\n#### 安装 git\n\n这边步骤在多篇博文中都有详细描述，这边就不再累述了，可以直接搜索引擎搜索，或者在本博客的其他文章中找到。\n\n\n#### 安装 Hexo\n\n[Hexo](https://hexo.io/zh-cn/) 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。接下来我们开始使用 Hexo 搭建博客。\n\n- 创建并进入目录 Hexo ：`mkdir Hexo && cd Hexo`\n- 使用 hexo 生成博客框架。依次执行如下命令(hexo init blog 过程可能会比较慢，需要耐心等待。)：\n```\n$ hexo init blog \n$ cd blog\n$ npm install \n$ hexo generate (hexo generate 为我们生成了静态文件存储于 public 文件夹之下，并且在一开始默认情况下执行这句将会为我们生成一个 Hello World 的页面。)\n$ hexo server (通过 hexo server 运行起 hexo 内置的服务器。这时候就可以开始在本地访问了，默认地址为 localhost:4000 。)\n```\n注意：hexo 中的 generate, server, dpoly 等操作都可以简写为首字母，所以 hexo generate 等同于 hexo g ，hexo server 等同于 hexo s，。\n\n\n### 模块简介\n通过 tree | less 可以查看以下 blog 的目录结构，主要的几个文件和目录的作用分别如下：\n- _config.yml ：配置文件，可以修改网站的主题、标题、作者等信息。\n- public ：由 hexo 根据 source 文件夹中的资源进行渲染生成的文件夹，里边存储着最终的静态网页文件。\n- scaffolds/ ：模板文件，当要给博客添加新文章的时候，将根据对应的模板进行创建。\n- source/ ：用于存储用户资源，比如文章与新页面等。其中以 _ 开头的文件夹中除了 _posts 文件夹中的 markdown 或 HTML 文件会在执行 generate 操作的时候被渲染添加到 public 文件夹中之外，其他均被忽略。而且在初始化博客的过程中 _posts 目录底会自带一个 hello-world.md 的文件。\n- themes/ ：主题文件，自带默认主题 landscape 。\n\n### 操作指导\n\n#### 主题配置\n\n下载并解压缩 [NexT 主题](https://github.com/iissnan/hexo-theme-next)，`wget http://labfile.oss.aliyuncs.com/courses/700/next.zip && unzip next.zip` 需要将主题文件放入 Hexo/blog/themes 下，打开 ../blog/_config.yml 修改 theme 后的内容就可以更改主题了。\n\n这会博客就套上了我们的新模板了。但是我们发现博客菜单上的文字是英文的于是我们还要重新配置以下，让主题以中文的方式显示。再次编辑 _config.yml 文件，将 language 项设置为 zh-Hans 。\n\n注意更改主题后每次需要重启 `hexo server` 服务才可以刷新网页。\n\n\n#### 文章创建\n\n`hexo new [layout] <filename>` 其中 layout 为可选参数，指定了新创建的文件布局，默认为 post 文件。 filename 为必填参数，指定了文件名，如果文件名中有空格则需要把文件名用引号\"\" 包裹起来。例如： 终端输入：  `hexo new \"我的第一篇文章\"` ，这时候我们发现 hexo 在 source/_post 目录之下创建了一个 我的第一篇文章.md 的文件。打开该文件进行编辑。我们也可以通过 atom 等常用的 markdown 编辑工具直接在 source/_post 目录下创建文章进行编辑即可。刷新浏览器就可以看到我们博客更新的内容了。\n\n至此我们基本配置好了本地 hexo 服务，能够自己写点内容了。\n\n\n#### 部署到 github page\n\n访问 github，创建库 `git账户名.github.io` ， 这一这个名字是固定的，一般的库没法修改跳转地址，只能显示为 github page 。\n\n将远程库同步到本地，`git clone [你的仓库的 url]`，本地会多出一个 `git账户名.github.io` 的文件夹，然后把 public 文件目录下的博客文件都复制到你的本地仓库中，并将本地仓库 push 到 github 仓库上。这样当其他人访问你的博客链接的时候 github 将会自动将该仓库中的相应文件展示出来。\n```\n$ cp -R public/* [你的仓库名]\n$ cd [你的仓库名]\n$ git add .\n$ git commit -m 'update blog'\n$ git push\n```\n\n以上步骤虽然看起来貌似繁琐，但实际可以写成 bash 脚本，这样每次就会自动生成 public 自动复制以及上传了。\n\n\n### 扩展补充\n\n上述虽然配置完成了 hexo 博客，但博客功能过于简单，使用起来不方便，可以添加图片，摘要，标签页与分类页等内容。\n\n\n### 小结\n\nhexo 比 jekyll 布局更简单，更加容易操作，但每次需要本地生成 html 然后上传同步，虽然这不是问题，可以用脚本实现，但对于图片等内容，需要依赖第三方图床就显得很是无奈了。\n\n\n> 参考链接：\n> http://behappyli.cn/2015/12/05/hexo%E6%95%99%E7%A8%8B/\n> http://www.runoob.com/w3cnote/git-guide.html\n","source":"_posts/2016/2016-12-14-githubpage-hexo搭建博客.md","raw":"---\nlayout: \"post\"\ntitle: \"GithubPage+Hexo搭建博客\"\ndate: \"2016-12-14 19:01\"\n---\n\n\n个人博客是使用 githubpage+jekyll 搭建的，且博客已经工作有半年了，但由于期初的模板没有找好，加上一些其他的问题，导致博客看起来比较凌乱，这边给出另外一个 GithubPage+Hexo 的博客搭建方法供大家参考，本文操作系统主要使用的是 ubuntu 16.04，使用其他 linux 发行版的用户，可以参考本文。附上最终效果图如下：\n\n\n### 安装步骤\n\n#### 安装 node.js\n\nNode.js 是一个开放源代码、跨平台的、可用于服务器端和网络应用的运行环境，该应用由 C++ 语言写成，在 Node.js 运行时运行。Node.js 提供事件驱动和非阻塞 I/O API，可优化应用程序的吞吐量和规模。这些技术通常被用于实时应用程序。并且它是采用 Google 的 V8 引擎来执行代码，它的大部分基本模块都是用 JavaScript 写成的，包含有一系列内置模块，使得程序可以作为独立服务器运行，从而脱离 Apache HTTP Server 或 IIS 运行。npm 也即 Node包管理器（Node Package Manager），它是一个以 Javascript 编写的软件包管理系统，默认环境为 Node.js 。\n\n- 安装 nodejs ： sudo apt-get install nodejs , 注意 ubuntu 16.04 使用：sudo apt install nodejs\n- 安装 npm ： sudo apt-get install npm ， 注意 ubuntu 16.04 使用：sudo apt install npm\n\n需要安装 nrm ， nrm 是 npm 的资源管理器，借助各个工具可以方便快捷地对 npm 的源进行管理。另外，由于国内网络环境原因在使用 npm 默认下载源的时候不仅速度非常慢而且常常会超时，因此这里还手动指定了从淘宝源下载。`sudo npm install nrm -g --registry https://registry.npm.taobao.org`，`nrm use taobao`（如果出现无法找到 node 则执行： `sudo  ln -s /usr/bin/nodejs /usr/bin/node` ）\n\n<!-- more -->\n\n\n#### 安装 git\n\n这边步骤在多篇博文中都有详细描述，这边就不再累述了，可以直接搜索引擎搜索，或者在本博客的其他文章中找到。\n\n\n#### 安装 Hexo\n\n[Hexo](https://hexo.io/zh-cn/) 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。接下来我们开始使用 Hexo 搭建博客。\n\n- 创建并进入目录 Hexo ：`mkdir Hexo && cd Hexo`\n- 使用 hexo 生成博客框架。依次执行如下命令(hexo init blog 过程可能会比较慢，需要耐心等待。)：\n```\n$ hexo init blog \n$ cd blog\n$ npm install \n$ hexo generate (hexo generate 为我们生成了静态文件存储于 public 文件夹之下，并且在一开始默认情况下执行这句将会为我们生成一个 Hello World 的页面。)\n$ hexo server (通过 hexo server 运行起 hexo 内置的服务器。这时候就可以开始在本地访问了，默认地址为 localhost:4000 。)\n```\n注意：hexo 中的 generate, server, dpoly 等操作都可以简写为首字母，所以 hexo generate 等同于 hexo g ，hexo server 等同于 hexo s，。\n\n\n### 模块简介\n通过 tree | less 可以查看以下 blog 的目录结构，主要的几个文件和目录的作用分别如下：\n- _config.yml ：配置文件，可以修改网站的主题、标题、作者等信息。\n- public ：由 hexo 根据 source 文件夹中的资源进行渲染生成的文件夹，里边存储着最终的静态网页文件。\n- scaffolds/ ：模板文件，当要给博客添加新文章的时候，将根据对应的模板进行创建。\n- source/ ：用于存储用户资源，比如文章与新页面等。其中以 _ 开头的文件夹中除了 _posts 文件夹中的 markdown 或 HTML 文件会在执行 generate 操作的时候被渲染添加到 public 文件夹中之外，其他均被忽略。而且在初始化博客的过程中 _posts 目录底会自带一个 hello-world.md 的文件。\n- themes/ ：主题文件，自带默认主题 landscape 。\n\n### 操作指导\n\n#### 主题配置\n\n下载并解压缩 [NexT 主题](https://github.com/iissnan/hexo-theme-next)，`wget http://labfile.oss.aliyuncs.com/courses/700/next.zip && unzip next.zip` 需要将主题文件放入 Hexo/blog/themes 下，打开 ../blog/_config.yml 修改 theme 后的内容就可以更改主题了。\n\n这会博客就套上了我们的新模板了。但是我们发现博客菜单上的文字是英文的于是我们还要重新配置以下，让主题以中文的方式显示。再次编辑 _config.yml 文件，将 language 项设置为 zh-Hans 。\n\n注意更改主题后每次需要重启 `hexo server` 服务才可以刷新网页。\n\n\n#### 文章创建\n\n`hexo new [layout] <filename>` 其中 layout 为可选参数，指定了新创建的文件布局，默认为 post 文件。 filename 为必填参数，指定了文件名，如果文件名中有空格则需要把文件名用引号\"\" 包裹起来。例如： 终端输入：  `hexo new \"我的第一篇文章\"` ，这时候我们发现 hexo 在 source/_post 目录之下创建了一个 我的第一篇文章.md 的文件。打开该文件进行编辑。我们也可以通过 atom 等常用的 markdown 编辑工具直接在 source/_post 目录下创建文章进行编辑即可。刷新浏览器就可以看到我们博客更新的内容了。\n\n至此我们基本配置好了本地 hexo 服务，能够自己写点内容了。\n\n\n#### 部署到 github page\n\n访问 github，创建库 `git账户名.github.io` ， 这一这个名字是固定的，一般的库没法修改跳转地址，只能显示为 github page 。\n\n将远程库同步到本地，`git clone [你的仓库的 url]`，本地会多出一个 `git账户名.github.io` 的文件夹，然后把 public 文件目录下的博客文件都复制到你的本地仓库中，并将本地仓库 push 到 github 仓库上。这样当其他人访问你的博客链接的时候 github 将会自动将该仓库中的相应文件展示出来。\n```\n$ cp -R public/* [你的仓库名]\n$ cd [你的仓库名]\n$ git add .\n$ git commit -m 'update blog'\n$ git push\n```\n\n以上步骤虽然看起来貌似繁琐，但实际可以写成 bash 脚本，这样每次就会自动生成 public 自动复制以及上传了。\n\n\n### 扩展补充\n\n上述虽然配置完成了 hexo 博客，但博客功能过于简单，使用起来不方便，可以添加图片，摘要，标签页与分类页等内容。\n\n\n### 小结\n\nhexo 比 jekyll 布局更简单，更加容易操作，但每次需要本地生成 html 然后上传同步，虽然这不是问题，可以用脚本实现，但对于图片等内容，需要依赖第三方图床就显得很是无奈了。\n\n\n> 参考链接：\n> http://behappyli.cn/2015/12/05/hexo%E6%95%99%E7%A8%8B/\n> http://www.runoob.com/w3cnote/git-guide.html\n","slug":"2016/2016-12-14-githubpage-hexo搭建博客","published":1,"updated":"2017-01-25T06:03:43.639Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aj9003smumuwou48d26","content":"<p>个人博客是使用 githubpage+jekyll 搭建的，且博客已经工作有半年了，但由于期初的模板没有找好，加上一些其他的问题，导致博客看起来比较凌乱，这边给出另外一个 GithubPage+Hexo 的博客搭建方法供大家参考，本文操作系统主要使用的是 ubuntu 16.04，使用其他 linux 发行版的用户，可以参考本文。附上最终效果图如下：</p>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><h4 id=\"安装-node-js\"><a href=\"#安装-node-js\" class=\"headerlink\" title=\"安装 node.js\"></a>安装 node.js</h4><p>Node.js 是一个开放源代码、跨平台的、可用于服务器端和网络应用的运行环境，该应用由 C++ 语言写成，在 Node.js 运行时运行。Node.js 提供事件驱动和非阻塞 I/O API，可优化应用程序的吞吐量和规模。这些技术通常被用于实时应用程序。并且它是采用 Google 的 V8 引擎来执行代码，它的大部分基本模块都是用 JavaScript 写成的，包含有一系列内置模块，使得程序可以作为独立服务器运行，从而脱离 Apache HTTP Server 或 IIS 运行。npm 也即 Node包管理器（Node Package Manager），它是一个以 Javascript 编写的软件包管理系统，默认环境为 Node.js 。</p>\n<ul>\n<li>安装 nodejs ： sudo apt-get install nodejs , 注意 ubuntu 16.04 使用：sudo apt install nodejs</li>\n<li>安装 npm ： sudo apt-get install npm ， 注意 ubuntu 16.04 使用：sudo apt install npm</li>\n</ul>\n<p>需要安装 nrm ， nrm 是 npm 的资源管理器，借助各个工具可以方便快捷地对 npm 的源进行管理。另外，由于国内网络环境原因在使用 npm 默认下载源的时候不仅速度非常慢而且常常会超时，因此这里还手动指定了从淘宝源下载。<code>sudo npm install nrm -g --registry https://registry.npm.taobao.org</code>，<code>nrm use taobao</code>（如果出现无法找到 node 则执行： <code>sudo  ln -s /usr/bin/nodejs /usr/bin/node</code> ）</p>\n<a id=\"more\"></a>\n<h4 id=\"安装-git\"><a href=\"#安装-git\" class=\"headerlink\" title=\"安装 git\"></a>安装 git</h4><p>这边步骤在多篇博文中都有详细描述，这边就不再累述了，可以直接搜索引擎搜索，或者在本博客的其他文章中找到。</p>\n<h4 id=\"安装-Hexo\"><a href=\"#安装-Hexo\" class=\"headerlink\" title=\"安装 Hexo\"></a>安装 Hexo</h4><p><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"external\">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。接下来我们开始使用 Hexo 搭建博客。</p>\n<ul>\n<li>创建并进入目录 Hexo ：<code>mkdir Hexo &amp;&amp; cd Hexo</code></li>\n<li>使用 hexo 生成博客框架。依次执行如下命令(hexo init blog 过程可能会比较慢，需要耐心等待。)：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo init blog </div><div class=\"line\">$ cd blog</div><div class=\"line\">$ npm install </div><div class=\"line\">$ hexo generate (hexo generate 为我们生成了静态文件存储于 public 文件夹之下，并且在一开始默认情况下执行这句将会为我们生成一个 Hello World 的页面。)</div><div class=\"line\">$ hexo server (通过 hexo server 运行起 hexo 内置的服务器。这时候就可以开始在本地访问了，默认地址为 localhost:4000 。)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意：hexo 中的 generate, server, dpoly 等操作都可以简写为首字母，所以 hexo generate 等同于 hexo g ，hexo server 等同于 hexo s，。</p>\n<h3 id=\"模块简介\"><a href=\"#模块简介\" class=\"headerlink\" title=\"模块简介\"></a>模块简介</h3><p>通过 tree | less 可以查看以下 blog 的目录结构，主要的几个文件和目录的作用分别如下：</p>\n<ul>\n<li>_config.yml ：配置文件，可以修改网站的主题、标题、作者等信息。</li>\n<li>public ：由 hexo 根据 source 文件夹中的资源进行渲染生成的文件夹，里边存储着最终的静态网页文件。</li>\n<li>scaffolds/ ：模板文件，当要给博客添加新文章的时候，将根据对应的模板进行创建。</li>\n<li>source/ ：用于存储用户资源，比如文章与新页面等。其中以 _ 开头的文件夹中除了 _posts 文件夹中的 markdown 或 HTML 文件会在执行 generate 操作的时候被渲染添加到 public 文件夹中之外，其他均被忽略。而且在初始化博客的过程中 _posts 目录底会自带一个 hello-world.md 的文件。</li>\n<li>themes/ ：主题文件，自带默认主题 landscape 。</li>\n</ul>\n<h3 id=\"操作指导\"><a href=\"#操作指导\" class=\"headerlink\" title=\"操作指导\"></a>操作指导</h3><h4 id=\"主题配置\"><a href=\"#主题配置\" class=\"headerlink\" title=\"主题配置\"></a>主题配置</h4><p>下载并解压缩 <a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"external\">NexT 主题</a>，<code>wget http://labfile.oss.aliyuncs.com/courses/700/next.zip &amp;&amp; unzip next.zip</code> 需要将主题文件放入 Hexo/blog/themes 下，打开 ../blog/_config.yml 修改 theme 后的内容就可以更改主题了。</p>\n<p>这会博客就套上了我们的新模板了。但是我们发现博客菜单上的文字是英文的于是我们还要重新配置以下，让主题以中文的方式显示。再次编辑 _config.yml 文件，将 language 项设置为 zh-Hans 。</p>\n<p>注意更改主题后每次需要重启 <code>hexo server</code> 服务才可以刷新网页。</p>\n<h4 id=\"文章创建\"><a href=\"#文章创建\" class=\"headerlink\" title=\"文章创建\"></a>文章创建</h4><p><code>hexo new [layout] &lt;filename&gt;</code> 其中 layout 为可选参数，指定了新创建的文件布局，默认为 post 文件。 filename 为必填参数，指定了文件名，如果文件名中有空格则需要把文件名用引号”” 包裹起来。例如： 终端输入：  <code>hexo new &quot;我的第一篇文章&quot;</code> ，这时候我们发现 hexo 在 source/_post 目录之下创建了一个 我的第一篇文章.md 的文件。打开该文件进行编辑。我们也可以通过 atom 等常用的 markdown 编辑工具直接在 source/_post 目录下创建文章进行编辑即可。刷新浏览器就可以看到我们博客更新的内容了。</p>\n<p>至此我们基本配置好了本地 hexo 服务，能够自己写点内容了。</p>\n<h4 id=\"部署到-github-page\"><a href=\"#部署到-github-page\" class=\"headerlink\" title=\"部署到 github page\"></a>部署到 github page</h4><p>访问 github，创建库 <code>git账户名.github.io</code> ， 这一这个名字是固定的，一般的库没法修改跳转地址，只能显示为 github page 。</p>\n<p>将远程库同步到本地，<code>git clone [你的仓库的 url]</code>，本地会多出一个 <code>git账户名.github.io</code> 的文件夹，然后把 public 文件目录下的博客文件都复制到你的本地仓库中，并将本地仓库 push 到 github 仓库上。这样当其他人访问你的博客链接的时候 github 将会自动将该仓库中的相应文件展示出来。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cp -R public/* [你的仓库名]</div><div class=\"line\">$ cd [你的仓库名]</div><div class=\"line\">$ git add .</div><div class=\"line\">$ git commit -m &apos;update blog&apos;</div><div class=\"line\">$ git push</div></pre></td></tr></table></figure></p>\n<p>以上步骤虽然看起来貌似繁琐，但实际可以写成 bash 脚本，这样每次就会自动生成 public 自动复制以及上传了。</p>\n<h3 id=\"扩展补充\"><a href=\"#扩展补充\" class=\"headerlink\" title=\"扩展补充\"></a>扩展补充</h3><p>上述虽然配置完成了 hexo 博客，但博客功能过于简单，使用起来不方便，可以添加图片，摘要，标签页与分类页等内容。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>hexo 比 jekyll 布局更简单，更加容易操作，但每次需要本地生成 html 然后上传同步，虽然这不是问题，可以用脚本实现，但对于图片等内容，需要依赖第三方图床就显得很是无奈了。</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://behappyli.cn/2015/12/05/hexo%E6%95%99%E7%A8%8B/\" target=\"_blank\" rel=\"external\">http://behappyli.cn/2015/12/05/hexo%E6%95%99%E7%A8%8B/</a><br><a href=\"http://www.runoob.com/w3cnote/git-guide.html\" target=\"_blank\" rel=\"external\">http://www.runoob.com/w3cnote/git-guide.html</a></p>\n</blockquote>\n","excerpt":"<p>个人博客是使用 githubpage+jekyll 搭建的，且博客已经工作有半年了，但由于期初的模板没有找好，加上一些其他的问题，导致博客看起来比较凌乱，这边给出另外一个 GithubPage+Hexo 的博客搭建方法供大家参考，本文操作系统主要使用的是 ubuntu 16.04，使用其他 linux 发行版的用户，可以参考本文。附上最终效果图如下：</p>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><h4 id=\"安装-node-js\"><a href=\"#安装-node-js\" class=\"headerlink\" title=\"安装 node.js\"></a>安装 node.js</h4><p>Node.js 是一个开放源代码、跨平台的、可用于服务器端和网络应用的运行环境，该应用由 C++ 语言写成，在 Node.js 运行时运行。Node.js 提供事件驱动和非阻塞 I/O API，可优化应用程序的吞吐量和规模。这些技术通常被用于实时应用程序。并且它是采用 Google 的 V8 引擎来执行代码，它的大部分基本模块都是用 JavaScript 写成的，包含有一系列内置模块，使得程序可以作为独立服务器运行，从而脱离 Apache HTTP Server 或 IIS 运行。npm 也即 Node包管理器（Node Package Manager），它是一个以 Javascript 编写的软件包管理系统，默认环境为 Node.js 。</p>\n<ul>\n<li>安装 nodejs ： sudo apt-get install nodejs , 注意 ubuntu 16.04 使用：sudo apt install nodejs</li>\n<li>安装 npm ： sudo apt-get install npm ， 注意 ubuntu 16.04 使用：sudo apt install npm</li>\n</ul>\n<p>需要安装 nrm ， nrm 是 npm 的资源管理器，借助各个工具可以方便快捷地对 npm 的源进行管理。另外，由于国内网络环境原因在使用 npm 默认下载源的时候不仅速度非常慢而且常常会超时，因此这里还手动指定了从淘宝源下载。<code>sudo npm install nrm -g --registry https://registry.npm.taobao.org</code>，<code>nrm use taobao</code>（如果出现无法找到 node 则执行： <code>sudo  ln -s /usr/bin/nodejs /usr/bin/node</code> ）</p>","more":"<h4 id=\"安装-git\"><a href=\"#安装-git\" class=\"headerlink\" title=\"安装 git\"></a>安装 git</h4><p>这边步骤在多篇博文中都有详细描述，这边就不再累述了，可以直接搜索引擎搜索，或者在本博客的其他文章中找到。</p>\n<h4 id=\"安装-Hexo\"><a href=\"#安装-Hexo\" class=\"headerlink\" title=\"安装 Hexo\"></a>安装 Hexo</h4><p><a href=\"https://hexo.io/zh-cn/\">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。接下来我们开始使用 Hexo 搭建博客。</p>\n<ul>\n<li>创建并进入目录 Hexo ：<code>mkdir Hexo &amp;&amp; cd Hexo</code></li>\n<li>使用 hexo 生成博客框架。依次执行如下命令(hexo init blog 过程可能会比较慢，需要耐心等待。)：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo init blog </div><div class=\"line\">$ cd blog</div><div class=\"line\">$ npm install </div><div class=\"line\">$ hexo generate (hexo generate 为我们生成了静态文件存储于 public 文件夹之下，并且在一开始默认情况下执行这句将会为我们生成一个 Hello World 的页面。)</div><div class=\"line\">$ hexo server (通过 hexo server 运行起 hexo 内置的服务器。这时候就可以开始在本地访问了，默认地址为 localhost:4000 。)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意：hexo 中的 generate, server, dpoly 等操作都可以简写为首字母，所以 hexo generate 等同于 hexo g ，hexo server 等同于 hexo s，。</p>\n<h3 id=\"模块简介\"><a href=\"#模块简介\" class=\"headerlink\" title=\"模块简介\"></a>模块简介</h3><p>通过 tree | less 可以查看以下 blog 的目录结构，主要的几个文件和目录的作用分别如下：</p>\n<ul>\n<li>_config.yml ：配置文件，可以修改网站的主题、标题、作者等信息。</li>\n<li>public ：由 hexo 根据 source 文件夹中的资源进行渲染生成的文件夹，里边存储着最终的静态网页文件。</li>\n<li>scaffolds/ ：模板文件，当要给博客添加新文章的时候，将根据对应的模板进行创建。</li>\n<li>source/ ：用于存储用户资源，比如文章与新页面等。其中以 _ 开头的文件夹中除了 _posts 文件夹中的 markdown 或 HTML 文件会在执行 generate 操作的时候被渲染添加到 public 文件夹中之外，其他均被忽略。而且在初始化博客的过程中 _posts 目录底会自带一个 hello-world.md 的文件。</li>\n<li>themes/ ：主题文件，自带默认主题 landscape 。</li>\n</ul>\n<h3 id=\"操作指导\"><a href=\"#操作指导\" class=\"headerlink\" title=\"操作指导\"></a>操作指导</h3><h4 id=\"主题配置\"><a href=\"#主题配置\" class=\"headerlink\" title=\"主题配置\"></a>主题配置</h4><p>下载并解压缩 <a href=\"https://github.com/iissnan/hexo-theme-next\">NexT 主题</a>，<code>wget http://labfile.oss.aliyuncs.com/courses/700/next.zip &amp;&amp; unzip next.zip</code> 需要将主题文件放入 Hexo/blog/themes 下，打开 ../blog/_config.yml 修改 theme 后的内容就可以更改主题了。</p>\n<p>这会博客就套上了我们的新模板了。但是我们发现博客菜单上的文字是英文的于是我们还要重新配置以下，让主题以中文的方式显示。再次编辑 _config.yml 文件，将 language 项设置为 zh-Hans 。</p>\n<p>注意更改主题后每次需要重启 <code>hexo server</code> 服务才可以刷新网页。</p>\n<h4 id=\"文章创建\"><a href=\"#文章创建\" class=\"headerlink\" title=\"文章创建\"></a>文章创建</h4><p><code>hexo new [layout] &lt;filename&gt;</code> 其中 layout 为可选参数，指定了新创建的文件布局，默认为 post 文件。 filename 为必填参数，指定了文件名，如果文件名中有空格则需要把文件名用引号”” 包裹起来。例如： 终端输入：  <code>hexo new &quot;我的第一篇文章&quot;</code> ，这时候我们发现 hexo 在 source/_post 目录之下创建了一个 我的第一篇文章.md 的文件。打开该文件进行编辑。我们也可以通过 atom 等常用的 markdown 编辑工具直接在 source/_post 目录下创建文章进行编辑即可。刷新浏览器就可以看到我们博客更新的内容了。</p>\n<p>至此我们基本配置好了本地 hexo 服务，能够自己写点内容了。</p>\n<h4 id=\"部署到-github-page\"><a href=\"#部署到-github-page\" class=\"headerlink\" title=\"部署到 github page\"></a>部署到 github page</h4><p>访问 github，创建库 <code>git账户名.github.io</code> ， 这一这个名字是固定的，一般的库没法修改跳转地址，只能显示为 github page 。</p>\n<p>将远程库同步到本地，<code>git clone [你的仓库的 url]</code>，本地会多出一个 <code>git账户名.github.io</code> 的文件夹，然后把 public 文件目录下的博客文件都复制到你的本地仓库中，并将本地仓库 push 到 github 仓库上。这样当其他人访问你的博客链接的时候 github 将会自动将该仓库中的相应文件展示出来。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cp -R public/* [你的仓库名]</div><div class=\"line\">$ cd [你的仓库名]</div><div class=\"line\">$ git add .</div><div class=\"line\">$ git commit -m &apos;update blog&apos;</div><div class=\"line\">$ git push</div></pre></td></tr></table></figure></p>\n<p>以上步骤虽然看起来貌似繁琐，但实际可以写成 bash 脚本，这样每次就会自动生成 public 自动复制以及上传了。</p>\n<h3 id=\"扩展补充\"><a href=\"#扩展补充\" class=\"headerlink\" title=\"扩展补充\"></a>扩展补充</h3><p>上述虽然配置完成了 hexo 博客，但博客功能过于简单，使用起来不方便，可以添加图片，摘要，标签页与分类页等内容。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>hexo 比 jekyll 布局更简单，更加容易操作，但每次需要本地生成 html 然后上传同步，虽然这不是问题，可以用脚本实现，但对于图片等内容，需要依赖第三方图床就显得很是无奈了。</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://behappyli.cn/2015/12/05/hexo%E6%95%99%E7%A8%8B/\">http://behappyli.cn/2015/12/05/hexo%E6%95%99%E7%A8%8B/</a><br><a href=\"http://www.runoob.com/w3cnote/git-guide.html\">http://www.runoob.com/w3cnote/git-guide.html</a></p>\n</blockquote>"},{"layout":"post","title":"针对百度网盘限速的解决方案","date":"2016-12-26T07:17:00.000Z","_content":"\n虽然百度这家公司在道德水准上面没下限（卖假药，开赌场等），大多数产品做的也都比较烂（界面丑，体验差），但在搜索引擎和网盘这两个领域，因为国内种种众所周知的原因，还是只能用这家的产品。面对百度网盘下载速度越来越慢，收费越来越高，服务越来越差等特点，本文主要介绍一些方法，让我们能够更快地下载百度网盘中的资源。参考自[文章](http://www.runningcheese.com/baiduyun?from=singlemessage&nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D) 主要的方法可以分为两种，破解版的百度云管家和直链下载。\n\n\n<!-- more -->\n\n\n### 破解版百度云管家\n\n经常使用百度云的用户，无疑客户端是最佳的选择，破解版本的百度云管家是可以让你**无限时的免费试用百度云管家**。可以去[吾爱破解](http://www.52pojie.cn/)等论坛下载最新破解版本的百度云，但这边不推荐这种方法，主要原因是客户端破解版很容易失效。\n\n### 云直链下载\n\n#### 网页嵌入脚本下载\n\n- Chrome需要安装拓展 [Tampermonkey](http://tampermonkey.net/)，其他Chrome壳浏览器安装 Tampermonkey，在应用市场可以找到并下载安装。\n- 打开[脚本地址](https://greasyfork.org/zh-CN/scripts/23635-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B)，并安装。\n- 每次打开百度云资源后，脚本就会自动获取相关信息，加载，并可以获取直链了。\n\n但注意：将直连放到迅雷等软件中，下载速度依然很慢，时断时连，原因暂未明了，不排除我这边网络的问题。\n\n#### 应用数据获取直链\n\n提供这种方法的应用较多，例如：[百度网盘直链系统V2.0](http://bdbea3.duapp.com/baidu_pcs/index.php)，授权打开后，会在百度云盘根目录下的我的应用数据中新建文件夹，讲需要下载的文件，放到该新增的文件夹中，直接下载可以获取直链，个人实验速度要稍微比上面的直链快些，但也仅有 600-700k 的样子，且也不适用于几个G的大文件，依然不是很满意。\n\n百度云直连系统：[免费云存储-免费百度网盘直链平台-永久外链-139直链网盘](http://www.139.sh/)，同样也是一个直链系统，方法依然是将需要下载的文件放入我的应用数据文件夹中，然后打开该服务网址，就可以看到外链已经被解析出来了，直接复制下载即可。就我个人的网络网盘来说这个速度最快，使用 aria2 可以得到数兆每秒的下载速度，且大文件也没有问题。\n\n*** \n\nTo be continued ...\n\n> 参考链接：\n> http://www.runningcheese.com/baiduyun?from=singlemessage&nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D\n> https://www.zhihu.com/question/28333225\n","source":"_posts/2016/2016-12-26-针对百度网盘限速的解决方案.md","raw":"---\nlayout: \"post\"\ntitle: \"针对百度网盘限速的解决方案\"\ndate: \"2016-12-26 15:17\"\n---\n\n虽然百度这家公司在道德水准上面没下限（卖假药，开赌场等），大多数产品做的也都比较烂（界面丑，体验差），但在搜索引擎和网盘这两个领域，因为国内种种众所周知的原因，还是只能用这家的产品。面对百度网盘下载速度越来越慢，收费越来越高，服务越来越差等特点，本文主要介绍一些方法，让我们能够更快地下载百度网盘中的资源。参考自[文章](http://www.runningcheese.com/baiduyun?from=singlemessage&nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D) 主要的方法可以分为两种，破解版的百度云管家和直链下载。\n\n\n<!-- more -->\n\n\n### 破解版百度云管家\n\n经常使用百度云的用户，无疑客户端是最佳的选择，破解版本的百度云管家是可以让你**无限时的免费试用百度云管家**。可以去[吾爱破解](http://www.52pojie.cn/)等论坛下载最新破解版本的百度云，但这边不推荐这种方法，主要原因是客户端破解版很容易失效。\n\n### 云直链下载\n\n#### 网页嵌入脚本下载\n\n- Chrome需要安装拓展 [Tampermonkey](http://tampermonkey.net/)，其他Chrome壳浏览器安装 Tampermonkey，在应用市场可以找到并下载安装。\n- 打开[脚本地址](https://greasyfork.org/zh-CN/scripts/23635-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B)，并安装。\n- 每次打开百度云资源后，脚本就会自动获取相关信息，加载，并可以获取直链了。\n\n但注意：将直连放到迅雷等软件中，下载速度依然很慢，时断时连，原因暂未明了，不排除我这边网络的问题。\n\n#### 应用数据获取直链\n\n提供这种方法的应用较多，例如：[百度网盘直链系统V2.0](http://bdbea3.duapp.com/baidu_pcs/index.php)，授权打开后，会在百度云盘根目录下的我的应用数据中新建文件夹，讲需要下载的文件，放到该新增的文件夹中，直接下载可以获取直链，个人实验速度要稍微比上面的直链快些，但也仅有 600-700k 的样子，且也不适用于几个G的大文件，依然不是很满意。\n\n百度云直连系统：[免费云存储-免费百度网盘直链平台-永久外链-139直链网盘](http://www.139.sh/)，同样也是一个直链系统，方法依然是将需要下载的文件放入我的应用数据文件夹中，然后打开该服务网址，就可以看到外链已经被解析出来了，直接复制下载即可。就我个人的网络网盘来说这个速度最快，使用 aria2 可以得到数兆每秒的下载速度，且大文件也没有问题。\n\n*** \n\nTo be continued ...\n\n> 参考链接：\n> http://www.runningcheese.com/baiduyun?from=singlemessage&nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D\n> https://www.zhihu.com/question/28333225\n","slug":"2016/2016-12-26-针对百度网盘限速的解决方案","published":1,"updated":"2017-01-05T01:38:06.638Z","comments":1,"photos":[],"link":"","_id":"ciyuv3aja003tmumuc8vkhz27","content":"<p>虽然百度这家公司在道德水准上面没下限（卖假药，开赌场等），大多数产品做的也都比较烂（界面丑，体验差），但在搜索引擎和网盘这两个领域，因为国内种种众所周知的原因，还是只能用这家的产品。面对百度网盘下载速度越来越慢，收费越来越高，服务越来越差等特点，本文主要介绍一些方法，让我们能够更快地下载百度网盘中的资源。参考自<a href=\"http://www.runningcheese.com/baiduyun?from=singlemessage&amp;nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D\" target=\"_blank\" rel=\"external\">文章</a> 主要的方法可以分为两种，破解版的百度云管家和直链下载。</p>\n<a id=\"more\"></a>\n<h3 id=\"破解版百度云管家\"><a href=\"#破解版百度云管家\" class=\"headerlink\" title=\"破解版百度云管家\"></a>破解版百度云管家</h3><p>经常使用百度云的用户，无疑客户端是最佳的选择，破解版本的百度云管家是可以让你<strong>无限时的免费试用百度云管家</strong>。可以去<a href=\"http://www.52pojie.cn/\" target=\"_blank\" rel=\"external\">吾爱破解</a>等论坛下载最新破解版本的百度云，但这边不推荐这种方法，主要原因是客户端破解版很容易失效。</p>\n<h3 id=\"云直链下载\"><a href=\"#云直链下载\" class=\"headerlink\" title=\"云直链下载\"></a>云直链下载</h3><h4 id=\"网页嵌入脚本下载\"><a href=\"#网页嵌入脚本下载\" class=\"headerlink\" title=\"网页嵌入脚本下载\"></a>网页嵌入脚本下载</h4><ul>\n<li>Chrome需要安装拓展 <a href=\"http://tampermonkey.net/\" target=\"_blank\" rel=\"external\">Tampermonkey</a>，其他Chrome壳浏览器安装 Tampermonkey，在应用市场可以找到并下载安装。</li>\n<li>打开<a href=\"https://greasyfork.org/zh-CN/scripts/23635-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B\" target=\"_blank\" rel=\"external\">脚本地址</a>，并安装。</li>\n<li>每次打开百度云资源后，脚本就会自动获取相关信息，加载，并可以获取直链了。</li>\n</ul>\n<p>但注意：将直连放到迅雷等软件中，下载速度依然很慢，时断时连，原因暂未明了，不排除我这边网络的问题。</p>\n<h4 id=\"应用数据获取直链\"><a href=\"#应用数据获取直链\" class=\"headerlink\" title=\"应用数据获取直链\"></a>应用数据获取直链</h4><p>提供这种方法的应用较多，例如：<a href=\"http://bdbea3.duapp.com/baidu_pcs/index.php\" target=\"_blank\" rel=\"external\">百度网盘直链系统V2.0</a>，授权打开后，会在百度云盘根目录下的我的应用数据中新建文件夹，讲需要下载的文件，放到该新增的文件夹中，直接下载可以获取直链，个人实验速度要稍微比上面的直链快些，但也仅有 600-700k 的样子，且也不适用于几个G的大文件，依然不是很满意。</p>\n<p>百度云直连系统：<a href=\"http://www.139.sh/\" target=\"_blank\" rel=\"external\">免费云存储-免费百度网盘直链平台-永久外链-139直链网盘</a>，同样也是一个直链系统，方法依然是将需要下载的文件放入我的应用数据文件夹中，然后打开该服务网址，就可以看到外链已经被解析出来了，直接复制下载即可。就我个人的网络网盘来说这个速度最快，使用 aria2 可以得到数兆每秒的下载速度，且大文件也没有问题。</p>\n<hr>\n<p>To be continued …</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.runningcheese.com/baiduyun?from=singlemessage&amp;nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D\" target=\"_blank\" rel=\"external\">http://www.runningcheese.com/baiduyun?from=singlemessage&amp;nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D</a><br><a href=\"https://www.zhihu.com/question/28333225\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/28333225</a></p>\n</blockquote>\n","excerpt":"<p>虽然百度这家公司在道德水准上面没下限（卖假药，开赌场等），大多数产品做的也都比较烂（界面丑，体验差），但在搜索引擎和网盘这两个领域，因为国内种种众所周知的原因，还是只能用这家的产品。面对百度网盘下载速度越来越慢，收费越来越高，服务越来越差等特点，本文主要介绍一些方法，让我们能够更快地下载百度网盘中的资源。参考自<a href=\"http://www.runningcheese.com/baiduyun?from=singlemessage&amp;nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D\">文章</a> 主要的方法可以分为两种，破解版的百度云管家和直链下载。</p>","more":"<h3 id=\"破解版百度云管家\"><a href=\"#破解版百度云管家\" class=\"headerlink\" title=\"破解版百度云管家\"></a>破解版百度云管家</h3><p>经常使用百度云的用户，无疑客户端是最佳的选择，破解版本的百度云管家是可以让你<strong>无限时的免费试用百度云管家</strong>。可以去<a href=\"http://www.52pojie.cn/\">吾爱破解</a>等论坛下载最新破解版本的百度云，但这边不推荐这种方法，主要原因是客户端破解版很容易失效。</p>\n<h3 id=\"云直链下载\"><a href=\"#云直链下载\" class=\"headerlink\" title=\"云直链下载\"></a>云直链下载</h3><h4 id=\"网页嵌入脚本下载\"><a href=\"#网页嵌入脚本下载\" class=\"headerlink\" title=\"网页嵌入脚本下载\"></a>网页嵌入脚本下载</h4><ul>\n<li>Chrome需要安装拓展 <a href=\"http://tampermonkey.net/\">Tampermonkey</a>，其他Chrome壳浏览器安装 Tampermonkey，在应用市场可以找到并下载安装。</li>\n<li>打开<a href=\"https://greasyfork.org/zh-CN/scripts/23635-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B\">脚本地址</a>，并安装。</li>\n<li>每次打开百度云资源后，脚本就会自动获取相关信息，加载，并可以获取直链了。</li>\n</ul>\n<p>但注意：将直连放到迅雷等软件中，下载速度依然很慢，时断时连，原因暂未明了，不排除我这边网络的问题。</p>\n<h4 id=\"应用数据获取直链\"><a href=\"#应用数据获取直链\" class=\"headerlink\" title=\"应用数据获取直链\"></a>应用数据获取直链</h4><p>提供这种方法的应用较多，例如：<a href=\"http://bdbea3.duapp.com/baidu_pcs/index.php\">百度网盘直链系统V2.0</a>，授权打开后，会在百度云盘根目录下的我的应用数据中新建文件夹，讲需要下载的文件，放到该新增的文件夹中，直接下载可以获取直链，个人实验速度要稍微比上面的直链快些，但也仅有 600-700k 的样子，且也不适用于几个G的大文件，依然不是很满意。</p>\n<p>百度云直连系统：<a href=\"http://www.139.sh/\">免费云存储-免费百度网盘直链平台-永久外链-139直链网盘</a>，同样也是一个直链系统，方法依然是将需要下载的文件放入我的应用数据文件夹中，然后打开该服务网址，就可以看到外链已经被解析出来了，直接复制下载即可。就我个人的网络网盘来说这个速度最快，使用 aria2 可以得到数兆每秒的下载速度，且大文件也没有问题。</p>\n<hr>\n<p>To be continued …</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.runningcheese.com/baiduyun?from=singlemessage&amp;nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D\">http://www.runningcheese.com/baiduyun?from=singlemessage&amp;nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D</a><br><a href=\"https://www.zhihu.com/question/28333225\">https://www.zhihu.com/question/28333225</a></p>\n</blockquote>"},{"layout":"post","title":"ssh 使用详解","date":"2016-12-27T03:13:00.000Z","_content":"\n\n<!-- more -->\n\n\n\n> 参考链接：\n> http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/\n> http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\n> http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html\n","source":"_posts/2016/2016-12-27-ssh-使用详解.md","raw":"---\nlayout: \"post\"\ntitle: \"ssh 使用详解\"\ndate: \"2016-12-27 11:13\"\n---\n\n\n<!-- more -->\n\n\n\n> 参考链接：\n> http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/\n> http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\n> http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html\n","slug":"2016/2016-12-27-ssh-使用详解","published":1,"updated":"2017-01-05T01:38:09.854Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ajb003umumuvyvp27et","content":"<a id=\"more\"></a>\n<blockquote>\n<p>参考链接：<br><a href=\"http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/\" target=\"_blank\" rel=\"external\">http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a><br><a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a><br><a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html</a></p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>参考链接：<br><a href=\"http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/\">http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a><br><a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a><br><a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html\">http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html</a></p>\n</blockquote>"},{"_content":"EFM32 芯片采用 JLINK V9 多次测试多款不同型号的芯片都无法单步执行，单步只能在 while(1) 中执行，一般从 startup 到 main 函数中就会发生错误，开始怀疑是调试工具的问题，通过增加断点部分解决了这个问题，经过评估板测试，查看 RAM 占用，静态区全局变量等查看不断排查，之后发现是共同规律是每次 inline 函数调用某一个普通函数时，单步执行到 return 时，无法找到真实的返回地址。\n","source":"_posts/FAQ/EFM32芯片单步执行跳转错误.md","raw":"EFM32 芯片采用 JLINK V9 多次测试多款不同型号的芯片都无法单步执行，单步只能在 while(1) 中执行，一般从 startup 到 main 函数中就会发生错误，开始怀疑是调试工具的问题，通过增加断点部分解决了这个问题，经过评估板测试，查看 RAM 占用，静态区全局变量等查看不断排查，之后发现是共同规律是每次 inline 函数调用某一个普通函数时，单步执行到 return 时，无法找到真实的返回地址。\n","slug":"FAQ/EFM32芯片单步执行跳转错误","published":1,"date":"2017-02-07T01:39:04.222Z","updated":"2016-12-30T03:36:15.618Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciyuv3ajc003vmumuu21ujc7s","content":"<p>EFM32 芯片采用 JLINK V9 多次测试多款不同型号的芯片都无法单步执行，单步只能在 while(1) 中执行，一般从 startup 到 main 函数中就会发生错误，开始怀疑是调试工具的问题，通过增加断点部分解决了这个问题，经过评估板测试，查看 RAM 占用，静态区全局变量等查看不断排查，之后发现是共同规律是每次 inline 函数调用某一个普通函数时，单步执行到 return 时，无法找到真实的返回地址。</p>\n","excerpt":"","more":"<p>EFM32 芯片采用 JLINK V9 多次测试多款不同型号的芯片都无法单步执行，单步只能在 while(1) 中执行，一般从 startup 到 main 函数中就会发生错误，开始怀疑是调试工具的问题，通过增加断点部分解决了这个问题，经过评估板测试，查看 RAM 占用，静态区全局变量等查看不断排查，之后发现是共同规律是每次 inline 函数调用某一个普通函数时，单步执行到 return 时，无法找到真实的返回地址。</p>\n"},{"layout":"post","title":"MCU中的HardFault_Handler问题","date":"2016-12-28T08:49:00.000Z","_content":"\n### 问题描述\n\n使用的工具 KDE-5.11 在调试目标芯片 EFM32 时出现问题，起初是调试铁电驱动，但在单步仿真时到某一步总会不再响应，或者结束仿真时 PC 跳转到了 HardFault_Handler 异常。为了解决这个问题，于是不断地缩减代码，之后发现程序从 startup 开始执行时，一进入 main 函数就会不响应或者跳转到 HardFault_Handler 中，一度怀疑自己的硬件 CMSIS 移植有问题。为了解决这个问题，尝试了多个办法，包括并不仅仅限于更换调试工具，断点调试，评估板代替测试，重新移植底层代码，查看 RAM 占用，修改静态区全局变量占用大小等等。下面总结一些遇到 HardFault_Handler 异常的解决方法。\n\n<!-- more -->\n\n\n### HardFault_Handler 分析\n\n\n一般 HardFault_Handler 错误是指 PC 指向了一个无法访问的位置，主要可以分为两种：\n- 内存溢出或者访问越界。这个需要自己写程序的时候规范代码，遇到了需要慢慢排查。\n- 堆栈溢出。增加堆栈的大小。\n\n\n仿真时，有时会出现 HardFault_Handler 这种错误，这种错误往往会涉及到一些编译运行时的深层次原理，但基本可以肯定的是一般都是 SP,LR,PC 这三个寄存器出了问题，下面介绍这三个寄存器：\n\n- 堆栈指针r13（SP）：每一种异常模式都有其自己独立的r13，它通常指向异常模式所专用的堆栈，也就是说五种异常模式、非异常模式（用户模式和系统模式），都有各自独立的堆栈，用不同的堆栈指针来索引。这样当ARM进入异常模式的时候，程序就可以把一般通用寄存器压入堆栈，返回时再出栈，保证了各种模式下程序的状态的完整性。\n\n- 连接寄存器r14（LR）：每种模式下r14都有自身版组，它有两个特殊功能：\n\n```\n（1）保存子程序返回地址。使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回，通常用下列指令之一：\n            MOV PC, LR \n            BX LR\n\n\t通常子程序这样写，保证了子程序中还可以调用子程序。\n             stmfd sp!, {lr}\n             ……\n             ldmfd sp!, {pc}\n\n（2）当异常发生时，异常模式的r14用来保存异常返回地址，将r14如栈可以处理嵌套中断。\n```\n\n- 程序计数器r15（PC）：PC是有读写限制的。当没有超过读取限制的时候，读取的值是指令的地址加上8个字节，由于ARM指令总是以字对齐的，故bit[1:0]总是00。当用str或stm存储PC的时候，偏移量有可能是8或12等其它值。在V3及以下版本中，写入bit[1:0]的值将被忽略，而在V4及以上版本写入r15的bit[1:0]必须为00，否则后果不可预测。\n\n需要研究到底寄存器、函数是如何跳转调用的，我们需要使用 KDE 中的两个仿真工具： Register 和 Call Stack+Locals。Register 中主要观察 SP,LR,PC 三个寄存器的数据，PC永远指向 CPU 正在执行工作的位置，LR 会保存你调用子函数之前的跳转地址，也就是说当子函数完成返回时，会回到 LR 值对应的地址继续执行下面的程序。我这边实验时，能够看出每次执行错误后， PC 会跳转到一个很大的错误地址。\n\n\n### 指针跑飞\n\n在 HardFault_Handler 中的 while(1) 设置断点，然后运行，给它触发 HardFault_Handler 的条件，然后到断点处之后，查看 watch 窗口中的 Call Stack+Locals，也就是堆栈以及局部变量，程序执行到哪一句发生的错误，以及当时各个压栈的函数的各个局部变量的值一目了然。一般而言最常出现的就是**指针跑飞，数组越界**，这两种其实可以看做一个情况，都是指针访问了无权限访问的空间，通过 Call Stack+Locals 窗口往往能够定位到该函数，然后可以采用单步执行，看到具体在哪一步触发了异常。\n\n### RAM溢出\n\n这种情况也是我排查的一种情况，编译完成之后，全局变量已经占用了相应大小 RAM 中的静态存储区域，如果你的 MCU 本身不够大，例如我的只有 8K RAM空间，而 COM 的缓冲数组占用了过多的全局变量，这边就存在一定的可能 RAM 不够分配而越界。\n\n\n### 底层 CMSIS 问题\n\n因为我的项目是在进入 main 函数一开始就出错了，所以为了排除是不是之前的跳转就有问题，所以重新移植 startup.s 文件\n\n\n### Jlink \n\n不排除调试器存在缺陷，所以更换了调试器，将自己的程序移植到评估板上面运行，进一步验证，直接使用官方自带例程，在评估板上面运行。\n\n### inline函数无法捕捉\n\n这边是我主要出现错误的情况，一般较为少见，根本原因在于 inline 函数是类似于宏定义，直接本地展开的，如果使用断点是无法捕捉到的，这边我的 inline 函数中又调用了一个普通函数，因为 inline 函数是原地展开，LR 没有载入它的地址，而每次普通函数在返回时，无法获取到 inline 函数的返回地址，然后就跳转了异常，这本身并不能算是一个问题，在 MCU 正常运行时不会产生任何影响，影响的仅是你的调试过程。另外我个人在调试 SPI 驱动时，因为也调用了固件库自带的 inline 函数，所以导致也没法单步执行这段程序。\n\n\n### 小结\n\n虽然这边查出我的问题出现在内联函数上面，但是，以上的集中方法都可以作为常用排查 HardFault_Handler 异常的方法，且一般而言出现指针跑飞的可能性最高。\n\n\n> 参考链接：\n> http://blog.csdn.net/zyboy2000/article/details/7668331\n> http://www.51hei.com/bbs/dpj-39846-1.html\n> http://blog.csdn.net/jimmy2013_1_1/article/details/9723461\n> http://blog.chinaunix.net/uid-26967414-id-3823606.html\n> http://blog.csdn.net/zhou1232006/article/details/6149548\n> http://blog.csdn.net/pony_maggie/article/details/5270501\n> http://wenku.baidu.com/view/f7bf4ad6b14e852458fb576a.html?re=view\n","source":"_posts/2016/2016-12-28-mcu中的hardfault-handler问题.md","raw":"---\nlayout: \"post\"\ntitle: \"MCU中的HardFault_Handler问题\"\ndate: \"2016-12-28 16:49\"\n---\n\n### 问题描述\n\n使用的工具 KDE-5.11 在调试目标芯片 EFM32 时出现问题，起初是调试铁电驱动，但在单步仿真时到某一步总会不再响应，或者结束仿真时 PC 跳转到了 HardFault_Handler 异常。为了解决这个问题，于是不断地缩减代码，之后发现程序从 startup 开始执行时，一进入 main 函数就会不响应或者跳转到 HardFault_Handler 中，一度怀疑自己的硬件 CMSIS 移植有问题。为了解决这个问题，尝试了多个办法，包括并不仅仅限于更换调试工具，断点调试，评估板代替测试，重新移植底层代码，查看 RAM 占用，修改静态区全局变量占用大小等等。下面总结一些遇到 HardFault_Handler 异常的解决方法。\n\n<!-- more -->\n\n\n### HardFault_Handler 分析\n\n\n一般 HardFault_Handler 错误是指 PC 指向了一个无法访问的位置，主要可以分为两种：\n- 内存溢出或者访问越界。这个需要自己写程序的时候规范代码，遇到了需要慢慢排查。\n- 堆栈溢出。增加堆栈的大小。\n\n\n仿真时，有时会出现 HardFault_Handler 这种错误，这种错误往往会涉及到一些编译运行时的深层次原理，但基本可以肯定的是一般都是 SP,LR,PC 这三个寄存器出了问题，下面介绍这三个寄存器：\n\n- 堆栈指针r13（SP）：每一种异常模式都有其自己独立的r13，它通常指向异常模式所专用的堆栈，也就是说五种异常模式、非异常模式（用户模式和系统模式），都有各自独立的堆栈，用不同的堆栈指针来索引。这样当ARM进入异常模式的时候，程序就可以把一般通用寄存器压入堆栈，返回时再出栈，保证了各种模式下程序的状态的完整性。\n\n- 连接寄存器r14（LR）：每种模式下r14都有自身版组，它有两个特殊功能：\n\n```\n（1）保存子程序返回地址。使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回，通常用下列指令之一：\n            MOV PC, LR \n            BX LR\n\n\t通常子程序这样写，保证了子程序中还可以调用子程序。\n             stmfd sp!, {lr}\n             ……\n             ldmfd sp!, {pc}\n\n（2）当异常发生时，异常模式的r14用来保存异常返回地址，将r14如栈可以处理嵌套中断。\n```\n\n- 程序计数器r15（PC）：PC是有读写限制的。当没有超过读取限制的时候，读取的值是指令的地址加上8个字节，由于ARM指令总是以字对齐的，故bit[1:0]总是00。当用str或stm存储PC的时候，偏移量有可能是8或12等其它值。在V3及以下版本中，写入bit[1:0]的值将被忽略，而在V4及以上版本写入r15的bit[1:0]必须为00，否则后果不可预测。\n\n需要研究到底寄存器、函数是如何跳转调用的，我们需要使用 KDE 中的两个仿真工具： Register 和 Call Stack+Locals。Register 中主要观察 SP,LR,PC 三个寄存器的数据，PC永远指向 CPU 正在执行工作的位置，LR 会保存你调用子函数之前的跳转地址，也就是说当子函数完成返回时，会回到 LR 值对应的地址继续执行下面的程序。我这边实验时，能够看出每次执行错误后， PC 会跳转到一个很大的错误地址。\n\n\n### 指针跑飞\n\n在 HardFault_Handler 中的 while(1) 设置断点，然后运行，给它触发 HardFault_Handler 的条件，然后到断点处之后，查看 watch 窗口中的 Call Stack+Locals，也就是堆栈以及局部变量，程序执行到哪一句发生的错误，以及当时各个压栈的函数的各个局部变量的值一目了然。一般而言最常出现的就是**指针跑飞，数组越界**，这两种其实可以看做一个情况，都是指针访问了无权限访问的空间，通过 Call Stack+Locals 窗口往往能够定位到该函数，然后可以采用单步执行，看到具体在哪一步触发了异常。\n\n### RAM溢出\n\n这种情况也是我排查的一种情况，编译完成之后，全局变量已经占用了相应大小 RAM 中的静态存储区域，如果你的 MCU 本身不够大，例如我的只有 8K RAM空间，而 COM 的缓冲数组占用了过多的全局变量，这边就存在一定的可能 RAM 不够分配而越界。\n\n\n### 底层 CMSIS 问题\n\n因为我的项目是在进入 main 函数一开始就出错了，所以为了排除是不是之前的跳转就有问题，所以重新移植 startup.s 文件\n\n\n### Jlink \n\n不排除调试器存在缺陷，所以更换了调试器，将自己的程序移植到评估板上面运行，进一步验证，直接使用官方自带例程，在评估板上面运行。\n\n### inline函数无法捕捉\n\n这边是我主要出现错误的情况，一般较为少见，根本原因在于 inline 函数是类似于宏定义，直接本地展开的，如果使用断点是无法捕捉到的，这边我的 inline 函数中又调用了一个普通函数，因为 inline 函数是原地展开，LR 没有载入它的地址，而每次普通函数在返回时，无法获取到 inline 函数的返回地址，然后就跳转了异常，这本身并不能算是一个问题，在 MCU 正常运行时不会产生任何影响，影响的仅是你的调试过程。另外我个人在调试 SPI 驱动时，因为也调用了固件库自带的 inline 函数，所以导致也没法单步执行这段程序。\n\n\n### 小结\n\n虽然这边查出我的问题出现在内联函数上面，但是，以上的集中方法都可以作为常用排查 HardFault_Handler 异常的方法，且一般而言出现指针跑飞的可能性最高。\n\n\n> 参考链接：\n> http://blog.csdn.net/zyboy2000/article/details/7668331\n> http://www.51hei.com/bbs/dpj-39846-1.html\n> http://blog.csdn.net/jimmy2013_1_1/article/details/9723461\n> http://blog.chinaunix.net/uid-26967414-id-3823606.html\n> http://blog.csdn.net/zhou1232006/article/details/6149548\n> http://blog.csdn.net/pony_maggie/article/details/5270501\n> http://wenku.baidu.com/view/f7bf4ad6b14e852458fb576a.html?re=view\n","slug":"2016/2016-12-28-mcu中的hardfault-handler问题","published":1,"updated":"2017-01-19T04:57:44.290Z","comments":1,"photos":[],"link":"","_id":"ciyuv3ajd003wmumuynb6jc66","content":"<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>使用的工具 KDE-5.11 在调试目标芯片 EFM32 时出现问题，起初是调试铁电驱动，但在单步仿真时到某一步总会不再响应，或者结束仿真时 PC 跳转到了 HardFault_Handler 异常。为了解决这个问题，于是不断地缩减代码，之后发现程序从 startup 开始执行时，一进入 main 函数就会不响应或者跳转到 HardFault_Handler 中，一度怀疑自己的硬件 CMSIS 移植有问题。为了解决这个问题，尝试了多个办法，包括并不仅仅限于更换调试工具，断点调试，评估板代替测试，重新移植底层代码，查看 RAM 占用，修改静态区全局变量占用大小等等。下面总结一些遇到 HardFault_Handler 异常的解决方法。</p>\n<a id=\"more\"></a>\n<h3 id=\"HardFault-Handler-分析\"><a href=\"#HardFault-Handler-分析\" class=\"headerlink\" title=\"HardFault_Handler 分析\"></a>HardFault_Handler 分析</h3><p>一般 HardFault_Handler 错误是指 PC 指向了一个无法访问的位置，主要可以分为两种：</p>\n<ul>\n<li>内存溢出或者访问越界。这个需要自己写程序的时候规范代码，遇到了需要慢慢排查。</li>\n<li>堆栈溢出。增加堆栈的大小。</li>\n</ul>\n<p>仿真时，有时会出现 HardFault_Handler 这种错误，这种错误往往会涉及到一些编译运行时的深层次原理，但基本可以肯定的是一般都是 SP,LR,PC 这三个寄存器出了问题，下面介绍这三个寄存器：</p>\n<ul>\n<li><p>堆栈指针r13（SP）：每一种异常模式都有其自己独立的r13，它通常指向异常模式所专用的堆栈，也就是说五种异常模式、非异常模式（用户模式和系统模式），都有各自独立的堆栈，用不同的堆栈指针来索引。这样当ARM进入异常模式的时候，程序就可以把一般通用寄存器压入堆栈，返回时再出栈，保证了各种模式下程序的状态的完整性。</p>\n</li>\n<li><p>连接寄存器r14（LR）：每种模式下r14都有自身版组，它有两个特殊功能：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">（1）保存子程序返回地址。使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回，通常用下列指令之一：</div><div class=\"line\">            MOV PC, LR </div><div class=\"line\">            BX LR</div><div class=\"line\"></div><div class=\"line\">\t通常子程序这样写，保证了子程序中还可以调用子程序。</div><div class=\"line\">             stmfd sp!, &#123;lr&#125;</div><div class=\"line\">             ……</div><div class=\"line\">             ldmfd sp!, &#123;pc&#125;</div><div class=\"line\"></div><div class=\"line\">（2）当异常发生时，异常模式的r14用来保存异常返回地址，将r14如栈可以处理嵌套中断。</div></pre></td></tr></table></figure>\n<ul>\n<li>程序计数器r15（PC）：PC是有读写限制的。当没有超过读取限制的时候，读取的值是指令的地址加上8个字节，由于ARM指令总是以字对齐的，故bit[1:0]总是00。当用str或stm存储PC的时候，偏移量有可能是8或12等其它值。在V3及以下版本中，写入bit[1:0]的值将被忽略，而在V4及以上版本写入r15的bit[1:0]必须为00，否则后果不可预测。</li>\n</ul>\n<p>需要研究到底寄存器、函数是如何跳转调用的，我们需要使用 KDE 中的两个仿真工具： Register 和 Call Stack+Locals。Register 中主要观察 SP,LR,PC 三个寄存器的数据，PC永远指向 CPU 正在执行工作的位置，LR 会保存你调用子函数之前的跳转地址，也就是说当子函数完成返回时，会回到 LR 值对应的地址继续执行下面的程序。我这边实验时，能够看出每次执行错误后， PC 会跳转到一个很大的错误地址。</p>\n<h3 id=\"指针跑飞\"><a href=\"#指针跑飞\" class=\"headerlink\" title=\"指针跑飞\"></a>指针跑飞</h3><p>在 HardFault_Handler 中的 while(1) 设置断点，然后运行，给它触发 HardFault_Handler 的条件，然后到断点处之后，查看 watch 窗口中的 Call Stack+Locals，也就是堆栈以及局部变量，程序执行到哪一句发生的错误，以及当时各个压栈的函数的各个局部变量的值一目了然。一般而言最常出现的就是<strong>指针跑飞，数组越界</strong>，这两种其实可以看做一个情况，都是指针访问了无权限访问的空间，通过 Call Stack+Locals 窗口往往能够定位到该函数，然后可以采用单步执行，看到具体在哪一步触发了异常。</p>\n<h3 id=\"RAM溢出\"><a href=\"#RAM溢出\" class=\"headerlink\" title=\"RAM溢出\"></a>RAM溢出</h3><p>这种情况也是我排查的一种情况，编译完成之后，全局变量已经占用了相应大小 RAM 中的静态存储区域，如果你的 MCU 本身不够大，例如我的只有 8K RAM空间，而 COM 的缓冲数组占用了过多的全局变量，这边就存在一定的可能 RAM 不够分配而越界。</p>\n<h3 id=\"底层-CMSIS-问题\"><a href=\"#底层-CMSIS-问题\" class=\"headerlink\" title=\"底层 CMSIS 问题\"></a>底层 CMSIS 问题</h3><p>因为我的项目是在进入 main 函数一开始就出错了，所以为了排除是不是之前的跳转就有问题，所以重新移植 startup.s 文件</p>\n<h3 id=\"Jlink\"><a href=\"#Jlink\" class=\"headerlink\" title=\"Jlink\"></a>Jlink</h3><p>不排除调试器存在缺陷，所以更换了调试器，将自己的程序移植到评估板上面运行，进一步验证，直接使用官方自带例程，在评估板上面运行。</p>\n<h3 id=\"inline函数无法捕捉\"><a href=\"#inline函数无法捕捉\" class=\"headerlink\" title=\"inline函数无法捕捉\"></a>inline函数无法捕捉</h3><p>这边是我主要出现错误的情况，一般较为少见，根本原因在于 inline 函数是类似于宏定义，直接本地展开的，如果使用断点是无法捕捉到的，这边我的 inline 函数中又调用了一个普通函数，因为 inline 函数是原地展开，LR 没有载入它的地址，而每次普通函数在返回时，无法获取到 inline 函数的返回地址，然后就跳转了异常，这本身并不能算是一个问题，在 MCU 正常运行时不会产生任何影响，影响的仅是你的调试过程。另外我个人在调试 SPI 驱动时，因为也调用了固件库自带的 inline 函数，所以导致也没法单步执行这段程序。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>虽然这边查出我的问题出现在内联函数上面，但是，以上的集中方法都可以作为常用排查 HardFault_Handler 异常的方法，且一般而言出现指针跑飞的可能性最高。</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/zyboy2000/article/details/7668331\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/zyboy2000/article/details/7668331</a><br><a href=\"http://www.51hei.com/bbs/dpj-39846-1.html\" target=\"_blank\" rel=\"external\">http://www.51hei.com/bbs/dpj-39846-1.html</a><br><a href=\"http://blog.csdn.net/jimmy2013_1_1/article/details/9723461\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/jimmy2013_1_1/article/details/9723461</a><br><a href=\"http://blog.chinaunix.net/uid-26967414-id-3823606.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-26967414-id-3823606.html</a><br><a href=\"http://blog.csdn.net/zhou1232006/article/details/6149548\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/zhou1232006/article/details/6149548</a><br><a href=\"http://blog.csdn.net/pony_maggie/article/details/5270501\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/pony_maggie/article/details/5270501</a><br><a href=\"http://wenku.baidu.com/view/f7bf4ad6b14e852458fb576a.html?re=view\" target=\"_blank\" rel=\"external\">http://wenku.baidu.com/view/f7bf4ad6b14e852458fb576a.html?re=view</a></p>\n</blockquote>\n","excerpt":"<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>使用的工具 KDE-5.11 在调试目标芯片 EFM32 时出现问题，起初是调试铁电驱动，但在单步仿真时到某一步总会不再响应，或者结束仿真时 PC 跳转到了 HardFault_Handler 异常。为了解决这个问题，于是不断地缩减代码，之后发现程序从 startup 开始执行时，一进入 main 函数就会不响应或者跳转到 HardFault_Handler 中，一度怀疑自己的硬件 CMSIS 移植有问题。为了解决这个问题，尝试了多个办法，包括并不仅仅限于更换调试工具，断点调试，评估板代替测试，重新移植底层代码，查看 RAM 占用，修改静态区全局变量占用大小等等。下面总结一些遇到 HardFault_Handler 异常的解决方法。</p>","more":"<h3 id=\"HardFault-Handler-分析\"><a href=\"#HardFault-Handler-分析\" class=\"headerlink\" title=\"HardFault_Handler 分析\"></a>HardFault_Handler 分析</h3><p>一般 HardFault_Handler 错误是指 PC 指向了一个无法访问的位置，主要可以分为两种：</p>\n<ul>\n<li>内存溢出或者访问越界。这个需要自己写程序的时候规范代码，遇到了需要慢慢排查。</li>\n<li>堆栈溢出。增加堆栈的大小。</li>\n</ul>\n<p>仿真时，有时会出现 HardFault_Handler 这种错误，这种错误往往会涉及到一些编译运行时的深层次原理，但基本可以肯定的是一般都是 SP,LR,PC 这三个寄存器出了问题，下面介绍这三个寄存器：</p>\n<ul>\n<li><p>堆栈指针r13（SP）：每一种异常模式都有其自己独立的r13，它通常指向异常模式所专用的堆栈，也就是说五种异常模式、非异常模式（用户模式和系统模式），都有各自独立的堆栈，用不同的堆栈指针来索引。这样当ARM进入异常模式的时候，程序就可以把一般通用寄存器压入堆栈，返回时再出栈，保证了各种模式下程序的状态的完整性。</p>\n</li>\n<li><p>连接寄存器r14（LR）：每种模式下r14都有自身版组，它有两个特殊功能：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">（1）保存子程序返回地址。使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回，通常用下列指令之一：</div><div class=\"line\">            MOV PC, LR </div><div class=\"line\">            BX LR</div><div class=\"line\"></div><div class=\"line\">\t通常子程序这样写，保证了子程序中还可以调用子程序。</div><div class=\"line\">             stmfd sp!, &#123;lr&#125;</div><div class=\"line\">             ……</div><div class=\"line\">             ldmfd sp!, &#123;pc&#125;</div><div class=\"line\"></div><div class=\"line\">（2）当异常发生时，异常模式的r14用来保存异常返回地址，将r14如栈可以处理嵌套中断。</div></pre></td></tr></table></figure>\n<ul>\n<li>程序计数器r15（PC）：PC是有读写限制的。当没有超过读取限制的时候，读取的值是指令的地址加上8个字节，由于ARM指令总是以字对齐的，故bit[1:0]总是00。当用str或stm存储PC的时候，偏移量有可能是8或12等其它值。在V3及以下版本中，写入bit[1:0]的值将被忽略，而在V4及以上版本写入r15的bit[1:0]必须为00，否则后果不可预测。</li>\n</ul>\n<p>需要研究到底寄存器、函数是如何跳转调用的，我们需要使用 KDE 中的两个仿真工具： Register 和 Call Stack+Locals。Register 中主要观察 SP,LR,PC 三个寄存器的数据，PC永远指向 CPU 正在执行工作的位置，LR 会保存你调用子函数之前的跳转地址，也就是说当子函数完成返回时，会回到 LR 值对应的地址继续执行下面的程序。我这边实验时，能够看出每次执行错误后， PC 会跳转到一个很大的错误地址。</p>\n<h3 id=\"指针跑飞\"><a href=\"#指针跑飞\" class=\"headerlink\" title=\"指针跑飞\"></a>指针跑飞</h3><p>在 HardFault_Handler 中的 while(1) 设置断点，然后运行，给它触发 HardFault_Handler 的条件，然后到断点处之后，查看 watch 窗口中的 Call Stack+Locals，也就是堆栈以及局部变量，程序执行到哪一句发生的错误，以及当时各个压栈的函数的各个局部变量的值一目了然。一般而言最常出现的就是<strong>指针跑飞，数组越界</strong>，这两种其实可以看做一个情况，都是指针访问了无权限访问的空间，通过 Call Stack+Locals 窗口往往能够定位到该函数，然后可以采用单步执行，看到具体在哪一步触发了异常。</p>\n<h3 id=\"RAM溢出\"><a href=\"#RAM溢出\" class=\"headerlink\" title=\"RAM溢出\"></a>RAM溢出</h3><p>这种情况也是我排查的一种情况，编译完成之后，全局变量已经占用了相应大小 RAM 中的静态存储区域，如果你的 MCU 本身不够大，例如我的只有 8K RAM空间，而 COM 的缓冲数组占用了过多的全局变量，这边就存在一定的可能 RAM 不够分配而越界。</p>\n<h3 id=\"底层-CMSIS-问题\"><a href=\"#底层-CMSIS-问题\" class=\"headerlink\" title=\"底层 CMSIS 问题\"></a>底层 CMSIS 问题</h3><p>因为我的项目是在进入 main 函数一开始就出错了，所以为了排除是不是之前的跳转就有问题，所以重新移植 startup.s 文件</p>\n<h3 id=\"Jlink\"><a href=\"#Jlink\" class=\"headerlink\" title=\"Jlink\"></a>Jlink</h3><p>不排除调试器存在缺陷，所以更换了调试器，将自己的程序移植到评估板上面运行，进一步验证，直接使用官方自带例程，在评估板上面运行。</p>\n<h3 id=\"inline函数无法捕捉\"><a href=\"#inline函数无法捕捉\" class=\"headerlink\" title=\"inline函数无法捕捉\"></a>inline函数无法捕捉</h3><p>这边是我主要出现错误的情况，一般较为少见，根本原因在于 inline 函数是类似于宏定义，直接本地展开的，如果使用断点是无法捕捉到的，这边我的 inline 函数中又调用了一个普通函数，因为 inline 函数是原地展开，LR 没有载入它的地址，而每次普通函数在返回时，无法获取到 inline 函数的返回地址，然后就跳转了异常，这本身并不能算是一个问题，在 MCU 正常运行时不会产生任何影响，影响的仅是你的调试过程。另外我个人在调试 SPI 驱动时，因为也调用了固件库自带的 inline 函数，所以导致也没法单步执行这段程序。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>虽然这边查出我的问题出现在内联函数上面，但是，以上的集中方法都可以作为常用排查 HardFault_Handler 异常的方法，且一般而言出现指针跑飞的可能性最高。</p>\n<blockquote>\n<p>参考链接：<br><a href=\"http://blog.csdn.net/zyboy2000/article/details/7668331\">http://blog.csdn.net/zyboy2000/article/details/7668331</a><br><a href=\"http://www.51hei.com/bbs/dpj-39846-1.html\">http://www.51hei.com/bbs/dpj-39846-1.html</a><br><a href=\"http://blog.csdn.net/jimmy2013_1_1/article/details/9723461\">http://blog.csdn.net/jimmy2013_1_1/article/details/9723461</a><br><a href=\"http://blog.chinaunix.net/uid-26967414-id-3823606.html\">http://blog.chinaunix.net/uid-26967414-id-3823606.html</a><br><a href=\"http://blog.csdn.net/zhou1232006/article/details/6149548\">http://blog.csdn.net/zhou1232006/article/details/6149548</a><br><a href=\"http://blog.csdn.net/pony_maggie/article/details/5270501\">http://blog.csdn.net/pony_maggie/article/details/5270501</a><br><a href=\"http://wenku.baidu.com/view/f7bf4ad6b14e852458fb576a.html?re=view\">http://wenku.baidu.com/view/f7bf4ad6b14e852458fb576a.html?re=view</a></p>\n</blockquote>"}],"PostAsset":[],"PostCategory":[{"post_id":"ciyuv3ag9000dmumulag1qk2p","category_id":"ciyuv3ag0000amumu3oz051d5","_id":"ciyuv3age000jmumukthv2g5d"},{"post_id":"ciyuv3afy0008mumuwe6o0u0x","category_id":"ciyuv3ag0000amumu3oz051d5","_id":"ciyuv3agg000omumut57no6nn"},{"post_id":"ciyuv3aga000emumux3blqlro","category_id":"ciyuv3ag0000amumu3oz051d5","_id":"ciyuv3agi000rmumun6fgsjx1"},{"post_id":"ciyuv3agc000imumu3mf6mmdh","category_id":"ciyuv3ag0000amumu3oz051d5","_id":"ciyuv3agk000vmumuyx525kct"},{"post_id":"ciyuv3afz0009mumuvg71y1mc","category_id":"ciyuv3agb000fmumuo3jd9kam","_id":"ciyuv3agn000ymumus8et84h0"},{"post_id":"ciyuv3age000kmumucmuqyljl","category_id":"ciyuv3ag0000amumu3oz051d5","_id":"ciyuv3ago0011mumuks1u11i9"},{"post_id":"ciyuv3agh000pmumur4emrdoz","category_id":"ciyuv3ag0000amumu3oz051d5","_id":"ciyuv3agq0016mumuajndw9hq"},{"post_id":"ciyuv3ag8000cmumuknmh8x7c","category_id":"ciyuv3ag0000amumu3oz051d5","_id":"ciyuv3ags0019mumul9tnb167"},{"post_id":"ciyuv3agi000smumufh8sfoyf","category_id":"ciyuv3ag0000amumu3oz051d5","_id":"ciyuv3agv001dmumuzyeiqv28"},{"post_id":"ciyuv3agp0013mumu2d52hxrt","category_id":"ciyuv3ag0000amumu3oz051d5","_id":"ciyuv3agx001hmumuq1ua75kw"},{"post_id":"ciyuv3agq0017mumuqpccgixf","category_id":"ciyuv3ag0000amumu3oz051d5","_id":"ciyuv3agz001kmumu3sbsikfe"},{"post_id":"ciyuv3agn000zmumuwlwxhuy2","category_id":"ciyuv3agq0014mumuxh8ecrte","_id":"ciyuv3ah3001nmumuq8yxjz4z"},{"post_id":"ciyuv3agw001emumuzuj1zxm2","category_id":"ciyuv3ag0000amumu3oz051d5","_id":"ciyuv3ah5001qmumucwx92p68"},{"post_id":"ciyuv3agz001lmumuy5esjuhs","category_id":"ciyuv3ag0000amumu3oz051d5","_id":"ciyuv3ah7001tmumucn1wred7"},{"post_id":"ciyuv3agt001bmumuifd6vt6t","category_id":"ciyuv3agw001fmumuzggi6nmz","_id":"ciyuv3ah8001wmumuv5ifj7bc"}],"PostTag":[{"post_id":"ciyuv3afy0008mumuwe6o0u0x","tag_id":"ciyuv3ag6000bmumu47c484qo","_id":"ciyuv3agb000hmumuy1z6v7u4"},{"post_id":"ciyuv3agc000imumu3mf6mmdh","tag_id":"ciyuv3ag6000bmumu47c484qo","_id":"ciyuv3agg000nmumuizwbfkxs"},{"post_id":"ciyuv3afz0009mumuvg71y1mc","tag_id":"ciyuv3agb000gmumuyb9w6wra","_id":"ciyuv3agi000qmumu35f1zz3y"},{"post_id":"ciyuv3agh000pmumur4emrdoz","tag_id":"ciyuv3agg000mmumui576cqjx","_id":"ciyuv3agk000umumuw0yq49in"},{"post_id":"ciyuv3ag8000cmumuknmh8x7c","tag_id":"ciyuv3agg000mmumui576cqjx","_id":"ciyuv3agn000xmumuex1sbtiq"},{"post_id":"ciyuv3agi000smumufh8sfoyf","tag_id":"ciyuv3ag6000bmumu47c484qo","_id":"ciyuv3ago0010mumuti3fsfgf"},{"post_id":"ciyuv3ag9000dmumulag1qk2p","tag_id":"ciyuv3agj000tmumumq2p47ya","_id":"ciyuv3agq0015mumuz6fysrt5"},{"post_id":"ciyuv3agn000zmumuwlwxhuy2","tag_id":"ciyuv3ag6000bmumu47c484qo","_id":"ciyuv3ags0018mumusji0lnsp"},{"post_id":"ciyuv3agp0013mumu2d52hxrt","tag_id":"ciyuv3agg000mmumui576cqjx","_id":"ciyuv3agv001cmumutxep403v"},{"post_id":"ciyuv3aga000emumux3blqlro","tag_id":"ciyuv3agg000mmumui576cqjx","_id":"ciyuv3agx001gmumu4jmucz2m"},{"post_id":"ciyuv3agq0017mumuqpccgixf","tag_id":"ciyuv3ag6000bmumu47c484qo","_id":"ciyuv3agy001jmumuq3g0ii1l"},{"post_id":"ciyuv3agt001bmumuifd6vt6t","tag_id":"ciyuv3agg000mmumui576cqjx","_id":"ciyuv3ah3001mmumu78bbi42t"},{"post_id":"ciyuv3age000kmumucmuqyljl","tag_id":"ciyuv3agg000mmumui576cqjx","_id":"ciyuv3ah5001pmumuy20icwfj"},{"post_id":"ciyuv3agw001emumuzuj1zxm2","tag_id":"ciyuv3ag6000bmumu47c484qo","_id":"ciyuv3ah7001smumub25q8ubh"},{"post_id":"ciyuv3agz001lmumuy5esjuhs","tag_id":"ciyuv3agg000mmumui576cqjx","_id":"ciyuv3ah8001vmumuuw6jki9e"}],"Tag":[{"name":"软件安装","_id":"ciyuv3ag6000bmumu47c484qo"},{"name":"杂记","_id":"ciyuv3agb000gmumuyb9w6wra"},{"name":"问题总结","_id":"ciyuv3agg000mmumui576cqjx"},{"name":"linux基础","_id":"ciyuv3agj000tmumumq2p47ya"}]}}